{
  "extends": {
    "Gemfile": {},
    "_": {},
    "actionscript": {},
    "ada": {},
    "all": {},
    "alpaca": {},
    "angular": {},
    "angular_coffee": {},
    "apache": {},
    "applescript": {},
    "arduino": {},
    "asciidoc": {},
    "asciidoctor": {
      "asciidoc": true
    },
    "asm": {},
    "autoit": {},
    "awk": {},
    "axios": {},
    "base": {},
    "beancount": {},
    "bib": {},
    "bindzone": {},
    "blade": {
      "html": true
    },
    "c": {},
    "chef": {},
    "classnames": {},
    "clojure": {},
    "cmake": {},
    "codeigniter": {},
    "coffee": {},
    "coffee-jasmine": {
      "coffee": true
    },
    "coffee-react": {
      "coffee": true
    },
    "cpp": {
      "c": true
    },
    "crystal": {},
    "cs": {},
    "css": {},
    "cuda": {
      "cpp": true
    },
    "cypress": {},
    "d": {
      "c": true
    },
    "dart": {},
    "dart-flutter": {},
    "diff": {},
    "django": {},
    "dockerfile": {},
    "dosini": {},
    "dotenv": {},
    "dotenv-safe": {},
    "eelixir": {
      "html": true
    },
    "ejs": {},
    "elixir": {},
    "elm": {},
    "erlang": {},
    "eruby": {
      "html": true
    },
    "falcon": {},
    "fortran": {},
    "framer-motion": {},
    "freemarker": {
      "html": true
    },
    "fsharp": {},
    "gatsby": {},
    "gatsby-image": {},
    "gitcommit": {},
    "gnuplot": {},
    "go": {},
    "graphql-request": {},
    "groovy": {},
    "haml": {},
    "handlebars": {},
    "haskell": {},
    "helm": {},
    "help": {},
    "html": {},
    "html_minimal": {},
    "htmldjango": {
      "html": true
    },
    "htmljinja": {
      "html": true,
      "jinja2": true
    },
    "htmltornado": {},
    "idris": {},
    "ignore": {},
    "jade": {},
    "java": {},
    "javascript": {},
    "javascript-angular": {},
    "javascript-bemjson": {},
    "javascript-d3": {},
    "javascript-ember": {},
    "javascript-jasmine": {},
    "javascript-jasmine-arrow": {},
    "javascript-jquery": {},
    "javascript-jsdoc": {},
    "javascript-mocha": {},
    "javascript-node": {},
    "javascript-openui5": {},
    "javascript-react": {},
    "javascript-redux": {},
    "javascript-requirejs": {},
    "javascript.node": {},
    "javascript_react": {},
    "jenkins": {},
    "jest": {},
    "jinja": {
      "html": true
    },
    "jinja2": {},
    "jquery_coffee": {},
    "json": {},
    "jsonc": {},
    "jsp": {},
    "julia": {},
    "kotlin": {},
    "kp19pp": {},
    "laravel": {},
    "ledger": {},
    "lfe": {},
    "lhaskell": {
      "haskell": true
    },
    "liquid": {},
    "lodash": {},
    "lpc": {},
    "ls": {},
    "lua": {},
    "make": {},
    "mako": {},
    "markdown": {},
    "matlab": {},
    "mediawiki": {},
    "mkd": {
      "markdown": true
    },
    "moon": {},
    "mustache": {},
    "neosnippet": {},
    "next": {},
    "nim": {},
    "nuxt": {},
    "nuxt-config": {},
    "nuxt-script": {},
    "objc": {},
    "ocaml": {},
    "octave": {
      "matlab": true
    },
    "openfoam": {},
    "pandoc": {
      "markdown": true
    },
    "perl": {},
    "perl6": {},
    "phoenix": {},
    "php": {},
    "php-laravel": {},
    "php-phpspec": {},
    "php-symfony2": {},
    "plsql": {},
    "po": {},
    "processing": {},
    "progress": {},
    "prolog": {},
    "prop-types": {},
    "proto": {},
    "ps1": {},
    "puppet": {},
    "purescript": {},
    "python": {},
    "r": {},
    "r-snippets": {},
    "racket": {},
    "rails": {},
    "react": {},
    "react-helmet": {},
    "react-intersection-observer": {},
    "react-modal": {},
    "reason": {},
    "redux": {},
    "redux-thunk": {},
    "requirejs_coffee": {},
    "rmarkdown": {},
    "rmd": {},
    "rnoweb": {
      "r": true,
      "tex": true
    },
    "robot": {},
    "rst": {},
    "ruby": {},
    "rust": {},
    "sass": {},
    "scala": {},
    "scheme": {},
    "scss": {
      "css": true
    },
    "sh": {},
    "simplemvcf": {},
    "slim": {},
    "snippets": {},
    "snippets-ts": {},
    "soy": {
      "html": true
    },
    "sql": {},
    "sshconfig": {},
    "styled-components": {},
    "stylus": {},
    "supercollider": {},
    "svelte": {
      "css": true,
      "html": true,
      "javascript": true
    },
    "swift": {},
    "systemverilog": {
      "verilog": true
    },
    "tcl": {},
    "tex": {
      "texmath": true
    },
    "texmath": {},
    "textile": {},
    "toml": {},
    "ts-snippets": {},
    "twig": {},
    "typescript": {
      "javascript": true
    },
    "typescriptreact": {
      "typescript": true
    },
    "verilog": {},
    "vhdl": {},
    "vim": {},
    "vimshell": {},
    "vimspec": {
      "vim": true
    },
    "vimwiki": {},
    "vital": {},
    "vue": {
      "css": true,
      "html": true,
      "javascript": true
    },
    "vue-pug": {},
    "vue-script": {},
    "vue-script-router": {},
    "vue-script-vuex": {},
    "vue-template": {},
    "vuex": {},
    "xhtml": {
      "html": true
    },
    "xml": {},
    "xslt": {},
    "yii": {},
    "yii-chtml": {},
    "yup": {},
    "zsh": {
      "sh": true
    }
  },
  "snippets": {
    "Gemfile": [
      {
        "content": "source :rubygems",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "source-rubygems": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "gem '${1}', '${2} >= 1.0'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gem": true
        },
        "options": {
          "head": true
        }
      }
    ],
    "_": [
      {
        "content": "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lorem": true
        },
        "options": {}
      },
      {
        "content": "As a special exception, if other files instantiate generics from\nthis unit, or you link this unit with other files to produce an\nexecutable, this unit does not by itself cause the resulting\nexecutable to be covered by the GNU General Public License.\nThis exception does not however invalidate any other reasons why the\nexecutable file might be covered by the GNU Public License.\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "GMGPL linking exception": true
        },
        "options": {}
      },
      {
        "content": "This Source Code Form is subject to the terms of the Mozilla Public\nLicense, v. 2.0. If a copy of the MPL was not distributed with this\nfile, You can obtain one at http://mozilla.org/MPL/2.0/.\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "MPL2": true
        },
        "options": {}
      }
    ],
    "actionscript": [
      {
        "content": "#endinitclip",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ec": true
        },
        "options": {}
      },
      {
        "content": "#include \"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "inc": true
        },
        "options": {}
      },
      {
        "content": "break;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "br": true
        },
        "options": {}
      },
      {
        "content": "call(${1:#:frame});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ca": true
        },
        "options": {}
      },
      {
        "content": "case ${1:#:expression} :\n\t${1:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "ce",
        "matches": {
          "case": true
        },
        "options": {}
      },
      {
        "content": "catch ($1) {\n\t$2\n}",
        "doc": "",
        "grammar": "snu",
        "label": "ch",
        "matches": {
          "catch": true
        },
        "options": {}
      },
      {
        "content": "class ${1:#:ClassName} {\n\tvar _${2};\n\tfunction ${1}(${2}){\n\t\t_${2} = ${2};${0}\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "class": true
        },
        "options": {}
      },
      {
        "content": "continue;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "co": true
        },
        "options": {}
      },
      {
        "content": "default :\n\t${1:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dt": true
        },
        "options": {}
      },
      {
        "content": "delete ${1};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "de": true
        },
        "options": {}
      },
      {
        "content": "do {\n\t${1:TARGET}\n} while (${2:#:condition});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "do": true
        },
        "options": {}
      },
      {
        "content": "duplicateMovieClip(${1:#:target}, ${2:#:newName}, ${3:#:depth});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dm": true
        },
        "options": {}
      },
      {
        "content": "else if (${1}) {\n\t${2:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ei": true
        },
        "options": {}
      },
      {
        "content": "for (var ${1} in ${2}){\n\t${3:TARGET}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "fi",
        "matches": {
          "fori": true
        },
        "options": {}
      },
      {
        "content": "for (var ${1} = 0; $1 < ${2}.length; $1++) {\n\t${0:TARGET}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "fr",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "fscommand(${1:#:command}, ${2:#:paramaters});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fs": true
        },
        "options": {}
      },
      {
        "content": "function ${1}(${2}):${3}{\n\t${0:TARGET}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fn": true
        },
        "options": {}
      },
      {
        "content": "getURL(${1});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gu": true
        },
        "options": {}
      },
      {
        "content": "gotoAndPlay(${1});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gp": true
        },
        "options": {}
      },
      {
        "content": "gotoAndStop(${1});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gs": true
        },
        "options": {}
      },
      {
        "content": "if (${1}) {\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "ifFrameLoaded (${1}) {\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "il": true
        },
        "options": {}
      },
      {
        "content": "import ${1};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ip": true
        },
        "options": {}
      },
      {
        "content": "interface ${1}{\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "it": true
        },
        "options": {}
      },
      {
        "content": "loadMovie(${1:url}, ${2:target}, ${3:method});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lm": true
        },
        "options": {}
      },
      {
        "content": "loadMovieNum(${1:url}, ${2:level}, ${3:method});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ln": true
        },
        "options": {}
      },
      {
        "content": "loadVariables(${1:url}, ${2:target}, ${3:method});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lv": true
        },
        "options": {}
      },
      {
        "content": "loadVariables(${1:url}, ${2:level}, ${3:method});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vn": true
        },
        "options": {}
      },
      {
        "content": "MovieClip",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mc": true
        },
        "options": {}
      },
      {
        "content": "nextFrame();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nf": true
        },
        "options": {}
      },
      {
        "content": "nextScene();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ns": true
        },
        "options": {}
      },
      {
        "content": "on (${1}) {\n\t${2}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "on": true
        },
        "options": {}
      },
      {
        "content": "onClipEvent (${1}) {\n\t${0:TARGET}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "oc": true
        },
        "options": {}
      },
      {
        "content": "play();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pl": true
        },
        "options": {}
      },
      {
        "content": "pravFrame();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pf": true
        },
        "options": {}
      },
      {
        "content": "prevScene();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ps": true
        },
        "options": {}
      },
      {
        "content": "print(${1:#:target}, ${2:#:type});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pr": true
        },
        "options": {}
      },
      {
        "content": "printAsBitmapNum(${1:#:level}, ${2:#:type});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bn": true
        },
        "options": {}
      },
      {
        "content": "printNum(${1:#:level}, ${2:#:type});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pn": true
        },
        "options": {}
      },
      {
        "content": "removeMovieClip(${1:#:target});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rm": true
        },
        "options": {}
      },
      {
        "content": "return ${1};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rt": true
        },
        "options": {}
      },
      {
        "content": "setProperty(${1:#:target}, ${2:#:property}, ${3:#:value});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sp": true
        },
        "options": {}
      },
      {
        "content": "set(${1:#:name}, ${2:#:value});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sv": true
        },
        "options": {}
      },
      {
        "content": "startDrag(${1:#:target}, ${2:#:lockcenter}, ${3:#:l}, ${4:#:t}, ${5:#:r}, ${6:#:b} );",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dr": true
        },
        "options": {}
      },
      {
        "content": "stop();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "st": true
        },
        "options": {}
      },
      {
        "content": "stopAllSounds();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ss": true
        },
        "options": {}
      },
      {
        "content": "stopDrag();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sd": true
        },
        "options": {}
      },
      {
        "content": "switch ( ${1:#:condition} ) {\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sw": true
        },
        "options": {}
      },
      {
        "content": "tellTarget( ${1:#:target} ) {\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tt": true
        },
        "options": {}
      },
      {
        "content": "throw ${1};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "th": true
        },
        "options": {}
      },
      {
        "content": "toggleHighQuality();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tq": true
        },
        "options": {}
      },
      {
        "content": "trace(${1:\"$0\"});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tr": true
        },
        "options": {}
      },
      {
        "content": "try {\n\t${0:TARGET}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ty": true
        },
        "options": {}
      },
      {
        "content": "unloadMovie(${1:#:target});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "um": true
        },
        "options": {}
      },
      {
        "content": "unloadMovieNum(${1:#:level});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "un": true
        },
        "options": {}
      },
      {
        "content": "var ${1}:${2};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vr": true
        },
        "options": {}
      },
      {
        "content": "while (${1:#:condition}) {\n\t${0:TARGET}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh": true
        },
        "options": {}
      },
      {
        "content": "with (${1:#:target});\n\t${0:TARGET}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wt": true
        },
        "options": {}
      },
      {
        "content": "package {\n\timport flash.display.*;\n\timport flash.Events.*;\n\tpublic class Main extends Sprite {\n\t\tpublic function Main (\t) {\n\t\t\ttrace(\"start\");\n\t\t\tstage.scaleMode = StageScaleMode.NO_SCALE;\n\t\t\tstage.addEventListener(Event.RESIZE, resizeListener);\n\t\t}\n\t\tprivate function resizeListener (e:Event):void {\n\t\t\ttrace(\"The application window changed size!\");\n\t\t\ttrace(\"New width:  \" + stage.stageWidth);\n\t\t\ttrace(\"New height: \" + stage.stageHeight);\n\t\t}\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "main": true
        },
        "options": {}
      },
      {
        "content": "${1:public|internal} class ${2:name} ${0:extends } {\n\tpublic function $2 (\t) {\n\t\t(\"start\");\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "class": true
        },
        "options": {}
      },
      {
        "content": "package name {\n\t${1:public|internal|final} class ${2:name} ${0:extends } {\n\t\tprivate|public| static const FOO = \"abc\";\n\t\tprivate|public| static var BAR = \"abc\";\n\t\t// class initializer - no JIT !! one time setup\n\t\tif Cababilities.os == \"Linux|MacOS\" {\n\t\t\tFOO = \"other\";\n\t\t}\n\t\t// constructor:\n\t\tpublic function $2 (\t){\n\t\t\tsuper2();\n\t\t\ttrace(\"start\");\n\t\t}\n\t\tpublic function name (a, b...){\n\t\t\tsuper.name(..);\n\t\t\tlable:break\n\t\t}\n\t}\n}\nfunction A(){\n\t// A can only be accessed within this file\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "all": true
        },
        "options": {}
      },
      {
        "content": "switch(${1}){\n\tcase ${2}:\n\t\t${0}\n\tbreak;\n\tdefault:\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "switch": true
        },
        "options": {}
      },
      {
        "content": "case ${1}:\n\t${0}\nbreak;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case": true
        },
        "options": {}
      },
      {
        "content": "package ${1:package}{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "package": true
        },
        "options": {}
      },
      {
        "content": "while ${1:cond}{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh": true
        },
        "options": {}
      },
      {
        "content": "do {\n\t${0}\n} while (${1:cond})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "do": true
        },
        "options": {}
      },
      {
        "content": "for (${1:var} in ${2:object}){\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for enumerate names": true
        },
        "options": {}
      },
      {
        "content": "for each (${1:var} in ${2:object}){\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for enumerate values": true
        },
        "options": {}
      },
      {
        "content": "function get ${1:name} {\n\treturn ${2}\n}\nfunction set $1 (newValue) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "get_set": true
        },
        "options": {}
      },
      {
        "content": "interface name {\n\tfunction method(${1}):${0:returntype};\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "interface": true
        },
        "options": {}
      },
      {
        "content": "try {\n\t${1:${VISUAL}}\n} catch (error:ErrorType) {\n\t${2}\n} finally {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "try": true
        },
        "options": {}
      },
      {
        "content": "for (${2:i} = 0; $2 < ${1:count}; $2${3:++}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for for (..) {..}": true
        },
        "options": {}
      },
      {
        "content": "for (${1:i} = ${2:0}; ${3:$1 < 10}; $1${4:++}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forr": true
        },
        "options": {}
      },
      {
        "content": "if (${1:/* condition */}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "else {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "el": true
        },
        "options": {}
      },
      {
        "content": "${1:/* condition */} ? ${2:a} : ${0:b}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "t": true
        },
        "options": {}
      },
      {
        "content": "function ${1:function_name}(${2})${3}\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fun": true
        },
        "options": {}
      },
      {
        "content": "package\n{\n\timport org.flixel.*\n\tpublic class ${1:ClassName} extends ${2:FlxSprite}\n\t{\n\t\tpublic function $1(${3: X:Number, Y:Number}):void\n\t\t{\n\t\t\tsuper(X,Y);\n\t\t\t${4}\n\t\t}\n\t\toverride public function update():void\n\t\t{\n\t\t\tsuper.update();\n\t\t\t${0}\n\t\t}\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "FlxSprite": true
        },
        "options": {}
      }
    ],
    "ada": [
      {
        "content": "with ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "with ...;...",
        "matches": {
          "with": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "package ${1} is\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": "package {NAME} is {...} end",
        "matches": {
          "package": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "package body ${1} is\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": "package body {NAME} is {...} end",
        "matches": {
          "package_body": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "entry ${1}(${2}) when ${3} is\nbegin\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": "entry {...} when",
        "matches": {
          "entry": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "task ${1} is\n\tentry ${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "task": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "task body ${1} is\n\t${2}\nbegin\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": "task body",
        "matches": {
          "task_body": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "accept ${1}(${2}) do\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "accept": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "protected type ${1}(${2}) is\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": "protected type",
        "matches": {
          "protected_type": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "protected body ${1} is\n\t${2}\nbegin\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": "protected body",
        "matches": {
          "protected_body": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "generic\n\ttype ${1} is ${2};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "generic type",
        "matches": {
          "generic": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "type ${1} is ${2};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "type": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "type ${1} is ${2}\n\twith Default_Value => ${3};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "type with default value",
        "matches": {
          "type_default": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "subtype ${1} is ${2};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "subtype": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "declare\n\t${1}\nbegin\n\t${0}\nend;",
        "doc": "",
        "grammar": "snu",
        "label": "declare block",
        "matches": {
          "declare": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "${1}:\ndeclare\n\t${2}\nbegin\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": "declare named block",
        "matches": {
          "declare_named": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "if ${1} then ${2} else ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "if expression",
        "matches": {
          "ife": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "case ${1} is\n\twhen ${2} => ${3},${0}",
        "doc": "",
        "grammar": "snu",
        "label": "case expression",
        "matches": {
          "case_expression": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "for all ${1} ${2:in} ${3} => ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "for all",
        "matches": {
          "for_all": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "for some ${1} ${2:in} ${3} => ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "for some",
        "matches": {
          "for_some": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "if ${1} then\n\t${0}\nend if;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "if ${1} then\n\t${2}\nelse\n\t${0}\nend if;",
        "doc": "",
        "grammar": "snu",
        "label": "if ... else",
        "matches": {
          "ifelse": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "else\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "else": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "elsif ${1} then\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ei": true,
          "elseif": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "while ${1} loop\n\t${0}\nend loop;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "w": true,
          "while": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "${1}:\nwhile ${2} loop\n\t${0}\nend loop $1;",
        "doc": "",
        "grammar": "snu",
        "label": "named while",
        "matches": {
          "named_while": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "for ${1:I} in ${2} loop\n\t${0}\nend loop;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "for ${1} of ${2} loop\n\t${0}\nend loop;",
        "doc": "",
        "grammar": "snu",
        "label": "for each",
        "matches": {
          "for_each": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "${1}:\nfor ${2:I} in ${3} loop\n\t${0}\nend loop $1;",
        "doc": "",
        "grammar": "snu",
        "label": "named for",
        "matches": {
          "named_for": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "${1}:\nfor ${2} of ${3} loop\n\t${0}\nend loop $1;",
        "doc": "",
        "grammar": "snu",
        "label": "named for each",
        "matches": {
          "named_for_each": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "procedure ${1}(${2}) is\n\t${3}\nbegin\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "procedure": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "procedure ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "procedure declaration",
        "matches": {
          "procedure_declare": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "function ${1}(${2}) return ${3} is\n\t${4}\nbegin\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "function": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "function ${1} return ${2} is\n\t(${3});${0}",
        "doc": "",
        "grammar": "snu",
        "label": "expression function",
        "matches": {
          "function_expr": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "function ${1} return ${2};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "function declaration",
        "matches": {
          "function_declare": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "return ${1} do\n\t${0}\nend return;",
        "doc": "",
        "grammar": "snu",
        "label": "extended return",
        "matches": {
          "return": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "record\n\t${0}\nend record;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "record": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "case ${1} is\n\twhen ${2} => ${3};${0}\nend case;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "when ${1} => ${2};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "when": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "when others => ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "when others",
        "matches": {
          "when_others": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "loop\n\t${0}\nend loop;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "loop": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "${1}:\nloop\n\t${0}\nend loop $1;",
        "doc": "",
        "grammar": "snu",
        "label": "named loop",
        "matches": {
          "named_loop": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "exit when ${1};\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "exit when",
        "matches": {
          "exit_when": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "Ada.Text_IO.Put(${1});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "Ada.Text_IO.Put",
        "matches": {
          "put": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "Ada.Text_IO.Put_Line(${1});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "Ada.Text_IO.Put_Line",
        "matches": {
          "put_line": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "Ada.Text_IO.Get(${1});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "Ada.Text_IO.Get",
        "matches": {
          "get": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "Ada.Text_IO.Get_Line(${1});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "Ada.Text_IO.Get_Line",
        "matches": {
          "get_line": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "Ada.Text_IO.New_Line(${1:1});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "Ada.Text_IO.New_Line",
        "matches": {
          "newline": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "with ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wi with": true
        },
        "options": {}
      },
      {
        "content": "package ${1} is\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pac package": true
        },
        "options": {}
      },
      {
        "content": "package body ${1} is\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pacb package body": true
        },
        "options": {}
      },
      {
        "content": "entry ${1}(${2}) when ${3} is\nbegin\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ent entry ... when": true
        },
        "options": {}
      },
      {
        "content": "task ${1} is\n\tentry ${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "task task": true
        },
        "options": {}
      },
      {
        "content": "task body ${1} is\n\t${2}\nbegin\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "taskb task body": true
        },
        "options": {}
      },
      {
        "content": "accept ${1}(${2}) do\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "acc accept": true
        },
        "options": {}
      },
      {
        "content": "protected type ${1}(${2}) is\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prot protected type": true
        },
        "options": {}
      },
      {
        "content": "protected body ${1} is\n\t${2}\nbegin\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prob protected body": true
        },
        "options": {}
      },
      {
        "content": "generic\n\ttype ${1} is ${2};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gen generic type": true
        },
        "options": {}
      },
      {
        "content": "type ${1} is ${2};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ty type": true
        },
        "options": {}
      },
      {
        "content": "type ${1} is ${2}\n\twith Default_Value => ${3};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tyd type with default value": true
        },
        "options": {}
      },
      {
        "content": "subtype ${1} is ${2};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "subty subtype": true
        },
        "options": {}
      },
      {
        "content": "declare\n\t${1}\nbegin\n\t${0}\nend;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dec declare block": true
        },
        "options": {}
      },
      {
        "content": "${1}:\ndeclare\n\t${2}\nbegin\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "decn declare named block": true
        },
        "options": {}
      },
      {
        "content": "if ${1} then ${2} else ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifex if expression": true
        },
        "options": {}
      },
      {
        "content": "case ${1} is\n\twhen ${2} => ${3},${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "casex case expression": true
        },
        "options": {}
      },
      {
        "content": "for all ${1} ${2:in} ${3} => ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fora for all": true
        },
        "options": {}
      },
      {
        "content": "for some ${1} ${2:in} ${3} => ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fors for some": true
        },
        "options": {}
      },
      {
        "content": "if ${1} then\n\t${0:${VISUAL}}\nend if;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if if": true
        },
        "options": {}
      },
      {
        "content": "if ${1} then\n\t${2:${VISUAL}}\nelse\n\t${0}\nend if;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife if ... else": true
        },
        "options": {}
      },
      {
        "content": "else\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "el else": true
        },
        "options": {}
      },
      {
        "content": "elsif ${1} then\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eif elsif": true
        },
        "options": {}
      },
      {
        "content": "while ${1} loop\n\t${0:${VISUAL}}\nend loop;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh while": true
        },
        "options": {}
      },
      {
        "content": "${1}:\nwhile ${2} loop\n\t${0:${VISUAL}}\nend loop $1;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nwh named while": true
        },
        "options": {}
      },
      {
        "content": "for ${1:I} in ${2} loop\n\t${0}\nend loop;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for for": true
        },
        "options": {}
      },
      {
        "content": "for ${1} of ${2} loop\n\t${0}\nend loop;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fore for each": true
        },
        "options": {}
      },
      {
        "content": "${1}:\nfor ${2:I} in ${3} loop\n\t${0}\nend loop $1;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nfor named for": true
        },
        "options": {}
      },
      {
        "content": "${1}:\nfor ${2} of ${3} loop\n\t${0}\nend loop $1;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nfore named for each": true
        },
        "options": {}
      },
      {
        "content": "procedure ${1}(${2}) is\n\t${3}\nbegin\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "proc procedure": true
        },
        "options": {}
      },
      {
        "content": "procedure ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "procd procedure declaration": true
        },
        "options": {}
      },
      {
        "content": "function ${1}(${2}) return ${3} is\n\t${4}\nbegin\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fun function": true
        },
        "options": {}
      },
      {
        "content": "function ${1} return ${2} is\n\t(${3});${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fune expression function": true
        },
        "options": {}
      },
      {
        "content": "function ${1} return ${2};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fund function declaration": true
        },
        "options": {}
      },
      {
        "content": "return ${1} do\n\t${0}\nend return;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ret extended return": true
        },
        "options": {}
      },
      {
        "content": "record\n\t${0}\nend record;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rec record": true
        },
        "options": {}
      },
      {
        "content": "case ${1} is\n\twhen ${2} => ${3};${0}\nend case;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case case": true
        },
        "options": {}
      },
      {
        "content": "when ${1} => ${2};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whe when": true
        },
        "options": {}
      },
      {
        "content": "when others => ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wheo when others": true
        },
        "options": {}
      },
      {
        "content": "loop\n\t${0}\nend loop;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lo loop": true
        },
        "options": {}
      },
      {
        "content": "${1}:\nloop\n\t${0}\nend loop $1;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nlo named loop": true
        },
        "options": {}
      },
      {
        "content": "exit when ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ex exit when": true
        },
        "options": {}
      },
      {
        "content": "Ada.Text_IO.Put(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "put Ada.Text_IO.Put": true
        },
        "options": {}
      },
      {
        "content": "Ada.Text_IO.Put_Line(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "putl Ada.Text_IO.Put_Line": true
        },
        "options": {}
      },
      {
        "content": "Ada.Text_IO.Get(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "get Ada.Text_IO.Get": true
        },
        "options": {}
      },
      {
        "content": "Ada.Text_IO.Get_Line(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "getl Ada.Text_IO.Get_Line": true
        },
        "options": {}
      },
      {
        "content": "Ada.Text_IO.New_Line(${1:1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "newline Ada.Text_IO.New_Line": true
        },
        "options": {}
      }
    ],
    "all": [],
    "alpaca": [
      {
        "content": "import ${0:http}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "imp": true
        },
        "options": {}
      },
      {
        "content": "import type ${0:option.option}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "impt": true
        },
        "options": {}
      },
      {
        "content": "export ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "exp": true
        },
        "options": {}
      },
      {
        "content": "export ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "expt": true
        },
        "options": {}
      },
      {
        "content": "val ${1:fn} ${2}: fn ${3:'a} -> ${4:'a}\nlet $1 ${5} =\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fn": true
        },
        "options": {}
      },
      {
        "content": "match ${1} with\n| ${2} -> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mat": true
        },
        "options": {}
      },
      {
        "content": "| ${1} -> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "-": true
        },
        "options": {}
      },
      {
        "content": "let ${1} = ${2:${VISUAL}} in\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "let": true
        },
        "options": {}
      },
      {
        "content": "let ${1} =\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "letf": true
        },
        "options": {}
      },
      {
        "content": "type ${1:msg}\n\t= ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ty": true
        },
        "options": {}
      },
      {
        "content": "test \"${1}\" =\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "test": true
        },
        "options": {}
      },
      {
        "content": "{-| ${0}\n-}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "doc": true
        },
        "options": {}
      },
      {
        "content": "|> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p": true
        },
        "options": {}
      },
      {
        "content": "assert.equal ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ae": true
        },
        "options": {}
      }
    ],
    "angular": [
      {
        "content": "# Client App\nFROM johnpapa/angular-cli as client-app\nLABEL authors=\"${1:John Papa}\"\nWORKDIR /usr/src/app\nCOPY [\"package.json\", \"npm-shrinkwrap.json*\", \"./\"]\nRUN npm install --silent\nCOPY . .\nRUN ng build --prod\n\n# Node server\nFROM ${2:node:12-alpine} as node-server\nWORKDIR /usr/src/app\nCOPY [\"package.json\", \"npm-shrinkwrap.json*\", \"./\"]\nRUN npm install --production --silent && mv node_modules ../\nCOPY ${3:server.js} .\nCOPY ${4:/server} /usr/src/app/server\n\n# Final image\nFROM ${2:node:12-alpine}\nWORKDIR /usr/src/app\nCOPY --from=node-server /usr/src /usr/src\nCOPY --from=client-app /usr/src/app/dist ./\nEXPOSE ${5:3000}\n# CMD [\"node\", \"server.js\"]\nCMD [\"npm\", \"start\"]\n$0",
        "doc": "Multi-stage Node and Angular Dockerfile",
        "grammar": "lsp",
        "label": "multi-stage-node-and-angular-dockerfile",
        "matches": {
          "angular multi-stage node and dockerfile": true,
          "docker-angular-node-multi-stage": true
        },
        "options": {}
      },
      {
        "content": "[class]=\"${1:expression}\"",
        "doc": "Angular [class] binding",
        "grammar": "lsp",
        "label": "class",
        "matches": {
          "a-class": true,
          "angular class": true
        },
        "options": {}
      },
      {
        "content": "[style.${1:property}]=\"${2:expression}\"",
        "doc": "Angular [style] binding",
        "grammar": "lsp",
        "label": "style",
        "matches": {
          "a-style": true,
          "angular style": true
        },
        "options": {}
      },
      {
        "content": "[ngClass]=\"{${1:cssClass}: ${2:expression}}\"",
        "doc": "Angular ngClass",
        "grammar": "lsp",
        "label": "ngclass",
        "matches": {
          "a-ngclass": true,
          "angular ng class": true
        },
        "options": {}
      },
      {
        "content": "*ngFor=\"let ${1:item} of ${2:list}\"${0}",
        "doc": "Angular *ngFor",
        "grammar": "lsp",
        "label": "ngfor",
        "matches": {
          "a-ngfor": true,
          "angular ng for": true
        },
        "options": {}
      },
      {
        "content": "*ngFor=\"let ${1:item} of ${2:list}; trackBy:${1:item}.id\"${0}",
        "doc": "Angular *ngFor with trackBy",
        "grammar": "lsp",
        "label": "ngfor-with-trackby",
        "matches": {
          "a-ngfor-trackby": true,
          "angular ng for with track by": true
        },
        "options": {}
      },
      {
        "content": "*ngFor=\"let ${1:item} of ${2:stream} | async as ${3:list}\"${0}",
        "doc": "Angular *ngForAsync",
        "grammar": "lsp",
        "label": "ngforasync",
        "matches": {
          "a-ngforasync": true,
          "angular ng for async": true
        },
        "options": {}
      },
      {
        "content": "<form (ngSubmit)=\"onSubmit()\" #${1:form}=\"ngForm\">\n</form>",
        "doc": "Form with ngSubmit and form attributes",
        "grammar": "lsp",
        "label": "ngform",
        "matches": {
          "a-form": true,
          "angular ng form": true
        },
        "options": {}
      },
      {
        "content": "formArrayName=\"${1:control}\"",
        "doc": "Angular formArrayName",
        "grammar": "lsp",
        "label": "ngformarrayname",
        "matches": {
          "a-formarrayname": true,
          "angular ng form array name": true
        },
        "options": {}
      },
      {
        "content": "formControlName=\"${1:control}\"",
        "doc": "Angular formControlName",
        "grammar": "lsp",
        "label": "ngformcontrolname",
        "matches": {
          "a-formcontrolname": true,
          "angular ng form control name": true
        },
        "options": {}
      },
      {
        "content": "[formGroup]=\"${1:form}\"",
        "doc": "Angular formGroup",
        "grammar": "lsp",
        "label": "ngformgroup",
        "matches": {
          "a-formgroup": true,
          "angular ng form group": true
        },
        "options": {}
      },
      {
        "content": "[formGroupName]=\"${1:name}\"",
        "doc": "Angular formGroupName",
        "grammar": "lsp",
        "label": "ngformgroupname",
        "matches": {
          "a-formgroupname": true,
          "angular ng form group name": true
        },
        "options": {}
      },
      {
        "content": "<button type=\"submit\" [disabled]=\"!${1:form}.form.valid\">\n\tSave\n</button>",
        "doc": "Angular form submit",
        "grammar": "lsp",
        "label": "ngformsubmit",
        "matches": {
          "a-form-submit": true,
          "angular ng form submit": true
        },
        "options": {}
      },
      {
        "content": "*ngIf=\"${1:expression}\"",
        "doc": "Angular *ngIf",
        "grammar": "lsp",
        "label": "ngif",
        "matches": {
          "a-ngif": true,
          "angular ng if": true
        },
        "options": {}
      },
      {
        "content": "*ngIf=\"${1:expression};else ${2:templateName}\"",
        "doc": "Angular *ngIfElse",
        "grammar": "lsp",
        "label": "ngifelse",
        "matches": {
          "a-ngifelse": true,
          "angular ng if else": true
        },
        "options": {}
      },
      {
        "content": "[(ngModel)]=\"${1:binding}\"",
        "doc": "Angular ngModel",
        "grammar": "lsp",
        "label": "ngmodel",
        "matches": {
          "a-ngmodel": true,
          "angular ng model": true
        },
        "options": {}
      },
      {
        "content": "[routerLink]=\"['/${1:routePath}']\" routerLinkActive=\"${2:router-link-active}\" $0",
        "doc": "Angular routerLink",
        "grammar": "lsp",
        "label": "ngrouterlink",
        "matches": {
          "a-routerlink": true,
          "angular ng router link": true
        },
        "options": {}
      },
      {
        "content": "[routerLink]=\"['${1:routePath}', ${2:routeParameterValue}]\"\nrouterLinkActive=\"${3:router-link-active}\"$0",
        "doc": "Angular routerLink with a route parameter",
        "grammar": "lsp",
        "label": "ngrouterlinkwithparameter",
        "matches": {
          "a-routerlink-param": true,
          "angular ng router link with parameter": true
        },
        "options": {}
      },
      {
        "content": "<select [(ngModel)]=\"${1:model}\">\n\t<option *ngFor=\"let ${2:item} of ${3:list}\" [value]=\"${2:item}\">{{${2:item}}}</option>\n</select>",
        "doc": "<select> control with ngModel",
        "grammar": "lsp",
        "label": "ngselect",
        "matches": {
          "a-select": true,
          "angular ng select": true
        },
        "options": {}
      },
      {
        "content": "[ngStyle]=\"{${1:style}: ${2:expression}}\"",
        "doc": "Angular ngStyle",
        "grammar": "lsp",
        "label": "ngstyle",
        "matches": {
          "a-ngstyle": true,
          "angular ng style": true
        },
        "options": {}
      },
      {
        "content": "<div [ngSwitch]=\"${1:conditionExpression}\">\n\t<div *ngSwitchCase=\"${2:expression}\">${3:output}</div>\n\t<div *ngSwitchDefault>${4:output2}</div>\n</div>",
        "doc": "Angular ngSwitch",
        "grammar": "lsp",
        "label": "ngswitch",
        "matches": {
          "a-ngswitch": true,
          "angular ng switch": true
        },
        "options": {}
      },
      {
        "content": "<pre>{{${1:model} | json}}</pre>$0",
        "doc": "Angular pre debug | json",
        "grammar": "lsp",
        "label": "pre-w-json",
        "matches": {
          "a-prej": true,
          "angular pre json": true
        },
        "options": {}
      },
      {
        "content": "<pre>{{${1:model} | async | json}}</pre>$0",
        "doc": "Angular pre debug | async | json",
        "grammar": "lsp",
        "label": "pre-w-async-json",
        "matches": {
          "a-preja": true,
          "angular pre async json": true
        },
        "options": {}
      },
      {
        "content": "<ng-container $0></ng-container>",
        "doc": "Angular ng-container",
        "grammar": "lsp",
        "label": "ng-container",
        "matches": {
          "a-ng-container": true,
          "angular ng-container": true
        },
        "options": {}
      },
      {
        "content": "<ng-template [ngTemplateOutlet]=\"${1:outlet}\" [ngOutletContext]=\"${2:context}\"></ng-template>",
        "doc": "Angular ng-template",
        "grammar": "lsp",
        "label": "ng-template",
        "matches": {
          "a-ng-template": true,
          "angular ng-template": true
        },
        "options": {}
      },
      {
        "content": "<ng-content select=\"${0:selector}\"></ng-content>",
        "doc": "Angular ng-content",
        "grammar": "lsp",
        "label": "ng-content",
        "matches": {
          "a-ng-content": true,
          "angular ng-content": true
        },
        "options": {}
      },
      {
        "content": "const express = require('express');\nconst app = express();\nconst port = process.env.PORT || ${1:port};\nconst www = process.env.WWW || '${2:./}';\napp.use(express.static(www));\nconsole.log(`serving \\${www}`);\napp.get('*', (req, res) => {\n\tres.sendFile(`index.html`, { root: www });\n});\napp.listen(port, () => console.log(`listening on http://localhost:\\${port}`));\n$0",
        "doc": "Node.js Express Server",
        "grammar": "lsp",
        "label": "node-js-express-server",
        "matches": {
          "angular node express server": true,
          "ex-node-server-simple": true
        },
        "options": {}
      },
      {
        "content": "import { Component, OnInit } from '@angular/core';\n\n@Component({\n\tselector: '${1:selector-name}',\n\ttemplateUrl: '${2:name}.component.html'\n})\n\nexport class ${3:Name}Component implements OnInit {\n\tconstructor() { }\n\n\tngOnInit() { }$0\n}",
        "doc": "Angular component",
        "grammar": "lsp",
        "label": "angular-component",
        "matches": {
          "a-component": true,
          "angular component": true
        },
        "options": {}
      },
      {
        "content": "import { Component, OnInit } from '@angular/core';\n\n@Component({\n\tselector: '${1:selector-name}',\n\ttemplate: `$0`\n})\n\nexport class ${2:Name}Component implements OnInit {\n\tconstructor() { }\n\n\tngOnInit() { }\n}",
        "doc": "Angular component with an inline template",
        "grammar": "lsp",
        "label": "angular-component-with-inline-template",
        "matches": {
          "a-component-inline": true,
          "angular component inline template": true
        },
        "options": {}
      },
      {
        "content": "import { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n\tname: '${1:selector-name}'\n})\n\nexport class ${2:Name}Pipe implements PipeTransform {\n\ttransform(value: any, ...args: any[]): any {\n\t\t$0\n\t}\n}",
        "doc": "Angular pipe",
        "grammar": "lsp",
        "label": "angular-pipe",
        "matches": {
          "a-pipe": true,
          "angular pipe": true
        },
        "options": {}
      },
      {
        "content": "import { Injectable } from '@angular/core';\n\n@Injectable({providedIn: ${1:'root'}})\nexport class ${2:ServiceName}Service {\n\tconstructor() { }\n\t$0\n}",
        "doc": "Angular Service with Injectable ProvidedIn Root",
        "grammar": "lsp",
        "label": "angular-service",
        "matches": {
          "a-service": true,
          "angular service": true
        },
        "options": {}
      },
      {
        "content": "{ path: '', pathMatch: 'full', redirectTo: '${1:path}' }$0",
        "doc": "Angular default route path",
        "grammar": "lsp",
        "label": "angular-default-route-path",
        "matches": {
          "a-route-path-default": true,
          "angular default route path": true
        },
        "options": {}
      },
      {
        "content": "{\n\tpath: '${1:path}', \n\tcomponent: ${2:Component},\n\tchildren: [\n\t\t{ path: '${3:childpath}', component: ${4:ChildComponent} }\n\t]\n}$0",
        "doc": "Angular route path with children",
        "grammar": "lsp",
        "label": "angular-route-path-with-children",
        "matches": {
          "a-route-path-with-children": true,
          "angular route path children": true
        },
        "options": {}
      },
      {
        "content": "{ path: '**', component: ${1:PathNotFoundComponent} }$0",
        "doc": "Angular 404 route path",
        "grammar": "lsp",
        "label": "angular-404-route-path",
        "matches": {
          "a-route-path-404": true,
          "angular 404 route path": true
        },
        "options": {}
      },
      {
        "content": "{ path: '${1:path}', component: ${2:Name}Component },",
        "doc": "Angular eager route path",
        "grammar": "lsp",
        "label": "angular-eager-route-path",
        "matches": {
          "a-route-path-eager": true,
          "angular eager route path": true
        },
        "options": {}
      },
      {
        "content": "{\n\tpath: '${1:path}', \n\tloadChildren: () => import('${2:lazy-path}').then(m => m.${3:lazy-module})\n},",
        "doc": "Angular lazy route path",
        "grammar": "lsp",
        "label": "angular-lazy-route-path",
        "matches": {
          "a-route-path-lazy": true,
          "angular lazy route path": true
        },
        "options": {}
      },
      {
        "content": "this.route.paramMap\n\t.pipe(switchMap(params => params.get('id')), tap(id => (this.id = +id)))\n\t.subscribe(id => {$1});\n$0",
        "doc": "Angular - subscribe to routing parameters",
        "grammar": "lsp",
        "label": "routing-params-subscribe",
        "matches": {
          "a-route-params-subscribe": true,
          "angular routing params subscribe": true
        },
        "options": {}
      },
      {
        "content": "return this.httpClient.get('${1:url}');$0",
        "doc": "Angular HttpClient.get",
        "grammar": "lsp",
        "label": "httpclient-get",
        "matches": {
          "a-httpclient-get": true,
          "angular http client get": true
        },
        "options": {}
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\n@Injectable({providedIn: ${1:'root'}})\nexport class ${2:ServiceName}Service {\n\tconstructor(private httpClient: HttpClient) { }\n\t$0\n}",
        "doc": "Angular service with HttpClient",
        "grammar": "lsp",
        "label": "angular-httpclient-service",
        "matches": {
          "a-service-httpclient": true,
          "angular http client service": true
        },
        "options": {}
      },
      {
        "content": "import { HttpInterceptor, HttpHandler, HttpRequest, HttpEvent, HttpResponse } from '@angular/common/http';\nimport { Observable } from 'rxjs';\nimport { tap } from 'rxjs/operators';\n\n@Injectable()\nexport class LogInterceptor implements HttpInterceptor {\n\tconstructor() {}\n\n\tintercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n\t\tconst started = Date.now();\n\t\treturn next.handle(req).pipe(\n\t\t\ttap(event => {\n\t\t\t\tif (event instanceof HttpResponse) {\n\t\t\t\t\tconst elapsed = Date.now() - started;\n\t\t\t\t\tconsole.log(`Request for \\${req.urlWithParams} took \\${elapsed} ms.`);\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\t}\n}",
        "doc": "Angular HttpInterceptor for Logging HttpClient",
        "grammar": "lsp",
        "label": "angular-httpinterceptor-for-logging",
        "matches": {
          "a-http-interceptor-logging": true,
          "angular http interceptor logging": true
        },
        "options": {}
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { HttpEvent, HttpInterceptor, HttpHandler, HttpRequest } from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class HeaderInterceptor implements HttpInterceptor {\n\tconstructor() {}\n\n\tintercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n\t\tconst headers = req.headers\n\t\t\t.set('Content-Type', 'application/json');\n\t\tconst authReq = req.clone({ headers });\n\t\treturn next.handle(authReq);\n\t}\n}",
        "doc": "Angular HttpInterceptor for headers HttpClient",
        "grammar": "lsp",
        "label": "angular-httpinterceptor-for-headers",
        "matches": {
          "a-http-interceptor-headers": true,
          "angular http interceptor headers": true
        },
        "options": {}
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { HttpInterceptor, HttpEvent, HttpHandler, HttpRequest } from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class ${2:Your}Interceptor implements HttpInterceptor {\n\tintercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n\t\treturn next.handle(req);\n\t}\n}",
        "doc": "Empty Angular HttpInterceptor for HttpClient",
        "grammar": "lsp",
        "label": "angular-httpinterceptor-empty",
        "matches": {
          "a-http-interceptor": true,
          "angular http interceptor empty": true
        },
        "options": {}
      },
      {
        "content": "@Output() ${1:eventName} = new EventEmitter<${2:eventType}>();",
        "doc": "Angular @Output event and emitter",
        "grammar": "lsp",
        "label": "output-event",
        "matches": {
          "a-output-event": true,
          "angular output event": true
        },
        "options": {}
      },
      {
        "content": "this.${1:service}.${2:function}\n\t.subscribe(${3:arg} => this.${4:property} = ${3:arg});\n$0",
        "doc": "Angular observable subscribe",
        "grammar": "lsp",
        "label": "subscribe",
        "matches": {
          "a-subscribe": true,
          "angular subscribe": true
        },
        "options": {}
      },
      {
        "content": "import { Component } from '@angular/core';\n\n@Component({\n\tselector: '${1:prefix-app}',\n\ttemplate: `\n\t\t<router-outlet></router-outlet>\n\t\t`\n})\nexport class ${2:App}Component { }\n$0",
        "doc": "Angular App root component",
        "grammar": "lsp",
        "label": "angular-root-component",
        "matches": {
          "a-component-root": true,
          "angular root component": true
        },
        "options": {}
      },
      {
        "content": "import { NgModule } from '@angular/core';\nimport { BrowserModule  } from '@angular/platform-browser';\nimport { HttpModule } from '@angular/http';\n\nimport { ${1:App}Component } from './${1:app}.component';\n\n@NgModule({\n\timports: [\n\t\tBrowserModule,\n\t\tHttpModule,\n\t],\n\tdeclarations: [${1:App}Component],\n\tbootstrap: [${1:App}Component],\n})\nexport class ${1:App}Module { }\n$0",
        "doc": "Angular Root Module",
        "grammar": "lsp",
        "label": "angular-root-module",
        "matches": {
          "a-module-root": true,
          "angular root module": true
        },
        "options": {}
      },
      {
        "content": "import { Routes } from '@angular/router';\n\nexport const routes: Routes = [${0}]",
        "doc": "Route definitions",
        "grammar": "lsp",
        "label": "route-definitions",
        "matches": {
          "a-routes": true,
          "angular route definitions": true
        },
        "options": {}
      },
      {
        "content": "import { NgModule } from '@angular/core';\n\nimport { ${1:Name}Component } from './${2:name}.component';\n\n@NgModule({\n\timports: [],\n\texports: [],\n\tdeclarations: [${1:Name}Component],\n\tproviders: [],\n})\nexport class ${1:Name}Module { }\n$0",
        "doc": "Angular Module",
        "grammar": "lsp",
        "label": "angular-module",
        "matches": {
          "a-module": true,
          "angular module": true
        },
        "options": {}
      },
      {
        "content": "import { Directive } from '@angular/core';\n\n@Directive({ selector: '[${1:selector-name}]' })\nexport class ${2:Name}Directive {\n\tconstructor() { }\n}",
        "doc": "Angular directive",
        "grammar": "lsp",
        "label": "angular-directive",
        "matches": {
          "a-directive": true,
          "angular directive": true
        },
        "options": {}
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { ActivatedRouteSnapshot, CanActivate, RouterStateSnapshot } from '@angular/router';\n\n@Injectable({providedIn: ${1:'root'}})\nexport class ${2:Name}Guard implements CanActivate {\n\tconstructor() { }\n\n\tcanActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {\n\t\treturn true;$0\n\t}\n}",
        "doc": "Angular CanActivate guard",
        "grammar": "lsp",
        "label": "angular-canactivate-guard",
        "matches": {
          "a-guard-can-activate": true,
          "angular can activate guard": true
        },
        "options": {}
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { ActivatedRouteSnapshot, CanActivateChild, RouterStateSnapshot } from '@angular/router';\n\n@Injectable({providedIn: ${1:'root'}})\nexport class ${2:Name}Guard implements CanActivateChild {\n\tconstructor() { }\n\n\tcanActivateChild(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {\n\t\treturn true;$0\n\t}\n}",
        "doc": "Angular CanActivateChild guard",
        "grammar": "lsp",
        "label": "angular-canactivatechild-guard",
        "matches": {
          "a-guard-can-activate-child": true,
          "angular can activate child guard": true
        },
        "options": {}
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { CanLoad, Route } from '@angular/router';\n\n@Injectable({providedIn: ${1:'root'}})\nexport class ${2:Name}Guard implements CanLoad {\n\tconstructor() { }\n\n\tcanLoad(route: Route) {\n\t\treturn true;$0\n\t}\n}",
        "doc": "Angular CanLoad guard",
        "grammar": "lsp",
        "label": "angular-canload-guard",
        "matches": {
          "a-guard-can-load": true,
          "angular can load guard": true
        },
        "options": {}
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { ActivatedRouteSnapshot, CanDeactivate, RouterStateSnapshot } from '@angular/router';\nimport { Observable } from 'rxjs';\n\nimport { ${2:ComponentName}Component } from './${3:filename}.component';\n\n// Consider using this interface for all CanDeactivate guards,\n// and have your components implement this interface, too.\n//\n//   e.g. export class CanDeactivateGuard implements CanDeactivate<CanComponentDeactivate> {\n//\n// export interface CanComponentDeactivate {\n// canDeactivate: () => any;\n// }\n\n@Injectable({providedIn: ${4:'root'}})\nexport class ${1:Name}Guard implements CanDeactivate<${2:ComponentName}Component> {\n\tcanDeactivate(\n\t\tcomponent: ${2:ComponentName}Component,\n\t\tcurrentRoute: ActivatedRouteSnapshot, \n\t\tcurrentState: RouterStateSnapshot\n\t): Observable<boolean>|Promise<boolean>|boolean {\n\t\treturn false;$0\n\t}\n}",
        "doc": "Angular CanDeactivate guard",
        "grammar": "lsp",
        "label": "angular-candeactivate-guard",
        "matches": {
          "a-guard-can-deactivate": true,
          "angular can deactivate guard": true
        },
        "options": {}
      },
      {
        "content": "import { PreloadingStrategy, Route } from '@angular/router';\nimport { Observable, of } from 'rxjs';\n\nexport class PreloadSelectedModulesList implements PreloadingStrategy {\n\tpreload(route: Route, load: Function): Observable<any> {\n\t\treturn route.data && route.data['${1:preload}'] ? load() : of(null);\n\t}\n}\n$0",
        "doc": "Angular opt-in preload strategy",
        "grammar": "lsp",
        "label": "angular-opt-in-preload-strategy",
        "matches": {
          "a-preload-opt-in-strategy": true,
          "angular opt-in preload strategy": true
        },
        "options": {}
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { PreloadingStrategy, Route } from '@angular/router';\nimport { Observable, EMPTY } from 'rxjs';\n\n// avoid typing issues for now\nexport declare var navigator;\n\n@Injectable({ providedIn: 'root' })\nexport class NetworkAwarePreloadStrategy implements PreloadingStrategy {\n\tpreload(route: Route, load: () => Observable<any>): Observable<any> {\n\t\treturn this.hasGoodConnection() ? load() : EMPTY;\n\t}\n\n\thasGoodConnection(): boolean {\n\t\tconst conn = navigator.connection;\n\t\tif (conn) {\n\t\t\tif (conn.saveData) {\n\t\t\t\treturn false; // save data mode is enabled, so dont preload\n\t\t\t}\n\t\t\tconst avoidTheseConnections = ['slow-2g', '2g' /* , '3g', '4g' */];\n\t\t\tconst effectiveType = conn.effectiveType || '';\n\t\t\tif (avoidTheseConnections.includes(effectiveType)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}",
        "doc": "Angular network aware preload strategy",
        "grammar": "lsp",
        "label": "angular-network-aware-preload-strategy",
        "matches": {
          "a-preload-network-strategy": true,
          "angular network-aware preload strategy": true
        },
        "options": {}
      },
      {
        "content": "checkEvents() {\n\tthis.router.events.subscribe(event => {\n\t\tswitch (true) {\n\t\t\tcase event instanceof ${1:eventName}:\n\t\t\t\t$0\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t});\n}",
        "doc": "Angular Router Events",
        "grammar": "lsp",
        "label": "angular-router-events",
        "matches": {
          "a-router-events": true,
          "angular router events": true
        },
        "options": {}
      },
      {
        "content": "constructor( @Optional() @SkipSelf() parentModule: ${1:ModuleName} {\n\tif (parentModule) {\n\t\tconst msg = `${1:ModuleName} has already been loaded. \n\t\t\tImport ${1:ModuleName} once, only, in the root AppModule.`;\n\t\tthrow new Error(msg);\n\t}\n}",
        "doc": "Angular Module SkipSelf constructor",
        "grammar": "lsp",
        "label": "angular-module-skipself-constructor",
        "matches": {
          "a-ctor-skip-self": true,
          "angular module skip self constructor": true
        },
        "options": {}
      },
      {
        "content": "import { ${1:Observable} } from 'rxjs';\n$0",
        "doc": "RxJs import",
        "grammar": "lsp",
        "label": "rxjs-import",
        "matches": {
          "a-rxjs-import": true,
          "angular import rx js": true
        },
        "options": {}
      },
      {
        "content": "import { ${1:map} } from 'rxjs/operators';\n$0",
        "doc": "RxJs import",
        "grammar": "lsp",
        "label": "rxjs-operator-import",
        "matches": {
          "a-rxjs-operator-import": true,
          "angular import rx js operator": true
        },
        "options": {}
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { Resolve, ActivatedRouteSnapshot } from '@angular/router';\nimport { Observable } from 'rxjs';\n\n@Injectable({ providedIn: ${1:'root'} })\nexport class ${2:YourResolver} implements Resolve<${3:ObjectToResolve}> {\n\tresolve(route: ActivatedRouteSnapshot): Observable<${3:ObjectToResolve}> | Promise<${3:ObjectToResolve}> | ${3:ObjectToResolve} {\n\t\treturn ${0};\n\t}\n}",
        "doc": "Angular Resolver",
        "grammar": "lsp",
        "label": "angular-resolver",
        "matches": {
          "a-resolver": true,
          "angular resolver": true
        },
        "options": {}
      },
      {
        "content": "import { NgModule } from '@angular/core';\nimport { EffectsModule } from '@ngrx/effects';\nimport { StoreModule } from '@ngrx/store';\nimport { StoreDevtoolsModule } from '@ngrx/store-devtools';\nimport { environment } from '../../environments/environment';\n\n@NgModule({\n  imports: [\n    StoreModule.forRoot({}),\n    EffectsModule.forRoot([]),\n    environment.production ? [] : StoreDevtoolsModule.instrument()\n  ]\n})\nexport class $1StoreModule {}",
        "doc": "NgRx Store Module",
        "grammar": "lsp",
        "label": "ngrx-store-module",
        "matches": {
          "a-ngrx-store-module": true,
          "angular ng rx store module": true
        },
        "options": {}
      },
      {
        "content": "export const ${1:action} = createAction('[${2:Source}] ${3:Event}');",
        "doc": "Creates an NgRx Action",
        "grammar": "lsp",
        "label": "ngrx-create-action",
        "matches": {
          "a-ngrx-create-action": true,
          "angular ng rx create action": true
        },
        "options": {}
      },
      {
        "content": "export const ${1:action} = createAction('[${2:Source}] ${3:Event}', props<{${4:key}: ${5:type}}>());",
        "doc": "Creates an NgRx Action with Props",
        "grammar": "lsp",
        "label": "ngrx-create-action-w-props",
        "matches": {
          "a-ngrx-create-action-props": true,
          "angular ng rx create action props": true
        },
        "options": {}
      },
      {
        "content": "const ${1:feature}Reducer = createReducer(\n\tinitialState,\n\ton($1Actions.action, state => ({ ...state, ${2:prop}: ${3:updatedValue} })),\n);\n\nexport function reducer(state: State | undefined, action: Action) {\n\treturn $1Reducer(state, action);\n}",
        "doc": "Creates an NgRx Reducer",
        "grammar": "lsp",
        "label": "ngrx-create-reducer",
        "matches": {
          "a-ngrx-create-reducer": true,
          "angular ng rx create reducer": true
        },
        "options": {}
      },
      {
        "content": "export const select${1:Feature}${2:Property} = createSelector(\n\tselect$1,\n\t(state: $1State) => state.${3:property}\n);",
        "doc": "Creates an NgRx Selector",
        "grammar": "lsp",
        "label": "ngrx-create-selector",
        "matches": {
          "a-ngrx-create-selector": true,
          "angular ng rx create selector": true
        },
        "options": {}
      },
      {
        "content": "export const select${1:Feature}${2:Property} = createSelector(\n\tselect$1,\n\t(state: $1State, props) => ${3:selectLogic}\n);",
        "doc": "Creates an NgRx Selector using props",
        "grammar": "lsp",
        "label": "ngrx-create-selector-w-props",
        "matches": {
          "a-ngrx-create-selector-props": true,
          "angular ng rx create selector props": true
        },
        "options": {}
      },
      {
        "content": "EntityDataModule.forRoot(${1:entityConfig}),",
        "doc": "Import NgRx Entity Data Module",
        "grammar": "lsp",
        "label": "ngrx-data-import-entity-data-module",
        "matches": {
          "a-ngrx-data-entity-data-module-import": true,
          "angular ng rx data import entity module": true
        },
        "options": {}
      },
      {
        "content": "import { EntityMetadataMap } from '@ngrx/data';\n\nconst entityMetadata: EntityMetadataMap = {\n  ${1:Model1}: {},${0}\n};\n\nexport const entityConfig = {\n  entityMetadata\n};",
        "doc": "NgRx Data Entity Metadata",
        "grammar": "lsp",
        "label": "ngrx-data-entity-metadata",
        "matches": {
          "a-ngrx-data-entity-metadata": true,
          "angular ng rx data entity metadata": true
        },
        "options": {}
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport {\n  EntityCollectionServiceBase,\n  EntityCollectionServiceElementsFactory\n} from '@ngrx/data';\nimport { ${1:Model} } from '${2:../core}';\n\n@Injectable({ providedIn: ${3:'root'} })\nexport class ${1:Model}Service extends EntityCollectionServiceBase<${1:Model}> {\n  constructor(serviceElementsFactory: EntityCollectionServiceElementsFactory) {\n    super('${1:Model}', serviceElementsFactory);\n  }\n}",
        "doc": "NgRx Data Entity Collection Data Service",
        "grammar": "lsp",
        "label": "ngrx-data-entity-collection-data-service",
        "matches": {
          "a-ngrx-data-entity-collection-data-service": true,
          "angular ng rx data entity collection service": true
        },
        "options": {}
      },
      {
        "content": "${1:trackBy}(index: number, ${2:name}: ${3:model}): ${4:number} {\n  return ${2:name}${5:.id};$0\n}",
        "doc": "TrackBy Function",
        "grammar": "lsp",
        "label": "trackby-function",
        "matches": {
          "a-trackby": true,
          "angular track by function": true
        },
        "options": {}
      }
    ],
    "angular_coffee": [
      {
        "content": "${1:controllerName} = (${2:scope}, ${3:injectables}) ->\n\t${4}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ngc": true
        },
        "options": {}
      },
      {
        "content": "angular.forEach ${1:iterateOver}, (value, key) ->\n\t${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ngfor": true
        },
        "options": {}
      },
      {
        "content": "angular.module '${1:moduleName}', [${2:moduleDependencies}]\n${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ngm": true
        },
        "options": {}
      },
      {
        "content": "${1:moduleName} = angular.module '$1', [${2:moduleDeps}]\n${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ngma": true
        },
        "options": {}
      },
      {
        "content": "${1:moduleName} = angular.module('$1', [${2:moduleDeps}], (${3:configDeps}) ->\n\t${4}\n)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ngmc": true
        },
        "options": {}
      },
      {
        "content": "factory '${1:factoryName}', (${2:dependencies}) ->\n\t${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ngmfa": true
        },
        "options": {}
      },
      {
        "content": "service '${1:serviceName}', (${2:injectables}) ->\n\t${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ngms": true
        },
        "options": {}
      },
      {
        "content": "filter '${1:filterName}', (${2:injectables}) ->\n\t(input, ${3:args}) ->\n\t\t${4}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ngmfi": true
        },
        "options": {}
      },
      {
        "content": "$routeProvider.when '${1:url}',\n\ttemplateUrl: '${2:templateUrl}'\n\tcontroller: '${3:controller}'\n${4}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ngrw": true
        },
        "options": {}
      },
      {
        "content": "$routeProvider.when '${1:url}',\n\ttemplateUrl: '${2:templateUrl}'\n\tcontroller: '${3:controller}'\n\tresolve:\n\t\t${4}\n${5}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ngrwr": true
        },
        "options": {}
      },
      {
        "content": "$routeProvider.otherwise redirectTo: '${1:url}'\n${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ngro": true
        },
        "options": {}
      },
      {
        "content": "$scope.${1:functionName} = (${2:args}) ->\n\t${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "$f": true
        },
        "options": {}
      },
      {
        "content": "$scope.${1:variable} = ${2:value}\n${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "$v": true
        },
        "options": {}
      },
      {
        "content": "$scope.${1:variable} = ${2:variable}\n${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "$va": true
        },
        "options": {}
      },
      {
        "content": "$scope.$watch '${1:watchExpr}', (newValue, oldValue) ->\n\t${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "$w": true
        },
        "options": {}
      },
      {
        "content": "$scope.$on '${1:eventName}', (event, ${2:args}) ->\n\t${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "$on": true
        },
        "options": {}
      },
      {
        "content": "$scope.$broadcast '${1:eventName}', ${2:eventArgs}\n${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "$b": true
        },
        "options": {}
      },
      {
        "content": "$scope.$emit '${1:eventName}', ${2:eventArgs}\n${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "$e": true
        },
        "options": {}
      },
      {
        "content": "compile = (tElement, tAttrs, transclude) ->\n\t(scope, element, attrs) ->\n\t\t${1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ngdcf": true
        },
        "options": {}
      },
      {
        "content": "(scope, element, attrs${1:ctrl}) ->\n\t${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ngdlf": true
        },
        "options": {}
      },
      {
        "content": "directive '${1:directiveName}', factory = (${2:injectables}) ->\n\tdirectiveDefinitionObject =\n\t\t${3:directiveAttrs}\n\t\tcompile: compile = (tElement, tAttrs, transclude) ->\n\t\t\t(scope, element, attrs) ->\n\tdirectiveDefinitionObject",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ngdc": true
        },
        "options": {}
      },
      {
        "content": ".directive('${1:directiveName}', (${2:directiveDeps}) ->\n\t(scope, element, attrs${3:ctrl}) ->\n\t\t${4}\n)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ngdl": true
        },
        "options": {}
      }
    ],
    "apache": [
      {
        "content": "AllowOverride ${1:#:AuthConfig} ${2:#:FileInfo} ${3:#:Indexes} ${4:#:Limit} ${5:#:Options}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "allow": true
        },
        "options": {}
      },
      {
        "content": "Options ${1:#:All} ${2:#:ExecCGI} ${3:#:FollowSymLinks} ${4:#:Includes} ${5:#:IncludesNOEXEC} ${6:#:Indexes} ${7:#:MultiViews} ${8:#:SymLinksIfOwnerMatch}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "opt": true
        },
        "options": {}
      },
      {
        "content": "<VirtualHost ${1:example.org}>\n\tServerAdmin webmaster@${1}\n\tDocumentRoot /www/vhosts/${1}\n\tServerName ${1}\n\tErrorLog logs/${1}-error_log\n\tCustomLog logs/${1}-access_log common\n</VirtualHost>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vhost": true
        },
        "options": {}
      },
      {
        "content": "<Directory ${1:/Library/WebServer/}>\n\t${0}\n</Directory>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dir": true
        },
        "options": {}
      },
      {
        "content": "<IfModule ${1:module_name}>\n        ${2}\n</IfModule>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifmodule": true
        },
        "options": {}
      },
      {
        "content": "<If ${1:condition}>\n        ${2}\n</If>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "RemoteIPHeader X-Forwarded-For",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "RemoteIPHeader": true
        },
        "options": {}
      },
      {
        "content": "<Location ${1:location}>\n        ${2:config}\n</Location>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "location": true
        },
        "options": {}
      },
      {
        "content": "<LocationMatch \"${1:regex}\">\n        ${2:config}\n</LocationMatch>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "locationmatch": true
        },
        "options": {}
      },
      {
        "content": "DirectoryIndex index.php index.html",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "directoryindex": true
        },
        "options": {}
      },
      {
        "content": "Require all granted",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "require": true
        },
        "options": {}
      },
      {
        "content": "<Directory ${1:/}>\n\tDirectoryIndex ${0:index.html}\n\tOrder Deny,Allow\n\tDeny from All\n</Directory>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dir": true
        },
        "options": {}
      },
      {
        "content": "<FilesMatch \"${1:regex}\">\n\t${0:${VISUAL}}\n</FilesMatch>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "filesmatch": true
        },
        "options": {}
      },
      {
        "content": "<IfModule ${1:mod_example.c}>\n\t${0:${VISUAL}}\n</IfModule>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifmodule": true
        },
        "options": {}
      },
      {
        "content": "<LimitExcept ${1:POST GET}>\n\t${0:${VISUAL}}\n</LimitExcept>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "limitexcept": true
        },
        "options": {}
      },
      {
        "content": "<Proxy ${1:*}>\n\t${0:${VISUAL}}\n</Proxy>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "proxy": true
        },
        "options": {}
      },
      {
        "content": "<VirtualHost ${1:*}:${2:80}>\n\tServerAdmin ${3:webmaster@example.com}\n\tDocumentRoot ${4:/www/example.com}\n\tServerName ${0:www.example.com}\n</VirtualHost>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "virtualhost": true
        },
        "options": {}
      }
    ],
    "applescript": [
      {
        "content": "script ${1:#:new_object}\n\ton run\n\t\t${2:TARGET}\n\tend run\nend script",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "script": true
        },
        "options": {}
      },
      {
        "content": "on ${1:#:functionName}(${2:#:arguments})\n\t${3:TARGET}\nend ${1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "on": true
        },
        "options": {}
      },
      {
        "content": "tell ${1:#:app}\n\t${0:TARGET}\nend tell",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tell": true
        },
        "options": {}
      },
      {
        "content": "using terms from ${1:#:app}\n\t${0:TARGET}\nend using terms from",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "terms": true
        },
        "options": {}
      },
      {
        "content": "if ${1:true} then\n\t${0:TARGET}\nend if",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "repeat ${1} times}\n\t${0:TARGET}\nend repeat",
        "doc": "",
        "grammar": "snu",
        "label": "rep",
        "matches": {
          "rept": true
        },
        "options": {}
      },
      {
        "content": "repeat while ${1:#:condition}\n\t${0:TARGET}\nend repeat",
        "doc": "",
        "grammar": "snu",
        "label": "rep",
        "matches": {
          "repwh": true
        },
        "options": {}
      },
      {
        "content": "repeat with ${1} in ${2}\n\t${0:TARGET}\nend repeat",
        "doc": "",
        "grammar": "snu",
        "label": "rep",
        "matches": {
          "repwi": true
        },
        "options": {}
      },
      {
        "content": "try\n\t${0:TARGET}\non error\n\t-- error handling\nend try",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "try": true
        },
        "options": {}
      },
      {
        "content": "with timeout ${1:#:number} seconds\n\t${0:TARGET}\nend timeout",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "timeout": true
        },
        "options": {}
      },
      {
        "content": "considering ${1:#:case}\n\t${0:TARGET}\nend considering",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "con": true
        },
        "options": {}
      },
      {
        "content": "ignoring ${1:#:application responses}\n\t${0:TARGET}\nend ignoring",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ign": true
        },
        "options": {}
      },
      {
        "content": "${1:#:set shell_stdout to }do shell script ${3:\"${2:#script}\"}\n\twithout altering line endings\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "shell": true
        },
        "options": {}
      },
      {
        "content": "set oldDelims to AppleScript's text item delimiters\nset AppleScript's text item delimiters to {\"${1:,}\"}\n${0:#:TARGET}\nset AppleScript's text item delimiters to oldDelims",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "delim": true
        },
        "options": {}
      },
      {
        "content": "prop parent : app \"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "parent": true
        },
        "options": {}
      },
      {
        "content": "display alert \"${1:#:alert text}\"\n\t${2:#:message} \"${3:#:message text}\"\n\t${4:#:as warning}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "alert": true
        },
        "options": {}
      },
      {
        "content": "display dialog \"${1:#:text}\"\n\t${2:#:with icon} ${3:1}\n\tbuttons {\"${4:OK}\"} default button 1",
        "doc": "",
        "grammar": "snu",
        "label": "dialog",
        "matches": {
          "dialog_OK": true
        },
        "options": {}
      },
      {
        "content": "display dialog \"${1:#:text}\"\n\t${2:#:with icon}\n\tbuttons {\"${3:Cancel}\", \"${4:OK}\"}\n\tdefault button \"${4}\"\nset button_pressed to button returned of result\nif button_pressed is \"${4}\" then\n\t${5:#:TARGET}\nelse\n\t-- action for cancel button goes here\nend if",
        "doc": "",
        "grammar": "snu",
        "label": "dialog",
        "matches": {
          "dialog_OK/Cancel": true
        },
        "options": {}
      },
      {
        "content": "display dialog \"${1:#:text}\"\n\t${2:#:with icon}\n\tbuttons {\"${3:Cancel}\", \"${4:Other Choice}\", \"${5:OK}\"}\n\tdefault button \"${5}\"\nset button_pressed to button returned of result\nif button_pressed is \"${5}\" then\n\t${6:TARGET}\nelse if button_pressed is \"${3}\" then\n\t-- action for cancel button goes here\nelse\n\t-- action for other button goes here\nend if",
        "doc": "",
        "grammar": "snu",
        "label": "dialog",
        "matches": {
          "dialog_OK/Cancel/Other": true
        },
        "options": {}
      },
      {
        "content": "set the_result to display dialog \"${1:#:text}\"\n\tdefault answer \"${2:#:type here}\"\n\t${3:#:with icon}\n\tbuttons {\"${4:Cancel}\", \"${5:OK}\"}\n\tdefault button \"${5}\"\nset button_pressed to button returned of the_result\nset text_typed to text returned of the_result\nif button_pressed is \"${5}\" then\n\t${6:#:TARGET}\nelse\n\t-- action for cancel button goes here\nend if",
        "doc": "",
        "grammar": "snu",
        "label": "dialog",
        "matches": {
          "dialog_TextFierld": true
        },
        "options": {}
      },
      {
        "content": "${1:#:set the_application to }choose application with prompt \"${2:#:Choose an application:}\"${3:#:with multiple selections allowed}",
        "doc": "",
        "grammar": "snu",
        "label": "choose",
        "matches": {
          "choose_Applications": true
        },
        "options": {}
      },
      {
        "content": "${1:#:set the_file to }choose file with prompt \"${2:#:Pick a file:}\"\n${3:#:default location path to home folder}\n${4:#:with invisibles}\n${5:#:with multiple selections allowed}\n${6:#:with showing package contents}",
        "doc": "",
        "grammar": "snu",
        "label": "choose",
        "matches": {
          "choose_Files": true
        },
        "options": {}
      },
      {
        "content": "${1:#:set the_folder to }choose folder with prompt \"${2:#:Pick a folder:}\"\n${3:#:default location path to home folder}\n${4:#:with invisibles}\n${5:#:with multiple selections allowed}\n${6:#:with showing package contents}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "choose",
        "matches": {
          "choose_Folders": true
        },
        "options": {}
      },
      {
        "content": "${1:#:set the_filename to }choose file name with prompt \"${2:#:Name this file:}\"\n\tdefault name \"${3:untitled}\" default location ${4:#:path to home folder}",
        "doc": "",
        "grammar": "snu",
        "label": "choose",
        "matches": {
          "choose_NewFile": true
        },
        "options": {}
      },
      {
        "content": "${1:#:set the_url to }choose URL showing ${2:Web} servers with editable URL",
        "doc": "",
        "grammar": "snu",
        "label": "choose",
        "matches": {
          "choose_URL": true
        },
        "options": {}
      },
      {
        "content": "${1:#:set the_color to }choose color default color ${2:{65536, 65536, 65536\\}}",
        "doc": "",
        "grammar": "snu",
        "label": "choose",
        "matches": {
          "choose_Color": true
        },
        "options": {}
      },
      {
        "content": "set the_choice to choose from list ${1}\"\\}}",
        "doc": "",
        "grammar": "snu",
        "label": "choose",
        "matches": {
          "choose_ItemFromList": true
        },
        "options": {}
      }
    ],
    "arduino": [
      {
        "content": "void setup()\n{\n\tSerial.begin(${1:9600});\n\t${2}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "setup": true
        },
        "options": {}
      },
      {
        "content": "void loop()\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "loop": true
        },
        "options": {}
      },
      {
        "content": "#include <${1}.h>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "inc": true
        },
        "options": {}
      },
      {
        "content": "#define ${1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "def": true
        },
        "options": {}
      },
      {
        "content": "if (${1:/* condition */}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "else {\n\t${1}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "el": true
        },
        "options": {}
      },
      {
        "content": "else if (${1:/* condition */}) {\n\t${2}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "elif": true
        },
        "options": {}
      },
      {
        "content": "if (${1:/* condition */}) ${2};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifi": true
        },
        "options": {}
      },
      {
        "content": "switch (${1:/* variable */}) {\n\tcase ${2:/* variable case */}:\n\t\t${3}\n\t\t${4:break;}${5}\n\tdefault:\n\t\t${6}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "switch": true
        },
        "options": {}
      },
      {
        "content": "case ${1:/* variable case */}:\n\t${2}\n\t${3:break;}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case": true
        },
        "options": {}
      },
      {
        "content": "for (int ${2:i} = 0; $2 < ${1:count}; $2${3:++}) {\n\t${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "for (int ${1:i} = ${2:0}; ${3:$1 < 10}; $1${4:++}) {\n\t${5}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forr": true
        },
        "options": {}
      },
      {
        "content": "while (${1:/* condition */}) {\n\t${2}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh": true
        },
        "options": {}
      },
      {
        "content": "do {\n\t${2}\n} while (${1:/* condition */});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "do": true
        },
        "options": {}
      },
      {
        "content": "${1:void} ${2:function_name}(${3})\n{\n\t${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fun": true
        },
        "options": {}
      },
      {
        "content": "pinMode(${1}, OUTPUT);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pinout": true
        },
        "options": {}
      },
      {
        "content": "pinMode(${1}, INPUT);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pinin": true
        },
        "options": {}
      },
      {
        "content": "digitalWrite(${1}, HIGH);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dwHigh": true
        },
        "options": {}
      },
      {
        "content": "digitalWrite(${1}, LOW);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dwLow": true
        },
        "options": {}
      },
      {
        "content": "digitalRead(${1});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dr": true
        },
        "options": {}
      },
      {
        "content": "analogRead(${1});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ar": true
        },
        "options": {}
      },
      {
        "content": "analogWrite(${1});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "aw": true
        },
        "options": {}
      },
      {
        "content": "Serial.read();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sr": true
        },
        "options": {}
      },
      {
        "content": "Serial.write();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sw": true
        },
        "options": {}
      },
      {
        "content": "Serial.print(${1});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sp": true
        },
        "options": {}
      },
      {
        "content": "Serial.println(${1});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sl": true
        },
        "options": {}
      },
      {
        "content": "delay(${1});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dl": true
        },
        "options": {}
      },
      {
        "content": "millis();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ml": true
        },
        "options": {}
      }
    ],
    "asciidoc": [
      {
        "content": "= ${1:Document Name}\n${2:Alice <alice@example.com>}\n${3:Revision line}\n:toc:\n:imagesdir: img/\n:homepage: https://www.example.com\n:icons: font\n:data-uri:\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "Start a new document",
        "matches": {
          "doc": true,
          "title": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "[source,${1:language}]\n----\n${0}\n----",
        "doc": "",
        "grammar": "snu",
        "label": "source code block --- source ---",
        "matches": {
          "block-source": true,
          "source": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "[quote, ${1:Name}, ${2:Occasion}}]\n____\n${0}\n____",
        "doc": "",
        "grammar": "snu",
        "label": "quote block --- text ---",
        "matches": {
          "block-quote": true,
          "quote": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "....\n${0}\n....",
        "doc": "",
        "grammar": "snu",
        "label": "literal block ... text ...",
        "matches": {
          "block-literal": true,
          "literalblock": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "*${1}*${0}",
        "doc": "",
        "grammar": "snu",
        "label": "*bold*",
        "matches": {
          "bold": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "_${1}_${0}",
        "doc": "",
        "grammar": "snu",
        "label": "_italic_",
        "matches": {
          "italic": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "+${1}+${0}",
        "doc": "",
        "grammar": "snu",
        "label": "+verbatim+",
        "matches": {
          "verb": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "== ${1:Title}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "== heading on level 2",
        "matches": {
          "heading": true,
          "section": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "[#${2:Id}]\n== ${1:Title}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "== heading on level 2 with anchor",
        "matches": {
          "heading-anchor": true,
          "section-anchor": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "include::${1:example.doc}[]${0}",
        "doc": "",
        "grammar": "snu",
        "label": "include::example.doc",
        "matches": {
          "inc": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "'''\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "horizontal rule",
        "matches": {
          "hrule": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "<<<\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "page break",
        "matches": {
          "pagebreak": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "${1:definiendum}::\n${2:definiens}",
        "doc": "",
        "grammar": "snu",
        "label": "definition",
        "matches": {
          "def": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "[cols=\"${1}\", options=\"header\"]\n|===\n|${2:row1-col1}\n${0}\n|===",
        "doc": "",
        "grammar": "snu",
        "label": "table",
        "matches": {
          "table": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "[%header,format=csv]\n|===\n${0}\n|===",
        "doc": "",
        "grammar": "snu",
        "label": "CSV table",
        "matches": {
          "csvtable": true,
          "tablecsv": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "${1:https://www.example.org}[${2:Text}]${0}",
        "doc": "",
        "grammar": "snu",
        "label": "External link",
        "matches": {
          "extlink": true,
          "link": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "link:${1:/example.pdf}[${2:Text}]${0}",
        "doc": "",
        "grammar": "snu",
        "label": "Relative link",
        "matches": {
          "linkrel": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "mailto:${1:alice@example.com}[${2:Alice}]${0}",
        "doc": "",
        "grammar": "snu",
        "label": "mailto link",
        "matches": {
          "mailto": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "[[${1:id}]]${0}",
        "doc": "",
        "grammar": "snu",
        "label": "[[id]] text",
        "matches": {
          "anchor": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "[#${1:Id}] ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "[#anchor] #text#, itemize, ...",
        "matches": {
          "anchorblock": true,
          "block-anchor": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "<<${1:id}>>${0}",
        "doc": "",
        "grammar": "snu",
        "label": "reference to anchor",
        "matches": {
          "ref": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "image::${1:example.jpg}[${2:Description}]\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "image::file[desc]",
        "matches": {
          "image": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "image::${1:example.jpg}[${2:Description},align=\"center\"]\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "Centered image::file[desc]",
        "matches": {
          "imagecenter": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "image:${1:example.jpg}[${2:Description}]${0}",
        "doc": "",
        "grammar": "snu",
        "label": "Inline image:file[desc]",
        "matches": {
          "imageinline": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": ".footnote:[${1:footnotetext}]${0}",
        "doc": "",
        "grammar": "snu",
        "label": "footnote",
        "matches": {
          "footnote": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "[bibliography]\n== References\n- [[${1:id}]] ${2:Entry}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "bibliography",
        "matches": {
          "bib": true
        },
        "options": {
          "head": true
        }
      }
    ],
    "asciidoctor": [
      {
        "content": ":source-highlighter: rouge$0",
        "doc": "",
        "grammar": "snu",
        "label": "source-highlighter: rouge",
        "matches": {
          "highlight-rouge": true,
          "hirouge": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": ":source-highlighter: pygments$0",
        "doc": "",
        "grammar": "snu",
        "label": "source-highlighter: pygments",
        "matches": {
          "highlight-pygments": true,
          "hipygments": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": ":source-highlighter: highlight.js$0",
        "doc": "",
        "grammar": "snu",
        "label": "source-highlighter: highlight.js",
        "matches": {
          "highlight-highlight.js": true,
          "hihighlight.js": true
        },
        "options": {
          "head": true
        }
      }
    ],
    "asm": [
      {
        "content": ";;\n;; @brief      ${1:function description}\n;;\n;; @details    ${2:detailed description}\n;;\n;; @param      ${3:param}\n;;\n;; @return     ${4:return}\n;;",
        "doc": "",
        "grammar": "snu",
        "label": ";; @brief ...",
        "matches": {
          "doxy": true
        },
        "options": {
          "head": true
        }
      }
    ],
    "autoit": [
      {
        "content": "If ${1:condition} Then\n\t${0:; True code}\nEndIf",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "Else\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "el": true
        },
        "options": {}
      },
      {
        "content": "ElseIf ${1:condition} Then\n\t${0:; True code}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eif": true
        },
        "options": {}
      },
      {
        "content": "If ${1:condition} Then\n\t${2:; True code}\nElse\n\t${0:; Else code}\nEndIf",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "If ${1:condition 1} Then\n\t${2:; True code}\nElseIf ${3:condition 2} Then\n\t${4:; True code}\nElse\n\t${0:; Else code}\nEndIf",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifelif": true
        },
        "options": {}
      },
      {
        "content": "Switch (${1:condition})\nCase ${2:case1}:\n\t${3:; Case 1 code}\nCase Else:\n\t${0:; Else code}\nEndSwitch",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "switch": true
        },
        "options": {}
      },
      {
        "content": "Select (${1:condition})\nCase ${2:case1}:\n\t${3:; Case 1 code}\nCase Else:\n\t${0:; Else code}\nEndSelect",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "select": true
        },
        "options": {}
      },
      {
        "content": "While (${1:condition})\n\t${0:; code...}\nWEnd",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh": true
        },
        "options": {}
      },
      {
        "content": "For ${1:n} = ${3:1} to ${2:count}\n\t${0:; code...}\nNext",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "MsgBox(${0:MsgType}, ${1:\"Title\"}, ${2:\"Message Text\"})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "msg": true
        },
        "options": {}
      },
      {
        "content": "MsgBox(0, \"Debug\", ${0:\"Debug Message\"})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "debug": true
        },
        "options": {}
      },
      {
        "content": "MsgBox(0, \"${0:VarName}\", $1)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "showvar": true
        },
        "options": {}
      }
    ],
    "awk": [
      {
        "content": "#!/usr/bin/awk -f",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#! #!/usr/bin/awk -f": true
        },
        "options": {}
      },
      {
        "content": "@include \"${1}\"${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "inc @include": true
        },
        "options": {}
      },
      {
        "content": "@load \"${1}\"${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "loa @load": true
        },
        "options": {}
      },
      {
        "content": "BEGIN {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "beg BEGIN { ... }": true
        },
        "options": {}
      },
      {
        "content": "BEGINFILE {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "begf BEGINFILE { ... }": true
        },
        "options": {}
      },
      {
        "content": "END {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "end END { ... }": true
        },
        "options": {}
      },
      {
        "content": "ENDFILE {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "endf ENDFILE { ... }": true
        },
        "options": {}
      },
      {
        "content": "print ${1:\"${2}\"}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pri print": true
        },
        "options": {}
      },
      {
        "content": "printf(\"${1:%s}\\n\", ${2})${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "printf printf": true
        },
        "options": {}
      },
      {
        "content": "IGNORECASE = ${1:1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ign IGNORECASE": true
        },
        "options": {}
      },
      {
        "content": "if (${1}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if if {...}": true
        },
        "options": {}
      },
      {
        "content": "if (${1}) {\n\t${2:${VISUAL}}\n} else {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife if ... else ...": true
        },
        "options": {}
      },
      {
        "content": "else if (${1}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eif else if ...": true
        },
        "options": {}
      },
      {
        "content": "else {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "el else {...}": true
        },
        "options": {}
      },
      {
        "content": "while (${1}) {\n\t${2}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh while": true
        },
        "options": {}
      },
      {
        "content": "do {\n\t${0}\n} while (${1})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "do do ... while": true
        },
        "options": {}
      },
      {
        "content": "for (${2:i} = 0; i < ${1:n}; ${3:++i}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for for": true
        },
        "options": {}
      },
      {
        "content": "for (${1:i} in ${2:array}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fore for each": true
        },
        "options": {}
      },
      {
        "content": "switch (${1}) {\ncase ${2}:\n\t${3}\n\tbreak\ndefault:\n\t${0}\n\tbreak\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sw switch": true
        },
        "options": {}
      },
      {
        "content": "case ${1}:\n\t${0}\n\tbreak",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case case": true
        },
        "options": {}
      }
    ],
    "axios": [
      {
        "content": "const axios = require('axios').default;",
        "doc": "require axios",
        "grammar": "lsp",
        "label": "axios-require",
        "matches": {
          "axios require": true
        },
        "options": {}
      },
      {
        "content": "import axios from 'axios';",
        "doc": "import axios",
        "grammar": "lsp",
        "label": "axios-import",
        "matches": {
          "axios import": true
        },
        "options": {}
      },
      {
        "content": "axios.get('${1:uri}')\n.then(function (response) {\n\t${2:success}\n})\n.catch(function (error) {\n\t${3:error}\n})",
        "doc": "Use Axios to make a get request - promise based",
        "grammar": "lsp",
        "label": "axios-get-promise",
        "matches": {
          "axios get promise": true
        },
        "options": {}
      },
      {
        "content": "async function ${1:name}() {\n\ttry {\n\t\tconst response = await axios.get('${2:uri}');\n\t\t${3:success}\n\t}\tcatch (error) {\n\t\t${4:error}\n\t}\n}",
        "doc": "Use Axios to make a get request - async-await",
        "grammar": "lsp",
        "label": "axios-get-async-await",
        "matches": {
          "axios get async await": true
        },
        "options": {}
      },
      {
        "content": "axios.post('${1:uri}', ${2:post})\n.then(function (response) {\n\t${3:success}\n})\n.catch(function (error) {\n\t${4:error}\n})",
        "doc": "Use Axios to make a post request - promise based",
        "grammar": "lsp",
        "label": "axios-post-promise",
        "matches": {
          "axios post promise": true
        },
        "options": {}
      },
      {
        "content": "async function ${1:name}() {\n\ttry {\n\t\tconst response = await axios.post('${2:uri}', ${3:post});\n\t\t${4:success}\n\t}\tcatch (error) {\n\t\t${5:error}\n\t}\n}",
        "doc": "Use Axios to make a post request - async-await",
        "grammar": "lsp",
        "label": "axios-post-async-await",
        "matches": {
          "axios post async await": true
        },
        "options": {}
      },
      {
        "content": "const ${1:instance} = axios.create({\n\tbaseURL: '${2:uri}',\n\ttimeout: $3,\n\theaders: {'${4:key}': '${5:value}'}",
        "doc": "Create an Axios instance for requests",
        "grammar": "lsp",
        "label": "axios-instance",
        "matches": {
          "axios instance": true
        },
        "options": {}
      },
      {
        "content": "axios.defaults.${1:key} = '${2:value}';",
        "doc": "Define global axios defaults, eg. baseURL, headers etc.",
        "grammar": "lsp",
        "label": "axios-defaults",
        "matches": {
          "axios defaults": true
        },
        "options": {}
      },
      {
        "content": "axios.interceptors.request.use(function (config) {\n\t${1:do something}\nreturn config;\n}, function (error) {\n\t${2:do something}\n$return Promise.reject(error);\n});",
        "doc": "You can intercept requests before they are handled by then or catch.",
        "grammar": "lsp",
        "label": "axios-interceptors-request",
        "matches": {
          "axios interceptors request": true
        },
        "options": {}
      },
      {
        "content": "axios.interceptors.response.use(function (response) {\n\t${1:do something}\nreturn response;\n}, function (error) {\n\t${2:do something}\n$return Promise.reject(error);\n});",
        "doc": "You can intercept responses before they are handled by then or catch.",
        "grammar": "lsp",
        "label": "axios-interceptors-response",
        "matches": {
          "axios interceptors response": true
        },
        "options": {}
      }
    ],
    "base": [
      {
        "content": "var ${1:name} = ${2:value};",
        "doc": "var assignment",
        "grammar": "lsp",
        "label": "var-assignment",
        "matches": {
          "base var": true
        },
        "options": {}
      },
      {
        "content": "let ${1:name} = ${2:value};",
        "doc": "let assignment",
        "grammar": "lsp",
        "label": "let-assignment",
        "matches": {
          "base let": true
        },
        "options": {}
      },
      {
        "content": "let {${1:name}} = ${2:value};",
        "doc": "Object destructing",
        "grammar": "lsp",
        "label": "destructuring-let-assignment",
        "matches": {
          "base let destruct object": true
        },
        "options": {}
      },
      {
        "content": "let [${1:name}] = ${2:value};",
        "doc": "Array destructing",
        "grammar": "lsp",
        "label": "destructuring-let-array",
        "matches": {
          "base let destruct array": true
        },
        "options": {}
      },
      {
        "content": "const ${1:name} = ${2:value};",
        "doc": "const assignment",
        "grammar": "lsp",
        "label": "const-assignment",
        "matches": {
          "base const": true
        },
        "options": {}
      },
      {
        "content": "const {${1:name}} = ${2:value};",
        "doc": "Object destructing",
        "grammar": "lsp",
        "label": "destructuring-const-assignment",
        "matches": {
          "base const destruct object": true
        },
        "options": {}
      },
      {
        "content": "const [${2:propertyName}] = ${1:arrayToDestruct};",
        "doc": "Array destructing",
        "grammar": "lsp",
        "label": "destructingarray",
        "matches": {
          "base const destruct array": true
        },
        "options": {}
      },
      {
        "content": "if (${1:condition}) {\n\t${0}\n}",
        "doc": "if statement",
        "grammar": "lsp",
        "label": "if-statement",
        "matches": {
          "base if": true
        },
        "options": {}
      },
      {
        "content": "else {\n\t${0}\n}",
        "doc": "else statement",
        "grammar": "lsp",
        "label": "else-statement",
        "matches": {
          "base else": true
        },
        "options": {}
      },
      {
        "content": "if (${1:condition}) {\n\t${0}\n} else {\n\t\n}",
        "doc": "if/else statement",
        "grammar": "lsp",
        "label": "if-else-statement",
        "matches": {
          "base if else": true
        },
        "options": {}
      },
      {
        "content": "else if (${1:condition}) {\n\t${0}\n}",
        "doc": "else if statement",
        "grammar": "lsp",
        "label": "else-if-statement",
        "matches": {
          "base else if": true
        },
        "options": {}
      },
      {
        "content": "${1:condition} ? ${2:expression} : ${3:expression};",
        "doc": "ternary operator",
        "grammar": "lsp",
        "label": "ternary-operator",
        "matches": {
          "base ternary operator": true
        },
        "options": {}
      },
      {
        "content": "for (let ${1:i} = 0, ${2:len} = ${3:iterable}.length; ${1:i} < ${2:len}; ${1:i}++) {\n\t${0}\n}",
        "doc": "for loop",
        "grammar": "lsp",
        "label": "for-loop",
        "matches": {
          "base for": true
        },
        "options": {}
      },
      {
        "content": "for (let ${1:i} = ${2:iterable}.length - 1; ${1:i} >= 0; ${1:i}--) {\n\t${0}\n}",
        "doc": "reverse for loop",
        "grammar": "lsp",
        "label": "reverse-for-loop",
        "matches": {
          "base for reverse": true
        },
        "options": {}
      },
      {
        "content": "for (let ${1:key} in ${2:array}) {\n\tif (${2:array}.hasOwnProperty(${1:key})) {\n\t\t${0}\n\t}\n}",
        "doc": "for in loop",
        "grammar": "lsp",
        "label": "for-in-loop",
        "matches": {
          "base for in": true
        },
        "options": {}
      },
      {
        "content": "for (let ${1:key} of ${2:array}) {\n\t${0}\n}",
        "doc": "for of loop (ES6)",
        "grammar": "lsp",
        "label": "for-of-loop-es6-",
        "matches": {
          "base for of": true
        },
        "options": {}
      },
      {
        "content": "while (${1:condition}) {\n\t${0}\n}",
        "doc": "while loop",
        "grammar": "lsp",
        "label": "while-loop",
        "matches": {
          "base while": true
        },
        "options": {}
      },
      {
        "content": "try {\n\t${0}\n} catch (${1:err}) {\n\t\n}",
        "doc": "try/catch",
        "grammar": "lsp",
        "label": "try-catch",
        "matches": {
          "base try catch": true
        },
        "options": {}
      },
      {
        "content": "try {\n\t${0}\n} finally {\n\t\n}",
        "doc": "try/finally",
        "grammar": "lsp",
        "label": "try-finally",
        "matches": {
          "base try finally": true
        },
        "options": {}
      },
      {
        "content": "try {\n\t${0}\n} catch (${1:err}) {\n\t\n} finally {\n\t\n}",
        "doc": "try/catch/finally",
        "grammar": "lsp",
        "label": "try-catch-finally",
        "matches": {
          "base try catch finally": true
        },
        "options": {}
      },
      {
        "content": "switch (${1:expr}) {\n\tcase ${2:value}:\n\t\treturn $0;\n\tdefault:\n\t\treturn;\n}",
        "doc": "switch case",
        "grammar": "lsp",
        "label": "switch-case",
        "matches": {
          "base switch case": true
        },
        "options": {}
      },
      {
        "content": "function (${1:arguments}) {\n\t${0}\n}",
        "doc": "anonymous function",
        "grammar": "lsp",
        "label": "anonymous-function",
        "matches": {
          "base function anonymous": true
        },
        "options": {}
      },
      {
        "content": "function ${1:name}(${2:arguments}) {\n\t${0}\n}",
        "doc": "named function",
        "grammar": "lsp",
        "label": "named-function",
        "matches": {
          "base function named": true
        },
        "options": {}
      },
      {
        "content": "((${1:arguments}) => {\n\t${0}\n})(${2});",
        "doc": "immediately-invoked function expression (IIFE)",
        "grammar": "lsp",
        "label": "immediately-invoked-function-expression-iife-",
        "matches": {
          "base function immediate": true
        },
        "options": {}
      },
      {
        "content": "${1:fn}.apply(${2:this}, ${3:arguments})",
        "doc": "function apply",
        "grammar": "lsp",
        "label": "function-apply",
        "matches": {
          "base function apply": true
        },
        "options": {}
      },
      {
        "content": "${1:fn}.call(${2:this}, ${3:arguments})",
        "doc": "function call",
        "grammar": "lsp",
        "label": "function-call",
        "matches": {
          "base function call": true
        },
        "options": {}
      },
      {
        "content": "${1:fn}.bind(${2:this}, ${3:arguments})",
        "doc": "function bind",
        "grammar": "lsp",
        "label": "function-bind",
        "matches": {
          "base function bind": true
        },
        "options": {}
      },
      {
        "content": "(${1:arguments}) => ${2:statement}",
        "doc": "arrow function (ES6)",
        "grammar": "lsp",
        "label": "arrow-function-es6-",
        "matches": {
          "base function arrow": true
        },
        "options": {}
      },
      {
        "content": "(${1:arguments}) => {\n\t${0}\n}",
        "doc": "arrow function with body (ES6)",
        "grammar": "lsp",
        "label": "arrow-function-with-body-es6-",
        "matches": {
          "base function arrow body": true
        },
        "options": {}
      },
      {
        "content": "function* (${1:arguments}) {\n\t${0}\n}",
        "doc": "generator function (ES6)",
        "grammar": "lsp",
        "label": "generator-function-es6-",
        "matches": {
          "base function generator": true
        },
        "options": {}
      },
      {
        "content": "function* ${1:name}(${2:arguments}) {\n\t${0}\n}",
        "doc": "named generator function (ES6)",
        "grammar": "lsp",
        "label": "named-generator-function-es6-",
        "matches": {
          "base function generator named": true
        },
        "options": {}
      },
      {
        "content": "[...Array(${1:length}).keys()]${0}",
        "doc": "sequence of 0..n",
        "grammar": "lsp",
        "label": "sequence-of-0-n",
        "matches": {
          "base sequence of": true
        },
        "options": {}
      },
      {
        "content": "${1}.forEach((${2:item}) => {\n\t${0}\n});",
        "doc": "forEach loop",
        "grammar": "lsp",
        "label": "foreach-loop",
        "matches": {
          "base foreach": true
        },
        "options": {}
      },
      {
        "content": "${1}.map((${2:item}) => {\n\t${0}\n});",
        "doc": "map",
        "grammar": "lsp",
        "label": "map",
        "matches": {
          "base map": true
        },
        "options": {}
      },
      {
        "content": "${1}.reduce((${2:previous}, ${3:current}) => {\n\t${0}\n}${4:, initial});",
        "doc": "reduce",
        "grammar": "lsp",
        "label": "reduce",
        "matches": {
          "base reduce": true
        },
        "options": {}
      },
      {
        "content": "${1}.filter(${2:item} => {\n\t${0}\n});",
        "doc": "filter",
        "grammar": "lsp",
        "label": "filter",
        "matches": {
          "base filter": true
        },
        "options": {}
      },
      {
        "content": "${1}.find(${2:item} => {\n\t${0}\n});",
        "doc": "find",
        "grammar": "lsp",
        "label": "find",
        "matches": {
          "base find": true
        },
        "options": {}
      },
      {
        "content": "class ${1:name} {\n\tconstructor(${2:arguments}) {\n\t\t${0}\n\t}\n}",
        "doc": "class (ES6)",
        "grammar": "lsp",
        "label": "class-es6-",
        "matches": {
          "base class": true
        },
        "options": {}
      },
      {
        "content": "class ${1:name} extends ${2:base} {\n\tconstructor(${3:arguments}) {\n\t\tsuper(${3:arguments});\n\t\t${0}\n\t}\n}",
        "doc": "child class (ES6)",
        "grammar": "lsp",
        "label": "child-class-es6-",
        "matches": {
          "base child class": true
        },
        "options": {}
      },
      {
        "content": "constructor(${1:arguments}) {\n\tsuper(${1:arguments});${0}\n}",
        "doc": "class constructor (ES6)",
        "grammar": "lsp",
        "label": "class-constructor-es6-",
        "matches": {
          "base class constructor": true
        },
        "options": {}
      },
      {
        "content": "${1:method}(${2:arguments}) {\n\t${0}\n}",
        "doc": "method (ES6 syntax)",
        "grammar": "lsp",
        "label": "method-es6-syntax-",
        "matches": {
          "base method": true
        },
        "options": {}
      },
      {
        "content": "get ${1:property}() {\n\t${0}\n}",
        "doc": "getter (ES6 syntax)",
        "grammar": "lsp",
        "label": "getter-es6-syntax-",
        "matches": {
          "base getter": true
        },
        "options": {}
      },
      {
        "content": "set ${1:property}(${2:value}) {\n\t${0}\n}",
        "doc": "setter (ES6 syntax)",
        "grammar": "lsp",
        "label": "setter-es6-syntax-",
        "matches": {
          "base setter": true
        },
        "options": {}
      },
      {
        "content": "get ${1:property}() {\n\t${0}\n}\nset ${1:property}(${2:value}) {\n\t\n}",
        "doc": "getter and setter (ES6 syntax)",
        "grammar": "lsp",
        "label": "getter-and-setter-es6-syntax-",
        "matches": {
          "base getter setter": true
        },
        "options": {}
      },
      {
        "content": "${1:Class}.prototype.${2:method} = function(${3:arguments}) {\n\t${0}\n};",
        "doc": "prototype method",
        "grammar": "lsp",
        "label": "prototype-method",
        "matches": {
          "base prototype method": true
        },
        "options": {}
      },
      {
        "content": "Object.assign(${1:dest}, ${2:source})",
        "doc": "Object.assign",
        "grammar": "lsp",
        "label": "object-assign",
        "matches": {
          "base object assign": true
        },
        "options": {}
      },
      {
        "content": "Object.assign({}, ${1:original}, ${2:source})",
        "doc": "Object.assign copy (shallow clone)",
        "grammar": "lsp",
        "label": "object-assign-copy-shallow-clone-",
        "matches": {
          "base object assign copy": true
        },
        "options": {}
      },
      {
        "content": "return ${0};",
        "doc": "return",
        "grammar": "lsp",
        "label": "return",
        "matches": {
          "base return": true
        },
        "options": {}
      },
      {
        "content": "return new Promise((resolve, reject) => {\n\t${0}\n});",
        "doc": "return Promise (ES6)",
        "grammar": "lsp",
        "label": "return-promise-es6-",
        "matches": {
          "base return promise": true
        },
        "options": {}
      },
      {
        "content": "return (\n\t${0}\n);",
        "doc": "return complex value (such as JSX components)",
        "grammar": "lsp",
        "label": "return-complex-value-such-as-jsx-components-",
        "matches": {
          "base return complex value": true
        },
        "options": {}
      },
      {
        "content": "typeof ${1:source} === '${2:undefined}'",
        "doc": "typeof",
        "grammar": "lsp",
        "label": "typeof",
        "matches": {
          "base typeof": true
        },
        "options": {}
      },
      {
        "content": "${1:source} instanceof ${2:Object}",
        "doc": "instanceof",
        "grammar": "lsp",
        "label": "instanceof",
        "matches": {
          "base instanceof": true
        },
        "options": {}
      },
      {
        "content": "new Promise((resolve, reject) => {\n\t${0}\n})",
        "doc": "Promise (ES6)",
        "grammar": "lsp",
        "label": "promise-es6-",
        "matches": {
          "base promise": true
        },
        "options": {}
      },
      {
        "content": "${1:promise}.then((${2:value}) => {\n\t${0}\n})",
        "doc": "Promise.then",
        "grammar": "lsp",
        "label": "promise-then",
        "matches": {
          "base promise then": true
        },
        "options": {}
      },
      {
        "content": "${1:promise}.catch((${2:err}) => {\n\t${0}\n})",
        "doc": "Promise.catch",
        "grammar": "lsp",
        "label": "promise-catch",
        "matches": {
          "base promise catch": true
        },
        "options": {}
      },
      {
        "content": "export const ${1:exportVariable} = ${2:localVariable};\n",
        "doc": "Export named variable in ES6 syntax",
        "grammar": "lsp",
        "label": "exportnamedvariable",
        "matches": {
          "base export named variable": true
        },
        "options": {}
      },
      {
        "content": "export const ${1:functionName} = (${2:params}) => {\n\t$0\n};\n",
        "doc": "Export named function in ES6 syntax",
        "grammar": "lsp",
        "label": "exportnamedfunction",
        "matches": {
          "base export named function": true
        },
        "options": {}
      },
      {
        "content": "export default function ${1:${TM_FILENAME_BASE}}(${2:params}) {\n\t$0\n};\n",
        "doc": "Export default function in ES6 syntax",
        "grammar": "lsp",
        "label": "exportdefaultfunction",
        "matches": {
          "base export default function": true
        },
        "options": {}
      },
      {
        "content": "export default class ${1:className} {\n\t$0\n};\n",
        "doc": "Export default class in ES6 syntax",
        "grammar": "lsp",
        "label": "exportclass",
        "matches": {
          "base export class": true
        },
        "options": {}
      },
      {
        "content": "export default class ${1:className} extends ${2:baseclassName} {\n\t$0\n};\n",
        "doc": "Export default class which extends a base one in ES6 syntax",
        "grammar": "lsp",
        "label": "exportclassextends",
        "matches": {
          "base export class extends": true
        },
        "options": {}
      },
      {
        "content": "import ${2:moduleName} from '${1:module}';$0",
        "doc": "Imports entire module statement in ES6 syntax",
        "grammar": "lsp",
        "label": "import",
        "matches": {
          "base import": true
        },
        "options": {}
      },
      {
        "content": "import '${1:module}';$0",
        "doc": "Imports entire module in ES6 syntax without module name",
        "grammar": "lsp",
        "label": "importnomodulename",
        "matches": {
          "base import no module name": true
        },
        "options": {}
      },
      {
        "content": "import { $2 } from '${1:module}';$0",
        "doc": "Imports only a portion of the module in ES6 syntax",
        "grammar": "lsp",
        "label": "importdestructing",
        "matches": {
          "base import destructing": true
        },
        "options": {}
      },
      {
        "content": "import * as ${2:alias} from '${1:module}';$0",
        "doc": "Imports everything as alias from the module in ES6 syntax",
        "grammar": "lsp",
        "label": "importeverything",
        "matches": {
          "base import everything": true
        },
        "options": {}
      },
      {
        "content": "import { ${2:originalName} as ${3:alias} } from '${1:module}';$0",
        "doc": "Imports a specific portion of the module by assigning a local alias in ES6 syntax",
        "grammar": "lsp",
        "label": "importas",
        "matches": {
          "base import as": true
        },
        "options": {}
      },
      {
        "content": "require('${1:module}');",
        "doc": "require",
        "grammar": "lsp",
        "label": "require",
        "matches": {
          "base require": true
        },
        "options": {}
      },
      {
        "content": "require('./${1:module}');",
        "doc": "require local",
        "grammar": "lsp",
        "label": "require-local",
        "matches": {
          "base require local": true
        },
        "options": {}
      },
      {
        "content": "const ${1:module} = require('${1:module}');",
        "doc": "require assignment",
        "grammar": "lsp",
        "label": "require-assignment",
        "matches": {
          "base require assignment": true
        },
        "options": {}
      },
      {
        "content": "const ${1:module} = require('./${1:module}');",
        "doc": "require assignment local",
        "grammar": "lsp",
        "label": "require-assignment-local",
        "matches": {
          "base require assignment local": true
        },
        "options": {}
      },
      {
        "content": "const {${1:module}} = require('${1:module}');",
        "doc": "destructuring require assignment",
        "grammar": "lsp",
        "label": "destructuring-require-assignment",
        "matches": {
          "base require assignment": true
        },
        "options": {}
      },
      {
        "content": "const {${1:module}} = require('./${1:module}');",
        "doc": "destructuring require assignment local",
        "grammar": "lsp",
        "label": "destructuring-require-assignment-local",
        "matches": {
          "base require assignment local destruct": true
        },
        "options": {}
      },
      {
        "content": "exports.${1:member} = ${2:value};",
        "doc": "exports.member",
        "grammar": "lsp",
        "label": "exports-member",
        "matches": {
          "base exports member": true
        },
        "options": {}
      },
      {
        "content": "module.exports = ${1:name};",
        "doc": "module.exports",
        "grammar": "lsp",
        "label": "module-exports",
        "matches": {
          "base module exports": true
        },
        "options": {}
      },
      {
        "content": "module.exports = {\n\t${1:member}\n};",
        "doc": "module exports object",
        "grammar": "lsp",
        "label": "module-exports-object",
        "matches": {
          "base module exports object": true
        },
        "options": {}
      },
      {
        "content": "${1:emitter}.on('${2:event}', (${3:arguments}) => {\n\t${0}\n});",
        "doc": "event handler",
        "grammar": "lsp",
        "label": "event-handler",
        "matches": {
          "base event handler": true
        },
        "options": {}
      },
      {
        "content": "console.assert(${1:expression}, ${2:object});",
        "doc": "If the specified expression is false, the message is written to the console along with a stack trace",
        "grammar": "lsp",
        "label": "consoleassert",
        "matches": {
          "base console assert": true
        },
        "options": {}
      },
      {
        "content": "console.clear();",
        "doc": "Clears the console",
        "grammar": "lsp",
        "label": "consoleclear",
        "matches": {
          "base console clear": true
        },
        "options": {}
      },
      {
        "content": "console.count(${1:label});",
        "doc": "Writes the the number of times that count() has been invoked at the same line and with the same label",
        "grammar": "lsp",
        "label": "consolecount",
        "matches": {
          "base console count": true
        },
        "options": {}
      },
      {
        "content": "console.debug(${1:object});",
        "doc": "Displays a message in the console. Also display a blue right arrow icon along with the logged message in Safari",
        "grammar": "lsp",
        "label": "consoledebug",
        "matches": {
          "base console debug": true
        },
        "options": {}
      },
      {
        "content": "console.dir(${1:object});",
        "doc": "Prints a JavaScript representation of the specified object",
        "grammar": "lsp",
        "label": "consoledir",
        "matches": {
          "base console dir": true
        },
        "options": {}
      },
      {
        "content": "console.error(${1:object});",
        "doc": "Displays a message in the console and also includes a stack trace from where the method was called",
        "grammar": "lsp",
        "label": "consoleerror",
        "matches": {
          "base console error": true
        },
        "options": {}
      },
      {
        "content": "console.group('${1:label}');",
        "doc": "Groups and indents all following output by an additional level, until console.groupEnd() is called.",
        "grammar": "lsp",
        "label": "consolegroup",
        "matches": {
          "base console group": true
        },
        "options": {}
      },
      {
        "content": "console.groupEnd();",
        "doc": "Closes out the corresponding console.group().",
        "grammar": "lsp",
        "label": "consolegroupend",
        "matches": {
          "base console group end": true
        },
        "options": {}
      },
      {
        "content": "console.log(${1:object});",
        "doc": "Displays a message in the console",
        "grammar": "lsp",
        "label": "consolelog",
        "matches": {
          "base console log": true
        },
        "options": {}
      },
      {
        "content": "console.log('${1:object} :>> ', ${1:object});",
        "doc": "Displays an object in the console with its name",
        "grammar": "lsp",
        "label": "consolelogobject",
        "matches": {
          "base console log object": true
        },
        "options": {}
      },
      {
        "content": "console.trace(${1:object});",
        "doc": "Prints a stack trace from the point where the method was called",
        "grammar": "lsp",
        "label": "consoletrace",
        "matches": {
          "base console trace": true
        },
        "options": {}
      },
      {
        "content": "console.warn(${1:object});",
        "doc": "Displays a message in the console but also displays a yellow warning icon along with the logged message",
        "grammar": "lsp",
        "label": "consolewarn",
        "matches": {
          "base console warn": true
        },
        "options": {}
      },
      {
        "content": "console.info(${1:object});",
        "doc": "Displays a message in the console but also displays a blue information icon along with the logged message",
        "grammar": "lsp",
        "label": "consoleinfo",
        "matches": {
          "base console info": true
        },
        "options": {}
      },
      {
        "content": "console.table(${1:object});",
        "doc": "Displays tabular data as a table.",
        "grammar": "lsp",
        "label": "consoletable",
        "matches": {
          "base console table": true
        },
        "options": {}
      },
      {
        "content": "console.time(${1:object});",
        "doc": "Sets starting point for execution time measurement",
        "grammar": "lsp",
        "label": "consoletime",
        "matches": {
          "base console time": true
        },
        "options": {}
      },
      {
        "content": "console.timeEnd(${1:object});",
        "doc": "Sets end point for execution time measurement",
        "grammar": "lsp",
        "label": "consoletimeend",
        "matches": {
          "base console time end": true
        },
        "options": {}
      },
      {
        "content": "setTimeout(() => {\n\t${0}\n}, ${1:delay});",
        "doc": "setTimeout",
        "grammar": "lsp",
        "label": "settimeout",
        "matches": {
          "base set timeout": true
        },
        "options": {}
      },
      {
        "content": "setInterval(() => {\n\t${0}\n}, ${1:delay});",
        "doc": "setInterval",
        "grammar": "lsp",
        "label": "setinterval",
        "matches": {
          "base set interval": true
        },
        "options": {}
      },
      {
        "content": "setImmediate(() => {\n\t${0}\n});",
        "doc": "setImmediate",
        "grammar": "lsp",
        "label": "setimmediate",
        "matches": {
          "base set immediate": true
        },
        "options": {}
      },
      {
        "content": "process.nextTick(() => {\n\t${0}\n});",
        "doc": "process nextTick",
        "grammar": "lsp",
        "label": "process-nexttick",
        "matches": {
          "base process next tick": true
        },
        "options": {}
      },
      {
        "content": "'use strict';",
        "doc": "insert 'use strict' statement",
        "grammar": "lsp",
        "label": "insert-use-strict-statement",
        "matches": {
          "base use strict": true
        },
        "options": {}
      }
    ],
    "beancount": [
      {
        "content": "${1:YYYY}-${2:MM}-${3:DD} open ${4:Account} ${8:#:Commodity}",
        "doc": "",
        "grammar": "snu",
        "label": "open account",
        "matches": {
          "open": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "${1:YYYY}-${2:MM}-${3:DD} close ${4:#:Account}",
        "doc": "",
        "grammar": "snu",
        "label": "close account",
        "matches": {
          "close": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "${1:YYYY}-${2:MM}-${3:DD} commodity ${4:Commodity}",
        "doc": "",
        "grammar": "snu",
        "label": "declare commodity",
        "matches": {
          "commodity": true,
          "currency": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "${1:YYYY}-${2:MM}-${3:DD} * \"${5:Payee}\" \"${6:Narration}\"\n\t${9:Account} ${10:Amount} ${11:Commodity}\n\t${14:Account} ${15:#:Amount} ${16:#:Commodity}",
        "doc": "",
        "grammar": "snu",
        "label": "transaction",
        "matches": {
          "transaction": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "${1:YYYY}-${2:MM}-${3:DD} balance ${4:Account} ${5:Amount} ${6:#:Commodity}",
        "doc": "",
        "grammar": "snu",
        "label": "balance",
        "matches": {
          "balance": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "${1:YYYY}-${2:MM}-${3:DD} pad ${4:BalanceAccount} ${5:PadAccount}",
        "doc": "",
        "grammar": "snu",
        "label": "pad",
        "matches": {
          "pad": true
        },
        "options": {
          "head": true
        }
      }
    ],
    "bib": [
      {
        "content": "@article{${1:LABEL},\n    author = {${2}},\n    title = {${3}},\n    journal = {${4}},\n    year = {${5}},\n    memo = {volume, number, pages, month, note}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@article": true,
          "article": true
        },
        "options": {}
      },
      {
        "content": "@book{${1:LABEL},\n    author/editor = {${2}},\n    title = {${3}},\n    publisher = {${4}},\n    year = {${5}},\n    memo = {volume, series, address, edition, month, note},\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@book": true,
          "book": true
        },
        "options": {}
      },
      {
        "content": "@booklet{${1:LABEL},\n    title = {${2}},\n    memo = {author, howpublished, address, month, year, note},\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@booklet": true,
          "booklet": true
        },
        "options": {}
      },
      {
        "content": "@inbook{${1:LABEL},\n    author/editor = {${2}},\n    title = {${3}},\n    chapter/pages = {${4}},\n    publisher = {${5}},\n    year = {${6}},\n    memo = {volume, series, address, edition, month, note},\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@inbook": true,
          "inbook": true
        },
        "options": {}
      },
      {
        "content": "@incollection{${1:LABEL},\n    author = {${2}},\n    title = {${3}},\n    booktitle = {${4}},\n    year = {${5}},\n    memo = {editor, pages, organization, publisher, address, month, note},\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@incollection": true,
          "incollection": true
        },
        "options": {}
      },
      {
        "content": "@inproceedings{${1:LABEL},\n    author = {${2}},\n    title = {${3}},\n    booktitle = {${4}},\n    year = {${5}},\n    memo = {editor, volume, number, series, pages, address, month,\n        organization, publisher, note}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@inproceedings @conference conference": true,
          "inproceedings": true
        },
        "options": {}
      },
      {
        "content": "@manual{${1:LABEL},\n    title = {${2}},\n    memo = {author, organization, address, edition, month, year, note},\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@manual": true,
          "manual": true
        },
        "options": {}
      },
      {
        "content": "@mastersthesis{${1:LABEL},\n    author = {${2}},\n    title = {${3}},\n    school = {${4}},\n    year = {${5}},\n    memo = {address, month, note},\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@mastersthesis": true,
          "mastersthesis": true
        },
        "options": {}
      },
      {
        "content": "@misc{${1:LABEL},\n    memo = {author, title, howpublished, month, year, note},\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@misc": true,
          "misc": true
        },
        "options": {}
      },
      {
        "content": "@online{${1:LABEL},\n    author = {${2}},\n    title = {${3}},\n    url = {${4}},\n    note = {year/date},\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@online": true,
          "online": true
        },
        "options": {}
      },
      {
        "content": "@phdthesis{${1:LABEL},\n    author = {${2}},\n    title = {${3}},\n    school = {${4}},\n    year = {${5}},\n    memo = {address, month, note},\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@phdthesis": true,
          "phdthesis": true
        },
        "options": {}
      },
      {
        "content": "@proceedings{${1:LABEL},\n    title = {${2}},\n    year = {${3}},\n    memo = {editor, publisher, organization, address, month, note},\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@proceedings": true,
          "proceedings": true
        },
        "options": {}
      },
      {
        "content": "@techreport{${1:LABEL},\n    author = {${2}},\n    title = {${3}},\n    institution = {${4}},\n    year = {${5}},\n    memo = {type, number, address, month, note},\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@techreport": true,
          "techreport": true
        },
        "options": {}
      },
      {
        "content": "@unpublished{${1:LABEL},\n    author = {${2}},\n    title = {${3}},\n    note = {${4}},\n    memo = {month, year},\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@unpublished": true,
          "unpublished": true
        },
        "options": {}
      },
      {
        "content": "address = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "address": true
        },
        "options": {}
      },
      {
        "content": "annote = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "annote": true
        },
        "options": {}
      },
      {
        "content": "author = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "author": true
        },
        "options": {}
      },
      {
        "content": "booktitle = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "booktitle": true
        },
        "options": {}
      },
      {
        "content": "crossref = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "crossref": true
        },
        "options": {}
      },
      {
        "content": "chapter = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "chapter": true
        },
        "options": {}
      },
      {
        "content": "edition = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "edition": true
        },
        "options": {}
      },
      {
        "content": "editor = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "editor": true
        },
        "options": {}
      },
      {
        "content": "eprint = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eprint": true
        },
        "options": {}
      },
      {
        "content": "howpublished = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "howpublished": true
        },
        "options": {}
      },
      {
        "content": "institution = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "institution": true
        },
        "options": {}
      },
      {
        "content": "journal = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "journal": true
        },
        "options": {}
      },
      {
        "content": "key = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "key": true
        },
        "options": {}
      },
      {
        "content": "month = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "month": true
        },
        "options": {}
      },
      {
        "content": "note = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "note": true
        },
        "options": {}
      },
      {
        "content": "number = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "number": true
        },
        "options": {}
      },
      {
        "content": "organization = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "organization": true
        },
        "options": {}
      },
      {
        "content": "pages = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pages": true
        },
        "options": {}
      },
      {
        "content": "publisher = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "publisher": true
        },
        "options": {}
      },
      {
        "content": "school = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "school": true
        },
        "options": {}
      },
      {
        "content": "series = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "series": true
        },
        "options": {}
      },
      {
        "content": "title = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "title": true
        },
        "options": {}
      },
      {
        "content": "type = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "type": true
        },
        "options": {}
      },
      {
        "content": "url = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "url": true
        },
        "options": {}
      },
      {
        "content": "volume = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "volume": true
        },
        "options": {}
      },
      {
        "content": "year = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "year": true
        },
        "options": {}
      },
      {
        "content": "@online{${1:name},\n\tauthor={${2:author}},\n\ttitle={${3:title}},\n\tdate={${4:date}},\n\turl={${5:url}}\n}\n$0",
        "doc": "",
        "grammar": "snu",
        "label": "Online resource",
        "matches": {
          "online": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "@article{${1:name},\n\tauthor={${2:author}},\n\ttitle={${3:title}},\n\tjournaltitle={${4:journal}},\n\tvolume={${5:NN}},\n\tnumber={${6:NN}},\n\tyear={${7:YYYY}},\n\tpages={${8:NN}--${9:NN}}\n}\n$0",
        "doc": "",
        "grammar": "snu",
        "label": "Article reference",
        "matches": {
          "article": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "@book{${1:name},\n\tauthor={${2:author}},\n\ttitle={${3:title}},\n\tsubtitle={${4:subtitle}},\n\tyear={${5:YYYY}},\n\tlocation={${6:somewhere}},\n\tpublisher={${7:publisher}},\n\tpages={${8:NN}--${9:NN}}\n}\n$0",
        "doc": "",
        "grammar": "snu",
        "label": "Book reference",
        "matches": {
          "book": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "@inbook{${1:name},\n\tauthor={${2:author}},\n\ttitle={${3:title}},\n\tsubtitle={${4:subtitle}},\n\tbooktitle={${5:book}},\n\teditor={${6:editor}},\n\tyear={${7:YYYY}},\n\tlocation={${8:somewhere}},\n\tpublisher={${9:publisher}},\n\tpages={${10:NN}--${11:NN}}\n}\n$0",
        "doc": "",
        "grammar": "snu",
        "label": "In Book reference",
        "matches": {
          "inb": true
        },
        "options": {
          "b": true
        }
      }
    ],
    "bindzone": [],
    "blade": [
      {
        "content": "@yield('${1}')",
        "doc": "",
        "grammar": "snu",
        "label": "@yield",
        "matches": {
          "yl": true
        },
        "options": {}
      },
      {
        "content": "@extends('${1}')",
        "doc": "",
        "grammar": "snu",
        "label": "@extends",
        "matches": {
          "ext": true
        },
        "options": {}
      },
      {
        "content": "@section('${1}', '${2}')",
        "doc": "",
        "grammar": "snu",
        "label": "@section",
        "matches": {
          "sec": true
        },
        "options": {}
      },
      {
        "content": "@section('${1:section name}')\n    ${2}\n@endsection",
        "doc": "",
        "grammar": "snu",
        "label": "@section ... @endsection",
        "matches": {
          "section": true
        },
        "options": {}
      },
      {
        "content": "@section('${1:section name}')\n    @parent\n    ${2}\n@endsection",
        "doc": "",
        "grammar": "snu",
        "label": "@section @parent ... @endsection",
        "matches": {
          "section-parent": true
        },
        "options": {}
      },
      {
        "content": "@component('${1}')\n    ${2}\n@endcomponent",
        "doc": "",
        "grammar": "snu",
        "label": "@component ... @endcomponent",
        "matches": {
          "compo": true
        },
        "options": {}
      },
      {
        "content": "@slot('${1}')\n    ${2}\n@endslot",
        "doc": "",
        "grammar": "snu",
        "label": "@slot ... @endslot",
        "matches": {
          "slot": true
        },
        "options": {}
      },
      {
        "content": "@if(${1:condition})\n   ${2}\n@endif",
        "doc": "",
        "grammar": "snu",
        "label": "if ... endif",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "@if (${1:condition})\n   ${2}\n@elseif (${3:condition})\n   ${4}\n@else\n   ${5}\n@endif",
        "doc": "",
        "grammar": "snu",
        "label": "if elseif else endif",
        "matches": {
          "ifelse": true
        },
        "options": {}
      },
      {
        "content": "@unless (${1:condition})\n    ${2}\n@endunless",
        "doc": "",
        "grammar": "snu",
        "label": "@unless ... @endunless",
        "matches": {
          "unless": true
        },
        "options": {}
      },
      {
        "content": "@isset(${1})\n    ${2}\n@endisset",
        "doc": "",
        "grammar": "snu",
        "label": "@isset ... @endisset",
        "matches": {
          "isset": true
        },
        "options": {}
      },
      {
        "content": "@empty(${1})\n    ${2}\n@endempty",
        "doc": "",
        "grammar": "snu",
        "label": "@empty ... @endempty",
        "matches": {
          "empty": true
        },
        "options": {}
      },
      {
        "content": "@for ($i = 0; $i < ${1}; $i++)\n    ${2}\n@endfor",
        "doc": "",
        "grammar": "snu",
        "label": "@for ... @endfor",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "@foreach (${1} as ${2})\n    ${3}\n@endforeach",
        "doc": "",
        "grammar": "snu",
        "label": "@foreach ... @endforeach",
        "matches": {
          "foreach": true
        },
        "options": {}
      },
      {
        "content": "@forelse (${1} as ${2})\n    ${3}\n@empty\n    ${4}\n@endforelse",
        "doc": "",
        "grammar": "snu",
        "label": "@forelse ... @empty ... @endforeach",
        "matches": {
          "forelse": true
        },
        "options": {}
      },
      {
        "content": "@while (${1})\n    ${2}\n@endwhile",
        "doc": "",
        "grammar": "snu",
        "label": "@while ... @endwhile",
        "matches": {
          "while": true
        },
        "options": {}
      },
      {
        "content": "{{-- ${1} --}}",
        "doc": "",
        "grammar": "snu",
        "label": "{{-- comments --}}",
        "matches": {
          "comment": true
        },
        "options": {}
      },
      {
        "content": "@php\n    ${1}\n@endphp",
        "doc": "",
        "grammar": "snu",
        "label": "@php ... @endphp",
        "matches": {
          "php": true
        },
        "options": {}
      },
      {
        "content": "@include('${1}')",
        "doc": "",
        "grammar": "snu",
        "label": "@include",
        "matches": {
          "include": true
        },
        "options": {}
      },
      {
        "content": "@break",
        "doc": "",
        "grammar": "snu",
        "label": "@break",
        "matches": {
          "break": true
        },
        "options": {}
      },
      {
        "content": "@component('$1')\n\t${2:${VISUAL}}\n@endcomponent",
        "doc": "",
        "grammar": "snu",
        "label": "@component directive",
        "matches": {
          "component": true
        },
        "options": {}
      },
      {
        "content": "@each('$1', $$2, '$3')",
        "doc": "",
        "grammar": "snu",
        "label": "@each directive",
        "matches": {
          "each": true
        },
        "options": {}
      },
      {
        "content": "@else",
        "doc": "",
        "grammar": "snu",
        "label": "@else directive",
        "matches": {
          "else": true
        },
        "options": {}
      },
      {
        "content": "@else if ($1)\n\t${2:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "@else if directive",
        "matches": {
          "eif": true
        },
        "options": {}
      },
      {
        "content": "@for ($1)\n\t${2:${VISUAL}}\n@endfor",
        "doc": "",
        "grammar": "snu",
        "label": "@for directive",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "@foreach ($$1 as $$2)\n\t${3:${VISUAL}}\n@endforeach",
        "doc": "",
        "grammar": "snu",
        "label": "@foreach directive",
        "matches": {
          "foreach": true
        },
        "options": {}
      },
      {
        "content": "@extends('$1')",
        "doc": "",
        "grammar": "snu",
        "label": "@extends directive",
        "matches": {
          "extends": true
        },
        "options": {}
      },
      {
        "content": "@if ($1)\n\t${2:${VISUAL}}\n@endif",
        "doc": "",
        "grammar": "snu",
        "label": "@if directive",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "@if ($1)\n\t${2:${VISUAL}}\n@else\n\t${3:${VISUAL}}\n@endif",
        "doc": "",
        "grammar": "snu",
        "label": "@if @else structure",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "@include('$1')",
        "doc": "",
        "grammar": "snu",
        "label": "@include directive",
        "matches": {
          "include": true
        },
        "options": {}
      },
      {
        "content": "@includeIf('$1')",
        "doc": "",
        "grammar": "snu",
        "label": "@includeIf directive",
        "matches": {
          "includeIf": true
        },
        "options": {}
      },
      {
        "content": "@isset\n\t${1:${VISUAL}}\n@endisset",
        "doc": "",
        "grammar": "snu",
        "label": "@isset directive",
        "matches": {
          "isset": true
        },
        "options": {}
      },
      {
        "content": "@inject('$1', '$2')",
        "doc": "",
        "grammar": "snu",
        "label": "@inject directive",
        "matches": {
          "inject": true
        },
        "options": {}
      },
      {
        "content": "@lang('$1')",
        "doc": "",
        "grammar": "snu",
        "label": "@lang directive",
        "matches": {
          "lang": true
        },
        "options": {
          "i": true
        }
      },
      {
        "content": "@php\n\t${1:${VISUAL}}\n@endphp",
        "doc": "",
        "grammar": "snu",
        "label": "@php directive",
        "matches": {
          "php": true
        },
        "options": {}
      },
      {
        "content": "@push('$1')\n\t${2:${VISUAL}}\n@endpush",
        "doc": "",
        "grammar": "snu",
        "label": "@push directive",
        "matches": {
          "push": true
        },
        "options": {}
      },
      {
        "content": "@section('$1')",
        "doc": "",
        "grammar": "snu",
        "label": "@section directive",
        "matches": {
          "section": true
        },
        "options": {}
      },
      {
        "content": "@show",
        "doc": "",
        "grammar": "snu",
        "label": "@show directive",
        "matches": {
          "show": true
        },
        "options": {}
      },
      {
        "content": "@slot('$1')\n\t${2:${VISUAL}}\n@endslot",
        "doc": "",
        "grammar": "snu",
        "label": "@slot directive",
        "matches": {
          "slot": true
        },
        "options": {}
      },
      {
        "content": "@unless\n\t${1:${VISUAL}}\n@endunless",
        "doc": "",
        "grammar": "snu",
        "label": "@unless directive",
        "matches": {
          "unless": true
        },
        "options": {}
      },
      {
        "content": "@verbatim\n\t${0:$VISUAL}\n@endverbatim",
        "doc": "",
        "grammar": "snu",
        "label": "@verbatim directive",
        "matches": {
          "verbatim": true
        },
        "options": {}
      },
      {
        "content": "@while ($1)\n\t${2:${VISUAL}}\n@endwhile",
        "doc": "",
        "grammar": "snu",
        "label": "@while directive",
        "matches": {
          "wh": true
        },
        "options": {}
      },
      {
        "content": "@yield('$1')",
        "doc": "",
        "grammar": "snu",
        "label": "@yield directive",
        "matches": {
          "yield": true
        },
        "options": {}
      },
      {
        "content": "{{ $1 }}",
        "doc": "",
        "grammar": "snu",
        "label": "{{ }} statement.",
        "matches": {
          "{": true
        },
        "options": {
          "i": true
        }
      },
      {
        "content": "{!! $1 !!}",
        "doc": "",
        "grammar": "snu",
        "label": "{!! !!} statement",
        "matches": {
          "{!": true
        },
        "options": {
          "i": true
        }
      }
    ],
    "c": [
      {
        "content": "if (${1:#:condition}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if () {}",
        "matches": {
          "if": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "else {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "else {}",
        "matches": {
          "else": true
        },
        "options": {}
      },
      {
        "content": "else if (${1:#:condition}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "else () {}",
        "matches": {
          "elseif": true
        },
        "options": {}
      },
      {
        "content": "if (${1:#:condition}) {\n    ${2:TARGET}\n} else {\n    ${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if () {} else {}",
        "matches": {
          "ifelse": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "for (${1:int} ${2:i} = ${3:0}; $2 < ${4}; $2++) {\n    ${0:#:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "for () {}",
        "matches": {
          "for": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "for (int ${1:i} = 0; $1 < ${2}; $1++) {\n    ${0:#:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "for (int x;...; x++) {}",
        "matches": {
          "fori": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "for (int ${1:i} = ${2}; $1 >= 0; $1--) {\n    ${0:#:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "for (int x; ...; x--) {}",
        "matches": {
          "forri": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "while (${1:#:condition}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "while () {}",
        "matches": {
          "while": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "do {\n    ${0:TARGET:code}\n} while (${1:#:condition});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "do": true,
          "do_while": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "switch (${1:#:var}) {\n\tcase ${2:#:val}:\n\t\t${0:TARGET}\n\t\tbreak;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "switch () {}",
        "matches": {
          "switch": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "case ${1}:\n\t${0}\n\tbreak;",
        "doc": "",
        "grammar": "snu",
        "label": "case: break;",
        "matches": {
          "case": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "(${1:#:condition}) ? ${2:#:a} : ${3:#:b}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "conditional": true
        },
        "options": {}
      },
      {
        "content": "${1:void} ${2:#:func_name}(${3:void}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "func() {}",
        "matches": {
          "func": true,
          "function": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "struct ${1:#:name} {\n    ${0:TARGET:data}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "struct {}",
        "matches": {
          "struct": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "typedef struct ${1:#:name} {\n    ${0:TARGET:data}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "struct_typedef": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "enum ${1:#:name} {\n    ${0:TARGET}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "enum {}",
        "matches": {
          "enum": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "int main(int argc, char* argv[])\n{\n\t${0:TARGET}\n\treturn 0;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "main": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "#include <stdio.h>\nint main(int argc, char* argv[])\n{\n    puts(\"hello, world!\");\n    return 0;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "helloworld": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "#include <${1:stdio}.h>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#inc, #include": true,
          "inc": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "#include \"${1}.h\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#inc2, #include2": true,
          "inc2": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "#if ${1}\n${0}\n#endif",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#if": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "#ifdef ${1:#:SYMBOL}\n${0}\n#endif",
        "doc": "",
        "grammar": "snu",
        "label": "#ifdef ... #endif",
        "matches": {
          "#ifdef": true,
          "ifdef": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "#ifndef $1\n#define ${1:#:SYMBOL}\n#endif${0}",
        "doc": "",
        "grammar": "snu",
        "label": "#ifndef ... #define ... #endif",
        "matches": {
          "#ifndef": true,
          "ifndef": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "#define ${1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#def, #define": true,
          "def": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "#ifndef ${1:#:SYMBOL}\n    #define $1\n    ${0:TARGET}\n#endif /* end of include guard */",
        "doc": "",
        "grammar": "snu",
        "label": "#ifndef ... #define ... #endif",
        "matches": {
          "include-guard": true,
          "once": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "printf(\"${1}\\n\"${2});",
        "doc": "",
        "grammar": "snu",
        "label": "printf(\"...\\n\", ...);",
        "matches": {
          "printf": true
        },
        "options": {}
      },
      {
        "content": "scanf(\"${1}\", ${2});",
        "doc": "",
        "grammar": "snu",
        "label": "scanf(\"...\", ...);",
        "matches": {
          "scanf": true
        },
        "options": {}
      },
      {
        "content": "fprintf(${1:stderr}, \"${2}\\n\"${3});",
        "doc": "",
        "grammar": "snu",
        "label": "fprintf(..., \"...\\n\", ...);",
        "matches": {
          "fprintf": true
        },
        "options": {}
      },
      {
        "content": "fopen(\"${1:PATH}\", \"${2:MODE}\");\n${0:TARGET}\nfclose(${3:FD});",
        "doc": "",
        "grammar": "snu",
        "label": "fopen(\"...\", \"...\");",
        "matches": {
          "fopen": true
        },
        "options": {}
      },
      {
        "content": "fgets(${0:ROW}, ${1:LENGTH}, ${2:stdin});",
        "doc": "",
        "grammar": "snu",
        "label": "fgets(row, length, file);",
        "matches": {
          "fgets": true
        },
        "options": {}
      },
      {
        "content": "fscanf(${1:stdin}, \"${2}\", ${3});",
        "doc": "",
        "grammar": "snu",
        "label": "fscanf(file, \"...\", ...);",
        "matches": {
          "fscanf": true
        },
        "options": {}
      },
      {
        "content": "fwrite(${1:ARRAY}, sizeof(${2:TYPE}), ${3:N_MEMBERS}, ${4:FILE})",
        "doc": "",
        "grammar": "snu",
        "label": "fwrite(......, file)",
        "matches": {
          "fwrite": true
        },
        "options": {}
      },
      {
        "content": "fread(${1:ARRAY}, sizeof(${2:TYPE}), ${3:N_MEMBERS}, ${4:FILE})",
        "doc": "",
        "grammar": "snu",
        "label": "fread(......, file)",
        "matches": {
          "fread": true
        },
        "options": {}
      },
      {
        "content": "memcpy(${1:DEST}, ${2:SRC}, ${3:NBYTES})",
        "doc": "",
        "grammar": "snu",
        "label": "memcpy(dest, src, nbytes)",
        "matches": {
          "memcpy": true
        },
        "options": {}
      },
      {
        "content": "($2 *)malloc(${1:N_MEMBERS} * sizeof(${2:TYPE}));\n${0}\nfree(${3:MEM});",
        "doc": "",
        "grammar": "snu",
        "label": "malloc(size)",
        "matches": {
          "malloc": true
        },
        "options": {}
      },
      {
        "content": "($2 *)calloc(${1:N_MEMBERS}, sizeof(${2:TYPE}));\n${0}\nfree(${3:MEM});",
        "doc": "",
        "grammar": "snu",
        "label": "calloc(n, size)",
        "matches": {
          "calloc": true
        },
        "options": {}
      },
      {
        "content": "($3 *)realloc(${1:OLD}, ${2:N_MEMBERS} * sizeof(${3:TYPE}));\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "realloc(old, size)",
        "matches": {
          "realloc": true
        },
        "options": {}
      },
      {
        "content": "srand(time(NULL));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "seed_rand": true
        },
        "options": {}
      },
      {
        "content": "typedef ${1:#:base_type} ${2:#:custom_type};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "typedef": true
        },
        "options": {}
      },
      {
        "content": "sizeof(${0:TARGET})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "size": true,
          "sizeof": true
        },
        "options": {}
      },
      {
        "content": "(sizeof(${1:#:array}) / sizeof(*($1)))",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "array_size": true,
          "sizeof_array": true
        },
        "options": {}
      },
      {
        "content": "_Static_assert(${1:#:condition}, ${2:#:message});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "_Static_assert": true,
          "_static_assert": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "static_assert(${1:#:condition}, ${2:#:message});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "static_assert": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "_Generic(${1:#:expression}, ${2:#:association-list})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "_Generic": true,
          "generic, select": true
        },
        "options": {}
      },
      {
        "content": "va_list ${1:ap};\nva_start($1, ${2:LAST_ARG});\n${0}\nva_end($1);",
        "doc": "",
        "grammar": "snu",
        "label": "va_start(va_list, last_arg); ... ; va_end()",
        "matches": {
          "va_list": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "/* ${1:#:comment} */\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "/*": true,
          "comment": true
        },
        "options": {}
      },
      {
        "content": "/**\n * @brief    ${1:function description}\n *\n * @details  ${2:detailed description}\n *\n * @param    ${3:param}\n *\n * @return   ${4:return type}\n */",
        "doc": "",
        "grammar": "snu",
        "label": "/** @brief ...",
        "matches": {
          "doxy": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "int main(int argc, char *argv[])\n{\n\t${0}\n\treturn 0;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "main": true
        },
        "options": {}
      },
      {
        "content": "int main(void)\n{\n\t${0}\n\treturn 0;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mainn": true
        },
        "options": {}
      },
      {
        "content": "#include <${1:stdio}.h>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "inc": true
        },
        "options": {}
      },
      {
        "content": "#ifndef $1\n#define ${1:SYMBOL} ${2:value}\n#endif /* ifndef $1 */",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ndef": true
        },
        "options": {}
      },
      {
        "content": "#define",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "def": true
        },
        "options": {}
      },
      {
        "content": "#ifdef ${1:FOO}\n\t${2:#define }\n#endif",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifdef": true
        },
        "options": {}
      },
      {
        "content": "#if ${1:FOO}\n\t${0:${VISUAL}}\n#endif",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#if": true
        },
        "options": {}
      },
      {
        "content": "#ifdef __cplusplus\nextern \"C\" {\n#endif\n${0}\n#ifdef __cplusplus\n} /* extern \"C\" */\n#endif",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nocxx": true
        },
        "options": {}
      },
      {
        "content": "if (${1:true}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "if (${1:true}) {\n\t${2:${VISUAL}}\n} else {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "else {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "el": true
        },
        "options": {}
      },
      {
        "content": "else if (${1:true}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "elif": true
        },
        "options": {}
      },
      {
        "content": "if (${1:true}) ${0};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifi": true
        },
        "options": {}
      },
      {
        "content": "${1:/* condition */} ? ${2:a} : ${3:b}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "t": true
        },
        "options": {}
      },
      {
        "content": "switch (${1:/* variable */}) {\n\tcase ${2:/* variable case */}:\n\t\t${3}\n\t\t${4:break;}${5}\n\tdefault:\n\t\t${6}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "switch": true
        },
        "options": {}
      },
      {
        "content": "switch (${1:/* variable */}) {\n\tcase ${2:/* variable case */}:\n\t\t${3}\n\t\t${4:break;}${5}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "switchndef": true
        },
        "options": {}
      },
      {
        "content": "case ${1:/* variable case */}:\n\t${2}\n\t${3:break;}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case": true
        },
        "options": {}
      },
      {
        "content": "return ${0};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ret": true
        },
        "options": {}
      },
      {
        "content": "for (int ${2:i} = 0; $2 < ${1:count}; $2${3:++}) {\n\t${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "for (int ${1:i} = ${2:0}; ${3:$1 < 10}; $1${4:++}) {\n\t${5}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forr": true
        },
        "options": {}
      },
      {
        "content": "while (${1:/* condition */}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh": true
        },
        "options": {}
      },
      {
        "content": "do {\n\t${0:${VISUAL}}\n} while (${1:/* condition */});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "do": true
        },
        "options": {}
      },
      {
        "content": "${1:void} ${2:function_name}(${3})\n{\n\t${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fun": true
        },
        "options": {}
      },
      {
        "content": "${1:void} ${2:function_name}()\n{\n\t${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fun0": true
        },
        "options": {}
      },
      {
        "content": "/*! \\brief ${1:Brief function description here}\n *\n *  ${2:Detailed description of the function}\n *\n * \\return ${3:Return parameter description}\n */\n${4:void} ${5:function_name}()\n{\n\t${6}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dfun0": true
        },
        "options": {}
      },
      {
        "content": "${1:void} ${2:function_name}(${3:Type} ${4:Parameter})\n{\n\t${5}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fun1": true
        },
        "options": {}
      },
      {
        "content": "/*! \\brief ${1:Brief function description here}\n *\n *  ${2:Detailed description of the function}\n *\n * \\param $3 ${4:Parameter description}\n * \\return ${5:Return parameter description}\n */\n${6:void} ${7:function_name}(${8:Type} ${3:Parameter})\n{\n\t${9}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dfun1": true
        },
        "options": {}
      },
      {
        "content": "${1:void} ${2:function_name}(${3:Type} ${4:Parameter}, ${5:Type} ${6:Parameter})\n{\n\t${7}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fun2": true
        },
        "options": {}
      },
      {
        "content": "/*! \\brief ${1:Brief function description here}\n *\n *  ${2:Detailed description of the function}\n *\n * \\param $3 ${4:Parameter description}\n * \\param $5 ${6:Parameter description}\n * \\return ${7:Return parameter description}\n */\n${8:void} ${9:function_name}(${10:Type} ${3:Parameter}, ${11:Type} ${5:Parameter})\n{\n\t${12}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dfun2": true
        },
        "options": {}
      },
      {
        "content": "${1:void} ${2:function_name}(${3:Type} ${4:Parameter}, ${5:Type} ${6:Parameter}, ${7:Type} ${8:Parameter})\n{\n\t${9}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fun3": true
        },
        "options": {}
      },
      {
        "content": "/*! \\brief ${1:Brief function description here}\n *\n *  ${2:Detailed description of the function}\n *\n * \\param $3 ${4:Parameter description}\n * \\param $5 ${6:Parameter description}\n * \\param $7 ${8:Parameter description}\n * \\return ${9:Return parameter description}\n */\n${10:void} ${11:function_name}(${12:Type} ${3:Parameter}, ${13:Type} ${5:Parameter}, ${14:Type} ${7:Parameter})\n{\n\t${15}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dfun3": true
        },
        "options": {}
      },
      {
        "content": "${1:void} ${2:function_name}(${3});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fund": true
        },
        "options": {}
      },
      {
        "content": "typedef ${1:int} ${2:MyCustomType};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "td": true
        },
        "options": {}
      },
      {
        "content": "/*! \\enum $1\n *\n *  ${2:Detailed description}\n */\nenum ${1:name} { ${0} };",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "enum": true
        },
        "options": {}
      },
      {
        "content": "/*! \\enum $2\n *\n *  ${4:Detailed description}\n */\ntypedef enum {\n\t${1:Data} /*!< ${3:Description} */\n} ${2:foo};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tde": true
        },
        "options": {}
      },
      {
        "content": "printf(\"${1:%s}\\n\"${2});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pr": true
        },
        "options": {}
      },
      {
        "content": "fprintf(${1:stderr}, \"${2:%s}\\n\"${3});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fpr": true
        },
        "options": {}
      },
      {
        "content": "printf(\"${1:} = %d\\n\", $1);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prd": true
        },
        "options": {}
      },
      {
        "content": "printf(\"${1:} = %f\\n\", $1);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prf": true
        },
        "options": {}
      },
      {
        "content": "printf(\"${1:} = %${2}\\n\", $1);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prx": true
        },
        "options": {}
      },
      {
        "content": "int choice;\nwhile (1)\n{\n\tstatic struct option long_options[] =\n\t{\n\t\t/* Use flags like so:\n\t\t{\"verbose\",\tno_argument,\t&verbose_flag, 'V'}*/\n\t\t/* Argument styles: no_argument, required_argument, optional_argument */\n\t\t{\"version\", no_argument,\t0,\t'v'},\n\t\t{\"help\",\tno_argument,\t0,\t'h'},\n\t\t${1}\n\t\t{0,0,0,0}\n\t};\n\tint option_index = 0;\n\t/* Argument parameters:\n\t\tno_argument: \" \"\n\t\trequired_argument: \":\"\n\t\toptional_argument: \"::\" */\n\tchoice = getopt_long( argc, argv, \"vh\",\n\t\t\t\tlong_options, &option_index);\n\tif (choice == -1)\n\t\tbreak;\n\tswitch( choice )\n\t{\n\t\tcase 'v':\n\t\t\t${2}\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\t${3}\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t/* getopt_long will have already printed an error */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Not sure how to get here... */\n\t\t\treturn EXIT_FAILURE;\n\t}\n}\n/* Deal with non-option arguments here */\nif ( optind < argc )\n{\n\twhile ( optind < argc )\n\t{\n\t\t${0}\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "getopt": true
        },
        "options": {}
      },
      {
        "content": "/*! TODO: ${1:Todo description here}\n *  \\todo $1\n */",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "todo": true
        },
        "options": {}
      },
      {
        "content": "[${1}]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ".": true
        },
        "options": {}
      },
      {
        "content": "__asm__ __volatile__(\n\"${0}\\n\\t\"\n:\n:\n);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asm": true
        },
        "options": {}
      }
    ],
    "chef": [
      {
        "content": "# Cookbook File resource\ncookbook_file ${1:\"/path/to/file\"} do # The remote path where the file will reside\n\t${2:#}backup ${3} # How many backups of this file to keep. Set to false  if you want no backups\n\t${4:#}group ${5} # The group owner of the file (string or id)\n\t${6:#}mode ${7} # The octal mode of the file - e.g. 0755\n\t${8:#}owner ${9} # The owner for the file\n\t${10:#}source ${11} # The basename of the source file\n\t${12:#}cookbook ${13} # The cookbook this file is stored in\n\t${14:#}${15: action :create} # Create this file (Default)\n\t${16:#}${17: action :create_if_missing} # Create only if it doesn't exist yet\n\t${18:#}${0: action :delete} # Delete this file\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cookbook_file": true
        },
        "options": {}
      },
      {
        "content": "# Execute resource\nexecute ${1:\"command to execute\"} do # The command to execute\n\t${2:#}creates ${3:nil} # A file this command creates - if the file exists, the command will not be run.\n\t${4:#}cwd ${5:nil} # Current working directory to run the command from.\n\t${6:#}environment ${7:nil} # A hash of environment variables to set before running this command.\n\t${8:#}group ${9:nil} # A group name or group ID that we should change to before running this command.\n\t${10:#}path ${11:nil} # An array of paths to use when searching for the command. Nil uses system path.\n\t${12:#}returns ${13:0} # The return value of the command - this resource raises an exception if the return value does not match.\n\t${14:#}timeout ${15:nil} # How many seconds to let the command run before timing it out.\n\t${16:#}user ${17:nil} # A user name or user ID that we should change to before running this command.\n\t${18:#}umask ${19:nil} # Umask for files created by the command\n\t${20:#}${21:action :run} # Run this command (Default)\n\t${22:#}${0:action :nothing} # Do not run this command\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "execute": true
        },
        "options": {}
      },
      {
        "content": "# Link resource\nlink ${1:\"/target/file\"} do # The file name of the link\n\t${2:#}to ${3} # The real file you want to link to\n\t${4:#}link_type ${5:symbolic} # Either :symbolic or :hard\n\t${6:#}owner ${7} # The owner of the symlink\n\t${8:#}group ${9} # The group of the symlink\n\t${10:#}${11:action :create} # Create a link (Default)\n\t${12:#}${0:action :delete} # Delete a link\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "link": true
        },
        "options": {}
      },
      {
        "content": "# Package resource\npackage ${1:\"package_name\"} do # Name of the package to install\n\t${2:#}version ${3:nil} # The version of the package to install/upgrade\n\t${4:#}response_file ${5:nil} # An optional response file - used to pre-seed packages (note: the file is fetched by Remote File)\n\t${6:#}source ${7} # Used to provide an optional package source for providers that use a local file (rubygems, dpkg and rpm)\n\t${8:#}options ${9:nil} # Add additional options to the underlying package command\n\t${10:#}gem_binary ${11:gem} # A gem_package attribut to specify a gem binary. Useful for installing ruby 1.9 gems while running chef in ruby 1.8\n\t${12:#}${13:action :install} # Install a package - if version is provided, install that specific version (Default)\n\t${14:#}${15:action :upgrade} # Upgrade a package - if version is provided, upgrade to that specific version\n\t${16:#}${17:action :remove} # Remove a package\n\t${18:#}${0:action :purge} # Purge a package (this usually entails removing configuration files as well as the package itself)\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "package": true
        },
        "options": {}
      },
      {
        "content": "# Service resource\nservice ${1:\"service_name\"} do # Name of the service\n\t${2:#}enabled ${3:nil} # Whether the service is enabled at boot time\n\t${4:#}running ${5:nil} # Make sure the service is running. Start if stopped\n\t${6:#}pattern ${7} # Pattern to look for in the process table\n\t${8:#}start_command ${9:nil} # Command used to start this service\n\t${10:#}stop_command ${11:nil} # Command used to stop this service\n\t${12:#}status_command ${13:nil} # Command used to check the service run status\n\t${14:#}restart_command ${15:nil} # Command used to restart this service\n\t${16:#}reload_command ${17:nil} # Command used to tell this service to reload its configuration\n\t${18:#}supports ${19:false} # Features this service supports, ie :restart, :reload, :status\n\t${20:#}${21:action :enable} # Enable this service\n\t${22:#}${23:action :disable} # Disable this service\n\t${24:#}${25:action :nothing} # Don't do anything with this service (Default)\n\t${26:#}${27:action :start} # Start this service\n\t${28:#}${29:action :stop} # Stop this service\n\t${30:#}${31:action :restart} # Restart this service\n\t${32:#}${0:action :reload} # Reload the configuration for this service\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "service": true
        },
        "options": {}
      },
      {
        "content": "# File resource\nfile ${1:\"/path/to/file\"} do # Path to the file\n\t${2:#}backup ${3:5} # How many backups of this file to keep. Set to false if you want no backups.\n\t${4:#}owner ${5} # The owner for the file\n\t${6:#}group ${7} # The group owner of the file (string or id)\n\t${8:#}mode ${9} # The octal mode of the file (4-digit format)\n\t${10:#}content ${11:nil} # A string to write to the file. This will replace any previous content if set\n\t${12:#}${13:action :create} # Create this file (Default)\n\t${14:#}${15:action :delete} # Delete this file\n\t${16:#}${0:action :touch} # Touch this file (update the mtime/atime)\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "file": true
        },
        "options": {}
      },
      {
        "content": "# Directory resource\ndirectory ${1:\"/path/to/dir\"} do # The path to the directory\n\t${2:#}group ${3} # The group owner of the directory (string or id)\n\t${4:#}mode ${5} # The octal mode of the directory, eg 0755\n\t${6:#}owner ${7} # The owner for the directory\n\t${10:#}recursive ${11:false} # When deleting the directory, delete it recursively. When creating the directory, create recursively (ie, mkdir -p)\n\t${12:#}${13:action :create} # Create this directory (Default)\n\t${14:#}${0:action :delete} # Delete this directory\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "directory": true
        },
        "options": {}
      },
      {
        "content": "# Template resource\ntemplate ${1:\"/path/to/file\"} do # Path to the file\n\t${2:#}cookbook ${3:nil} # Specify the cookbook where the template is located, default is current cookbook\n\t${4:#}source ${5:nil} # Template source file. Found in templates/default for the cookbook\n\t${6:#}variables ${7} # Variables to use in the template\n\t${8:#}local ${9:false} # Is the template already present on the node?\n\t${10:#}backup ${11:5} # How many backups of this file to keep. Set to false if you want no backups.\n\t${12:#}owner ${13} # The owner for the file\n\t${14:#}group ${15} # The group owner of the file (string or id)\n\t${16:#}mode ${17} # The octal mode of the file (4-digit format)\n\t${18:#}content ${19:nil} # A string to write to the file. This will replace any previous content if set\n\t${20:#}${21:action :create} # Create the file (Default)\n\t${22:#}${23:action :delete} # Delete this file\n\t${24:#}${0:action :touch} # Touch this file (update the mtime/atime)\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "template": true
        },
        "options": {}
      },
      {
        "content": "# SCM Resource, Chef::Provider::Subversion\nsvn ${1:\"/destination/path\"} do # Path to clone/checkout/export the source to\n\t${2:#}repository ${3} # URI of the repository\n\t${4:#}revision ${5:\"HEAD\"} # revision to checkout. can be symbolic, like \"HEAD\" or an SCM specific revision id\n\t${6:#}reference ${7} # (Git only) alias for revision\n\t${8:#}user ${9:nil} # System user to own the checked out code\n\t${10:#}group ${11:nil} # System group to own the checked out code\n\t${12:#}svn_username ${13} # (Subversion only) Username for Subversion operations\n\t${14:#}svn_password ${15} # (Subversion only) Password for Subversion operations\n\t${16:#}svn_arguments ${17} # (Subversion only) Extra arguments passed to the subversion command\n\t${18:#}${19:action :sync} # Update the source to the specified revision, or get a new checkout (Default)\n\t${20:#}${21:action :checkout} # Checkout the source. Does nothing if a checkout is available\n\t${22:#}${0:action :export} # Export the source, excluding or removing any version control artifacts\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "svn": true
        },
        "options": {}
      },
      {
        "content": "# SCM Resource, Chef::Provider::Git\ngit ${1:\"/destination/path\"} do # Path to clone/checkout/export the source to\n\t${2:#}repository ${3} # URI of the repository\n\t${4:#}revision ${5:\"HEAD\"} # revision to checkout. can be symbolic, like \"HEAD\" or an SCM specific revision id\n\t${6:#}reference ${7} # (Git only) alias for revision\n\t${8:#}user ${9:nil} # System user to own the checked out code\n\t${10:#}group ${11:nil} # System group to own the checked out code\n\t${12:#}depth ${13:nil} # (Git only) Number of past revisions to include in Git shallow clone\n\t${14:#}enable_submodules ${15:\"false\"} # (Git only) performs a submodule init and submodule update\n\t${16:#}remote ${17:\"origin\"} # (Git only) remote repository to use for syncing an existing clone\n\t${18:#}ssh_wrapper ${19} # (Git only) path to a wrapper script for running SSH with git. GIT_SSH environment variable is set to this.\n\t${20:#}${21:action :sync} # Update the source to the specified revision, or get a new clone (Default)\n\t${22:#}${23:action :checkout} # Clone the source. Does nothing if a checkout is available\n\t${24:#}${0:action :export} # Export the source, excluding or removing any version control artifacts\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "git": true
        },
        "options": {}
      },
      {
        "content": "# Deploy resource\ndeploy ${1:\"/deploy/dir/\"} do # Path to deploy to\n\t${2:#}deploy_to ${3} # The \"meta root\" for your application.\n\t${4:#}repository ${5} # URI of the repository\n\t${6:#}repo ${7} # alias for repository\n\t${8:#}revision ${9:\"HEAD\"} # revision to checkout. can be symbolic, like \"HEAD\" or an SCM specific revision id\n\t${10:#}branch ${11} # alias for revision\n\t${12:#}user ${13:nil} # System user to run the deploy as\n\t${14:#}group ${15:nil} # System group to run the deploy as\n\t${16:#}svn_username ${17} # (Subversion only) Username for Subversion operations}\n\t${18:#}svn_password ${19} # (Subversion only) Password for Subversion operations}\n\t${20:#}svn_arguments ${21} # (Subversion only) Extra arguments passed to the subversion command}\n\t${22:#}shallow_clone ${23:nil} # (Git only) boolean, true sets clone depth to 5\n\t${24:#}enable_submodules ${25:false} # (Git only) performs a submodule init and submodule update\n\t${26:#}remote ${27:\"origin\"} # (Git only) remote repository to use for syncing an existing clone\n\t${28:#}ssh_wrapper ${29} # (Git only) path to a wrapper script for running SSH with git. GIT_SSH environment variable is set to this.\n\t${30:#}git_ssh_wrapper ${31} # alias for ssh_wrapper\n\t${32:#}scm_provider ${33:Chef::Provider::Git} # SCM Provider to use.\n\t${34:#}repository_cache ${35: \"cached-copy\"} # Name of the subdirectory where the pristine copy of your app's source is kept\n\t${36:#}environment ${37} # A hash of the form {\"ENV_VARIABLE\"=>\"VALUE\"}}\n\t${38:#}purge_before_symlink ${39:%w(log tmp/pids public/system)} # An array of paths, relative to app root, to be removed from a checkout before symlinking\n\t${40:#}create_dirs_before_symlink ${41:%w(tmp public config)} # Directories to create before symlinking. Runs after purge_before_symlink\n\t${42:#}symlinks ${43:\"system\" => \"public/system\", \"pids\" => \"tmp/pids\", \"log\" => \"log\"} # A hash that maps files in the shared directory to their paths in the current release\n\t${44:#}symlink_before_migrate ${45:\"config/database.yml\" => \"config/database.yml\"} # A hash that maps files in the shared directory into the current release. Runs before migration\n\t${46:#}migrate ${47:false} # Should the migration command be executed? (true or false)\n\t${48:#}migration_command ${49} # A string containing a shell command to execute to run the migration\n\t${50:#}restart_command ${51:nil} # A code block to evaluate or a string containing a shell command\n\t${52:#}before_migrate ${53:\"deploy/before_migrate.rb\"} # A block or path to a file containing chef code to run before migrating\n\t${54:#}before_symlink ${55:\"deploy/before_symlink.rb\"} # A block or path to a file containing chef code to run before symlinking\n\t${56:#}before_restart ${57:\"deploy/before_restart.rb\"} # A block or path to a file containing chef code to run before restarting\n\t${58:#}after_restart ${59:\"deploy/after_restart.rb\"} # A block or path to a file containing chef code to run after restarting\n\t${60:#}${61::deploy} # Deploy the application (Default)\n\t${62:#}${63::force_deploy} # For the revision deploy strategy, this removes any existing release of the same code version and re-deploys in its place\n\t${64:#}${0::rollback} # Rollback the application to the previous release\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "deploy": true
        },
        "options": {}
      }
    ],
    "classnames": [
      {
        "content": "${1:classNames}('${2:foo}', '${3:bar}');",
        "doc": "",
        "grammar": "lsp",
        "label": "classnames-usage",
        "matches": {
          "classnames usage": true
        },
        "options": {}
      },
      {
        "content": "${1:classNames}({ '${2:foo-bar}': true });",
        "doc": "",
        "grammar": "lsp",
        "label": "classnames-usage-object",
        "matches": {
          "classnames usage object": true
        },
        "options": {}
      },
      {
        "content": "import ${1:classNames} from 'classnames/bind';",
        "doc": "",
        "grammar": "lsp",
        "label": "classnames-import-bind",
        "matches": {
          "classnames import bind": true
        },
        "options": {}
      },
      {
        "content": "const ${1:cx} = ${2:classNames}.bind(styles);",
        "doc": "",
        "grammar": "lsp",
        "label": "classnames-bind-usage",
        "matches": {
          "classnames bind usage": true
        },
        "options": {}
      }
    ],
    "clojure": [
      {
        "content": "(defn ${1:name}\n\t\"${2:doc}\"\n\t[${3}]\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": "defn function \"...\" [...] ...",
        "matches": {
          "defn-doc": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "(try\n\t${1}\n\t(catch ${2:Exception} e ${3:nil}))",
        "doc": "",
        "grammar": "snu",
        "label": "(try ... (catch ...",
        "matches": {
          "try": true
        },
        "options": {}
      },
      {
        "content": "(dosync\n\t(ref-set ${1:ref} ${2:value}))",
        "doc": "",
        "grammar": "snu",
        "label": "(dosync (ref-set ...",
        "matches": {
          "ref-set": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "(binding [*out* *err*]\n  (println ${0:TARGET}))",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "warn": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "(defrecord ${1:record} [${2:constructor-args}]\n  ${3:protocol} (${3:method} [${5}] ${6}))",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defrecord": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "(defrecord ${1:type} [${2:constructor-args}]\n  ${3:protocol} (${3:method} [${5}] ${6}))",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "deftype": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "(ns ${1:example}\n  (:require [clojure.core.match :as m]))\n; vim: set lispwords+=m/match :",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "require-core-match": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "(deftest ${1:a}-test\n  (testing \"${2:hello}\"\n    ${0:TARGET:(is (= 0 1))}))",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "deftest": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "(:require [clojure.core.strint :refer (<<)])",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "use-strint-in-ns": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "[org.clojars.hozumi/clj-glob \"0.1.2\"]\n(:require [org.satta.glob :as g])\n(g/glob \"${0:TARGET}\")",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dir-glob": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "(Thread/sleep ${1})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sleep": true
        },
        "options": {}
      },
      {
        "content": "(defproject ${1:aaa} \"0.1-SNAPSHOT\"\n  :description \"FIXME: write description\"\n  :url \"https://github.com/${2}\"\n  :license {:name \"GNU GPL v3+\"\n            :url \"http://www.gnu.org/licenses/gpl-3.0.en.html\"}\n  :dependencies [[org.clojure/clojure \"1.7.0\"]]\n  :main ^:skip-aot ${3:aaa.core}\n  :target-path \"target/%s\"\n  :min-lein-version \"2.3.0\")",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defproejct": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "(let [bench-before (System/currentTimeMillis)]\n  ${1:TARGET}\n  (prn 'Took (- (System/currentTimeMillis) bench-before) 'msec))",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bench": true
        },
        "options": {}
      },
      {
        "content": "@#'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "private": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "(:members (clojure.reflect/refrect ${1}))",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "java-methods": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "(comment\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "comm": true
        },
        "options": {}
      },
      {
        "content": "(condp ${1:pred} ${2:expr}\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "condp": true
        },
        "options": {}
      },
      {
        "content": "(def ${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "def": true
        },
        "options": {}
      },
      {
        "content": "(defmethod ${1:multifn} \"${2:doc-string}\" ${3:dispatch-val} [${4:args}]\n\t${0:code})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defm": true
        },
        "options": {}
      },
      {
        "content": "(defmulti ${1:name} \"${2:doc-string}\" ${0:dispatch-fn})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defmm": true
        },
        "options": {}
      },
      {
        "content": "(defmacro ${1:name} \"${2:doc-string}\" ${0:dispatch-fn})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defma": true
        },
        "options": {}
      },
      {
        "content": "(defn ${1:name} \"${2:doc-string}\" [${3:arg-list}]\n\t${0:code})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defn": true
        },
        "options": {}
      },
      {
        "content": "(defprotocol ${1:name}\n\t${0:code})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defp": true
        },
        "options": {}
      },
      {
        "content": "(defrecord ${1:name} [${2:fields}]\n\t${3:protocol}\n\t${0:code})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defr": true
        },
        "options": {}
      },
      {
        "content": "(deftest ${1:name}\n\t(is (= ${0:assertion})))",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "deft": true
        },
        "options": {}
      },
      {
        "content": "(is (= ${1} ${0}))",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "is": true
        },
        "options": {}
      },
      {
        "content": "(deftype ${1:Name} [${2:fields}]\n\t${3:Protocol}\n\t${0:code})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defty": true
        },
        "options": {}
      },
      {
        "content": "(doseq [${1:elem} ${2:coll}]\n\t${0:code})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "doseq": true
        },
        "options": {}
      },
      {
        "content": "(fn [${1:arg-list}] ${0:code})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fn": true
        },
        "options": {}
      },
      {
        "content": "(if ${1:test-expr}\n\t${2:then-expr}\n\t${0:else-expr})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "(if-let [${1:result} ${2:test-expr}]\n\t(${3:then-expr} $1)\n\t(${0:else-expr}))",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if-let": true
        },
        "options": {}
      },
      {
        "content": "(:import [${1:package}])\n\t& {:keys [${1:keys}] :or {${0:defaults}}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "imp": true
        },
        "options": {}
      },
      {
        "content": "(let [${1:name} ${2:expr}]\n\t${0:code})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "let": true
        },
        "options": {}
      },
      {
        "content": "(letfn [(${1:name}) [${2:args}]\n\t${0:code})])",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "letfn": true
        },
        "options": {}
      },
      {
        "content": "(map ${1:func} ${0:coll})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "map": true
        },
        "options": {}
      },
      {
        "content": "(map #(${1:lambda}) ${0:coll})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mapl": true
        },
        "options": {}
      },
      {
        "content": "(${1:name} [${2:this} ${3:args}]\n\t${0:code})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "met": true
        },
        "options": {}
      },
      {
        "content": "(ns ${0:name})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ns": true
        },
        "options": {}
      },
      {
        "content": "(dotimes [_ 10]\n\t(time\n\t\t(dotimes [_ ${1:times}]\n\t\t\t${0:code})))",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dotimes": true
        },
        "options": {}
      },
      {
        "content": "(${1:name} [${2:this} ${0:args}])",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pmethod": true
        },
        "options": {}
      },
      {
        "content": "(:refer-clojure :exclude [${0}])",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "refer": true
        },
        "options": {}
      },
      {
        "content": "(:require [${1:namespace} :as [${0}]])",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "require": true
        },
        "options": {}
      },
      {
        "content": "(:use [${1:namespace} :only [${0}]])",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "use": true
        },
        "options": {}
      },
      {
        "content": "(println ${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "print": true
        },
        "options": {}
      },
      {
        "content": "(reduce ${1:(fn [p n] ${3})} ${2})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "reduce": true
        },
        "options": {}
      },
      {
        "content": "(when ${1:test} ${0:body})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "when": true
        },
        "options": {}
      },
      {
        "content": "(when-let [${1:result} ${2:test}]\n\t${0:body})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "when-let": true
        },
        "options": {}
      }
    ],
    "cmake": [
      {
        "content": "project(${1:project_name})\nset(${2:PROJECT}_VERSION_MAJOR 0)\nset($2_VERSION_MINOR 0)\nset($2_VERSION_TEENY 1)\nset(PACKAGE_VERSION \"${$2_VERSION_MAJOR}.${$2_VERSION_MINOR}.${$2_VERSION_TEENY}\")\ncmake_minimum_required(VERSION ${3:2.8})\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "new_project": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "if(${1:#:condition})\n\t${0}\nendif()",
        "doc": "",
        "grammar": "snu",
        "label": "if() endif()",
        "matches": {
          "if": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "if(${1:#:condition})\n\t${2}\nelse()\n\t${3}\nendif()",
        "doc": "",
        "grammar": "snu",
        "label": "if() else() endif()",
        "matches": {
          "if_else": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "foreach(${1:item} ${2:items})\n\t${3}\nendforeach($1)",
        "doc": "",
        "grammar": "snu",
        "label": "foreach() endforeach()",
        "matches": {
          "foreach": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "macro(${1:name} ${2:args})\n\t${3}\nendmacro($1)",
        "doc": "",
        "grammar": "snu",
        "label": "macro() endmacro()",
        "matches": {
          "macro": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "function(${1:name} ${2:args})\n\t${3}\nendfunction($1)",
        "doc": "",
        "grammar": "snu",
        "label": "function() endfunction()",
        "matches": {
          "function": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "message(\"${1}\")",
        "doc": "",
        "grammar": "snu",
        "label": "message(\"...\")",
        "matches": {
          "message": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "message(STATUS \"${1}\")",
        "doc": "",
        "grammar": "snu",
        "label": "message(STATUS \"...\")",
        "matches": {
          "status_message": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "message(WARNING \"${1}\")",
        "doc": "",
        "grammar": "snu",
        "label": "message(WARNING \"...\")",
        "matches": {
          "warning_message": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "message(AUTHOR_WARNING \"${1}\")",
        "doc": "",
        "grammar": "snu",
        "label": "message(AUTHOR_WARNING \"...\")",
        "matches": {
          "author_warning_message": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "message(SEND_ERROR \"${1}\")",
        "doc": "",
        "grammar": "snu",
        "label": "message(SEND_ERROR \"...\")",
        "matches": {
          "send_error_message": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "message(FATAL_ERROR \"${1}\")",
        "doc": "",
        "grammar": "snu",
        "label": "message(FATAL_ERROR \"...\")",
        "matches": {
          "fatal_error_message": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "while(${1:#:condition})\n\t${2}\nendwhile()",
        "doc": "",
        "grammar": "snu",
        "label": "while() endwhile()",
        "matches": {
          "while": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "file(GLOB_RECURSE ${1:#:var} ${2:#:glob_paths})",
        "doc": "",
        "grammar": "snu",
        "label": "file(GLOB_RECURSE ...)",
        "matches": {
          "file_GLOBE_RECURSE": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "cmake_minimum_required(VERSION ${1:2.8.2})\nproject(${2:ProjectName})\nfind_package(${3:library})\ninclude_directories(${$3_INCLUDE_DIRS})\nadd_subdirectory(${0:src})\nadd_executable($2)\ntarget_link_libraries($2 ${$3_LIBRARIES})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "init": true
        },
        "options": {}
      },
      {
        "content": "project(${0:Name})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "proj": true
        },
        "options": {}
      },
      {
        "content": "cmake_minimum_required(VERSION ${0:2.8.2})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "min": true
        },
        "options": {}
      },
      {
        "content": "include_directories(${${0:include_dir}})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "include": true
        },
        "options": {}
      },
      {
        "content": "find_package(${1:library} ${0:REQUIRED})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "find": true
        },
        "options": {}
      },
      {
        "content": "file(glob ${1:srcs} *.${0:cpp})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "glob": true
        },
        "options": {}
      },
      {
        "content": "add_subdirectory(${0:src})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "subdir": true
        },
        "options": {}
      },
      {
        "content": "add_library(${1:lib} ${${0:srcs}})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lib": true
        },
        "options": {}
      },
      {
        "content": "target_link_libraries(${1:bin} ${0:somelib})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "link": true
        },
        "options": {}
      },
      {
        "content": "add_executable(${1:bin})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bin": true
        },
        "options": {}
      },
      {
        "content": "set(${1:var} ${0:val})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "set": true
        },
        "options": {}
      },
      {
        "content": "add_dependencies(${1:target}\n\t${0:dep}\n)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dep": true
        },
        "options": {}
      },
      {
        "content": "include(ExternalProject)\nExternalProject_Add(${1:googletest}\n  URL ${2:http://googletest.googlecode.com/files/gtest-1.7.0.zip}\n  URL_HASH SHA1=${3:f85f6d2481e2c6c4a18539e391aa4ea8ab0394af}\n  SOURCE_DIR \"${4:${CMAKE_BINARY_DIR}/gtest-src}\"\n  BINARY_DIR \"${0:${CMAKE_BINARY_DIR}/gtest-build}\"\n  CONFIGURE_COMMAND \"\"\n  BUILD_COMMAND     \"\"\n  INSTALL_COMMAND   \"\"\n  TEST_COMMAND      \"\"\n)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Ext_url": true
        },
        "options": {}
      },
      {
        "content": "include(ExternalProject)\nExternalProject_Add(${1:googletest}\n  GIT_REPOSITORY    ${2:https://github.com/google/googletest.git}\n  GIT_TAG           ${3:master}\n  SOURCE_DIR        \"${4:${CMAKE_BINARY_DIR}/googletest-src}\"\n  BINARY_DIR        \"${0:${CMAKE_BINARY_DIR}/googletest-build}\"\n  CONFIGURE_COMMAND \"\"\n  BUILD_COMMAND     \"\"\n  INSTALL_COMMAND   \"\"\n  TEST_COMMAND      \"\"\n)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Ext_git": true
        },
        "options": {}
      },
      {
        "content": "set_target_properties(${1:target}\n\t${2:properties} ${3:compile_flags}\n\t${0:\"-O3 -Wall -pedantic\"}\n)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "props": true
        },
        "options": {}
      },
      {
        "content": "add_test(${1:ATestName} ${0:testCommand --options})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "test": true
        },
        "options": {}
      }
    ],
    "codeigniter": [
      {
        "content": "<?php if ( ! defined('BASEPATH')) exit('No direct script access allowed');\nclass ${1:ClassName} extends CI_Controller\n{\n\tfunction __construct()\n\t{\n\t\tparent::__construct();\n\t\t${2:// code...}\n\t}\n\tfunction ${3:index}()\n\t{\n\t\t${4:// code...}\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_controller": true
        },
        "options": {}
      },
      {
        "content": "<?php if ( ! defined('BASEPATH')) exit('No direct script access allowed');\nclass ${1:ClassName_model} extends CI_Model\n{\n\tfunction __construct()\n\t{\n\t\tparent::__construct();\n\t\t${2:// code...}\n\t}\n} ",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_model": true
        },
        "options": {}
      },
      {
        "content": "<?php if ( ! defined('BASEPATH')) exit('No direct script access allowed');\nclass ${1:ClassName_model} extends CI_Model\n{\n\tprivate $table = '${2:table_name}';\n\tfunction __construct()\n\t{\n\t\tparent::__construct();\n\t\t${3:// code...}\n\t}\n\tpublic function create($data)\n\t{\n\t\tif($this->db->insert($this->table, $data))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\tpublic function read($id)\n\t{\n\t\treturn $this->db->get_where($this->table, array('id', $id))->result();\n\t}\n\tpublic function update($id, $data)\n\t{\n\t\tif($this->db->update($this->table, $data, array('id' => $id)))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\tpublic function delete($id)\n\t{\n\t\tif(is_array($id))\n\t\t{\n\t\t\t$this->db->trans_start();\n\t\t\tforeach($id as $elem)\n\t\t\t\t$this->db->delete($this->table, array('id' => $elem));\n\t\t\t$this->db->trans_complete();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif($this->db->delete($this->table, array('id' => $id)))\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t}\n\tpublic function listRows($limit = null, $offset = 0)\n\t{\n\t\tif(!is_null($limit))\n\t\t\t$this->db->limit($limit, $offset);\n\t\treturn $this->db->get($this->table)->result();\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_model_crudl": true
        },
        "options": {}
      },
      {
        "content": "$this->load->view(\"${1:view_name}\", $${2:data});${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_load-view": true
        },
        "options": {}
      },
      {
        "content": "$this->db->insert(\"${1:table}\", $${2:data});${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_db-insert": true
        },
        "options": {}
      },
      {
        "content": "$this->db->select(\"${1:id, ...}\");${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_db-select": true
        },
        "options": {}
      },
      {
        "content": "$this->db->from(\"${1:table}\");${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_db-from": true
        },
        "options": {}
      },
      {
        "content": "$this->db->join(\"${1:table}\", \"${2:condition}\", \"${3:type}\");${4}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_db-join": true
        },
        "options": {}
      },
      {
        "content": "$this->db->where(\"${1:key}\", \"${2:value}\");${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_db-where": true
        },
        "options": {}
      },
      {
        "content": "$this->db->or_where(\"${1:key}\", \"${2:value}\");${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_db-or_where": true
        },
        "options": {}
      },
      {
        "content": "$this->db->get(\"${1:table}\", ${2:limit}, ${3:offset});${4}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_db-get": true
        },
        "options": {}
      },
      {
        "content": "$this->db->delete(\"${1:table}\", \"${2:where}\");${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_db-delete": true
        },
        "options": {}
      },
      {
        "content": "$this->db->update(\"${1:table}\", $${2:set}, $${3:where});${4}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_db-update": true
        },
        "options": {}
      },
      {
        "content": "$this->input->post(\"${1:index}\");${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_input-post": true
        },
        "options": {}
      },
      {
        "content": "$this->input->get(\"${1:index}\");${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_input-get": true
        },
        "options": {}
      },
      {
        "content": "$this->input->cookie(\"${1:index}\");${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_input-cookie": true
        },
        "options": {}
      },
      {
        "content": "$this->input->server(\"${1:index}\");${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_input-server": true
        },
        "options": {}
      },
      {
        "content": "$this->input->user_agent();${1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_input-user_agent": true
        },
        "options": {}
      },
      {
        "content": "$this->input->is_ajax_request();${1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_input-is_ajax_request": true
        },
        "options": {}
      },
      {
        "content": "$this->input->is_cli_request();${1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_input-is_cli_request": true
        },
        "options": {}
      },
      {
        "content": "$this->form_validation->set_rules(\"${1:field}\", \"${2:label}\", \"${3:trim|required}\");${4}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_form_validation-set_rules": true
        },
        "options": {}
      },
      {
        "content": "form_open(\"${1:action}\");${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_form_open": true
        },
        "options": {}
      },
      {
        "content": "form_open_multipart(\"${1:action}\");${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_form_open_multipart": true
        },
        "options": {}
      },
      {
        "content": "form_hidden(\"${1:name}\", \"${2:value}\");${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_form_hidden": true
        },
        "options": {}
      },
      {
        "content": "form_input(\"${1:name}\", \"${2:value}\");${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_form_input": true
        },
        "options": {}
      },
      {
        "content": "form_password(\"${1:name}\", \"${2:value}\");${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_form_password": true
        },
        "options": {}
      },
      {
        "content": "form_upload(\"${1:name}\", \"${2:value}\");${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_form_upload": true
        },
        "options": {}
      },
      {
        "content": "form_textarea(\"${1:name}\", \"${2:value}\");${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_form_textarea": true
        },
        "options": {}
      },
      {
        "content": "form_checkbox(\"${1:name}\", \"${2:value}\");${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_form_checkbox": true
        },
        "options": {}
      },
      {
        "content": "form_radio(\"${1:name}\", \"${2:value}\");${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_form_radio": true
        },
        "options": {}
      },
      {
        "content": "form_submit(\"${1:name}\", \"${2:value}\");${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_form_submit": true
        },
        "options": {}
      },
      {
        "content": "form_reset(\"${1:name}\", \"${2:value}\");${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_form_reset": true
        },
        "options": {}
      },
      {
        "content": "form_button(\"${1:name}\", \"${2:value}\");${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_form_button": true
        },
        "options": {}
      },
      {
        "content": "form_label(\"${1:label text}\", \"${2:id}\");${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_form_label": true
        },
        "options": {}
      },
      {
        "content": "form_close();${1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_form_close": true
        },
        "options": {}
      },
      {
        "content": "validation_errors();${1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_validation_errors": true
        },
        "options": {}
      },
      {
        "content": "$this->session->userdata(\"${1:item}\");${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_session_userdata": true
        },
        "options": {}
      },
      {
        "content": "$this->session->set_userdata($${1:array});${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_session_set_userdata": true
        },
        "options": {}
      },
      {
        "content": "$this->session->flashdata(\"${1:item}\");${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_session_flashdata": true
        },
        "options": {}
      },
      {
        "content": "$this->session->set_flashdata(\"${1:item}\", \"${2:value}\");${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci_session_set_flashdata": true
        },
        "options": {}
      }
    ],
    "coffee": [
      {
        "content": "${1:#:object} = require('$1')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "req": true
        },
        "options": {}
      },
      {
        "content": "console.log ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "log": true
        },
        "options": {}
      },
      {
        "content": "${1:#:action} unless ${2:#:condition}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "unl": true
        },
        "options": {}
      },
      {
        "content": "try\n  ${1:TARGET}\ncatch ${2:#:error}\n  ${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "try": true
        },
        "options": {}
      },
      {
        "content": "if ${1:#:condition}\n  ${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "else if ${1:#:condition}\n  ${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "elif": true
        },
        "options": {}
      },
      {
        "content": "if ${1:#:condition} then ${2:#:value} else ${3:#:other}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifte": true
        },
        "options": {}
      },
      {
        "content": "if ${1:#:condition}\n  ${2:TARGET}\nelse\n  ${3:#:body...}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "switch ${1:#:object}\n  when ${2:#:value}\n    ${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "swi": true
        },
        "options": {}
      },
      {
        "content": "for ${1:#:key}, ${2:#:value} of ${3:#:object}\n  ${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "foro": true
        },
        "options": {}
      },
      {
        "content": "for ${1:#:name} in ${2:#:array}\n  ${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fora": true
        },
        "options": {}
      },
      {
        "content": "${1:#:name} = (${2:#:args}) ->\n  ${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fun": true
        },
        "options": {}
      },
      {
        "content": "(${1:#:args}) =>\n  ${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bfun": true
        },
        "options": {}
      },
      {
        "content": "for ${1:name} in ${2:array}\n\tdo ($1) ->\n\t\t${0:// body}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forindo": true
        },
        "options": {}
      },
      {
        "content": "for ${1:name} in ${2:array}\n\t${0:# body...}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fora": true
        },
        "options": {}
      },
      {
        "content": "for ${1:key}, ${2:value} of ${3:object}\n\t${0:# body...}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "foro": true
        },
        "options": {}
      },
      {
        "content": "for ${1:name} in [${2:start}..${3:finish}]\n\t${0:# body...}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forr": true
        },
        "options": {}
      },
      {
        "content": "for ${1:name} in [${2:start}..${3:finish}] by ${4:step}\n\t${0:# body...}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forrb": true
        },
        "options": {}
      },
      {
        "content": "for ${1:name} in [${2:start}...${3:finish}]\n\t${0:# body...}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forrex": true
        },
        "options": {}
      },
      {
        "content": "for ${1:name} in [${2:start}...${3:finish}] by ${4:step}\n\t${0:# body...}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forrexb": true
        },
        "options": {}
      },
      {
        "content": "(${1:args}) ->\n\t${0:# body...}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fun": true
        },
        "options": {}
      },
      {
        "content": "(${1:args}) =>\n\t${0:# body...}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bfun": true
        },
        "options": {}
      },
      {
        "content": "if ${1:condition}\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "if ${1:condition}\n\t${2:${VISUAL}}\nelse\n\t${0:# body...}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "else if ${1:condition}\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eif": true
        },
        "options": {}
      },
      {
        "content": "if ${1:condition} then ${2:value} else ${0:other}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifte": true
        },
        "options": {}
      },
      {
        "content": "${1:action} unless ${0:condition}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "unl": true
        },
        "options": {}
      },
      {
        "content": "switch ${1:object}\n\twhen ${2:value}\n\t\t${0:# body...}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "swi": true
        },
        "options": {}
      },
      {
        "content": "console.log ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "log": true
        },
        "options": {}
      },
      {
        "content": "try\n\t${1:${VISUAL}}\ncatch ${2:error}\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "try": true
        },
        "options": {}
      },
      {
        "content": "${2:$1} = require '${1:sys}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "req": true
        },
        "options": {}
      },
      {
        "content": "${0:root} = exports ? this",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "exp": true
        },
        "options": {}
      },
      {
        "content": "JSON.parse ${0:jstr}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jsonp": true
        },
        "options": {}
      },
      {
        "content": "JSON.stringify ${0:object}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jsons": true
        },
        "options": {}
      },
      {
        "content": "if ${1:condition}\n\t${0:# body...}",
        "doc": "",
        "grammar": "snu",
        "label": "If",
        "matches": {
          "if": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "if ${1:condition}\n\t${2:# body...}\nelse\n\t${3:# body...}",
        "doc": "",
        "grammar": "snu",
        "label": "If .. Else",
        "matches": {
          "ife": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "else if ${1:condition}\n\t${0:# body...}",
        "doc": "",
        "grammar": "snu",
        "label": "Else if",
        "matches": {
          "elif": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "if ${1:condition} then ${2:value} else ${3:other}",
        "doc": "",
        "grammar": "snu",
        "label": "Ternary if",
        "matches": {
          "ifte": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:action} unless ${2:condition}",
        "doc": "",
        "grammar": "snu",
        "label": "Unless",
        "matches": {
          "unl": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "for ${1:name} in ${2:array}\n\t${0:# body...}",
        "doc": "",
        "grammar": "snu",
        "label": "Array Comprehension",
        "matches": {
          "fora": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "for ${1:key}, ${2:value} of ${3:Object}\n\t${0:# body...}",
        "doc": "",
        "grammar": "snu",
        "label": "Object Comprehension",
        "matches": {
          "foro": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "switch ${1:object}\n\twhen ${2:value}\n\t\t${3:# body...}\n\telse\n\t\t$0",
        "doc": "",
        "grammar": "snu",
        "label": "Switch",
        "matches": {
          "swi": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "try\n\t$1\ncatch ${2:error}\n\t$3",
        "doc": "",
        "grammar": "snu",
        "label": "Try .. Catch",
        "matches": {
          "try": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "#{$1}$0",
        "doc": "",
        "grammar": "snu",
        "label": "Interpolated Code",
        "matches": {
          "#": true
        },
        "options": {
          "i": true
        }
      },
      {
        "content": "console.log ${1:\"${2:msg}\"}",
        "doc": "",
        "grammar": "snu",
        "label": "Log",
        "matches": {
          "log": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:key}:${2:value}",
        "doc": "",
        "grammar": "snu",
        "label": "Key:value for object",
        "matches": {
          "kv": true
        },
        "options": {
          "b": true
        }
      }
    ],
    "coffee-jasmine": [
      {
        "content": "describe '${1:description}', ->\n\t$0",
        "doc": "",
        "grammar": "snu",
        "label": "Describe (coffee)",
        "matches": {
          "des": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "it '${1:description}', ->\n\t$0",
        "doc": "",
        "grammar": "snu",
        "label": "it (coffee)",
        "matches": {
          "it": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "beforeEach ->\n\t$0",
        "doc": "",
        "grammar": "snu",
        "label": "before each (coffee)",
        "matches": {
          "bef": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "afterEach ->\n\t$0",
        "doc": "",
        "grammar": "snu",
        "label": "after each (coffee)",
        "matches": {
          "aft": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "jasmine.any($1)",
        "doc": "",
        "grammar": "snu",
        "label": "any (coffee)",
        "matches": {
          "any": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "runs ->\n\t$0",
        "doc": "",
        "grammar": "snu",
        "label": "runs (coffee)",
        "matches": {
          "ru": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "waits($1)",
        "doc": "",
        "grammar": "snu",
        "label": "waits (coffee)",
        "matches": {
          "wa": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "expect(${1:target})$0",
        "doc": "",
        "grammar": "snu",
        "label": "expect (coffee)",
        "matches": {
          "ex": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "expect(${1:target}).toEqual(${2:value})",
        "doc": "",
        "grammar": "snu",
        "label": "expect to equal (coffee)",
        "matches": {
          "ee": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "expect(${1:target}).toMatch(${2:pattern})",
        "doc": "",
        "grammar": "snu",
        "label": "expect to match (coffee)",
        "matches": {
          "em": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "expect(${1:target}).toHaveAttr('${2:attr}'${3:, '${4:value}'})",
        "doc": "",
        "grammar": "snu",
        "label": "expect to have attribute (coffee)",
        "matches": {
          "eha": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "expect(${1:target}).toBeTruthy()",
        "doc": "",
        "grammar": "snu",
        "label": "expect to be truthy (coffee)",
        "matches": {
          "et": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "expect(${1:target}).toBeFalsy()",
        "doc": "",
        "grammar": "snu",
        "label": "expect to be falsy (coffee)",
        "matches": {
          "ef": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "expect(${1:target}).toBeDefined()",
        "doc": "",
        "grammar": "snu",
        "label": "expect to be defined (coffee)",
        "matches": {
          "ed": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "expect(${1:target}).toBeNull()",
        "doc": "",
        "grammar": "snu",
        "label": "expect to be null (coffee)",
        "matches": {
          "en": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "expect(${1:target}).toContain(${2:value})",
        "doc": "",
        "grammar": "snu",
        "label": "expect to contain (coffee)",
        "matches": {
          "ec": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "expect(${1:target}).toBeVisible()",
        "doc": "",
        "grammar": "snu",
        "label": "expect to be visible (coffee)",
        "matches": {
          "ev": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "expect(${1:target}).toBeHidden()",
        "doc": "",
        "grammar": "snu",
        "label": "expect to be hidden (coffee)",
        "matches": {
          "eh": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "expect(${1:target}).not$0",
        "doc": "",
        "grammar": "snu",
        "label": "expect not (coffee)",
        "matches": {
          "notx": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "expect(${1:target}).not.toEqual(${2:value})",
        "doc": "",
        "grammar": "snu",
        "label": "expect not to equal (coffee)",
        "matches": {
          "note": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "expect(${1:target}).not.toMatch(${2:pattern})",
        "doc": "",
        "grammar": "snu",
        "label": "expect not to match (coffee)",
        "matches": {
          "notm": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "expect(${1:target}).not.toHaveAttr('${2:attr}'${3:, '${4:value}'})",
        "doc": "",
        "grammar": "snu",
        "label": "expect to not have attribute (coffee)",
        "matches": {
          "notha": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "expect(${1:target}).not.toBeTruthy()",
        "doc": "",
        "grammar": "snu",
        "label": "expect not to be truthy (coffee)",
        "matches": {
          "nott": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "expect(${1:target}).not.toBeFalsy()",
        "doc": "",
        "grammar": "snu",
        "label": "expect not to be falsy (coffee)",
        "matches": {
          "notf": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "expect(${1:target}).not.toBeDefined()",
        "doc": "",
        "grammar": "snu",
        "label": "expect not to be defined (coffee)",
        "matches": {
          "notd": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "expect(${1:target}).not.toBeNull()",
        "doc": "",
        "grammar": "snu",
        "label": "expect not to be null (coffee)",
        "matches": {
          "notn": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "expect(${1:target}).not.toContain(${2:value})",
        "doc": "",
        "grammar": "snu",
        "label": "expect not to contain (coffee)",
        "matches": {
          "notc": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "expect(${1:target}).not.toBeVisible()",
        "doc": "",
        "grammar": "snu",
        "label": "expect not to be visible (coffee)",
        "matches": {
          "notv": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "expect(${1:target}).not.toBeHidden()",
        "doc": "",
        "grammar": "snu",
        "label": "expect not to be hidden (coffee)",
        "matches": {
          "noth": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "spyOn(${1:object}, \"${2:method}\")$0",
        "doc": "",
        "grammar": "snu",
        "label": "spy on (coffee)",
        "matches": {
          "s": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "spyOn(${1:object}, \"${2:method}\").andReturn(${3:arguments})",
        "doc": "",
        "grammar": "snu",
        "label": "spy on and return (coffee)",
        "matches": {
          "sr": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "spyOn(${1:object}, \"${2:method}\").andThrow(${3:exception})",
        "doc": "",
        "grammar": "snu",
        "label": "spy on and throw (coffee)",
        "matches": {
          "st": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "spyOn(${1:object}, \"${2:method}\").andCallThrough()",
        "doc": "",
        "grammar": "snu",
        "label": "spy on and call through (coffee)",
        "matches": {
          "sct": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "spyOn(${1:object}, \"${2:method}\").andCallFake(${3:function})",
        "doc": "",
        "grammar": "snu",
        "label": "spy on and call fake (coffee)",
        "matches": {
          "scf": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "expect(${1:target}).wasCalled()",
        "doc": "",
        "grammar": "snu",
        "label": "expect was called (coffee)",
        "matches": {
          "esc": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "expect(${1:target}).wasCalledWith(${2:arguments})",
        "doc": "",
        "grammar": "snu",
        "label": "expect was called with (coffee)",
        "matches": {
          "escw": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "expect(${1:target}).wasNotCalled()",
        "doc": "",
        "grammar": "snu",
        "label": "expect was not called (coffee)",
        "matches": {
          "notsc": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "expect(${1:target}).wasNotCalledWith(${2:arguments})",
        "doc": "",
        "grammar": "snu",
        "label": "expect was not called with (coffee)",
        "matches": {
          "noscw": true
        },
        "options": {
          "b": true
        }
      }
    ],
    "coffee-react": [
      {
        "content": "${1:classname}Class = React.createClass\n\tdisplayName: \"$1\"\n\trender: ->\n\t\t$2\n$1 = React.createFactory($1)",
        "doc": "",
        "grammar": "snu",
        "label": "React define Class",
        "matches": {
          "createClass": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "propTypes: ->\n\t${1:myVar}: React.PropTypes.${2:type}${3:.isRequired}",
        "doc": "",
        "grammar": "snu",
        "label": "React define propTypes",
        "matches": {
          "PropTypes": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:myVar}: React.PropTypes.${2:type}${3:.isRequired}\n$4",
        "doc": "",
        "grammar": "snu",
        "label": "React propType (key/value)",
        "matches": {
          "propType": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "@setState\n\t${1:myvar}: ${2:myvalue}\n\t$3",
        "doc": "",
        "grammar": "snu",
        "label": "React setState",
        "matches": {
          "setState": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "getInitialState: ->\n\t${1:myvar}: ${2:myvalue}\n\t$3",
        "doc": "",
        "grammar": "snu",
        "label": "React define getInitialState",
        "matches": {
          "getInitialState": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "getDefaultProps: ->\n\t${1:myvar}: ${2:myvalue}\n\t$3",
        "doc": "",
        "grammar": "snu",
        "label": "React define getDefaultProps",
        "matches": {
          "getDefaultProps": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "componentWillMount: ->\n\t$1",
        "doc": "",
        "grammar": "snu",
        "label": "React define componentWillMount",
        "matches": {
          "componentWillMount": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "componentDidMount: ->\n\t$1",
        "doc": "",
        "grammar": "snu",
        "label": "React define componentDidMount",
        "matches": {
          "componentDidMount": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "componentWillReceiveProps: (nextProps) ->\n\t$1",
        "doc": "",
        "grammar": "snu",
        "label": "React define componentWillReceiveProps",
        "matches": {
          "componentWillReceiveProps": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "shouldComponentUpdate: (nextProps, nextState) ->\n\t$1",
        "doc": "",
        "grammar": "snu",
        "label": "React define shouldComponentUpdate",
        "matches": {
          "shouldComponentUpdate": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "componentWillUpdate: (nextProps, nextState) ->\n\t$1",
        "doc": "",
        "grammar": "snu",
        "label": "React define componentWillUpdate",
        "matches": {
          "componentWillUpdate": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "componentDidUpdate: (prevProps, prevState) ->\n\t$1",
        "doc": "",
        "grammar": "snu",
        "label": "React define componentDidUpdate",
        "matches": {
          "componentDidUpdate": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "componentWillUnmount: ->\n\t$1",
        "doc": "",
        "grammar": "snu",
        "label": "React define componentWillUnmount",
        "matches": {
          "componentWillUnmount": true
        },
        "options": {
          "b": true
        }
      }
    ],
    "cpp": [
      {
        "content": "#include <${1:iostream}>${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#inc, #include": true,
          "inc": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "#include \"${1}\"${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#inc2, #include2": true,
          "inc2": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "template<typename ${1:T}> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "template <T>",
        "matches": {
          "template": true
        },
        "options": {}
      },
      {
        "content": "class ${1:#:name} {\n    ${2}\npublic:\n    $1(${3});\n};\n$1::$1($3) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "class {}",
        "matches": {
          "class": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "class ${1:#:name} {\n    ${2}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "class {}",
        "matches": {
          "class-without-constructor": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "try {\n    ${1:#:TARGET}\n} catch (${2:...}) {\n    ${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "try catch",
        "matches": {
          "try": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "for (${1:auto&& }${2:var} : ${3:container}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "for (:) {}",
        "matches": {
          "for_CPP11": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "[${1}](${2})${3}{ ${4:TARGET} }${0:;}",
        "doc": "",
        "grammar": "snu",
        "label": "[](){}",
        "matches": {
          "lambda": true
        },
        "options": {}
      },
      {
        "content": "enum struct ${1:#:name} { ${2:#:TARGET} };",
        "doc": "",
        "grammar": "snu",
        "label": "enum struct {};",
        "matches": {
          "enum_scoped": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "static_assert( ${1}, \"${2}\" );${0}",
        "doc": "",
        "grammar": "snu",
        "label": "static_assert(,\"\")",
        "matches": {
          "static_assert": true
        },
        "options": {}
      },
      {
        "content": "namespace ${1:#:name} {\n    ${0:TARGET}\n} // namespace $1",
        "doc": "",
        "grammar": "snu",
        "label": "namespace {}",
        "matches": {
          "namespace": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "static_cast<${1}>(${2})${0}",
        "doc": "",
        "grammar": "snu",
        "label": "static_cast<>()",
        "matches": {
          "static_cast": true
        },
        "options": {}
      },
      {
        "content": "reinterpret_cast<${1}>(${2})${0}",
        "doc": "",
        "grammar": "snu",
        "label": "reinterpret_cast<>()",
        "matches": {
          "reinterpret_cast": true
        },
        "options": {}
      },
      {
        "content": "const_cast<${1}>(${2})${0}",
        "doc": "",
        "grammar": "snu",
        "label": "const_cast<>()",
        "matches": {
          "const_cast": true
        },
        "options": {}
      },
      {
        "content": "dynamic_cast<${1}>(${2})${0}",
        "doc": "",
        "grammar": "snu",
        "label": "dynamic_cast<>()",
        "matches": {
          "dynamic_cast": true
        },
        "options": {}
      },
      {
        "content": "#include <iostream>\nint main(int argc, char* argv[])\n{\n    std::cout << \"hello, world!\" << std::endl;\n    return 0;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "#include<iostream> int main...",
        "matches": {
          "helloworld": true
        },
        "options": {}
      },
      {
        "content": "std::cout << ${0:TARGET} << std::endl;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "#include <${1:iostream}>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "incc": true
        },
        "options": {}
      },
      {
        "content": "#include <boost/${1:shared_ptr}.hpp>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "binc": true
        },
        "options": {}
      },
      {
        "content": "std::array<${1:T}, ${2:N}> ${3};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "array": true
        },
        "options": {}
      },
      {
        "content": "std::vector<${1:T}> ${2};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vector": true
        },
        "options": {}
      },
      {
        "content": "std::deque<${1:T}> ${2};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "deque": true
        },
        "options": {}
      },
      {
        "content": "std::forward_list<${1:T}> ${2};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "flist": true
        },
        "options": {}
      },
      {
        "content": "std::list<${1:T}> ${2};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list": true
        },
        "options": {}
      },
      {
        "content": "std::set<${1:T}> ${2};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "set": true
        },
        "options": {}
      },
      {
        "content": "std::map<${1:Key}, ${2:T}> ${3};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "map": true
        },
        "options": {}
      },
      {
        "content": "std::multiset<${1:T}> ${2};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mset": true
        },
        "options": {}
      },
      {
        "content": "std::multimap<${1:Key}, ${2:T}> ${3};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mmap": true
        },
        "options": {}
      },
      {
        "content": "std::unordered_set<${1:T}> ${2};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "uset": true
        },
        "options": {}
      },
      {
        "content": "std::unordered_map<${1:Key}, ${2:T}> ${3};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "umap": true
        },
        "options": {}
      },
      {
        "content": "std::unordered_multiset<${1:T}> ${2};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "umset": true
        },
        "options": {}
      },
      {
        "content": "std::unordered_multimap<${1:Key}, ${2:T}> ${3};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ummap": true
        },
        "options": {}
      },
      {
        "content": "std::stack<${1:T}> ${2};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "stack": true
        },
        "options": {}
      },
      {
        "content": "std::queue<${1:T}> ${2};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "queue": true
        },
        "options": {}
      },
      {
        "content": "std::priority_queue<${1:T}> ${2};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pqueue": true
        },
        "options": {}
      },
      {
        "content": "std::shared_ptr<${1:T}> ${2} = std::make_shared<$1>(${3});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "msp": true
        },
        "options": {}
      },
      {
        "content": "auto ${1} = std::make_shared<${2:T}>(${3});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "amsp": true
        },
        "options": {}
      },
      {
        "content": "std::unique_ptr<${1:T}> ${2} = std::make_unique<$1>(${3});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mup": true
        },
        "options": {}
      },
      {
        "content": "auto ${1} = std::make_unique<${2:T}>(${3});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "amup": true
        },
        "options": {}
      },
      {
        "content": "private",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pri": true
        },
        "options": {}
      },
      {
        "content": "protected",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pro": true
        },
        "options": {}
      },
      {
        "content": "public",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pub": true
        },
        "options": {}
      },
      {
        "content": "friend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fr": true
        },
        "options": {}
      },
      {
        "content": "mutable",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mu": true
        },
        "options": {}
      },
      {
        "content": "namespace {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ans": true
        },
        "options": {}
      },
      {
        "content": "std::cout << ${1} << std::endl;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cout": true
        },
        "options": {}
      },
      {
        "content": "std::cin >> ${1};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cin": true
        },
        "options": {}
      },
      {
        "content": "static_cast<${1:unsigned}>(${2:expr})${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sca": true
        },
        "options": {}
      },
      {
        "content": "dynamic_cast<${1:unsigned}>(${2:expr})${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dca": true
        },
        "options": {}
      },
      {
        "content": "reinterpret_cast<${1:unsigned}>(${2:expr})${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rca": true
        },
        "options": {}
      },
      {
        "content": "const_cast<${1:unsigned}>(${2:expr})${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cca": true
        },
        "options": {}
      },
      {
        "content": "for (int ${2:i} = 0; $2 < ${1:count}; $2${3:++}) {\n\t${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fori": true
        },
        "options": {}
      },
      {
        "content": "for (${1:auto} ${2:i} : ${3:container}) {\n\t${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fore": true
        },
        "options": {}
      },
      {
        "content": "for (${1:std::vector}<${2:type}>::${3:const_iterator} ${4:i} = ${5:container}.begin(); $4 != $5.end(); ++$4) {\n\t${6}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "iter": true
        },
        "options": {}
      },
      {
        "content": "for (auto ${1:i} = ${2:container}.begin(); $1 != $2.end(); ++$1) {\n\t${3:std::cout << *$1 << std::endl;}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "itera": true
        },
        "options": {}
      },
      {
        "content": "[${1}](${2}){${3}};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ld": true
        },
        "options": {}
      },
      {
        "content": "[${1}](${2}){\n\t${3}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lld": true
        },
        "options": {}
      },
      {
        "content": "try {\n}catch(${1}) {\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "try": true
        },
        "options": {}
      },
      {
        "content": "auto ${1:name}(${2}) -> ${3:void}\n{\n\t${0}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "af auto function": true
        },
        "options": {}
      }
    ],
    "crystal": [
      {
        "content": "require \"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "req require": true
        },
        "options": {}
      },
      {
        "content": "case ${1:object}\nwhen ${2:condition}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case": true
        },
        "options": {}
      },
      {
        "content": "when ${1:condition}\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "when": true
        },
        "options": {}
      },
      {
        "content": "def ${1:method_name}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "def": true
        },
        "options": {}
      },
      {
        "content": "private def ${1:method_name}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pdef": true
        },
        "options": {}
      },
      {
        "content": "if ${1:condition}\n\t${0:${VISUAL}}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "if ${1:condition}\n\t${2:${VISUAL}}\nelse\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "while ${1:condition}\n\t${0:${VISUAL}}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh": true
        },
        "options": {}
      },
      {
        "content": "getter ${0:name}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "r": true
        },
        "options": {}
      },
      {
        "content": "getter! ${0:name}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "r!": true
        },
        "options": {}
      },
      {
        "content": "getter? ${0:name}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "r?": true
        },
        "options": {}
      },
      {
        "content": "setter ${0:name}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "w": true
        },
        "options": {}
      },
      {
        "content": "setter! ${0:name}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "w!": true
        },
        "options": {}
      },
      {
        "content": "setter? ${0:name}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "w?": true
        },
        "options": {}
      },
      {
        "content": "property ${0:name}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rw": true
        },
        "options": {}
      },
      {
        "content": "property! ${0:name}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rw!": true
        },
        "options": {}
      },
      {
        "content": "property? ${0:name}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rw?": true
        },
        "options": {}
      },
      {
        "content": "def self.${1:class_method_name}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defs": true
        },
        "options": {}
      },
      {
        "content": "def initialize(${1})\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defi": true
        },
        "options": {}
      },
      {
        "content": "do\n\t${0:${VISUAL}}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "do": true
        },
        "options": {}
      },
      {
        "content": "do |${1:v}|\n\t${2}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dov": true
        },
        "options": {}
      },
      {
        "content": "it \"${1}\" do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "it": true
        },
        "options": {}
      },
      {
        "content": "def ${1:method_name}${2:(${3:*args})}\n\t$0\nend",
        "doc": "",
        "grammar": "snu",
        "label": "def <name>...",
        "matches": {
          "\"\\b(de)?f": true
        },
        "options": {
          "r": true
        }
      },
      {
        "content": "private def ${1:method_name}${2:(${3:*args})}\n\t$0\nend",
        "doc": "",
        "grammar": "snu",
        "label": "private def <name>...",
        "matches": {
          "\"\\b(pde)?f": true
        },
        "options": {
          "r": true
        }
      }
    ],
    "cs": [
      {
        "content": "namespace ${1:#:Name} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "namespace {}",
        "matches": {
          "name": true,
          "namespace": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "class ${1:#:Name} ${2::} ${3:Parent}${4:,} ${5:Interface} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "class {}",
        "matches": {
          "class": true
        },
        "options": {}
      },
      {
        "content": "struct ${1:#:Name} ${2::} ${3:Interface} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "struct {}",
        "matches": {
          "struct": true
        },
        "options": {}
      },
      {
        "content": "interface ${1:#:IName} ${2::} ${3:Parent} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "interface {}",
        "matches": {
          "interface": true
        },
        "options": {}
      },
      {
        "content": "${1:void} ${2:#:Method}(${3:#:arguments}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "method": true
        },
        "options": {}
      },
      {
        "content": "enum ${1:#:Name} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "enum {}",
        "matches": {
          "enum": true
        },
        "options": {}
      },
      {
        "content": "delegate ${1:void} ${2:#:Delegate}(${3:#:arguments});${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "delegate": true
        },
        "options": {}
      },
      {
        "content": "${1:int} ${2:#:Name} { get${3:;} ${4:#:private }set${5:;} }${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prop": true,
          "property": true
        },
        "options": {}
      },
      {
        "content": "get {${1:TARGET}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "get {}",
        "matches": {
          "get": true
        },
        "options": {}
      },
      {
        "content": "set {${1:TARGET}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "set {}",
        "matches": {
          "set": true
        },
        "options": {}
      },
      {
        "content": "#define ${0:#:SYMBOL}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "def": true,
          "define": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "#undef ${0:#:SYMBOL}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "und": true,
          "undef": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "#if ${1:SYMBOL}\n    ${0:TARGET}\n#endif",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifdef": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "#warning ${0:#:message}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "warn": true,
          "warning": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "#error ${0:#:message}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "err": true,
          "error": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "#line ${0:#:number}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "line": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "#region ${1:#:name}\n    ${0:TARGET}\n#endregion",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "reg": true,
          "region": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "#pragma warning ${2:disable} ${3:#:errno}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pragma pragma_warn": true,
          "pragma_warning": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "if (${1:#:condition}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if () {}",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "else if (${1:#:condition}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "else if () {}",
        "matches": {
          "elif": true,
          "elseif": true
        },
        "options": {}
      },
      {
        "content": "if (${1:#:condition}) {\n    ${2:TARGET}\n} else {\n    ${3:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if () {} else {}",
        "matches": {
          "ifel": true,
          "ifelse": true
        },
        "options": {}
      },
      {
        "content": "while (${1:#:condition}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "while () {}",
        "matches": {
          "while": true
        },
        "options": {}
      },
      {
        "content": "do {\n    ${0:TARGET}\n} while (${1:#:condition});",
        "doc": "",
        "grammar": "snu",
        "label": "do {} while() {}",
        "matches": {
          "do_while": true,
          "dowhile": true
        },
        "options": {}
      },
      {
        "content": "for (${1:#:var}; ${2:#:condition}; ${3:#:effect}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "for () {}",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "foreach (${1:#:var} in ${2:#:iter}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "foreach () {}",
        "matches": {
          "fore": true,
          "foreach": true
        },
        "options": {}
      },
      {
        "content": "switch (${1:#:var}) {\ncase ${2:#:val}:\n    ${0:TARGET}\n    break;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "switch () {}",
        "matches": {
          "switch": true
        },
        "options": {}
      },
      {
        "content": "case ${1:#:val}:\n    ${0:TARGET}\n    break;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "break;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "break": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "goto case ${1:#:Val};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "goto": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "default:\n    ${0:TARGET}\n    break;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "default": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "try {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "try_n": true,
          "try_without_catch_nor_finally": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "try {\n    ${0:TARGET}\n} catch (${1:Exception} ${2:e}) {\n    ${3:Console.WriteLine(e.Message);}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "try {} catch () {}",
        "matches": {
          "try": true,
          "try_catch": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "try {\n    ${0:TARGET}\n} catch {\n    ${1}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "try {} catch {}",
        "matches": {
          "try_catch_n": true,
          "try_cn": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "try {\n    ${0:TARGET}\n} catch (${1:Exception} ${2:e}) {\n    ${3:Console.WriteLine(e.Message);}\n} finally {\n    ${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "try {} catch () {} finally {}",
        "matches": {
          "try_catch_finally": true,
          "try_cf": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "try {\n    ${0:TARGET}\n} finally {\n    ${1}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "try {} finally {}",
        "matches": {
          "try_f": true,
          "try_finally": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "try {\n    ${0:TARGET}\n} catch {\n    ${1}\n} finally {\n    ${2}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "try {} catch {} finally {}",
        "matches": {
          "try_catch_n_finally": true,
          "try_cnf": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "catch (${1:Exception} ${2:e}) {\n    ${0:Console.WriteLine(e.Message);}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "catch () {}",
        "matches": {
          "catch": true
        },
        "options": {}
      },
      {
        "content": "catch {\n    ${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "catch {}",
        "matches": {
          "catch_n": true
        },
        "options": {}
      },
      {
        "content": "finally {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "finally {}",
        "matches": {
          "fin": true,
          "finally": true
        },
        "options": {}
      },
      {
        "content": "throw ${0:#:exception}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "throw": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "lock (${1:#:resource}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "lock () {}",
        "matches": {
          "lock": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "using (${1:#:resource}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "using () {}",
        "matches": {
          "using resource": true,
          "using_resource": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "checked (${1:#:var}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "checked () {}",
        "matches": {
          "checked": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "unchecked (${1:#:var}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "unchecked () {}",
        "matches": {
          "unchecked": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "unsafe {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "unsafe {}",
        "matches": {
          "unsafe": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "fixed (${1:#:type}* ${2:#:var} = ${3:#:adress}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "fixed () {}",
        "matches": {
          "fixed": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "using ${1:#:path};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "import": true,
          "using_import": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "using ${1:Name} = ${2:Type};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "typedef": true,
          "using_typedef": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "System.Linq",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "s.l": true
        },
        "options": {}
      },
      {
        "content": "System.Collections.Generic",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "s.c.g": true
        },
        "options": {}
      },
      {
        "content": "System.Text",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "s.t": true
        },
        "options": {}
      },
      {
        "content": "System.IO",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "s.i": true
        },
        "options": {}
      },
      {
        "content": "System.Diagnostics",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "s.d": true
        },
        "options": {}
      },
      {
        "content": "System.Runtie.CompilerServices",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "s.r.c": true
        },
        "options": {}
      },
      {
        "content": "System.Windows.Forms",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "s.w.f": true
        },
        "options": {}
      },
      {
        "content": "[SerializableAttribute]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "serial": true,
          "serializable": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "[Conditional(\"${1:#:SYMBOL}\")]${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cond": true,
          "conditional": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "[Obsolete(\"${1:#:description}\")]${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "obs dep deprecated": true,
          "obsolete": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "[assembly: InternalsVisibleTo(\"${1:#:FriendName}\")]${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asm_internals_visible_to": true,
          "internals asmInternalsVisibleTo friend_attr": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "<c>${1:#:text}</c>",
        "doc": "",
        "grammar": "snu",
        "label": "<c></c>",
        "matches": {
          "c": true
        },
        "options": {}
      },
      {
        "content": "<code>${0:#:content}</code>",
        "doc": "",
        "grammar": "snu",
        "label": "<code></code>",
        "matches": {
          "code": true
        },
        "options": {}
      },
      {
        "content": "<example>${0:#:description}</example>",
        "doc": "",
        "grammar": "snu",
        "label": "<example></example>",
        "matches": {
          "example": true
        },
        "options": {}
      },
      {
        "content": "<exception cref=\"${1:#:class}\">${2:#:description}</exception>",
        "doc": "",
        "grammar": "snu",
        "label": "<exception cref=\"\"></exception>",
        "matches": {
          "exception": true
        },
        "options": {}
      },
      {
        "content": "<include file='${1:#:filename}' path='${2:#:tabpath}[@${3:#:name}=\"${4:#:id}\"]'/>",
        "doc": "",
        "grammar": "snu",
        "label": "<include file='' path=''/>",
        "matches": {
          "include": true
        },
        "options": {}
      },
      {
        "content": "<param name=\"${1:#:name}\">${0:#:description}</param>",
        "doc": "",
        "grammar": "snu",
        "label": "<param name=\"\"></param>",
        "matches": {
          "param": true
        },
        "options": {}
      },
      {
        "content": "<paramref name=\"${1:#:name}\"/>",
        "doc": "",
        "grammar": "snu",
        "label": "<paramref name=\"\"/>",
        "matches": {
          "paramref": true
        },
        "options": {}
      },
      {
        "content": "<returns>${0:#:description}</returns>",
        "doc": "",
        "grammar": "snu",
        "label": "<returns></returns>",
        "matches": {
          "returns": true
        },
        "options": {}
      },
      {
        "content": "<remarks>${0:#:description}</remarks>",
        "doc": "",
        "grammar": "snu",
        "label": "<remarks></remarks>",
        "matches": {
          "remarks": true
        },
        "options": {}
      },
      {
        "content": "<see cref=\"${1:#:member}\"/>",
        "doc": "",
        "grammar": "snu",
        "label": "<see cref=\"\"/>",
        "matches": {
          "see": true
        },
        "options": {}
      },
      {
        "content": "<seealso cref=\"${1:#:member}\"/>}",
        "doc": "",
        "grammar": "snu",
        "label": "<seealso cref=\"\"/>",
        "matches": {
          "seealso": true
        },
        "options": {}
      },
      {
        "content": "<summary>${0:#:description}</summary>",
        "doc": "",
        "grammar": "snu",
        "label": "<summary></summary>",
        "matches": {
          "summary": true
        },
        "options": {}
      },
      {
        "content": "<typeparam name=\"${1:#:name}\">${0:#:description}</typeparam>",
        "doc": "",
        "grammar": "snu",
        "label": "<typeparam name=\"\"></typeparam>",
        "matches": {
          "typeparam": true
        },
        "options": {}
      },
      {
        "content": "<typeparamref name=\"${1:#:name}\"/>",
        "doc": "",
        "grammar": "snu",
        "label": "<typeparamref name=\"\"/>",
        "matches": {
          "typeparamref": true
        },
        "options": {}
      },
      {
        "content": "<value>${0:#:description}</value>",
        "doc": "",
        "grammar": "snu",
        "label": "<value></value>",
        "matches": {
          "value": true
        },
        "options": {}
      },
      {
        "content": "public static void Main(string[] args) {\n    ${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "main": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "Console.WriteLine(${1:#:message});${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "println p": true,
          "writeline": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "Console.Write(${1:#:message});${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "print": true,
          "write": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "public class ${1:Hello} {\n    public static void Main(string[] args) {\n        System.Console.WriteLine(\"Hello, world!\");\n    }\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "helloworld": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "[TestFixture]\npublic class ${1}Test {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tc": true,
          "testclass": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "[SetUp]\npublic void SetUp() {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "testsetup": true,
          "tsu": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "[TearDown]\npublic void TearDown() {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "testteardown": true,
          "ttd": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "[Test]\npublic void ${1:#:Name}Test() {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "test": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "[Category(\"${0:#:category}\")]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "category": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "${1:public} static int Main(string[] args)\n{\n\t${0}\n\treturn 0;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sim": true
        },
        "options": {}
      },
      {
        "content": "public class Application\n{\n\t${1:public} static int Main(string[] args)\n\t{\n\t\t${0}\n\t\treturn 0;\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "simc": true
        },
        "options": {}
      },
      {
        "content": "${1:public} static void Main(string[] args)\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "svm": true
        },
        "options": {}
      },
      {
        "content": "if (${1:true})\n{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "else\n{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "el": true
        },
        "options": {}
      },
      {
        "content": "if (${1})\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifs": true
        },
        "options": {}
      },
      {
        "content": "${1} ? ${2} : ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "t": true
        },
        "options": {}
      },
      {
        "content": "${1} ? ${2} : ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "?": true
        },
        "options": {}
      },
      {
        "content": "do\n{\n\t${0:${VISUAL}}\n} while (${1:true});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "do": true
        },
        "options": {}
      },
      {
        "content": "while (${1:true})\n{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh": true
        },
        "options": {}
      },
      {
        "content": "for (int ${1:i} = 0; $1 < ${2:count}; $1${3:++})\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "for (int ${1:i} = ${2:length}; $1 >= 0; $1--)\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forr": true
        },
        "options": {}
      },
      {
        "content": "foreach (${1:var} ${2:entry} in ${3})\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fore": true
        },
        "options": {}
      },
      {
        "content": "foreach (${1:var} ${2:entry} in ${3})\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "foreach": true
        },
        "options": {}
      },
      {
        "content": "foreach (${1:var} ${2:entry} in ${3})\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "each": true
        },
        "options": {}
      },
      {
        "content": "${1:public} ${2:int} ${3} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prop": true
        },
        "options": {}
      },
      {
        "content": "${1:public} ${2:int} ${3} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p": true
        },
        "options": {}
      },
      {
        "content": "public ${1:int} ${2} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p+": true
        },
        "options": {}
      },
      {
        "content": "public ${1:int} ${2} { get; internal set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p+&": true
        },
        "options": {}
      },
      {
        "content": "public ${1:int} ${2} { get; protected set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p+|": true
        },
        "options": {}
      },
      {
        "content": "public ${1:int} ${2} { get; private set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p+-": true
        },
        "options": {}
      },
      {
        "content": "internal ${1:int} ${2} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p&": true
        },
        "options": {}
      },
      {
        "content": "internal ${1:int} ${2} { get; protected set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p&|": true
        },
        "options": {}
      },
      {
        "content": "internal ${1:int} ${2} { get; private set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p&-": true
        },
        "options": {}
      },
      {
        "content": "protected ${1:int} ${2} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p|": true
        },
        "options": {}
      },
      {
        "content": "protected ${1:int} ${2} { get; private set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p|-": true
        },
        "options": {}
      },
      {
        "content": "private ${1:int} ${2} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p-": true
        },
        "options": {}
      },
      {
        "content": "${1:public} int ${2} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pi": true
        },
        "options": {}
      },
      {
        "content": "public int ${1} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pi+": true
        },
        "options": {}
      },
      {
        "content": "public int ${1} { get; internal set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pi+&": true
        },
        "options": {}
      },
      {
        "content": "public int ${1} { get; protected set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pi+|": true
        },
        "options": {}
      },
      {
        "content": "public int ${1} { get; private set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pi+-": true
        },
        "options": {}
      },
      {
        "content": "internal int ${1} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pi&": true
        },
        "options": {}
      },
      {
        "content": "internal int ${1} { get; protected set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pi&|": true
        },
        "options": {}
      },
      {
        "content": "internal int ${1} { get; private set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pi&-": true
        },
        "options": {}
      },
      {
        "content": "protected int ${1} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pi|": true
        },
        "options": {}
      },
      {
        "content": "protected int ${1} { get; private set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pi|-": true
        },
        "options": {}
      },
      {
        "content": "private int ${1} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pi-": true
        },
        "options": {}
      },
      {
        "content": "${1:public} bool ${2} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pb": true
        },
        "options": {}
      },
      {
        "content": "public bool ${1} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pb+": true
        },
        "options": {}
      },
      {
        "content": "public bool ${1} { get; internal set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pb+&": true
        },
        "options": {}
      },
      {
        "content": "public bool ${1} { get; protected set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pb+|": true
        },
        "options": {}
      },
      {
        "content": "public bool ${1} { get; private set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pb+-": true
        },
        "options": {}
      },
      {
        "content": "internal bool ${1} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pb&": true
        },
        "options": {}
      },
      {
        "content": "internal bool ${1} { get; protected set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pb&|": true
        },
        "options": {}
      },
      {
        "content": "internal bool ${1} { get; private set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pb&-": true
        },
        "options": {}
      },
      {
        "content": "protected bool ${1} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pb|": true
        },
        "options": {}
      },
      {
        "content": "protected bool ${1} { get; private set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pb|-": true
        },
        "options": {}
      },
      {
        "content": "private bool ${1} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pb-": true
        },
        "options": {}
      },
      {
        "content": "${1:public} string ${2} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ps": true
        },
        "options": {}
      },
      {
        "content": "public string ${1} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ps+": true
        },
        "options": {}
      },
      {
        "content": "public string ${1} { get; internal set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ps+&": true
        },
        "options": {}
      },
      {
        "content": "public string ${1} { get; protected set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ps+|": true
        },
        "options": {}
      },
      {
        "content": "public string ${1} { get; private set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ps+-": true
        },
        "options": {}
      },
      {
        "content": "internal string ${1} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ps&": true
        },
        "options": {}
      },
      {
        "content": "internal string ${1} { get; protected set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ps&|": true
        },
        "options": {}
      },
      {
        "content": "internal string ${1} { get; private set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ps&-": true
        },
        "options": {}
      },
      {
        "content": "protected string ${1} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ps|": true
        },
        "options": {}
      },
      {
        "content": "protected string ${1} { get; private set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ps|-": true
        },
        "options": {}
      },
      {
        "content": "private string ${1} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ps-": true
        },
        "options": {}
      },
      {
        "content": "${1:public} ${2:void} ${3}(${4})\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "m": true
        },
        "options": {}
      },
      {
        "content": "public ${1:void} ${2}(${3})\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "m+": true
        },
        "options": {}
      },
      {
        "content": "internal ${1:void} ${2}(${3})\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "m&": true
        },
        "options": {}
      },
      {
        "content": "protected ${1:void} ${2}(${3})\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "m|": true
        },
        "options": {}
      },
      {
        "content": "private ${1:void} ${2}(${3})\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "m-": true
        },
        "options": {}
      },
      {
        "content": "${1:public} int ${2}(${3})\n{\n\t${0:return 0;}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mi": true
        },
        "options": {}
      },
      {
        "content": "public int ${1}(${2})\n{\n\t${0:return 0;}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mi+": true
        },
        "options": {}
      },
      {
        "content": "internal int ${1}(${2})\n{\n\t${0:return 0;}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mi&": true
        },
        "options": {}
      },
      {
        "content": "protected int ${1}(${2})\n{\n\t${0:return 0;}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mi|": true
        },
        "options": {}
      },
      {
        "content": "private int ${1}(${2})\n{\n\t${0:return 0;}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mi-": true
        },
        "options": {}
      },
      {
        "content": "${1:public} bool ${2}(${3})\n{\n\t${0:return false;}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mb": true
        },
        "options": {}
      },
      {
        "content": "public bool ${1}(${2})\n{\n\t${0:return false;}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mb+": true
        },
        "options": {}
      },
      {
        "content": "internal bool ${1}(${2})\n{\n\t${0:return false;}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mb&": true
        },
        "options": {}
      },
      {
        "content": "protected bool ${1}(${2})\n{\n\t${0:return false;}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mb|": true
        },
        "options": {}
      },
      {
        "content": "private bool ${1}(${2})\n{\n\t${0:return false;}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mb-": true
        },
        "options": {}
      },
      {
        "content": "${1:public} string ${2}(${3})\n{\n\t${0:return \"\";}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ms": true
        },
        "options": {}
      },
      {
        "content": "public string ${1}(${2})\n{\n\t${0:return \"\";}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ms+": true
        },
        "options": {}
      },
      {
        "content": "internal string ${1}(${2})\n{\n\t${0:return \"\";}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ms&": true
        },
        "options": {}
      },
      {
        "content": "protected string ${1:}(${2:})\n{\n\t${0:return \"\";}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ms|": true
        },
        "options": {}
      },
      {
        "content": "private string ${1}(${2})\n{\n\t${0:return \"\";}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ms-": true
        },
        "options": {}
      },
      {
        "content": "enum ${1}\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "enum": true
        },
        "options": {}
      },
      {
        "content": "public enum ${1}\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "enum+": true
        },
        "options": {}
      },
      {
        "content": "#if\n\t${0}\n#endif",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#if": true
        },
        "options": {}
      },
      {
        "content": "/// <summary>\n/// ${0}\n/// </summary>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "///": true
        },
        "options": {}
      },
      {
        "content": "<param name=\"${1}\">${2:$1}</param>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "<p": true
        },
        "options": {}
      },
      {
        "content": "<exception cref=\"${1:System.Exception}\">${2}</exception>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "<ex": true
        },
        "options": {}
      },
      {
        "content": "<returns>${1}</returns>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "<r": true
        },
        "options": {}
      },
      {
        "content": "<see cref=\"${1}\"/>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "<s": true
        },
        "options": {}
      },
      {
        "content": "<remarks>${1}</remarks>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "<rem": true
        },
        "options": {}
      },
      {
        "content": "<code>${1}</code>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "<c": true
        },
        "options": {}
      },
      {
        "content": "Console.WriteLine(${1});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cw": true
        },
        "options": {}
      },
      {
        "content": "public override bool Equals(object obj)\n{\n\tif (obj == null || GetType() != obj.GetType())\n\t{\n\t\treturn false;\n\t}\n\t${0:throw new NotImplementedException();}\n\treturn base.Equals(obj);\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eq": true
        },
        "options": {}
      },
      {
        "content": "public class ${1:MyException} : ${2:Exception}\n{\n\tpublic $1() { }\n\tpublic $1(string message) : base(message) { }\n\tpublic $1(string message, Exception inner) : base(message, inner) { }\n\tprotected $1(\n\t\tSystem.Runtime.Serialization.SerializationInfo info,\n\t\tSystem.Runtime.Serialization.StreamingContext context)\n\t\t\t: base(info, context) { }\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "exc": true
        },
        "options": {}
      },
      {
        "content": "public ${1:object} this[${2:int} index]\n{\n\tget { ${0} }\n\tset { ${0} }\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "index": true
        },
        "options": {}
      },
      {
        "content": "EventHandler temp = ${1:MyEvent};\nif (${2:temp} != null)\n{\n\t$2();\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "inv": true
        },
        "options": {}
      },
      {
        "content": "lock (${1:this})\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lock": true
        },
        "options": {}
      },
      {
        "content": "namespace ${1:MyNamespace}\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "namespace": true
        },
        "options": {}
      },
      {
        "content": "public ${1:int} ${2:MyProperty} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "propr": true
        },
        "options": {}
      },
      {
        "content": "private ${1:int} ${2:myVar};\npublic $1 ${3:MyProperty}\n{\n\tget { return $2; }\n\tset { $2 = value; }\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "propf": true
        },
        "options": {}
      },
      {
        "content": "public ${1:int} ${2:MyProperty} { get; private set; }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "propg": true
        },
        "options": {}
      },
      {
        "content": "switch (${1:switch_on})\n{\n\t${0}\n\tdefault:\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "switch": true
        },
        "options": {}
      },
      {
        "content": "try\n{\n\t${0:${VISUAL}}\n}\ncatch (${1:System.Exception})\n{\n\tthrow;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "try": true
        },
        "options": {}
      },
      {
        "content": "try\n{\n\t${0:${VISUAL}}\n}\nfinally\n{\n\t${1}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tryf": true
        },
        "options": {}
      },
      {
        "content": "using (${1:resource})\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "usi": true
        },
        "options": {}
      },
      {
        "content": "namespace ${1:MyNamespace}\n{\n\t${VISUAL}$0\n}",
        "doc": "",
        "grammar": "snu",
        "label": "namespace",
        "matches": {
          "namespace": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "enum ${1:MyEnum} { ${2:Item} };",
        "doc": "",
        "grammar": "snu",
        "label": "enumeration",
        "matches": {
          "enum": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "static int Main(string[] args)\n{\n\t$0\n}",
        "doc": "",
        "grammar": "snu",
        "label": "static int main",
        "matches": {
          "sim": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "static void Main(string[] args)\n{\n\t$0\n}",
        "doc": "",
        "grammar": "snu",
        "label": "static void main",
        "matches": {
          "svm": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "public ${1:int} ${2:MyProperty} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": "Simple property declaration",
        "matches": {
          "prop": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "private ${1:int} ${2:_myProperty};\n\npublic $1 ${3:MyProperty}\n{\n\tget { return $2; }\n\tset { $2 = value; }\n}",
        "doc": "",
        "grammar": "snu",
        "label": "Full property declaration",
        "matches": {
          "propfull": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "public ${1:int} ${2:MyProperty} { get; private set; }",
        "doc": "",
        "grammar": "snu",
        "label": "Property with a private setter",
        "matches": {
          "propg": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "#if ${1:DEBUG}\n${VISUAL}$0\n#endif",
        "doc": "",
        "grammar": "snu",
        "label": "#if #endif",
        "matches": {
          "#if": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "#region ${1:Region}\n${VISUAL}$0\n#endregion",
        "doc": "",
        "grammar": "snu",
        "label": "#region #endregion",
        "matches": {
          "#region": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "for (int ${1:i} = 0; $1 < ${2:10}; $1++)\n{\n\t${VISUAL}$0\n}",
        "doc": "",
        "grammar": "snu",
        "label": "for loop",
        "matches": {
          "for": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "for (int ${1:i} = ${2:10}; $1 >= 0; $1--)\n{\n\t${VISUAL}$0\n}",
        "doc": "",
        "grammar": "snu",
        "label": "for loop (reverse)",
        "matches": {
          "forr": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "foreach (${3:var} ${2:item} in ${1:items})\n{\n\t${VISUAL}$0\n}",
        "doc": "",
        "grammar": "snu",
        "label": "foreach loop",
        "matches": {
          "foreach": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "while (${1:true})\n{\n\t${VISUAL}$0\n}",
        "doc": "",
        "grammar": "snu",
        "label": "while loop",
        "matches": {
          "while": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "do\n{\n\t${VISUAL}$0\n} while (${1:true});",
        "doc": "",
        "grammar": "snu",
        "label": "do loop",
        "matches": {
          "do": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "if ($1)\n{\n\t${VISUAL}$0\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if statement",
        "matches": {
          "if": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "if ($1)\n{\n\t${VISUAL}$0\n}\nelse\n{\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if else statement",
        "matches": {
          "ife": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "else if ($1)\n{\n\t$0\n}",
        "doc": "",
        "grammar": "snu",
        "label": "else if",
        "matches": {
          "elif": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "else if ($1)\n{\n\t$0\n}",
        "doc": "",
        "grammar": "snu",
        "label": "else if",
        "matches": {
          "elseif": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "if ($1 != null)\n{\n\t${VISUAL}$0\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if not null",
        "matches": {
          "ifnn": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "switch (${1:statement})\n{\n\tcase ${2:value}:\n\t\tbreak;\n\n\tdefault:\n\t\t$0break;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "switch statement",
        "matches": {
          "switch": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "case ${1:value}:\n\t$2\n\tbreak;",
        "doc": "",
        "grammar": "snu",
        "label": "case",
        "matches": {
          "case": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "using (${1:resource})\n{\n\t${VISUAL}$0\n}",
        "doc": "",
        "grammar": "snu",
        "label": "using statement",
        "matches": {
          "using": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "unchecked\n{\n\t${VISUAL}$0\n}",
        "doc": "",
        "grammar": "snu",
        "label": "unchecked block",
        "matches": {
          "unchecked": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "checked\n{\n\t${VISUAL}$0\n}",
        "doc": "",
        "grammar": "snu",
        "label": "checked block",
        "matches": {
          "checked": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "unsafe\n{\n\t${VISUAL}$0\n}",
        "doc": "",
        "grammar": "snu",
        "label": "unsafe",
        "matches": {
          "unsafe": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "try\n{\n\t${VISUAL}$0\n}\ncatch (${1:Exception} ${2:e})\n{\n\tthrow;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "try catch block",
        "matches": {
          "try": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "try\n{\n\t${VISUAL}$0\n}\nfinally\n{\n}",
        "doc": "",
        "grammar": "snu",
        "label": "try finally block",
        "matches": {
          "tryf": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "throw new $1Exception(\"$2\");",
        "doc": "",
        "grammar": "snu",
        "label": "throw",
        "matches": {
          "throw": true
        },
        "options": {}
      },
      {
        "content": "var ${1:seq} =\n\tfrom ${2:item1} in ${3:items1}\n\tjoin ${4:item2} in ${5:items2} on $2.${6:prop1} equals $4.${7:prop2}\n\tselect ${8:$2.prop3}\n\twhere ${9:clause}",
        "doc": "",
        "grammar": "snu",
        "label": "LINQ syntax",
        "matches": {
          "from": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "Debug.Assert(${1:true});",
        "doc": "",
        "grammar": "snu",
        "label": "Debug.Assert",
        "matches": {
          "da": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "Console.WriteLine(\"$1\");",
        "doc": "",
        "grammar": "snu",
        "label": "Console.WriteLine",
        "matches": {
          "cw": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "Console.ReadLine();",
        "doc": "",
        "grammar": "snu",
        "label": "Console.ReadLine",
        "matches": {
          "cr": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "MessageBox.Show(\"${1:message}\");",
        "doc": "",
        "grammar": "snu",
        "label": "Message box",
        "matches": {
          "mbox": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "public override bool Equals(object obj) => Equals(obj as ${1:TYPE});\n\npublic bool Equals($1 other)  // IEquatable<$1>\n{\n\tif (object.ReferenceEquals(other, null))\n\t\treturn false;\n\tif (object.ReferenceEquals(this, other))\n\t\treturn true;\n\tif (this.GetType() != other.GetType())\n\t\treturn false;\n\t$0\n\treturn base.Equals(other);\n}\n\npublic override int GetHashCode() => base.GetHashCode();\n\npublic static bool operator ==($1 x, $1 y) =>\n\t(object.ReferenceEquals(x, null) && object.ReferenceEquals(y, null))\n\t|| (!object.ReferenceEquals(x, null) && x.Equals(y));\n\npublic static bool operator !=($1 x, $1 y) => !(x == y);\n",
        "doc": "",
        "grammar": "snu",
        "label": "Equality for a type",
        "matches": {
          "equals": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:public} ${2:void} ${3:MyMethod}(${4})\n{\n\t$0\n}",
        "doc": "",
        "grammar": "snu",
        "label": "Method",
        "matches": {
          "mth": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:public} static ${2:void} ${3:MyMethod}(${4})\n{\n\t$0\n}",
        "doc": "",
        "grammar": "snu",
        "label": "Static method",
        "matches": {
          "mths": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "/// <summary>\n/// $0\n/// </summary>",
        "doc": "",
        "grammar": "snu",
        "label": "XML summary comment",
        "matches": {
          "///": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "<param name=\"${1}\">${2}</param>",
        "doc": "",
        "grammar": "snu",
        "label": "XML pramameter comment",
        "matches": {
          "<p": true
        },
        "options": {
          "w": true
        }
      },
      {
        "content": "<exception cref=\"${1:System.Exception}\">${2}</exception>",
        "doc": "",
        "grammar": "snu",
        "label": "XML exception comment",
        "matches": {
          "<ex": true
        },
        "options": {
          "w": true
        }
      },
      {
        "content": "<returns>$0</returns>",
        "doc": "",
        "grammar": "snu",
        "label": "XML returns comment",
        "matches": {
          "<r": true
        },
        "options": {
          "w": true
        }
      },
      {
        "content": "<code>$0</code>",
        "doc": "",
        "grammar": "snu",
        "label": "XML code comment",
        "matches": {
          "<c": true
        },
        "options": {
          "w": true
        }
      }
    ],
    "css": [
      {
        "content": "background: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "background": true,
          "bg": true
        },
        "options": {}
      },
      {
        "content": "background-attachment: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ba": true,
          "backattachment": true
        },
        "options": {}
      },
      {
        "content": "background-color: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "backcolor": true,
          "bc": true
        },
        "options": {}
      },
      {
        "content": "background-image: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "backimage": true,
          "bi": true
        },
        "options": {}
      },
      {
        "content": "background-position: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "backposition": true,
          "bp": true
        },
        "options": {}
      },
      {
        "content": "background-repeat: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "backrepeat": true,
          "br": true
        },
        "options": {}
      },
      {
        "content": "border: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "b": true,
          "border": true
        },
        "options": {}
      },
      {
        "content": "border-style: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "border-style": true,
          "bs": true
        },
        "options": {}
      },
      {
        "content": "border-color: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bc": true,
          "border-color": true
        },
        "options": {}
      },
      {
        "content": "border-width: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "border-width": true,
          "bw": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-width: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bbw": true,
          "border-bottom-width": true
        },
        "options": {}
      },
      {
        "content": "border-top-width: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "border-top-width": true,
          "btw": true
        },
        "options": {}
      },
      {
        "content": "border-left-width: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "blw": true,
          "border-left-width": true
        },
        "options": {}
      },
      {
        "content": "border-right-width: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "border-right-width": true,
          "brw": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-style: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bbs": true,
          "border-bottom-style": true
        },
        "options": {}
      },
      {
        "content": "border-top-style: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "border-top-style": true,
          "bts": true
        },
        "options": {}
      },
      {
        "content": "border-left-style: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bls": true,
          "border-left-style": true
        },
        "options": {}
      },
      {
        "content": "border-right-style: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "border-right-style": true,
          "brs": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-color: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bbc": true,
          "border-bottom-color": true
        },
        "options": {}
      },
      {
        "content": "border-top-color: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "border-top-color": true,
          "btc": true
        },
        "options": {}
      },
      {
        "content": "border-left-color: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "blc": true,
          "border-left-color": true
        },
        "options": {}
      },
      {
        "content": "border-right-color: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "border-right-color": true,
          "brc": true
        },
        "options": {}
      },
      {
        "content": "outline: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ol": true,
          "outline": true
        },
        "options": {}
      },
      {
        "content": "outline-color: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "oc": true,
          "outline-color": true
        },
        "options": {}
      },
      {
        "content": "outline-style: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "os": true,
          "outline-style": true
        },
        "options": {}
      },
      {
        "content": "outline-width: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "outline-width": true,
          "ow": true
        },
        "options": {}
      },
      {
        "content": "color: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "c": true,
          "color": true
        },
        "options": {}
      },
      {
        "content": "direction: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d": true,
          "direction": true
        },
        "options": {}
      },
      {
        "content": "letter-spacing: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "letter-spacing": true,
          "ls": true
        },
        "options": {}
      },
      {
        "content": "line-height: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lh": true,
          "line-height": true
        },
        "options": {}
      },
      {
        "content": "text-align: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ta": true,
          "text-align": true
        },
        "options": {}
      },
      {
        "content": "text-decoration: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "td": true,
          "text-decoration": true
        },
        "options": {}
      },
      {
        "content": "text-indent: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "text-indent": true,
          "ti": true
        },
        "options": {}
      },
      {
        "content": "text-transform: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "text-transform": true,
          "tt": true
        },
        "options": {}
      },
      {
        "content": "unicode-bidi: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ub": true,
          "unicode-bidi": true
        },
        "options": {}
      },
      {
        "content": "white-space: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "white-space": true,
          "ws": true
        },
        "options": {}
      },
      {
        "content": "word-spacing: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "word-spacing": true,
          "ws": true
        },
        "options": {}
      },
      {
        "content": "font: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "f": true,
          "font": true
        },
        "options": {}
      },
      {
        "content": "font-family: ${1:\"Times New Roman\",Georgia,Serif};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ff": true,
          "font-family": true
        },
        "options": {}
      },
      {
        "content": "font-size: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "font-size": true,
          "fs": true
        },
        "options": {}
      },
      {
        "content": "font-style: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "font-style": true,
          "fs": true
        },
        "options": {}
      },
      {
        "content": "font-weight: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "font-weight": true,
          "fw": true
        },
        "options": {}
      },
      {
        "content": "margin: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "m": true,
          "margin": true
        },
        "options": {}
      },
      {
        "content": "margin-bottom: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "margin-bottom": true,
          "mb": true
        },
        "options": {}
      },
      {
        "content": "margin-top: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "margin-top": true,
          "mt": true
        },
        "options": {}
      },
      {
        "content": "margin-left: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "margin-left": true,
          "ml": true
        },
        "options": {}
      },
      {
        "content": "margin-right: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "margin-right": true,
          "mr": true
        },
        "options": {}
      },
      {
        "content": "padding: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p": true,
          "padding": true
        },
        "options": {}
      },
      {
        "content": "padding-bottom: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "padding-bottom": true,
          "pb": true
        },
        "options": {}
      },
      {
        "content": "padding-top: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "padding-top": true,
          "pt": true
        },
        "options": {}
      },
      {
        "content": "padding-left: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "padding-left": true,
          "pl": true
        },
        "options": {}
      },
      {
        "content": "padding-right: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "padding-right": true,
          "pr": true
        },
        "options": {}
      },
      {
        "content": "list-style: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list-style": true,
          "ls": true
        },
        "options": {}
      },
      {
        "content": "list-style-image: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list-style-image": true,
          "lsi": true
        },
        "options": {}
      },
      {
        "content": "list-style-position: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list-style-position": true,
          "lsp": true
        },
        "options": {}
      },
      {
        "content": "list-style-type: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list-style-type": true,
          "lst": true
        },
        "options": {}
      },
      {
        "content": "content: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "c": true,
          "content": true
        },
        "options": {}
      },
      {
        "content": "height: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "h": true,
          "height": true
        },
        "options": {}
      },
      {
        "content": "max-height: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mah": true,
          "max-height": true
        },
        "options": {}
      },
      {
        "content": "max-width: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "maw": true,
          "max-width": true
        },
        "options": {}
      },
      {
        "content": "min-height: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mih": true,
          "min-height": true
        },
        "options": {}
      },
      {
        "content": "min-width: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "min-width": true,
          "miw": true
        },
        "options": {}
      },
      {
        "content": "width: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "w": true,
          "width": true
        },
        "options": {}
      },
      {
        "content": "@media ${1:condition} {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "@media ...",
        "matches": {
          "media": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "@media ${1:all} and (min-width: ${2:SIZE}) {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "@media all and (min-width) {...}",
        "matches": {
          "media-min-width": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "@media ${1:all} and (max-width: ${2:SIZE}) {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "@media all and (max-width) {...}",
        "matches": {
          "media-max-width": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "${1} {\n\t${2:${VISUAL}}\n}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ". \"selector { }\"": true
        },
        "options": {}
      },
      {
        "content": "!important",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "! \"!important\"": true
        },
        "options": {}
      },
      {
        "content": "-moz-border-image: url(${1}) ${2:0} ${3:0} ${4:0} ${5:0} ${6:stretch} ${7:stretch};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdi:m+": true
        },
        "options": {}
      },
      {
        "content": "-moz-border-image: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdi:m": true
        },
        "options": {}
      },
      {
        "content": "-moz-border-radius: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdrz:m": true
        },
        "options": {}
      },
      {
        "content": "-moz-box-shadow: ${1:0} ${2:0} ${3:0} #${4:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bxsh:m+": true
        },
        "options": {}
      },
      {
        "content": "-moz-box-shadow: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bxsh:m": true
        },
        "options": {}
      },
      {
        "content": "-webkit-border-image: url(${1}) ${2:0} ${3:0} ${4:0} ${5:0} ${6:stretch} ${7:stretch};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdi:w+": true
        },
        "options": {}
      },
      {
        "content": "-webkit-border-image: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdi:w": true
        },
        "options": {}
      },
      {
        "content": "-webkit-border-radius: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdrz:w": true
        },
        "options": {}
      },
      {
        "content": "-webkit-box-shadow: ${1:0} ${2:0} ${3:0} #${4:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bxsh:w+": true
        },
        "options": {}
      },
      {
        "content": "-webkit-box-shadow: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bxsh:w": true
        },
        "options": {}
      },
      {
        "content": "@font-face {\n\tfont-family: ${1};\n\tsrc: url(${2});\n}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@f": true
        },
        "options": {}
      },
      {
        "content": "@import url(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@i": true
        },
        "options": {}
      },
      {
        "content": "@media ${1:print} {\n\t${2:${VISUAL}}\n}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@m \"@media mediatype { }\"": true
        },
        "options": {}
      },
      {
        "content": "align-content: ${1:stretch};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac": true
        },
        "options": {}
      },
      {
        "content": "align-content: start;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:s": true
        },
        "options": {}
      },
      {
        "content": "align-content: end;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:e": true
        },
        "options": {}
      },
      {
        "content": "align-content: center;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:c": true
        },
        "options": {}
      },
      {
        "content": "align-content: flex-start;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:fs": true
        },
        "options": {}
      },
      {
        "content": "align-content: flex-end;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:fe": true
        },
        "options": {}
      },
      {
        "content": "align-content: space-between;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:sb": true
        },
        "options": {}
      },
      {
        "content": "align-content: space-around;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:sa": true
        },
        "options": {}
      },
      {
        "content": "align-content: space-evenly;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:se": true
        },
        "options": {}
      },
      {
        "content": "align-content: stretch;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:st": true
        },
        "options": {}
      },
      {
        "content": "align-content: baseline;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:b": true
        },
        "options": {}
      },
      {
        "content": "align-content: first baseline;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:fb": true
        },
        "options": {}
      },
      {
        "content": "align-content: last baseline;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:lb": true
        },
        "options": {}
      },
      {
        "content": "align-items: ${1:stretch};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ai": true
        },
        "options": {}
      },
      {
        "content": "align-items: start;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ai:s": true
        },
        "options": {}
      },
      {
        "content": "align-items: end;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ai:e": true
        },
        "options": {}
      },
      {
        "content": "align-items: center;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ai:c": true
        },
        "options": {}
      },
      {
        "content": "align-items: flex-start;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ai:fs": true
        },
        "options": {}
      },
      {
        "content": "align-items: flex-end;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ai:fe": true
        },
        "options": {}
      },
      {
        "content": "align-items: stretch;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ai:st": true
        },
        "options": {}
      },
      {
        "content": "align-items: baseline;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ai:b": true
        },
        "options": {}
      },
      {
        "content": "align-items: first baseline;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ai:fb": true
        },
        "options": {}
      },
      {
        "content": "align-items: last baseline;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ai:lb": true
        },
        "options": {}
      },
      {
        "content": "align-self: ${1:stretch};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as": true
        },
        "options": {}
      },
      {
        "content": "align-self: start;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as:s": true
        },
        "options": {}
      },
      {
        "content": "align-self: end;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as:e": true
        },
        "options": {}
      },
      {
        "content": "align-self: center;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as:c": true
        },
        "options": {}
      },
      {
        "content": "align-self: stretch;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as:st": true
        },
        "options": {}
      },
      {
        "content": "align-self: flex-start;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as:fs": true
        },
        "options": {}
      },
      {
        "content": "align-self: flex-end;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as:fe": true
        },
        "options": {}
      },
      {
        "content": "align-self: baseline;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as:b": true
        },
        "options": {}
      },
      {
        "content": "align-self: first baseline;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as:fb": true
        },
        "options": {}
      },
      {
        "content": "align-self: last baseline;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as:lb": true
        },
        "options": {}
      },
      {
        "content": "background: #${1:fff} url(${2}) ${3:0} ${4:0} ${5:no-repeat};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bg+": true
        },
        "options": {}
      },
      {
        "content": "background-attachment: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bga": true
        },
        "options": {}
      },
      {
        "content": "background-attachment: fixed;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bga:f": true
        },
        "options": {}
      },
      {
        "content": "background-attachment: scroll;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bga:s": true
        },
        "options": {}
      },
      {
        "content": "background-break: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgbk": true
        },
        "options": {}
      },
      {
        "content": "background-break: bounding-box;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgbk:bb": true
        },
        "options": {}
      },
      {
        "content": "background-break: continuous;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgbk:c": true
        },
        "options": {}
      },
      {
        "content": "background-break: each-box;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgbk:eb": true
        },
        "options": {}
      },
      {
        "content": "background-clip: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgcp": true
        },
        "options": {}
      },
      {
        "content": "background-clip: border-box;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgcp:bb": true
        },
        "options": {}
      },
      {
        "content": "background-clip: content-box;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgcp:cb": true
        },
        "options": {}
      },
      {
        "content": "background-clip: no-clip;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgcp:nc": true
        },
        "options": {}
      },
      {
        "content": "background-clip: padding-box;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgcp:pb": true
        },
        "options": {}
      },
      {
        "content": "background-color: #${1:fff};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgc": true
        },
        "options": {}
      },
      {
        "content": "background-color: transparent;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgc:t": true
        },
        "options": {}
      },
      {
        "content": "background-image: url(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgi": true
        },
        "options": {}
      },
      {
        "content": "background-image: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgi:n": true
        },
        "options": {}
      },
      {
        "content": "background-origin: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgo": true
        },
        "options": {}
      },
      {
        "content": "background-origin: border-box;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgo:bb": true
        },
        "options": {}
      },
      {
        "content": "background-origin: content-box;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgo:cb": true
        },
        "options": {}
      },
      {
        "content": "background-origin: padding-box;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgo:pb": true
        },
        "options": {}
      },
      {
        "content": "background-position-x: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgpx": true
        },
        "options": {}
      },
      {
        "content": "background-position-y: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgpy": true
        },
        "options": {}
      },
      {
        "content": "background-position: ${1:0} ${2:0};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgp": true
        },
        "options": {}
      },
      {
        "content": "background-repeat: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgr": true
        },
        "options": {}
      },
      {
        "content": "background-repeat: no-repeat;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgr:n": true
        },
        "options": {}
      },
      {
        "content": "background-repeat: repeat-x;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgr:x": true
        },
        "options": {}
      },
      {
        "content": "background-repeat: repeat-y;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgr:y": true
        },
        "options": {}
      },
      {
        "content": "background-repeat: repeat;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgr:r": true
        },
        "options": {}
      },
      {
        "content": "background-size: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgz": true
        },
        "options": {}
      },
      {
        "content": "background-size: auto;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgz:a": true
        },
        "options": {}
      },
      {
        "content": "background-size: contain;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgz:ct": true
        },
        "options": {}
      },
      {
        "content": "background-size: cover;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgz:cv": true
        },
        "options": {}
      },
      {
        "content": "background: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bg": true
        },
        "options": {}
      },
      {
        "content": "filter: progid:DXImageTransform.Microsoft.AlphaImageLoader(src='${1}',sizingMethod='${0:crop}');",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bg:ie": true
        },
        "options": {}
      },
      {
        "content": "background: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bg:n": true
        },
        "options": {}
      },
      {
        "content": "border: ${1:1px} ${2:solid} #${3:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bd+": true
        },
        "options": {}
      },
      {
        "content": "border-bottom: ${1:1px} ${2:solid} #${3:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdb+": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-color: #${1:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbc": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-image: url(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbi": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-image: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbi:n": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-left-image: url(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbli": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-left-image: continue;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbli:c": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-left-image: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbli:n": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-left-radius: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdblrz": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-right-image: url(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbri": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-right-image: continue;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbri:c": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-right-image: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbri:n": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-right-radius: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbrrz": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-style: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbs": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-style: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbs:n": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-width: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbw": true
        },
        "options": {}
      },
      {
        "content": "border-bottom: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdb": true
        },
        "options": {}
      },
      {
        "content": "border-bottom: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdb:n": true
        },
        "options": {}
      },
      {
        "content": "border-break: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbk": true
        },
        "options": {}
      },
      {
        "content": "border-break: close;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbk:c": true
        },
        "options": {}
      },
      {
        "content": "border-collapse: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdcl": true
        },
        "options": {}
      },
      {
        "content": "border-collapse: collapse;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdcl:c": true
        },
        "options": {}
      },
      {
        "content": "border-collapse: separate;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdcl:s": true
        },
        "options": {}
      },
      {
        "content": "border-color: #${1:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdc": true
        },
        "options": {}
      },
      {
        "content": "border-corner-image: url(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdci": true
        },
        "options": {}
      },
      {
        "content": "border-corner-image: continue;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdci:c": true
        },
        "options": {}
      },
      {
        "content": "border-corner-image: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdci:n": true
        },
        "options": {}
      },
      {
        "content": "border-fit: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdf": true
        },
        "options": {}
      },
      {
        "content": "border-fit: clip;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdf:c": true
        },
        "options": {}
      },
      {
        "content": "border-fit: overwrite;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdf:of": true
        },
        "options": {}
      },
      {
        "content": "border-fit: overwrite;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdf:ow": true
        },
        "options": {}
      },
      {
        "content": "border-fit: repeat;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdf:r": true
        },
        "options": {}
      },
      {
        "content": "border-fit: scale;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdf:sc": true
        },
        "options": {}
      },
      {
        "content": "border-fit: space;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdf:sp": true
        },
        "options": {}
      },
      {
        "content": "border-fit: stretch;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdf:st": true
        },
        "options": {}
      },
      {
        "content": "border-image: url(${1}) ${2:0} ${3:0} ${4:0} ${5:0} ${6:stretch} ${7:stretch};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdi": true
        },
        "options": {}
      },
      {
        "content": "border-image: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdi:n": true
        },
        "options": {}
      },
      {
        "content": "border-left: ${1:1px} ${2:solid} #${3:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdl+": true
        },
        "options": {}
      },
      {
        "content": "border-left-color: #${1:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdlc": true
        },
        "options": {}
      },
      {
        "content": "border-left-image: url(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdli": true
        },
        "options": {}
      },
      {
        "content": "border-left-image: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdli:n": true
        },
        "options": {}
      },
      {
        "content": "border-left-style: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdls": true
        },
        "options": {}
      },
      {
        "content": "border-left-style: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdls:n": true
        },
        "options": {}
      },
      {
        "content": "border-left-width: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdlw": true
        },
        "options": {}
      },
      {
        "content": "border-left: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdl": true
        },
        "options": {}
      },
      {
        "content": "border-left: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdl:n": true
        },
        "options": {}
      },
      {
        "content": "border-length: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdlt": true
        },
        "options": {}
      },
      {
        "content": "border-length: auto;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdlt:a": true
        },
        "options": {}
      },
      {
        "content": "border-radius: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdrz": true
        },
        "options": {}
      },
      {
        "content": "border-right: ${1:1px} ${2:solid} #${3:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdr+": true
        },
        "options": {}
      },
      {
        "content": "border-right-color: #${1:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdrc": true
        },
        "options": {}
      },
      {
        "content": "border-right-image: url(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdri": true
        },
        "options": {}
      },
      {
        "content": "border-right-image: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdri:n": true
        },
        "options": {}
      },
      {
        "content": "border-right-style: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdrs": true
        },
        "options": {}
      },
      {
        "content": "border-right-style: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdrs:n": true
        },
        "options": {}
      },
      {
        "content": "border-right-width: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdrw": true
        },
        "options": {}
      },
      {
        "content": "border-right: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdr": true
        },
        "options": {}
      },
      {
        "content": "border-right: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdr:n": true
        },
        "options": {}
      },
      {
        "content": "border-spacing: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdsp": true
        },
        "options": {}
      },
      {
        "content": "border-style: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds": true
        },
        "options": {}
      },
      {
        "content": "border-style: dashed;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:ds": true
        },
        "options": {}
      },
      {
        "content": "border-style: dot-dash;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:dtds": true
        },
        "options": {}
      },
      {
        "content": "border-style: dot-dot-dash;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:dtdtds": true
        },
        "options": {}
      },
      {
        "content": "border-style: dotted;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:dt": true
        },
        "options": {}
      },
      {
        "content": "border-style: double;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:db": true
        },
        "options": {}
      },
      {
        "content": "border-style: groove;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:g": true
        },
        "options": {}
      },
      {
        "content": "border-style: hidden;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:h": true
        },
        "options": {}
      },
      {
        "content": "border-style: inset;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:i": true
        },
        "options": {}
      },
      {
        "content": "border-style: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:n": true
        },
        "options": {}
      },
      {
        "content": "border-style: outset;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:o": true
        },
        "options": {}
      },
      {
        "content": "border-style: ridge;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:r": true
        },
        "options": {}
      },
      {
        "content": "border-style: solid;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:s": true
        },
        "options": {}
      },
      {
        "content": "border-style: wave;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:w": true
        },
        "options": {}
      },
      {
        "content": "border-top: ${1:1px} ${2:solid} #${3:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdt+": true
        },
        "options": {}
      },
      {
        "content": "border-top-color: #${1:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdtc": true
        },
        "options": {}
      },
      {
        "content": "border-top-image: url(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdti": true
        },
        "options": {}
      },
      {
        "content": "border-top-image: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdti:n": true
        },
        "options": {}
      },
      {
        "content": "border-top-left-image: url(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdtli": true
        },
        "options": {}
      },
      {
        "content": "border-corner-image: continue;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdtli:c": true
        },
        "options": {}
      },
      {
        "content": "border-corner-image: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdtli:n": true
        },
        "options": {}
      },
      {
        "content": "border-top-left-radius: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdtlrz": true
        },
        "options": {}
      },
      {
        "content": "border-top-right-image: url(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdtri": true
        },
        "options": {}
      },
      {
        "content": "border-top-right-image: continue;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdtri:c": true
        },
        "options": {}
      },
      {
        "content": "border-top-right-image: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdtri:n": true
        },
        "options": {}
      },
      {
        "content": "border-top-right-radius: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdtrrz": true
        },
        "options": {}
      },
      {
        "content": "border-top-style: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdts": true
        },
        "options": {}
      },
      {
        "content": "border-top-style: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdts:n": true
        },
        "options": {}
      },
      {
        "content": "border-top-width: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdtw": true
        },
        "options": {}
      },
      {
        "content": "border-top: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdt": true
        },
        "options": {}
      },
      {
        "content": "border-top: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdt:n": true
        },
        "options": {}
      },
      {
        "content": "border-width: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdw": true
        },
        "options": {}
      },
      {
        "content": "border: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bd": true
        },
        "options": {}
      },
      {
        "content": "border: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bd:n": true
        },
        "options": {}
      },
      {
        "content": "bottom: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "b": true
        },
        "options": {}
      },
      {
        "content": "bottom: auto;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "b:a": true
        },
        "options": {}
      },
      {
        "content": "box-shadow: ${1:0} ${2:0} ${3:0} #${4:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bxsh+": true
        },
        "options": {}
      },
      {
        "content": "box-shadow: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bxsh": true
        },
        "options": {}
      },
      {
        "content": "box-shadow: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bxsh:n": true
        },
        "options": {}
      },
      {
        "content": "box-sizing: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bxz": true
        },
        "options": {}
      },
      {
        "content": "box-sizing: border-box;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bxz:bb": true
        },
        "options": {}
      },
      {
        "content": "box-sizing: content-box;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bxz:cb": true
        },
        "options": {}
      },
      {
        "content": "caption-side: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cps": true
        },
        "options": {}
      },
      {
        "content": "caption-side: bottom;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cps:b": true
        },
        "options": {}
      },
      {
        "content": "caption-side: top;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cps:t": true
        },
        "options": {}
      },
      {
        "content": "clear: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cl": true
        },
        "options": {}
      },
      {
        "content": "clear: both;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cl:b": true
        },
        "options": {}
      },
      {
        "content": "clear: left;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cl:l": true
        },
        "options": {}
      },
      {
        "content": "clear: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cl:n": true
        },
        "options": {}
      },
      {
        "content": "clear: right;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cl:r": true
        },
        "options": {}
      },
      {
        "content": "clip: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cp": true
        },
        "options": {}
      },
      {
        "content": "clip: auto;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cp:a": true
        },
        "options": {}
      },
      {
        "content": "clip: rect(${1:0} ${2:0} ${3:0} ${4:0});${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cp:r": true
        },
        "options": {}
      },
      {
        "content": "color: #${1:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "c": true
        },
        "options": {}
      },
      {
        "content": "content: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ct": true
        },
        "options": {}
      },
      {
        "content": "content: attr(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ct:a": true
        },
        "options": {}
      },
      {
        "content": "content: close-quote;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ct:cq": true
        },
        "options": {}
      },
      {
        "content": "content: counter(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ct:c": true
        },
        "options": {}
      },
      {
        "content": "content: counters(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ct:cs": true
        },
        "options": {}
      },
      {
        "content": "content: no-close-quote;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ct:ncq": true
        },
        "options": {}
      },
      {
        "content": "content: no-open-quote;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ct:noq": true
        },
        "options": {}
      },
      {
        "content": "content: normal;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ct:n": true
        },
        "options": {}
      },
      {
        "content": "content: open-quote;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ct:oq": true
        },
        "options": {}
      },
      {
        "content": "counter-increment: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "coi": true
        },
        "options": {}
      },
      {
        "content": "counter-reset: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cor": true
        },
        "options": {}
      },
      {
        "content": "cursor: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cur": true
        },
        "options": {}
      },
      {
        "content": "cursor: auto;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cur:a": true
        },
        "options": {}
      },
      {
        "content": "cursor: crosshair;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cur:c": true
        },
        "options": {}
      },
      {
        "content": "cursor: default;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cur:d": true
        },
        "options": {}
      },
      {
        "content": "cursor: hand;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cur:ha": true
        },
        "options": {}
      },
      {
        "content": "cursor: help;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cur:he": true
        },
        "options": {}
      },
      {
        "content": "cursor: move;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cur:m": true
        },
        "options": {}
      },
      {
        "content": "cursor: pointer;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cur:p": true
        },
        "options": {}
      },
      {
        "content": "cursor: text;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cur:t": true
        },
        "options": {}
      },
      {
        "content": "display: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d": true
        },
        "options": {}
      },
      {
        "content": "display: -moz-inline-box;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:mib": true
        },
        "options": {}
      },
      {
        "content": "display: -moz-inline-stack;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:mis": true
        },
        "options": {}
      },
      {
        "content": "display: block;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:b": true
        },
        "options": {}
      },
      {
        "content": "display: compact;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:cp": true
        },
        "options": {}
      },
      {
        "content": "display: grid;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:g": true
        },
        "options": {}
      },
      {
        "content": "display: flex;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:f": true
        },
        "options": {}
      },
      {
        "content": "display: inline-block;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:ib": true
        },
        "options": {}
      },
      {
        "content": "display: inline-table;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:itb": true
        },
        "options": {}
      },
      {
        "content": "display: inline;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:i": true
        },
        "options": {}
      },
      {
        "content": "display: list-item;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:li": true
        },
        "options": {}
      },
      {
        "content": "display: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:n": true
        },
        "options": {}
      },
      {
        "content": "display: run-in;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:ri": true
        },
        "options": {}
      },
      {
        "content": "display: table-caption;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:tbcp": true
        },
        "options": {}
      },
      {
        "content": "display: table-cell;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:tbc": true
        },
        "options": {}
      },
      {
        "content": "display: table-column-group;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:tbclg": true
        },
        "options": {}
      },
      {
        "content": "display: table-column;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:tbcl": true
        },
        "options": {}
      },
      {
        "content": "display: table-footer-group;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:tbfg": true
        },
        "options": {}
      },
      {
        "content": "display: table-header-group;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:tbhg": true
        },
        "options": {}
      },
      {
        "content": "display: table-row-group;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:tbrg": true
        },
        "options": {}
      },
      {
        "content": "display: table-row;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:tbr": true
        },
        "options": {}
      },
      {
        "content": "display: table;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:tb": true
        },
        "options": {}
      },
      {
        "content": "empty-cells: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ec": true
        },
        "options": {}
      },
      {
        "content": "empty-cells: hide;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ec:h": true
        },
        "options": {}
      },
      {
        "content": "empty-cells: show;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ec:s": true
        },
        "options": {}
      },
      {
        "content": "expression()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "exp": true
        },
        "options": {}
      },
      {
        "content": "flex: ${1:0} ${2:1} ${0:auto};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fx": true
        },
        "options": {}
      },
      {
        "content": "flex-basis: ${0:auto};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fxb": true
        },
        "options": {}
      },
      {
        "content": "flex-basis: auto;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fxb:a": true
        },
        "options": {}
      },
      {
        "content": "flex-direction: ${0:row};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fxd": true
        },
        "options": {}
      },
      {
        "content": "flex-direction: column;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fxd:c": true
        },
        "options": {}
      },
      {
        "content": "flex-direction: column-reverse;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fxd:cr": true
        },
        "options": {}
      },
      {
        "content": "flex-direction: row;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fxd:r": true
        },
        "options": {}
      },
      {
        "content": "flex-direction: row-reverse;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fxd:rr": true
        },
        "options": {}
      },
      {
        "content": "flex-flow: ${1:row} ${0:nowrap};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fxf": true
        },
        "options": {}
      },
      {
        "content": "flex-grow: ${0:0};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fxg": true
        },
        "options": {}
      },
      {
        "content": "flex-shrink: ${0:1};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fxs": true
        },
        "options": {}
      },
      {
        "content": "flex-wrap: ${0:nowrap};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fxw": true
        },
        "options": {}
      },
      {
        "content": "flex-wrap: nowrap;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fxw:n": true
        },
        "options": {}
      },
      {
        "content": "flex-wrap: wrap;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fxw:w": true
        },
        "options": {}
      },
      {
        "content": "flex-wrap: wrap-reverse;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fxw:wr": true
        },
        "options": {}
      },
      {
        "content": "float: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fl": true
        },
        "options": {}
      },
      {
        "content": "float: left;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fl:l": true
        },
        "options": {}
      },
      {
        "content": "float: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fl:n": true
        },
        "options": {}
      },
      {
        "content": "float: right;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fl:r": true
        },
        "options": {}
      },
      {
        "content": "font: ${1:1em} ${2:Arial},${3:sans-serif};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "f+": true
        },
        "options": {}
      },
      {
        "content": "font-effect: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fef": true
        },
        "options": {}
      },
      {
        "content": "font-effect: emboss;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fef:eb": true
        },
        "options": {}
      },
      {
        "content": "font-effect: engrave;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fef:eg": true
        },
        "options": {}
      },
      {
        "content": "font-effect: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fef:n": true
        },
        "options": {}
      },
      {
        "content": "font-effect: outline;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fef:o": true
        },
        "options": {}
      },
      {
        "content": "font-emphasize-position: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "femp": true
        },
        "options": {}
      },
      {
        "content": "font-emphasize-position: after;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "femp:a": true
        },
        "options": {}
      },
      {
        "content": "font-emphasize-position: before;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "femp:b": true
        },
        "options": {}
      },
      {
        "content": "font-emphasize-style: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fems": true
        },
        "options": {}
      },
      {
        "content": "font-emphasize-style: accent;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fems:ac": true
        },
        "options": {}
      },
      {
        "content": "font-emphasize-style: circle;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fems:c": true
        },
        "options": {}
      },
      {
        "content": "font-emphasize-style: disc;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fems:ds": true
        },
        "options": {}
      },
      {
        "content": "font-emphasize-style: dot;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fems:dt": true
        },
        "options": {}
      },
      {
        "content": "font-emphasize-style: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fems:n": true
        },
        "options": {}
      },
      {
        "content": "font-emphasize: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fem": true
        },
        "options": {}
      },
      {
        "content": "font-family: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ff": true
        },
        "options": {}
      },
      {
        "content": "font-family: ${0:'Monotype Corsiva','Comic Sans MS'},cursive;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ff:c": true
        },
        "options": {}
      },
      {
        "content": "font-family: ${0:Capitals,Impact},fantasy;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ff:f": true
        },
        "options": {}
      },
      {
        "content": "font-family: ${0:Monaco,'Courier New'},monospace;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ff:m": true
        },
        "options": {}
      },
      {
        "content": "font-family: ${0:Helvetica,Arial},sans-serif;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ff:ss": true
        },
        "options": {}
      },
      {
        "content": "font-family: ${0:Georgia,'Times New Roman'},serif;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ff:s": true
        },
        "options": {}
      },
      {
        "content": "font-size-adjust: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fza": true
        },
        "options": {}
      },
      {
        "content": "font-size-adjust: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fza:n": true
        },
        "options": {}
      },
      {
        "content": "font-size: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fz": true
        },
        "options": {}
      },
      {
        "content": "font-smooth: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fsm": true
        },
        "options": {}
      },
      {
        "content": "font-smooth: always;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fsm:aw": true
        },
        "options": {}
      },
      {
        "content": "font-smooth: auto;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fsm:a": true
        },
        "options": {}
      },
      {
        "content": "font-smooth: never;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fsm:n": true
        },
        "options": {}
      },
      {
        "content": "font-stretch: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fst": true
        },
        "options": {}
      },
      {
        "content": "font-stretch: condensed;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fst:c": true
        },
        "options": {}
      },
      {
        "content": "font-stretch: expanded;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fst:e": true
        },
        "options": {}
      },
      {
        "content": "font-stretch: extra-condensed;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fst:ec": true
        },
        "options": {}
      },
      {
        "content": "font-stretch: extra-expanded;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fst:ee": true
        },
        "options": {}
      },
      {
        "content": "font-stretch: normal;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fst:n": true
        },
        "options": {}
      },
      {
        "content": "font-stretch: semi-condensed;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fst:sc": true
        },
        "options": {}
      },
      {
        "content": "font-stretch: semi-expanded;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fst:se": true
        },
        "options": {}
      },
      {
        "content": "font-stretch: ultra-condensed;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fst:uc": true
        },
        "options": {}
      },
      {
        "content": "font-stretch: ultra-expanded;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fst:ue": true
        },
        "options": {}
      },
      {
        "content": "font-style: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fs": true
        },
        "options": {}
      },
      {
        "content": "font-style: italic;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fs:i": true
        },
        "options": {}
      },
      {
        "content": "font-style: normal;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fs:n": true
        },
        "options": {}
      },
      {
        "content": "font-style: oblique;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fs:o": true
        },
        "options": {}
      },
      {
        "content": "font-variant: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fv": true
        },
        "options": {}
      },
      {
        "content": "font-variant: normal;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fv:n": true
        },
        "options": {}
      },
      {
        "content": "font-variant: small-caps;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fv:sc": true
        },
        "options": {}
      },
      {
        "content": "font-weight: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fw": true
        },
        "options": {}
      },
      {
        "content": "font-weight: bold;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fw:b": true
        },
        "options": {}
      },
      {
        "content": "font-weight: bolder;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fw:br": true
        },
        "options": {}
      },
      {
        "content": "font-weight: lighter;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fw:lr": true
        },
        "options": {}
      },
      {
        "content": "font-weight: normal;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fw:n": true
        },
        "options": {}
      },
      {
        "content": "font: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "f": true
        },
        "options": {}
      },
      {
        "content": "grid: ${1};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "g": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-flow: ${1:row};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gaf": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-flow: ${1:row} ${2:dense};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gaf+": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-flow: row;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gaf:r": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-flow: column;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gaf:c": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-flow: dense;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gaf:d": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-flow: row dense;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gaf:rd": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-flow: column dense;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gaf:cd": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-rows: ${1};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gar": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-rows: auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gar:a": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-rows: max-content;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gar:mac": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-rows: min-content;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gar:mic": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-columns: ${1};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gac": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-columns: auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gac:a": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-columns: max-content;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gac:mac": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-columns: min-content;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gac:mic": true
        },
        "options": {}
      },
      {
        "content": "grid-template: ${1};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gt": true
        },
        "options": {}
      },
      {
        "content": "grid-template: ${1} / ${2};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gt+": true
        },
        "options": {}
      },
      {
        "content": "grid-template-rows: ${1};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gtr": true
        },
        "options": {}
      },
      {
        "content": "grid-template-columns: ${1};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gtc": true
        },
        "options": {}
      },
      {
        "content": "grid-template-areas: ${1};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gta": true
        },
        "options": {}
      },
      {
        "content": "grid-gap: ${1};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gg": true
        },
        "options": {}
      },
      {
        "content": "grid-gap: ${1} ${2};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gg+": true
        },
        "options": {}
      },
      {
        "content": "grid-gap: 0;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gg:0": true
        },
        "options": {}
      },
      {
        "content": "grid-row-gap: ${1};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "grg": true
        },
        "options": {}
      },
      {
        "content": "grid-row-gap: 0;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "grg:0": true
        },
        "options": {}
      },
      {
        "content": "grid-column-gap: ${1};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gcg": true
        },
        "options": {}
      },
      {
        "content": "grid-column-gap: 0;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gcg:0": true
        },
        "options": {}
      },
      {
        "content": "grid-row: ${1} / ${2};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gr": true
        },
        "options": {}
      },
      {
        "content": "grid-row-start: ${1};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "grs": true
        },
        "options": {}
      },
      {
        "content": "grid-row-end: ${1};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gre": true
        },
        "options": {}
      },
      {
        "content": "grid-column: ${1} / ${2};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gc": true
        },
        "options": {}
      },
      {
        "content": "grid-column-start: ${1};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gcs": true
        },
        "options": {}
      },
      {
        "content": "grid-column-end: ${1};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gce": true
        },
        "options": {}
      },
      {
        "content": "height: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "h": true
        },
        "options": {}
      },
      {
        "content": "height: auto;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "h:a": true
        },
        "options": {}
      },
      {
        "content": "justify-content: ${1};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc": true
        },
        "options": {}
      },
      {
        "content": "justify-content: start;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc:s": true
        },
        "options": {}
      },
      {
        "content": "justify-content: end;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc:e": true
        },
        "options": {}
      },
      {
        "content": "justify-content: center;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc:c": true
        },
        "options": {}
      },
      {
        "content": "justify-content: flex-start;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc:fs": true
        },
        "options": {}
      },
      {
        "content": "justify-content: flex-end;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc:fe": true
        },
        "options": {}
      },
      {
        "content": "justify-content: space-between;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc:sb": true
        },
        "options": {}
      },
      {
        "content": "justify-content: space-around;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc:sa": true
        },
        "options": {}
      },
      {
        "content": "justify-content: space-evenly;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc:se": true
        },
        "options": {}
      },
      {
        "content": "justify-content: stretch;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc:st": true
        },
        "options": {}
      },
      {
        "content": "justify-content: left;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc:l": true
        },
        "options": {}
      },
      {
        "content": "justify-content: right;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc:r": true
        },
        "options": {}
      },
      {
        "content": "justify-items: ${1:stretch};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ji": true
        },
        "options": {}
      },
      {
        "content": "justify-items: start;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ji:s": true
        },
        "options": {}
      },
      {
        "content": "justify-items: end;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ji:e": true
        },
        "options": {}
      },
      {
        "content": "justify-items: center;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ji:c": true
        },
        "options": {}
      },
      {
        "content": "justify-items: stretch;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ji:st": true
        },
        "options": {}
      },
      {
        "content": "justify-self: ${1:stretch};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "js": true
        },
        "options": {}
      },
      {
        "content": "justify-self: start;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "js:s": true
        },
        "options": {}
      },
      {
        "content": "justify-self: end;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "js:e": true
        },
        "options": {}
      },
      {
        "content": "justify-self: center;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "js:c": true
        },
        "options": {}
      },
      {
        "content": "justify-self: stretch;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "js:st": true
        },
        "options": {}
      },
      {
        "content": "left: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "l": true
        },
        "options": {}
      },
      {
        "content": "left: auto;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "l:a": true
        },
        "options": {}
      },
      {
        "content": "letter-spacing: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lts": true
        },
        "options": {}
      },
      {
        "content": "line-height: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lh": true
        },
        "options": {}
      },
      {
        "content": "list-style-image: url(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lisi": true
        },
        "options": {}
      },
      {
        "content": "list-style-image: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lisi:n": true
        },
        "options": {}
      },
      {
        "content": "list-style-position: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lisp": true
        },
        "options": {}
      },
      {
        "content": "list-style-position: inside;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lisp:i": true
        },
        "options": {}
      },
      {
        "content": "list-style-position: outside;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lisp:o": true
        },
        "options": {}
      },
      {
        "content": "list-style-type: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list": true
        },
        "options": {}
      },
      {
        "content": "list-style-type: circle;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list:c": true
        },
        "options": {}
      },
      {
        "content": "list-style-type: decimal-leading-zero;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list:dclz": true
        },
        "options": {}
      },
      {
        "content": "list-style-type: decimal;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list:dc": true
        },
        "options": {}
      },
      {
        "content": "list-style-type: disc;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list:d": true
        },
        "options": {}
      },
      {
        "content": "list-style-type: lower-roman;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list:lr": true
        },
        "options": {}
      },
      {
        "content": "list-style-type: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list:n": true
        },
        "options": {}
      },
      {
        "content": "list-style-type: square;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list:s": true
        },
        "options": {}
      },
      {
        "content": "list-style-type: upper-roman;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list:ur": true
        },
        "options": {}
      },
      {
        "content": "list-style: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lis": true
        },
        "options": {}
      },
      {
        "content": "list-style: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lis:n": true
        },
        "options": {}
      },
      {
        "content": "margin-bottom: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mb": true
        },
        "options": {}
      },
      {
        "content": "margin-bottom: auto;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mb:a": true
        },
        "options": {}
      },
      {
        "content": "margin-left: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ml": true
        },
        "options": {}
      },
      {
        "content": "margin-left: auto;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ml:a": true
        },
        "options": {}
      },
      {
        "content": "margin-right: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mr": true
        },
        "options": {}
      },
      {
        "content": "margin-right: auto;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mr:a": true
        },
        "options": {}
      },
      {
        "content": "margin-top: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mt": true
        },
        "options": {}
      },
      {
        "content": "margin-top: auto;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mt:a": true
        },
        "options": {}
      },
      {
        "content": "margin: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "m": true
        },
        "options": {}
      },
      {
        "content": "margin: ${1:0} ${2:0} ${3:0} ${4:0};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "m:4": true
        },
        "options": {}
      },
      {
        "content": "margin: ${1:0} ${2:0} ${3:0};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "m:3": true
        },
        "options": {}
      },
      {
        "content": "margin: ${1:0} ${2:0};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "m:2": true
        },
        "options": {}
      },
      {
        "content": "margin: 0;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "m:0": true
        },
        "options": {}
      },
      {
        "content": "margin: auto;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "m:a": true
        },
        "options": {}
      },
      {
        "content": "max-height: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mah": true
        },
        "options": {}
      },
      {
        "content": "max-height: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mah:n": true
        },
        "options": {}
      },
      {
        "content": "max-width: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "maw": true
        },
        "options": {}
      },
      {
        "content": "max-width: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "maw:n": true
        },
        "options": {}
      },
      {
        "content": "min-height: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mih": true
        },
        "options": {}
      },
      {
        "content": "min-width: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "miw": true
        },
        "options": {}
      },
      {
        "content": "opacity: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "op": true
        },
        "options": {}
      },
      {
        "content": "filter: progid:DXImageTransform.Microsoft.Alpha(Opacity=${1:100});${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "op:ie": true
        },
        "options": {}
      },
      {
        "content": "-ms-filter: 'progid:DXImageTransform.Microsoft.Alpha(Opacity=${0:100})';",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "op:ms": true
        },
        "options": {}
      },
      {
        "content": "orphans: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "orp": true
        },
        "options": {}
      },
      {
        "content": "order: ${0:0};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "or": true
        },
        "options": {}
      },
      {
        "content": "outline: ${1:1px} ${2:solid} #${3:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "o+": true
        },
        "options": {}
      },
      {
        "content": "outline-color: ${1:#000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "oc": true
        },
        "options": {}
      },
      {
        "content": "outline-color: invert;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "oc:i": true
        },
        "options": {}
      },
      {
        "content": "outline-offset: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "oo": true
        },
        "options": {}
      },
      {
        "content": "outline-style: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "os": true
        },
        "options": {}
      },
      {
        "content": "outline-width: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ow": true
        },
        "options": {}
      },
      {
        "content": "outline: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "o": true
        },
        "options": {}
      },
      {
        "content": "outline: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "o:n": true
        },
        "options": {}
      },
      {
        "content": "overflow-style: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovs": true
        },
        "options": {}
      },
      {
        "content": "overflow-style: auto;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovs:a": true
        },
        "options": {}
      },
      {
        "content": "overflow-style: marquee;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovs:mq": true
        },
        "options": {}
      },
      {
        "content": "overflow-style: move;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovs:mv": true
        },
        "options": {}
      },
      {
        "content": "overflow-style: panner;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovs:p": true
        },
        "options": {}
      },
      {
        "content": "overflow-style: scrollbar;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovs:s": true
        },
        "options": {}
      },
      {
        "content": "overflow-x: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovx": true
        },
        "options": {}
      },
      {
        "content": "overflow-x: auto;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovx:a": true
        },
        "options": {}
      },
      {
        "content": "overflow-x: hidden;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovx:h": true
        },
        "options": {}
      },
      {
        "content": "overflow-x: scroll;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovx:s": true
        },
        "options": {}
      },
      {
        "content": "overflow-x: visible;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovx:v": true
        },
        "options": {}
      },
      {
        "content": "overflow-y: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovy": true
        },
        "options": {}
      },
      {
        "content": "overflow-y: auto;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovy:a": true
        },
        "options": {}
      },
      {
        "content": "overflow-y: hidden;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovy:h": true
        },
        "options": {}
      },
      {
        "content": "overflow-y: scroll;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovy:s": true
        },
        "options": {}
      },
      {
        "content": "overflow-y: visible;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovy:v": true
        },
        "options": {}
      },
      {
        "content": "overflow: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ov": true
        },
        "options": {}
      },
      {
        "content": "overflow: auto;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ov:a": true
        },
        "options": {}
      },
      {
        "content": "overflow: hidden;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ov:h": true
        },
        "options": {}
      },
      {
        "content": "overflow: scroll;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ov:s": true
        },
        "options": {}
      },
      {
        "content": "overflow: visible;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ov:v": true
        },
        "options": {}
      },
      {
        "content": "padding-bottom: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pb": true
        },
        "options": {}
      },
      {
        "content": "padding-left: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pl": true
        },
        "options": {}
      },
      {
        "content": "padding-right: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pr": true
        },
        "options": {}
      },
      {
        "content": "padding-top: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pt": true
        },
        "options": {}
      },
      {
        "content": "padding: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p": true
        },
        "options": {}
      },
      {
        "content": "padding: ${1:0} ${2:0} ${3:0} ${4:0};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p:4": true
        },
        "options": {}
      },
      {
        "content": "padding: ${1:0} ${2:0} ${3:0};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p:3": true
        },
        "options": {}
      },
      {
        "content": "padding: ${1:0} ${2:0};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p:2": true
        },
        "options": {}
      },
      {
        "content": "padding: 0;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p:0": true
        },
        "options": {}
      },
      {
        "content": "place-content: ${1};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc": true
        },
        "options": {}
      },
      {
        "content": "place-content: ${1} ${2};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc+": true
        },
        "options": {}
      },
      {
        "content": "place-content: start;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc:s": true
        },
        "options": {}
      },
      {
        "content": "place-content: end;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc:e": true
        },
        "options": {}
      },
      {
        "content": "place-content: center;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc:c": true
        },
        "options": {}
      },
      {
        "content": "place-content: flex-start;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc:fs": true
        },
        "options": {}
      },
      {
        "content": "place-content: flex-end;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc:fe": true
        },
        "options": {}
      },
      {
        "content": "place-content: space-between;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc:sb": true
        },
        "options": {}
      },
      {
        "content": "place-content: space-around;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc:sa": true
        },
        "options": {}
      },
      {
        "content": "place-content: space-evenly;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc:se": true
        },
        "options": {}
      },
      {
        "content": "place-content: stretch;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc:st": true
        },
        "options": {}
      },
      {
        "content": "page-break-after: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgba": true
        },
        "options": {}
      },
      {
        "content": "page-break-after: always;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgba:aw": true
        },
        "options": {}
      },
      {
        "content": "page-break-after: auto;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgba:a": true
        },
        "options": {}
      },
      {
        "content": "page-break-after: left;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgba:l": true
        },
        "options": {}
      },
      {
        "content": "page-break-after: right;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgba:r": true
        },
        "options": {}
      },
      {
        "content": "page-break-before: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgbb": true
        },
        "options": {}
      },
      {
        "content": "page-break-before: always;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgbb:aw": true
        },
        "options": {}
      },
      {
        "content": "page-break-before: auto;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgbb:a": true
        },
        "options": {}
      },
      {
        "content": "page-break-before: left;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgbb:l": true
        },
        "options": {}
      },
      {
        "content": "page-break-before: right;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgbb:r": true
        },
        "options": {}
      },
      {
        "content": "page-break-inside: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgbi": true
        },
        "options": {}
      },
      {
        "content": "page-break-inside: auto;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgbi:a": true
        },
        "options": {}
      },
      {
        "content": "page-break-inside: avoid;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgbi:av": true
        },
        "options": {}
      },
      {
        "content": "place-items: ${1:stretch};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pi": true
        },
        "options": {}
      },
      {
        "content": "place-items: ${1:stretch} ${2:stretch};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pi+": true
        },
        "options": {}
      },
      {
        "content": "place-items: start;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pi:s": true
        },
        "options": {}
      },
      {
        "content": "place-items: end;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pi:e": true
        },
        "options": {}
      },
      {
        "content": "place-items: center;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pi:c": true
        },
        "options": {}
      },
      {
        "content": "",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pi:st": true
        },
        "options": {}
      },
      {
        "content": "position: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pos": true
        },
        "options": {}
      },
      {
        "content": "position: absolute;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pos:a": true
        },
        "options": {}
      },
      {
        "content": "position: fixed;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pos:f": true
        },
        "options": {}
      },
      {
        "content": "position: relative;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pos:r": true
        },
        "options": {}
      },
      {
        "content": "position: static;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pos:s": true
        },
        "options": {}
      },
      {
        "content": "place-self: ${1:stretch};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ps": true
        },
        "options": {}
      },
      {
        "content": "place-self: ${1:stretch} ${2:stretch};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ps+": true
        },
        "options": {}
      },
      {
        "content": "place-self: start;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ps:s": true
        },
        "options": {}
      },
      {
        "content": "place-self: end;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ps:e": true
        },
        "options": {}
      },
      {
        "content": "place-self: center;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ps:c": true
        },
        "options": {}
      },
      {
        "content": "place-self: stretch;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ps:st": true
        },
        "options": {}
      },
      {
        "content": "quotes: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "q": true
        },
        "options": {}
      },
      {
        "content": "quotes: '\\201C' '\\201D' '\\2018' '\\2019';",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "q:en": true
        },
        "options": {}
      },
      {
        "content": "quotes: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "q:n": true
        },
        "options": {}
      },
      {
        "content": "quotes: '\\00AB' '\\00BB' '\\201E' '\\201C';",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "q:ru": true
        },
        "options": {}
      },
      {
        "content": "resize: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rz": true
        },
        "options": {}
      },
      {
        "content": "resize: both;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rz:b": true
        },
        "options": {}
      },
      {
        "content": "resize: horizontal;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rz:h": true
        },
        "options": {}
      },
      {
        "content": "resize: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rz:n": true
        },
        "options": {}
      },
      {
        "content": "resize: vertical;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rz:v": true
        },
        "options": {}
      },
      {
        "content": "right: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "r": true
        },
        "options": {}
      },
      {
        "content": "right: auto;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "r:a": true
        },
        "options": {}
      },
      {
        "content": "table-layout: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tbl": true
        },
        "options": {}
      },
      {
        "content": "table-layout: auto;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tbl:a": true
        },
        "options": {}
      },
      {
        "content": "table-layout: fixed;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tbl:f": true
        },
        "options": {}
      },
      {
        "content": "text-align-last: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tal": true
        },
        "options": {}
      },
      {
        "content": "text-align-last: auto;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tal:a": true
        },
        "options": {}
      },
      {
        "content": "text-align-last: center;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tal:c": true
        },
        "options": {}
      },
      {
        "content": "text-align-last: left;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tal:l": true
        },
        "options": {}
      },
      {
        "content": "text-align-last: right;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tal:r": true
        },
        "options": {}
      },
      {
        "content": "text-align: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ta": true
        },
        "options": {}
      },
      {
        "content": "text-align: center;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ta:c": true
        },
        "options": {}
      },
      {
        "content": "text-align: left;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ta:l": true
        },
        "options": {}
      },
      {
        "content": "text-align: right;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ta:r": true
        },
        "options": {}
      },
      {
        "content": "text-decoration: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "td": true
        },
        "options": {}
      },
      {
        "content": "text-decoration: line-through;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "td:l": true
        },
        "options": {}
      },
      {
        "content": "text-decoration: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "td:n": true
        },
        "options": {}
      },
      {
        "content": "text-decoration: overline;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "td:o": true
        },
        "options": {}
      },
      {
        "content": "text-decoration: underline;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "td:u": true
        },
        "options": {}
      },
      {
        "content": "text-emphasis: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "te": true
        },
        "options": {}
      },
      {
        "content": "text-emphasis: accent;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "te:ac": true
        },
        "options": {}
      },
      {
        "content": "text-emphasis: after;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "te:a": true
        },
        "options": {}
      },
      {
        "content": "text-emphasis: before;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "te:b": true
        },
        "options": {}
      },
      {
        "content": "text-emphasis: circle;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "te:c": true
        },
        "options": {}
      },
      {
        "content": "text-emphasis: disc;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "te:ds": true
        },
        "options": {}
      },
      {
        "content": "text-emphasis: dot;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "te:dt": true
        },
        "options": {}
      },
      {
        "content": "text-emphasis: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "te:n": true
        },
        "options": {}
      },
      {
        "content": "text-height: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "th": true
        },
        "options": {}
      },
      {
        "content": "text-height: auto;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "th:a": true
        },
        "options": {}
      },
      {
        "content": "text-height: font-size;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "th:f": true
        },
        "options": {}
      },
      {
        "content": "text-height: max-size;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "th:m": true
        },
        "options": {}
      },
      {
        "content": "text-height: text-size;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "th:t": true
        },
        "options": {}
      },
      {
        "content": "text-indent: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ti": true
        },
        "options": {}
      },
      {
        "content": "text-indent: -9999px;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ti:-": true
        },
        "options": {}
      },
      {
        "content": "text-justify: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tj": true
        },
        "options": {}
      },
      {
        "content": "text-justify: auto;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tj:a": true
        },
        "options": {}
      },
      {
        "content": "text-justify: distribute;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tj:d": true
        },
        "options": {}
      },
      {
        "content": "text-justify: inter-cluster;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tj:ic": true
        },
        "options": {}
      },
      {
        "content": "text-justify: inter-ideograph;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tj:ii": true
        },
        "options": {}
      },
      {
        "content": "text-justify: inter-word;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tj:iw": true
        },
        "options": {}
      },
      {
        "content": "text-justify: kashida;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tj:k": true
        },
        "options": {}
      },
      {
        "content": "text-justify: tibetan;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tj:t": true
        },
        "options": {}
      },
      {
        "content": "text-outline: ${1:0} ${2:0} #${3:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "to+": true
        },
        "options": {}
      },
      {
        "content": "text-outline: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "to": true
        },
        "options": {}
      },
      {
        "content": "text-outline: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "to:n": true
        },
        "options": {}
      },
      {
        "content": "text-replace: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tr": true
        },
        "options": {}
      },
      {
        "content": "text-replace: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tr:n": true
        },
        "options": {}
      },
      {
        "content": "text-shadow: ${1:0} ${2:0} ${3:0} #${4:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tsh+": true
        },
        "options": {}
      },
      {
        "content": "text-shadow: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tsh": true
        },
        "options": {}
      },
      {
        "content": "text-shadow: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tsh:n": true
        },
        "options": {}
      },
      {
        "content": "text-transform: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tt": true
        },
        "options": {}
      },
      {
        "content": "text-transform: capitalize;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tt:c": true
        },
        "options": {}
      },
      {
        "content": "text-transform: lowercase;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tt:l": true
        },
        "options": {}
      },
      {
        "content": "text-transform: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tt:n": true
        },
        "options": {}
      },
      {
        "content": "text-transform: uppercase;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tt:u": true
        },
        "options": {}
      },
      {
        "content": "text-wrap: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tw": true
        },
        "options": {}
      },
      {
        "content": "text-wrap: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tw:no": true
        },
        "options": {}
      },
      {
        "content": "text-wrap: normal;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tw:n": true
        },
        "options": {}
      },
      {
        "content": "text-wrap: suppress;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tw:s": true
        },
        "options": {}
      },
      {
        "content": "text-wrap: unrestricted;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tw:u": true
        },
        "options": {}
      },
      {
        "content": "top: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "t": true
        },
        "options": {}
      },
      {
        "content": "top: auto;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "t:a": true
        },
        "options": {}
      },
      {
        "content": "vertical-align: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "va": true
        },
        "options": {}
      },
      {
        "content": "vertical-align: baseline;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "va:bl": true
        },
        "options": {}
      },
      {
        "content": "vertical-align: bottom;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "va:b": true
        },
        "options": {}
      },
      {
        "content": "vertical-align: middle;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "va:m": true
        },
        "options": {}
      },
      {
        "content": "vertical-align: sub;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "va:sub": true
        },
        "options": {}
      },
      {
        "content": "vertical-align: super;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "va:sup": true
        },
        "options": {}
      },
      {
        "content": "vertical-align: text-bottom;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "va:tb": true
        },
        "options": {}
      },
      {
        "content": "vertical-align: text-top;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "va:tt": true
        },
        "options": {}
      },
      {
        "content": "vertical-align: top;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "va:t": true
        },
        "options": {}
      },
      {
        "content": "visibility: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "v": true
        },
        "options": {}
      },
      {
        "content": "visibility: collapse;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "v:c": true
        },
        "options": {}
      },
      {
        "content": "visibility: hidden;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "v:h": true
        },
        "options": {}
      },
      {
        "content": "visibility: visible;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "v:v": true
        },
        "options": {}
      },
      {
        "content": "white-space-collapse: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whsc": true
        },
        "options": {}
      },
      {
        "content": "white-space-collapse: break-all;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whsc:ba": true
        },
        "options": {}
      },
      {
        "content": "white-space-collapse: break-strict;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whsc:bs": true
        },
        "options": {}
      },
      {
        "content": "white-space-collapse: keep-all;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whsc:k": true
        },
        "options": {}
      },
      {
        "content": "white-space-collapse: loose;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whsc:l": true
        },
        "options": {}
      },
      {
        "content": "white-space-collapse: normal;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whsc:n": true
        },
        "options": {}
      },
      {
        "content": "white-space: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whs": true
        },
        "options": {}
      },
      {
        "content": "white-space: normal;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whs:n": true
        },
        "options": {}
      },
      {
        "content": "white-space: nowrap;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whs:nw": true
        },
        "options": {}
      },
      {
        "content": "white-space: pre-line;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whs:pl": true
        },
        "options": {}
      },
      {
        "content": "white-space: pre-wrap;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whs:pw": true
        },
        "options": {}
      },
      {
        "content": "white-space: pre;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whs:p": true
        },
        "options": {}
      },
      {
        "content": "widows: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wid": true
        },
        "options": {}
      },
      {
        "content": "width: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "w": true
        },
        "options": {}
      },
      {
        "content": "width: auto;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "w:a": true
        },
        "options": {}
      },
      {
        "content": "word-break: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wob": true
        },
        "options": {}
      },
      {
        "content": "word-break: break-all;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wob:ba": true
        },
        "options": {}
      },
      {
        "content": "word-break: break-strict;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wob:bs": true
        },
        "options": {}
      },
      {
        "content": "word-break: keep-all;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wob:k": true
        },
        "options": {}
      },
      {
        "content": "word-break: loose;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wob:l": true
        },
        "options": {}
      },
      {
        "content": "word-break: normal;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wob:n": true
        },
        "options": {}
      },
      {
        "content": "word-spacing: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wos": true
        },
        "options": {}
      },
      {
        "content": "word-wrap: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wow": true
        },
        "options": {}
      },
      {
        "content": "word-wrap: none;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wow:no": true
        },
        "options": {}
      },
      {
        "content": "word-wrap: normal;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wow:n": true
        },
        "options": {}
      },
      {
        "content": "word-wrap: suppress;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wow:s": true
        },
        "options": {}
      },
      {
        "content": "word-wrap: unrestricted;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wow:u": true
        },
        "options": {}
      },
      {
        "content": "z-index: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "z": true
        },
        "options": {}
      },
      {
        "content": "z-index: auto;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "z:a": true
        },
        "options": {}
      },
      {
        "content": "zoom: 1;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "zoo": true
        },
        "options": {}
      },
      {
        "content": ":hover",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":h": true
        },
        "options": {}
      },
      {
        "content": ":first-child",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":fc": true
        },
        "options": {}
      },
      {
        "content": ":last-child",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":lc": true
        },
        "options": {}
      },
      {
        "content": ":nth-child(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":nc": true
        },
        "options": {}
      },
      {
        "content": ":nth-last-child(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":nlc": true
        },
        "options": {}
      },
      {
        "content": ":only-child",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":oc": true
        },
        "options": {}
      },
      {
        "content": ":after",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":a": true
        },
        "options": {}
      },
      {
        "content": ":before",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":b": true
        },
        "options": {}
      },
      {
        "content": "::after",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "::a": true
        },
        "options": {}
      },
      {
        "content": "::before",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "::b": true
        },
        "options": {}
      },
      {
        "content": "padding: ${1:0};$0",
        "doc": "",
        "grammar": "snu",
        "label": "padding",
        "matches": {
          "p": true
        },
        "options": {}
      },
      {
        "content": "margin: ${1:0};$0",
        "doc": "",
        "grammar": "snu",
        "label": "margin",
        "matches": {
          "m": true
        },
        "options": {}
      },
      {
        "content": "border: ${1:0};$0",
        "doc": "",
        "grammar": "snu",
        "label": "border",
        "matches": {
          "bd": true
        },
        "options": {}
      },
      {
        "content": "display: ${1:none};$0",
        "doc": "",
        "grammar": "snu",
        "label": "display",
        "matches": {
          "d": true
        },
        "options": {}
      },
      {
        "content": "background: ${1:none};$0",
        "doc": "",
        "grammar": "snu",
        "label": "background",
        "matches": {
          "bg": true
        },
        "options": {}
      },
      {
        "content": "font-family: ${1:\"Helvetica Neue\", Helvetica, Arial, sans-serif};$0",
        "doc": "",
        "grammar": "snu",
        "label": "font-family",
        "matches": {
          "ff": true
        },
        "options": {}
      },
      {
        "content": "height: ${1:auto};$0",
        "doc": "",
        "grammar": "snu",
        "label": "height",
        "matches": {
          "h": true
        },
        "options": {}
      },
      {
        "content": "width: ${1:auto};$0",
        "doc": "",
        "grammar": "snu",
        "label": "width",
        "matches": {
          "w": true
        },
        "options": {}
      },
      {
        "content": "position: ${1:relative};$0",
        "doc": "",
        "grammar": "snu",
        "label": "position",
        "matches": {
          "pos": true
        },
        "options": {}
      },
      {
        "content": "text-transform: ${1:none};$0",
        "doc": "",
        "grammar": "snu",
        "label": "text-transform",
        "matches": {
          "tt": true
        },
        "options": {}
      },
      {
        "content": "!important",
        "doc": "",
        "grammar": "snu",
        "label": "!important CSS (!)",
        "matches": {
          "!": true
        },
        "options": {}
      },
      {
        "content": "text-shadow: ${1:${2:color} ${3:offset-x} ${4:offset-y} ${5:blur}};$0",
        "doc": "",
        "grammar": "snu",
        "label": "text-shadow: color-hex x y blur (text)",
        "matches": {
          "tsh": true
        },
        "options": {}
      },
      {
        "content": "box-shadow: ${1:${2:offset-x} ${3:offset-y} ${4:blur} ${5:spread} ${6:color}};$0",
        "doc": "",
        "grammar": "snu",
        "label": "box-shadow: color-hex x y blur (text)",
        "matches": {
          "bxsh": true
        },
        "options": {}
      },
      {
        "content": "rgb(${1:255}, ${2:255}, ${3:255})$0",
        "doc": "",
        "grammar": "snu",
        "label": "color rgb",
        "matches": {
          "rgb": true
        },
        "options": {}
      },
      {
        "content": "rgba(${1:255}, ${2:255}, ${3:255}, ${4:0.5})$0",
        "doc": "",
        "grammar": "snu",
        "label": "color rgba",
        "matches": {
          "rgba": true
        },
        "options": {}
      },
      {
        "content": "hsl(${1:360}, ${2:100}%, ${3:100}%)$0",
        "doc": "",
        "grammar": "snu",
        "label": "color hsl",
        "matches": {
          "hsl": true
        },
        "options": {}
      },
      {
        "content": "hsla(${1:360}, ${2:100}%, ${3:100}%, ${4:0.5})$0",
        "doc": "",
        "grammar": "snu",
        "label": "color hsla",
        "matches": {
          "hsla": true
        },
        "options": {}
      },
      {
        "content": ":first-child",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":fc": true
        },
        "options": {}
      },
      {
        "content": ":last-child",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":lc": true
        },
        "options": {}
      },
      {
        "content": ":nth-child($0)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":nc": true
        },
        "options": {}
      },
      {
        "content": ":nth-last-child($0)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":nlc": true
        },
        "options": {}
      },
      {
        "content": ":only-child",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":oc": true
        },
        "options": {}
      },
      {
        "content": ":after",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":a": true
        },
        "options": {}
      },
      {
        "content": ":before",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":b": true
        },
        "options": {}
      },
      {
        "content": "::after",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "::a": true
        },
        "options": {}
      },
      {
        "content": "::before",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "::b": true
        },
        "options": {}
      },
      {
        "content": "background-attachment: ${1:scroll/fixed};$0",
        "doc": "",
        "grammar": "snu",
        "label": "background-attachment: scroll:fixed (background)",
        "matches": {
          "background": true
        },
        "options": {}
      },
      {
        "content": "background-color: #${1:DDD};$0",
        "doc": "",
        "grammar": "snu",
        "label": "background-color:  color-hex (background)",
        "matches": {
          "background": true
        },
        "options": {}
      },
      {
        "content": "background-color: ${1:red};$0",
        "doc": "",
        "grammar": "snu",
        "label": "background-color:  color-name (background)",
        "matches": {
          "background": true
        },
        "options": {}
      },
      {
        "content": "background-color: rgb(${1:255},${2:255},${3:255});$0",
        "doc": "",
        "grammar": "snu",
        "label": "background-color:  color-rgb (background)",
        "matches": {
          "background": true
        },
        "options": {}
      },
      {
        "content": "background-color: transparent;$0",
        "doc": "",
        "grammar": "snu",
        "label": "background-color:  transparent (background)",
        "matches": {
          "background": true
        },
        "options": {}
      },
      {
        "content": "background-image: none;$0",
        "doc": "",
        "grammar": "snu",
        "label": "background-image:  none (background)",
        "matches": {
          "background": true
        },
        "options": {}
      },
      {
        "content": "background-image: url($1);$0",
        "doc": "",
        "grammar": "snu",
        "label": "background-image:  url (background)",
        "matches": {
          "background": true
        },
        "options": {}
      },
      {
        "content": "background-position: ${1:top left/top center/top right/center left/center center/center right/bottom left/bottom center/bottom right/x-% y-%/x-pos y-pos};$0",
        "doc": "",
        "grammar": "snu",
        "label": "background-position:  position (background)",
        "matches": {
          "background": true
        },
        "options": {}
      },
      {
        "content": "background-repeat: ${1:repeat/repeat-x/repeat-y/no-repeat};$0",
        "doc": "",
        "grammar": "snu",
        "label": "background-repeat:  r:r-x:r-y:n-r (background)",
        "matches": {
          "background": true
        },
        "options": {}
      },
      {
        "content": "background:${6: #${1:DDD}} url($2) ${3:repeat/repeat-x/repeat-y/no-repeat} ${4:scroll/fixed} ${5:top left/top center/top right/center left/center center/center right/bottom left/bottom center/bottom right/x-% y-%/x-pos y-pos};$0",
        "doc": "",
        "grammar": "snu",
        "label": "background:  color image repeat attachment position (background)",
        "matches": {
          "background": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-color: #${1:999};$0",
        "doc": "",
        "grammar": "snu",
        "label": "border-bottom-color: size style color (border)",
        "matches": {
          "border": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-style: ${1:none/hidden/dotted/dashed/solid/double/groove/ridge/inset/outset};$0",
        "doc": "",
        "grammar": "snu",
        "label": "border-bottom-style: size style color (border)",
        "matches": {
          "border": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-width: ${1:1}px ${2:solid} #${3:999};$0",
        "doc": "",
        "grammar": "snu",
        "label": "border-bottom-width: size style color (border)",
        "matches": {
          "border": true
        },
        "options": {}
      },
      {
        "content": "border-bottom: ${1:1}px ${2:solid} #${3:999};$0",
        "doc": "",
        "grammar": "snu",
        "label": "border-bottom: size style color (border)",
        "matches": {
          "border": true
        },
        "options": {}
      },
      {
        "content": "border-color: ${1:999};$0",
        "doc": "",
        "grammar": "snu",
        "label": "border-color: color (border)",
        "matches": {
          "border": true
        },
        "options": {}
      },
      {
        "content": "border-right-color: #${1:999};$0",
        "doc": "",
        "grammar": "snu",
        "label": "border-left-color: color (border)",
        "matches": {
          "border": true
        },
        "options": {}
      },
      {
        "content": "border-left-style: ${1:none/hidden/dotted/dashed/solid/double/groove/ridge/inset/outset};$0",
        "doc": "",
        "grammar": "snu",
        "label": "border-left-style: style (border)",
        "matches": {
          "border": true
        },
        "options": {}
      },
      {
        "content": "border-left-width: ${1:1}px",
        "doc": "",
        "grammar": "snu",
        "label": "border-left-width: size (border)",
        "matches": {
          "border": true
        },
        "options": {}
      },
      {
        "content": "border-left: ${1:1}px ${2:solid} #${3:999};$0",
        "doc": "",
        "grammar": "snu",
        "label": "border-left: size style color (border)",
        "matches": {
          "border": true
        },
        "options": {}
      },
      {
        "content": "border-right-color: #${1:999};$0",
        "doc": "",
        "grammar": "snu",
        "label": "border-right-color: color (border)",
        "matches": {
          "border": true
        },
        "options": {}
      },
      {
        "content": "border-right-style: ${1:none/hidden/dotted/dashed/solid/double/groove/ridge/inset/outset};$0",
        "doc": "",
        "grammar": "snu",
        "label": "border-right-style: style (border)",
        "matches": {
          "border": true
        },
        "options": {}
      },
      {
        "content": "border-right-width: ${1:1}px",
        "doc": "",
        "grammar": "snu",
        "label": "border-right-width: size (border)",
        "matches": {
          "border": true
        },
        "options": {}
      },
      {
        "content": "border-right: ${1:1}px ${2:solid} #${3:999};$0",
        "doc": "",
        "grammar": "snu",
        "label": "border-right: size style color (border)",
        "matches": {
          "border": true
        },
        "options": {}
      },
      {
        "content": "border-style: ${1:none/hidden/dotted/dashed/solid/double/groove/ridge/inset/outset};$0",
        "doc": "",
        "grammar": "snu",
        "label": "border-style: style (border)",
        "matches": {
          "border": true
        },
        "options": {}
      },
      {
        "content": "border-top-color: #${1:999};$0",
        "doc": "",
        "grammar": "snu",
        "label": "border-top-color: color (border)",
        "matches": {
          "border": true
        },
        "options": {}
      },
      {
        "content": "border-top-style: ${1:none/hidden/dotted/dashed/solid/double/groove/ridge/inset/outset};$0",
        "doc": "",
        "grammar": "snu",
        "label": "border-top-style: style (border)",
        "matches": {
          "border": true
        },
        "options": {}
      },
      {
        "content": "border-top-width: ${1:1}px",
        "doc": "",
        "grammar": "snu",
        "label": "border-top-width: size (border)",
        "matches": {
          "border": true
        },
        "options": {}
      },
      {
        "content": "border-top: ${1:1}px ${2:solid} #${3:999};$0",
        "doc": "",
        "grammar": "snu",
        "label": "border-top: size style color (border)",
        "matches": {
          "border": true
        },
        "options": {}
      },
      {
        "content": "border-width: ${1:1px};$0",
        "doc": "",
        "grammar": "snu",
        "label": "border-width: width (border)",
        "matches": {
          "border": true
        },
        "options": {}
      },
      {
        "content": "border: ${1:1px} ${2:solid} #${3:999};$0",
        "doc": "",
        "grammar": "snu",
        "label": "border:   size style color (border)",
        "matches": {
          "border": true
        },
        "options": {}
      },
      {
        "content": "clear: ${1:left/right/both/none};$0",
        "doc": "",
        "grammar": "snu",
        "label": "clear: value (clear)",
        "matches": {
          "clear": true
        },
        "options": {}
      },
      {
        "content": "color: #${1:DDD};$0",
        "doc": "",
        "grammar": "snu",
        "label": "color:  color-hex (color)",
        "matches": {
          "color": true
        },
        "options": {}
      },
      {
        "content": "color: ${1:red};$0",
        "doc": "",
        "grammar": "snu",
        "label": "color:  color-name (color)",
        "matches": {
          "color": true
        },
        "options": {}
      },
      {
        "content": "color: rgb(${1:255},${2:255},${3:255});$0",
        "doc": "",
        "grammar": "snu",
        "label": "color:  color-rgb (color)",
        "matches": {
          "color": true
        },
        "options": {}
      },
      {
        "content": "cursor: ${1:default/auto/crosshair/pointer/move/*-resize/text/wait/help};$0",
        "doc": "",
        "grammar": "snu",
        "label": "cursor: type (cursor)",
        "matches": {
          "cursor": true
        },
        "options": {}
      },
      {
        "content": "cursor: url($1);$0",
        "doc": "",
        "grammar": "snu",
        "label": "cursor: url (cursor)",
        "matches": {
          "cursor": true
        },
        "options": {}
      },
      {
        "content": "direction: ${1:ltr|rtl};$0",
        "doc": "",
        "grammar": "snu",
        "label": "direction: ltr|rtl (direction)",
        "matches": {
          "direction": true
        },
        "options": {}
      },
      {
        "content": "display: block;$0",
        "doc": "",
        "grammar": "snu",
        "label": "display: block (display)",
        "matches": {
          "display": true
        },
        "options": {}
      },
      {
        "content": "display: ${1:none/inline/block/list-item/run-in/compact/marker};$0",
        "doc": "",
        "grammar": "snu",
        "label": "display: common-types (display)",
        "matches": {
          "display": true
        },
        "options": {}
      },
      {
        "content": "display: inline;$0",
        "doc": "",
        "grammar": "snu",
        "label": "display: inline (display)",
        "matches": {
          "display": true
        },
        "options": {}
      },
      {
        "content": "display: ${1:table/inline-table/table-row-group/table-header-group/table-footer-group/table-row/table-column-group/table-column/table-cell/table-caption};$0",
        "doc": "",
        "grammar": "snu",
        "label": "display: table-types (display)",
        "matches": {
          "display": true
        },
        "options": {}
      },
      {
        "content": "float: ${1:left/right/none};$0",
        "doc": "",
        "grammar": "snu",
        "label": "float: left:right:none (float)",
        "matches": {
          "float": true
        },
        "options": {}
      },
      {
        "content": "font-family: ${1:Arial, \"MS Trebuchet\"}, ${2:sans-}serif;$0",
        "doc": "",
        "grammar": "snu",
        "label": "font-family:   family (font)",
        "matches": {
          "font": true
        },
        "options": {}
      },
      {
        "content": "font-size: ${1:100%};$0",
        "doc": "",
        "grammar": "snu",
        "label": "font-size: size (font)",
        "matches": {
          "font": true
        },
        "options": {}
      },
      {
        "content": "font-style: ${1:normal/italic/oblique};$0",
        "doc": "",
        "grammar": "snu",
        "label": "font-style:   normal:italic:oblique (font)",
        "matches": {
          "font": true
        },
        "options": {}
      },
      {
        "content": "font-variant: ${1:normal/small-caps};$0",
        "doc": "",
        "grammar": "snu",
        "label": "font-variant:   normal:small-caps (font)",
        "matches": {
          "font": true
        },
        "options": {}
      },
      {
        "content": "font-weight: ${1:normal/bold};$0",
        "doc": "",
        "grammar": "snu",
        "label": "font-weight: weight (font)",
        "matches": {
          "font": true
        },
        "options": {}
      },
      {
        "content": "font: ${1:normal/italic/oblique} ${2:normal/small-caps} ${3:normal/bold} ${4:1em/1.5em} ${5:Arial}, ${6:sans-}serif;$0",
        "doc": "",
        "grammar": "snu",
        "label": "font:   style variant weight size:line-height font -family (font)",
        "matches": {
          "font": true
        },
        "options": {}
      },
      {
        "content": "font: ${1:75%} ${2:\"Lucida Grande\", \"Trebuchet MS\", Verdana,} ${3:sans-}serif;$0",
        "doc": "",
        "grammar": "snu",
        "label": "font: size font (font)",
        "matches": {
          "font": true
        },
        "options": {}
      },
      {
        "content": "letter-spacing: $1em;$0",
        "doc": "",
        "grammar": "snu",
        "label": "letter-spacing:   length-em (letter)",
        "matches": {
          "letter": true
        },
        "options": {}
      },
      {
        "content": "letter-spacing: $1px;$0",
        "doc": "",
        "grammar": "snu",
        "label": "letter-spacing:   length-px (letter)",
        "matches": {
          "letter": true
        },
        "options": {}
      },
      {
        "content": "list-style-image: url($1);$0",
        "doc": "",
        "grammar": "snu",
        "label": "list-style-image: url (list)",
        "matches": {
          "list": true
        },
        "options": {}
      },
      {
        "content": "list-style-position: ${1:inside/outside};$0",
        "doc": "",
        "grammar": "snu",
        "label": "list-style-position: pos (list)",
        "matches": {
          "list": true
        },
        "options": {}
      },
      {
        "content": "list-style-type: ${1:cjk-ideographic/hiragana/katakana/hiragana-iroha/katakana-iroha};$0",
        "doc": "",
        "grammar": "snu",
        "label": "list-style-type: asian (list)",
        "matches": {
          "list": true
        },
        "options": {}
      },
      {
        "content": "list-style-type: ${1:none/disc/circle/square};$0",
        "doc": "",
        "grammar": "snu",
        "label": "list-style-type: marker(list)",
        "matches": {
          "list": true
        },
        "options": {}
      },
      {
        "content": "list-style-type: ${1:decimal/decimal-leading-zero/zero};$0",
        "doc": "",
        "grammar": "snu",
        "label": "list-style-type: numeric (list)",
        "matches": {
          "list": true
        },
        "options": {}
      },
      {
        "content": "list-style-type: ${1:hebrew/armenian/georgian};$0",
        "doc": "",
        "grammar": "snu",
        "label": "list-style-type: other (list)",
        "matches": {
          "list": true
        },
        "options": {}
      },
      {
        "content": "list-style-type: ${1:lower-roman/upper-roman/lower-alpha/upper-alpha/lower-greek/lower-latin/upper-latin};$0",
        "doc": "",
        "grammar": "snu",
        "label": "list-style-type: roman-alpha-greek (list)",
        "matches": {
          "list": true
        },
        "options": {}
      },
      {
        "content": "list-style: ${1:none/disc/circle/square/decimal/zero} ${2:inside/outside} url($3);$0",
        "doc": "",
        "grammar": "snu",
        "label": "list-style: type position image (list)",
        "matches": {
          "list": true
        },
        "options": {}
      },
      {
        "content": "margin-bottom: ${1:20px};$0",
        "doc": "",
        "grammar": "snu",
        "label": "margin-bottom: length (margin)",
        "matches": {
          "margin": true
        },
        "options": {}
      },
      {
        "content": "margin-left: ${1:20px};$0",
        "doc": "",
        "grammar": "snu",
        "label": "margin-left: length (margin)",
        "matches": {
          "margin": true
        },
        "options": {}
      },
      {
        "content": "margin-right: ${1:20px};$0",
        "doc": "",
        "grammar": "snu",
        "label": "margin-right: length (margin)",
        "matches": {
          "margin": true
        },
        "options": {}
      },
      {
        "content": "margin-top: ${1:20px};$0",
        "doc": "",
        "grammar": "snu",
        "label": "margin-top: length (margin)",
        "matches": {
          "margin": true
        },
        "options": {}
      },
      {
        "content": "margin: ${1:20px};$0",
        "doc": "",
        "grammar": "snu",
        "label": "margin:   all (margin)",
        "matches": {
          "margin": true
        },
        "options": {}
      },
      {
        "content": "margin: ${1:20px} ${2:0px} ${3:40px} ${4:0px};$0",
        "doc": "",
        "grammar": "snu",
        "label": "margin: T R B L (margin)",
        "matches": {
          "margin": true
        },
        "options": {}
      },
      {
        "content": "margin: ${1:20px} ${2:0px};$0",
        "doc": "",
        "grammar": "snu",
        "label": "margin: V H (margin)",
        "matches": {
          "margin": true
        },
        "options": {}
      },
      {
        "content": "marker-offset: auto;$0",
        "doc": "",
        "grammar": "snu",
        "label": "marker-offset: auto (marker)",
        "matches": {
          "marker": true
        },
        "options": {}
      },
      {
        "content": "marker-offset: ${1:10px};$0",
        "doc": "",
        "grammar": "snu",
        "label": "marker-offset: length (marker)",
        "matches": {
          "marker": true
        },
        "options": {}
      },
      {
        "content": "overflow: ${1:visible/hidden/scroll/auto};$0",
        "doc": "",
        "grammar": "snu",
        "label": "overflow: type (overflow)",
        "matches": {
          "overflow": true
        },
        "options": {}
      },
      {
        "content": "padding-bottom: ${1:20px};$0",
        "doc": "",
        "grammar": "snu",
        "label": "padding-bottom: length (margin)",
        "matches": {
          "padding": true
        },
        "options": {}
      },
      {
        "content": "padding-left: ${1:20px};$0",
        "doc": "",
        "grammar": "snu",
        "label": "padding-left: length (margin)",
        "matches": {
          "padding": true
        },
        "options": {}
      },
      {
        "content": "padding-right: ${1:20px};$0",
        "doc": "",
        "grammar": "snu",
        "label": "padding-right: length (margin)",
        "matches": {
          "padding": true
        },
        "options": {}
      },
      {
        "content": "padding-top: ${1:20px};$0",
        "doc": "",
        "grammar": "snu",
        "label": "padding-top: length (margin)",
        "matches": {
          "padding": true
        },
        "options": {}
      },
      {
        "content": "padding: ${1:20px} ${2:0px} ${3:40px} ${4:0px};$0",
        "doc": "",
        "grammar": "snu",
        "label": "padding:   T R B L (padding)",
        "matches": {
          "padding": true
        },
        "options": {}
      },
      {
        "content": "padding: ${1:20px} ${2:0px};$0",
        "doc": "",
        "grammar": "snu",
        "label": "padding:   V H (padding)",
        "matches": {
          "padding": true
        },
        "options": {}
      },
      {
        "content": "padding: ${1:20px};$0",
        "doc": "",
        "grammar": "snu",
        "label": "padding:   all (padding)",
        "matches": {
          "padding": true
        },
        "options": {}
      },
      {
        "content": "position: ${1:static/relative/absolute/fixed};$0",
        "doc": "",
        "grammar": "snu",
        "label": "position: type (position)",
        "matches": {
          "position": true
        },
        "options": {}
      },
      {
        "content": "{\n\t/* $1 */\n\t$0\n",
        "doc": "",
        "grammar": "snu",
        "label": "properties { } ( } )",
        "matches": {
          "{": true
        },
        "options": {}
      },
      {
        "content": "scrollbar-base-color:       ${1:#CCCCCC};${2:\nscrollbar-arrow-color:      ${3:#000000};\nscrollbar-track-color:      ${4:#999999};\nscrollbar-3dlight-color:    ${5:#EEEEEE};\nscrollbar-highlight-color:  ${6:#FFFFFF};\nscrollbar-face-color:       ${7:#CCCCCC};\nscrollbar-shadow-color:     ${9:#999999};\nscrollbar-darkshadow-color: ${8:#666666};}",
        "doc": "",
        "grammar": "snu",
        "label": "scrollbar",
        "matches": {
          "scrollbar": true
        },
        "options": {}
      },
      {
        "content": "$1::-moz-selection,\n$1::selection {\n\tcolor: ${2:inherit};\n\tbackground: ${3:inherit};\n}",
        "doc": "",
        "grammar": "snu",
        "label": "selection",
        "matches": {
          "selection": true
        },
        "options": {}
      },
      {
        "content": "text-align: ${1:left/right/center/justify};$0",
        "doc": "",
        "grammar": "snu",
        "label": "text-align: left:center:right (txt)",
        "matches": {
          "text": true
        },
        "options": {}
      },
      {
        "content": "text-decoration: ${1:none/underline/overline/line-through/blink};$0",
        "doc": "",
        "grammar": "snu",
        "label": "text-decoration: none:underline:overline:line-through:blink (text)",
        "matches": {
          "text": true
        },
        "options": {}
      },
      {
        "content": "text-indent: ${1:10}px;$0",
        "doc": "",
        "grammar": "snu",
        "label": "text-indent: length (text)",
        "matches": {
          "text": true
        },
        "options": {}
      },
      {
        "content": "text-transform: ${1:capitalize/uppercase/lowercase};$0",
        "doc": "",
        "grammar": "snu",
        "label": "text-transform: capitalize:upper:lower (text)",
        "matches": {
          "text": true
        },
        "options": {}
      },
      {
        "content": "vertical-align: ${1:baseline/sub/super/top/text-top/middle/bottom/text-bottom/length/%};$0",
        "doc": "",
        "grammar": "snu",
        "label": "vertical-align: type (vertical)",
        "matches": {
          "vertical": true
        },
        "options": {}
      },
      {
        "content": "visibility: ${1:visible/hidden/collapse};$0",
        "doc": "",
        "grammar": "snu",
        "label": "visibility: type (visibility)",
        "matches": {
          "visibility": true
        },
        "options": {}
      },
      {
        "content": "white-space: ${1:normal/pre/nowrap};$0",
        "doc": "",
        "grammar": "snu",
        "label": "white-space:  normal:pre:nowrap (white)",
        "matches": {
          "white": true
        },
        "options": {}
      },
      {
        "content": "word-spacing: ${1:10px};$0",
        "doc": "",
        "grammar": "snu",
        "label": "word-spacing:  length (word)",
        "matches": {
          "word": true
        },
        "options": {}
      },
      {
        "content": "z-index: $1;$0",
        "doc": "",
        "grammar": "snu",
        "label": "z-index: index (z)",
        "matches": {
          "z": true
        },
        "options": {}
      }
    ],
    "cuda": [
      {
        "content": "__global__ void ${1:kernel}(${2:void}) {\n\t${0:// TODO: Implement}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "kern \"Kernel definition\"": true
        },
        "options": {}
      },
      {
        "content": "__device__ ${1:int} ${2:foo}(${3:void}) {\n\t${0:// TODO: Implement}\n\treturn 0;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dev \"Device function definition\"": true
        },
        "options": {}
      },
      {
        "content": "${1:kernel}<<<${2:args}>>>(${3});${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "call \"Kernel call\"": true
        },
        "options": {}
      },
      {
        "content": "__syncthreads();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sync \"Synchonize threads\"": true
        },
        "options": {}
      },
      {
        "content": "threadIdx.${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tid \"Thread Index\"": true
        },
        "options": {}
      },
      {
        "content": "blockIdx.${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bid \"Block Index\"": true
        },
        "options": {}
      },
      {
        "content": "blockDim.${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdim \"Block Dimension\"": true
        },
        "options": {}
      },
      {
        "content": "int ${1:index} = threadIdx.${2:x} + blockIdx.$2 * blockDim.$2;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ii \"Get current index (1D)\"": true
        },
        "options": {}
      },
      {
        "content": "int ${1:x} = threadIdx.x + blockIdx.x * blockDim.x;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ix \"Get current X index (1D)\"": true
        },
        "options": {}
      },
      {
        "content": "int ${1:y} = threadIdx.y + blockIdx.y * blockDim.y;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "iy \"Get current Y index (1D)\"": true
        },
        "options": {}
      },
      {
        "content": "int ${1:z} = threadIdx.z + blockIdx.z * blockDim.z;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "iz \"Get current Z index (1D)\"": true
        },
        "options": {}
      },
      {
        "content": "int ${1:x} = threadIdx.x + blockIdx.x * blockDim.x;\nint ${2:y} = threadIdx.y + blockIdx.y * blockDim.y;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ixy \"Get current X,Y index (2D)\"": true
        },
        "options": {}
      },
      {
        "content": "int ${1:x} = threadIdx.x + blockIdx.x * blockDim.x;\nint ${3:z} = threadIdx.z + blockIdx.z * blockDim.z;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ixz \"Get current X,Z index (2D)\"": true
        },
        "options": {}
      },
      {
        "content": "int ${2:y} = threadIdx.y + blockIdx.y * blockDim.y;\nint ${3:z} = threadIdx.z + blockIdx.z * blockDim.z;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "iyz \"Get current Y,Z index (2D)\"": true
        },
        "options": {}
      },
      {
        "content": "int ${1:x} = threadIdx.x + blockIdx.x * blockDim.x;\nint ${2:y} = threadIdx.y + blockIdx.y * blockDim.y;\nint ${3:z} = threadIdx.z + blockIdx.z * blockDim.z;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ixyz \"Get current X,Y,Z index (3D)\"": true
        },
        "options": {}
      },
      {
        "content": "__shared__ ${1:int} ${2:memo}[${3:SIZE}];${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "share \"Shared memory declaration\"": true
        },
        "options": {}
      }
    ],
    "cypress": [
      {
        "content": "cy.getCookies();",
        "doc": "Get all of the browser cookies.",
        "grammar": "lsp",
        "label": "cypress-cookies-get-all",
        "matches": {
          "cypress cookies get all": true
        },
        "options": {}
      },
      {
        "content": "cy.clearCookies();",
        "doc": "Clear all browser cookies for current domain and subdomain.",
        "grammar": "lsp",
        "label": "cypress-cookies-clear-all",
        "matches": {
          "cypress cookies clear all": true
        },
        "options": {}
      },
      {
        "content": "cy.get('${1:selector}');",
        "doc": "Get one or more DOM elements by selector or alias",
        "grammar": "lsp",
        "label": "cypress-get",
        "matches": {
          "cypress get": true
        },
        "options": {}
      },
      {
        "content": "cy.go('${1:direction}');",
        "doc": "Navigate back or forward to the previous or next URL in the browsers history.",
        "grammar": "lsp",
        "label": "cypress-go",
        "matches": {
          "cypress go": true
        },
        "options": {}
      },
      {
        "content": "cy.scrollTo(${1:x}, ${2:y});",
        "doc": "Scroll to a position defined by the distance in pixels from window/elements x and y or percentage of the window/elements width and height.",
        "grammar": "lsp",
        "label": "cypress-scroll-to-coordinates",
        "matches": {
          "cypress scroll to coordinates": true
        },
        "options": {}
      },
      {
        "content": "cy.scrollTo('${1:position}');",
        "doc": "Scroll to a specified position. Valid positions are topLeft, top, topRight, left, center, right, bottomLeft, bottom, and bottomRight.",
        "grammar": "lsp",
        "label": "cypress-scroll-to-position",
        "matches": {
          "cypress scroll to position": true
        },
        "options": {}
      },
      {
        "content": "cy.request({\n\tmethod: '${1:METHOD}',\n\turl: '${2:url}',\n\tbody: ${3:body}\n});",
        "doc": "Make an HTTP request.",
        "grammar": "lsp",
        "label": "cypress-request",
        "matches": {
          "cypress request": true
        },
        "options": {}
      },
      {
        "content": "cy.route('${1:METHOD}', '${2:url}', ${3:response});",
        "doc": "Use cy.route() to manage the behavior of network requests.",
        "grammar": "lsp",
        "label": "cypress-route",
        "matches": {
          "cypress route": true
        },
        "options": {}
      },
      {
        "content": "cy.server();",
        "doc": "Start a server to begin routing responses to cy.route() and to change the behavior of network requests.",
        "grammar": "lsp",
        "label": "cypress-server",
        "matches": {
          "cypress server": true
        },
        "options": {}
      },
      {
        "content": "cy.viewport(${1:width}, ${2:height});",
        "doc": "Control the size of the screen for your application.",
        "grammar": "lsp",
        "label": "cypress-viewport",
        "matches": {
          "cypress viewport": true
        },
        "options": {}
      },
      {
        "content": "cy.viewport('${1:preset}');",
        "doc": "Control the size of the screen for your application via presets. Preset supports the following options: ipad-2, ipad-mini, iphone-3, iphone-4, iphone-5, iphone-6, iphone-6+, iphone-x, iphone-xr, macbook-11, macbook-13, macbook-15, samsung-note9, samsung-s10",
        "grammar": "lsp",
        "label": "cypress-viewport-preset",
        "matches": {
          "cypress viewport preset": true
        },
        "options": {}
      },
      {
        "content": "cy.visit('${1:url}');",
        "doc": "Visit a remote URL",
        "grammar": "lsp",
        "label": "cypress-visit",
        "matches": {
          "cypress visit": true
        },
        "options": {}
      },
      {
        "content": "cy.wait(${1:time});",
        "doc": "Wait for a number of milliseconds or wait for an aliased resource to resolve before moving on to the next command.",
        "grammar": "lsp",
        "label": "cypress-wait",
        "matches": {
          "cypress wait": true
        },
        "options": {}
      }
    ],
    "d": [
      {
        "content": "foreach (${1:#:var}; ${2:#:list}) {\n    ${3:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "foreach() {}",
        "matches": {
          "foreach": true
        },
        "options": {}
      },
      {
        "content": "class ${1:#:name} {\n    ${2:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "class {}",
        "matches": {
          "class": true
        },
        "options": {}
      },
      {
        "content": "struct ${1:#:name} {\n    ${2:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "struct {}",
        "matches": {
          "struct": true
        },
        "options": {}
      },
      {
        "content": "enum ${1:#:name} {\n    ${2:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "enum {}",
        "matches": {
          "enum": true
        },
        "options": {}
      },
      {
        "content": "import ",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "imp": true
        },
        "options": {}
      },
      {
        "content": "public import",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pimp": true
        },
        "options": {}
      },
      {
        "content": "std.stdio",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "io": true
        },
        "options": {}
      },
      {
        "content": "std.traits",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "traits": true
        },
        "options": {}
      },
      {
        "content": "std.conv",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "conv": true
        },
        "options": {}
      },
      {
        "content": "std.array",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "arr": true
        },
        "options": {}
      },
      {
        "content": "std.algorithm",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "algo": true
        },
        "options": {}
      },
      {
        "content": "import std.stdio, std.string, std.array;\nimport std.traits, std.conv, std.algorithm;\nimport std.math, std.regex;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "theusual": true
        },
        "options": {}
      },
      {
        "content": "for(int ${1:i} = 0; $1 < ${2:count}; $1++) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "foreach(${1:elem}; ${2:range}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fe": true
        },
        "options": {}
      },
      {
        "content": "foreach(${1:i}, ${2:elem}; ${3:range}) {\n\t${0}\t\n} ",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fei": true
        },
        "options": {}
      },
      {
        "content": "foreach_reverse(${1:elem}; ${2:range}) {\n\t${0}\t\n} ",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fer": true
        },
        "options": {}
      },
      {
        "content": "foreach_reverse(${1:i}, ${2:elem}; ${3:range}) {\n\t${0}  \n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "feri": true
        },
        "options": {}
      },
      {
        "content": "scope(exit) ${1:f.close();}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sce": true
        },
        "options": {}
      },
      {
        "content": "scope(success) ${1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "scs": true
        },
        "options": {}
      },
      {
        "content": "scope(failure) ${1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "scf": true
        },
        "options": {}
      },
      {
        "content": "else {\n\t${1}\t\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "el": true
        },
        "options": {}
      },
      {
        "content": "else if(${1}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eif": true
        },
        "options": {}
      },
      {
        "content": "if(${1}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "if(${1}) {\n\t${2}\t\n} else {\n\t${3}\t\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "if(${1}) {\n\t${2}\t\n} else if(${3}) {\n\t${4}\n} else {\n\t${5}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifee": true
        },
        "options": {}
      },
      {
        "content": "switch(${1}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sw": true
        },
        "options": {}
      },
      {
        "content": "case ${1:0}:\n\t${2}\n\tbreak;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cs": true
        },
        "options": {}
      },
      {
        "content": "default:\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "def": true
        },
        "options": {}
      },
      {
        "content": "final switch(${1}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fsw": true
        },
        "options": {}
      },
      {
        "content": "try {\n\t${1:${VISUAL}}\n} catch(${2:Exception} ${3:e}) {\n\t${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "try": true
        },
        "options": {}
      },
      {
        "content": "try {\n\t${0:${VISUAL}}\n} catch(${1:Exception} ${2:e}) {\n\t${3}\n} finally {\n\t${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tcf": true
        },
        "options": {}
      },
      {
        "content": "while(${1:cond}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh": true
        },
        "options": {}
      },
      {
        "content": "do {\n\t${1}\n} while(${2});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dowh": true
        },
        "options": {}
      },
      {
        "content": "static if(${1:cond}) {\n\t${2}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sif": true
        },
        "options": {}
      },
      {
        "content": "static if(${1}) {\n\t${2}\n} else {\n\t${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sife": true
        },
        "options": {}
      },
      {
        "content": "static if(${1}) {\n\t${2}\n} else static if(${3}) {\n\t${4}\n} else {\n\t${5}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sifee": true
        },
        "options": {}
      },
      {
        "content": "else static if(${1}) {\n\t${2}\n} ",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "seif": true
        },
        "options": {}
      },
      {
        "content": "(${1: a > b}) ? ${2:a} : ${3:b}; ",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "?": true
        },
        "options": {}
      },
      {
        "content": "with(${1:exp}) {\n\t${2}\n} ${0}\t",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "with": true
        },
        "options": {}
      },
      {
        "content": "${1:auto} ${2:func}(${3:params}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fun": true
        },
        "options": {}
      },
      {
        "content": "in {\n\t${1}\n} out {\n\t${2}\n} body {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "contr": true
        },
        "options": {}
      },
      {
        "content": "(${1:x}) => ${2:x}${0:;}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "l": true
        },
        "options": {}
      },
      {
        "content": "function (${1:int x}) => ${2}${3:;}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "funl": true
        },
        "options": {}
      },
      {
        "content": "delegate (${1:int x}) => ${2}${3:;} ",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "del": true
        },
        "options": {}
      },
      {
        "content": "int opApply(Dg)(Dg dg) if(ParameterTypeTuble!Dg.length == 2) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "opApply": true
        },
        "options": {}
      },
      {
        "content": "pure @safe nothrow",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "psn": true
        },
        "options": {}
      },
      {
        "content": "@safe",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "safe": true
        },
        "options": {}
      },
      {
        "content": "@trusted",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "trusted": true
        },
        "options": {}
      },
      {
        "content": "@system",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "system": true
        },
        "options": {}
      },
      {
        "content": "enum ${1} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "enum": true
        },
        "options": {}
      },
      {
        "content": "public",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pu": true
        },
        "options": {}
      },
      {
        "content": "private",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pr": true
        },
        "options": {}
      },
      {
        "content": "protected",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "po": true
        },
        "options": {}
      },
      {
        "content": "this(${1}) {\n\t${0}\n} ",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ctor": true
        },
        "options": {}
      },
      {
        "content": "~this(${1}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dtor": true
        },
        "options": {}
      },
      {
        "content": "alias ${1:b} = ${2:a};\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "al": true
        },
        "options": {}
      },
      {
        "content": "alias ${1:value} this;\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "alth": true
        },
        "options": {}
      },
      {
        "content": "void main() {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "main": true
        },
        "options": {}
      },
      {
        "content": "void main(string[] args) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "maina": true
        },
        "options": {}
      },
      {
        "content": "module ${1:main};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mod": true
        },
        "options": {}
      },
      {
        "content": "${1:auto} ${2:var} = ${0:1};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "var": true
        },
        "options": {}
      },
      {
        "content": "${1:auto} ${2:var} = new ${3:Object}(${4});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "new": true
        },
        "options": {}
      },
      {
        "content": "auto ${1:f} = File(${2:\"useful_info.xml\"}, ${3:\"rw\"});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "file": true
        },
        "options": {}
      },
      {
        "content": "map!(${1:f})(${2:xs});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "map": true
        },
        "options": {}
      },
      {
        "content": "filter!(${1:p})(${2:xs});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "filter": true
        },
        "options": {}
      },
      {
        "content": "reduce!(${1:f})(${2:xs});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "reduce": true
        },
        "options": {}
      },
      {
        "content": "find!(${1:p})($2:xs);\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "find": true
        },
        "options": {}
      },
      {
        "content": "${1:int}[${2:string}] ${3:dict} = ${0};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "aa": true
        },
        "options": {}
      },
      {
        "content": "#!/usr/bin/env rdmd",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#!": true
        },
        "options": {}
      },
      {
        "content": "#!/usr/bin/env rdmd",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bang": true
        },
        "options": {}
      },
      {
        "content": "#!/usr/bin/env rdmd",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rdmd": true
        },
        "options": {}
      },
      {
        "content": "isSomeString!${1:S}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isstr": true
        },
        "options": {}
      },
      {
        "content": "isNumeric!${1:N}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isnum": true
        },
        "options": {}
      },
      {
        "content": "to!string(${1:x});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tos": true
        },
        "options": {}
      },
      {
        "content": "to!int(${1:str});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "toi": true
        },
        "options": {}
      },
      {
        "content": "to!double(${1:str});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tod": true
        },
        "options": {}
      },
      {
        "content": "unittest {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "un": true
        },
        "options": {}
      },
      {
        "content": "version(${1:Posix}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ver": true
        },
        "options": {}
      },
      {
        "content": "debug {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "de": true
        },
        "options": {}
      },
      {
        "content": "shared static this(${1}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sst": true
        },
        "options": {}
      },
      {
        "content": "// Typedef is deprecated. Use alias instead.\ntypedef",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "td": true
        },
        "options": {}
      },
      {
        "content": "inout",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ino": true
        },
        "options": {}
      },
      {
        "content": "immutable",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "imm": true
        },
        "options": {}
      },
      {
        "content": "final",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fin": true
        },
        "options": {}
      },
      {
        "content": "const",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "con": true
        },
        "options": {}
      },
      {
        "content": "private static immutable ${1:int} ${2:Constant} = ${3:1};\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "psi": true
        },
        "options": {}
      },
      {
        "content": "pragma(${1})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prag": true
        },
        "options": {}
      },
      {
        "content": "pragma(msg, ${1:Warning});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pms": true
        },
        "options": {}
      },
      {
        "content": "asm {\n\t${1}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asm": true
        },
        "options": {}
      },
      {
        "content": "override",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "over": true
        },
        "options": {}
      },
      {
        "content": "return ${1};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ret": true
        },
        "options": {}
      },
      {
        "content": "__FILE__",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "FILE": true
        },
        "options": {}
      },
      {
        "content": "__MODULE__",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "MOD": true
        },
        "options": {}
      },
      {
        "content": "__LINE__",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "LINE": true
        },
        "options": {}
      },
      {
        "content": "__FUNCTION__",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "FUN": true
        },
        "options": {}
      },
      {
        "content": "__PRETTY_FUNCTION__",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "PF": true
        },
        "options": {}
      },
      {
        "content": "cast(${1:T})(${2:val});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cast": true
        },
        "options": {}
      },
      {
        "content": "/*\n * ${1}\n*/",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "/*": true
        },
        "options": {}
      },
      {
        "content": "// I don't know how this works. Don't touch it.",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "idk": true
        },
        "options": {}
      },
      {
        "content": "// Don't FUCKING touch this.",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "idfk": true
        },
        "options": {}
      },
      {
        "content": "import ${1:std.stdio};",
        "doc": "",
        "grammar": "snu",
        "label": "import (imp)",
        "matches": {
          "imp": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "public import ${1:/*module*/};",
        "doc": "",
        "grammar": "snu",
        "label": "public import (pimp)",
        "matches": {
          "pimp": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "override ${1:/*function*/}",
        "doc": "",
        "grammar": "snu",
        "label": "override (over)",
        "matches": {
          "over": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "alias ${1:/*orig*/} ${2:/*alias*/};",
        "doc": "",
        "grammar": "snu",
        "label": "alias (al)",
        "matches": {
          "al": true
        },
        "options": {}
      },
      {
        "content": "mixin ${1:/*mixed_in*/} ${2:/*name*/};",
        "doc": "",
        "grammar": "snu",
        "label": "mixin (mixin)",
        "matches": {
          "mixin": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "new $1($2);",
        "doc": "",
        "grammar": "snu",
        "label": "new (new)",
        "matches": {
          "new": true
        },
        "options": {}
      },
      {
        "content": "@safe const pure nothrow",
        "doc": "",
        "grammar": "snu",
        "label": "@safe const pure nothrow (scpn)",
        "matches": {
          "scpn": true
        },
        "options": {}
      },
      {
        "content": "@safe pure nothrow",
        "doc": "",
        "grammar": "snu",
        "label": "@safe pure nothrow (spn)",
        "matches": {
          "spn": true
        },
        "options": {}
      },
      {
        "content": "continue;",
        "doc": "",
        "grammar": "snu",
        "label": "continue (cont)",
        "matches": {
          "cont": true
        },
        "options": {}
      },
      {
        "content": "@disable ${1:/*method*/};",
        "doc": "",
        "grammar": "snu",
        "label": "@disable (dis)",
        "matches": {
          "dis": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "public:\n\t${1:/*members*/}",
        "doc": "",
        "grammar": "snu",
        "label": "public (pub)",
        "matches": {
          "pub": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "private:\n\t${1:/*members*/}",
        "doc": "",
        "grammar": "snu",
        "label": "private (priv)",
        "matches": {
          "priv": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "protected:\n\t${1:/*members*/}",
        "doc": "",
        "grammar": "snu",
        "label": "protected (prot)",
        "matches": {
          "prot": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "package:\n\t${1:/*members*/}",
        "doc": "",
        "grammar": "snu",
        "label": "package (pack)",
        "matches": {
          "pack": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "return ${1:/*value to return*/};",
        "doc": "",
        "grammar": "snu",
        "label": "return (ret)",
        "matches": {
          "ret": true
        },
        "options": {}
      },
      {
        "content": "auto ${1:/*variable*/} = ${2:/*value*/};",
        "doc": "",
        "grammar": "snu",
        "label": "auto (auto)",
        "matches": {
          "auto": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "const ${1:/*variable*/} = ${2:/*value*/};",
        "doc": "",
        "grammar": "snu",
        "label": "const (con)",
        "matches": {
          "con": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "size_t ${1:/*variable*/} = ${2:/*value*/};",
        "doc": "",
        "grammar": "snu",
        "label": "size_t (siz)",
        "matches": {
          "siz": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "super(${1:/*args*/});",
        "doc": "",
        "grammar": "snu",
        "label": "super (sup)",
        "matches": {
          "sup": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "tuple(${1:/*args*/})",
        "doc": "",
        "grammar": "snu",
        "label": "tuple (tup)",
        "matches": {
          "tup": true
        },
        "options": {}
      },
      {
        "content": "writeln(${1:/*args*/});",
        "doc": "",
        "grammar": "snu",
        "label": "writeln (wr)",
        "matches": {
          "wr": true
        },
        "options": {}
      },
      {
        "content": "to!(${1:/*type*/})(${2:/*arg*/})",
        "doc": "",
        "grammar": "snu",
        "label": "to (to)",
        "matches": {
          "to": true
        },
        "options": {}
      },
      {
        "content": "enforce(${1:/*condition*/},\n\tnew $2Exception(${3:/*args*/}));",
        "doc": "",
        "grammar": "snu",
        "label": "enforce (enf)",
        "matches": {
          "enf": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "if(${1:/*condition*/})\n{\n\t${VISUAL}$0\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if .. (if)",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "if(${1:/*condition*/})\n{\n\t$2\n}\nelse\n{\n\t${3:/*else*/}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if .. else (ife)",
        "matches": {
          "ife": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "else\n{\n\t${VISUAL}$1\n}",
        "doc": "",
        "grammar": "snu",
        "label": "else (el)",
        "matches": {
          "el": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "else if(${1:/*condition*/})\n{\n\t${VISUAL}$0\n}",
        "doc": "",
        "grammar": "snu",
        "label": "else if (elif)",
        "matches": {
          "elif": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "switch(${1:/*var*/})\n{\n\tcase ${2:/*value*/}:\n\t\t$3\n\t\tbreak;\n\tcase ${4:/*value*/}:\n\t\t$5\n\t\tbreak;\n\t${7:/*more cases*/}\n\tdefault:\n\t\t${6:assert(false);}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "switch (sw)",
        "matches": {
          "sw": true
        },
        "options": {}
      },
      {
        "content": "final switch(${1:/*var*/})\n{\n\tcase ${2:/*value*/}:\n\t\t$3\n\t\tbreak;\n\tcase ${4:/*value*/}:\n\t\t$5\n\t\tbreak;\n\t${7:/*more cases*/}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "final switch (fsw)",
        "matches": {
          "fsw": true
        },
        "options": {}
      },
      {
        "content": "case ${1:/*value*/}:\n\t$2\n\tbreak;",
        "doc": "",
        "grammar": "snu",
        "label": "case (case)",
        "matches": {
          "case": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:/*condition*/} ? ${2:/*then*/} : ${3:/*else*/}$4",
        "doc": "",
        "grammar": "snu",
        "label": "ternary operator (?:)",
        "matches": {
          "?:": true
        },
        "options": {}
      },
      {
        "content": "do\n{\n\t${VISUAL}$2\n} while(${1:/*condition*/});",
        "doc": "",
        "grammar": "snu",
        "label": "do while (do)",
        "matches": {
          "do": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "while(${1:/*condition*/})\n{\n\t${VISUAL}$2\n}",
        "doc": "",
        "grammar": "snu",
        "label": "while (wh)",
        "matches": {
          "wh": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "for (${4:size_t} ${2:i} = 0; $2 < ${1:count}; ${3:++$2})\n{\n\t${VISUAL}$0\n}",
        "doc": "",
        "grammar": "snu",
        "label": "for (for)",
        "matches": {
          "for": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "for(;;)\n{\n\t${VISUAL}$0\n}",
        "doc": "",
        "grammar": "snu",
        "label": "forever (forever)",
        "matches": {
          "forever": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "foreach(${1:/*elem*/}; ${2:/*range*/})\n{\n\t${VISUAL}$3\n}",
        "doc": "",
        "grammar": "snu",
        "label": "foreach (fore)",
        "matches": {
          "fore": true
        },
        "options": {}
      },
      {
        "content": "foreach(${1:/*elem*/}; ${2:/*range*/}) if(${3:/*condition*/})\n{\n\t${VISUAL}$4\n}",
        "doc": "",
        "grammar": "snu",
        "label": "foreach if (forif)",
        "matches": {
          "forif": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "in\n{\n\tassert(${1:/*condition*/}, \"${2:error message}\");\n\t$3\n}\nbody",
        "doc": "",
        "grammar": "snu",
        "label": "in contract (in)",
        "matches": {
          "in": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "out${1:(result)}\n{\n\tassert(${2:/*condition*/}, \"${3:error message}\");\n\t$4\n}\nbody",
        "doc": "",
        "grammar": "snu",
        "label": "out contract (out)",
        "matches": {
          "out": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "invariant()\n{\n\tassert(${1:/*condition*/}, \"${2:error message}\");\n\t$3\n}",
        "doc": "",
        "grammar": "snu",
        "label": "invariant (inv)",
        "matches": {
          "inv": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:void} ${2:/*function name*/}(${3:/*args*/}) ${4:@safe pure nothrow}\n{\n\t${VISUAL}$5\n}",
        "doc": "",
        "grammar": "snu",
        "label": "function definition (fun)",
        "matches": {
          "fun": true
        },
        "options": {}
      },
      {
        "content": "void ${1:/*function name*/}(${2:/*args*/}) ${3:@safe pure nothrow}\n{\n\t${VISUAL}$4\n}",
        "doc": "",
        "grammar": "snu",
        "label": "void function definition (void)",
        "matches": {
          "void": true
        },
        "options": {}
      },
      {
        "content": "this(${1:/*args*/})\n{\n\t${VISUAL}$2\n}",
        "doc": "",
        "grammar": "snu",
        "label": "ctor (this)",
        "matches": {
          "this": true
        },
        "options": {
          "w": true
        }
      },
      {
        "content": "@property ${1:/*type*/} ${2:/*member_name*/}() const pure nothrow {return ${3:$2_};}",
        "doc": "",
        "grammar": "snu",
        "label": "getter property (get)",
        "matches": {
          "get": true
        },
        "options": {}
      },
      {
        "content": "@property void ${1:/*member_name*/}(${2:/*type*/} rhs) pure nothrow {${3:$1_} = rhs;}",
        "doc": "",
        "grammar": "snu",
        "label": "setter property (set)",
        "matches": {
          "set": true
        },
        "options": {}
      },
      {
        "content": "void main(string[] args)\n{\n\t${VISUAL}${0: /*code*/}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "Main",
        "matches": {
          "main": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "mixin Signal!(${1:/*args*/}) ${2:/*name*/};",
        "doc": "",
        "grammar": "snu",
        "label": "signal (signal)",
        "matches": {
          "signal": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "scope(${1:exit})\n{\n\t${VISUAL}$2\n}",
        "doc": "",
        "grammar": "snu",
        "label": "scope (scope)",
        "matches": {
          "scope": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "with($1)\n{\n\t${VISUAL}$2\n}",
        "doc": "",
        "grammar": "snu",
        "label": "with (with)",
        "matches": {
          "with": true
        },
        "options": {}
      },
      {
        "content": "try\n{\n\t${VISUAL}${1:/*code to try*/}\n}\ncatch($2Exception e)\n{\n\t${3:/*handle exception*/}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "try/catch (try)",
        "matches": {
          "try": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "try\n{\n\t${VISUAL}${1:/*code to try*/}\n}\ncatch($2Exception e)\n{\n\t${3:/*handle exception*/}\n}\nfinally\n{\n\t${4:/*cleanup*/}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "try/catch/finally (tryf)",
        "matches": {
          "tryf": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "catch($1Exception e)\n{\n\t${2:/*handle exception*/}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "catch (catch)",
        "matches": {
          "catch": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "throw new $1Exception(\"$2\");",
        "doc": "",
        "grammar": "snu",
        "label": "throw (thr)",
        "matches": {
          "thr": true
        },
        "options": {}
      },
      {
        "content": "/// ${3:/*documentation*/}\nclass $1Exception : $2Exception\n{\n\tpublic this(string msg, string file = __FILE__, int line = __LINE__)\n\t{\n\t\tsuper(msg, file, line);\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "exception declaration (exc)",
        "matches": {
          "exc": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "version(${1:/*version name*/})\n{\n\t${VISUAL}$2\n}",
        "doc": "",
        "grammar": "snu",
        "label": "version (version)",
        "matches": {
          "version": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "debug\n{\n\t${VISUAL}$1\n}",
        "doc": "",
        "grammar": "snu",
        "label": "debug",
        "matches": {
          "debug": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "template ${2:/*name*/}(${1:/*args*/})\n{\n\t$3\n}",
        "doc": "",
        "grammar": "snu",
        "label": "template (temp)",
        "matches": {
          "temp": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "assert(${1:false}, \"${2:TODO}\");\n",
        "doc": "",
        "grammar": "snu",
        "label": "assert (ass)",
        "matches": {
          "ass": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "unittest\n{\n\t$1\n}",
        "doc": "",
        "grammar": "snu",
        "label": "unittest (unittest)",
        "matches": {
          "unittest": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:/*return type*/} opDispatch(string s)()\n{\n\t$2;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "opDispatch (opDis)",
        "matches": {
          "opDis": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "void opAssign($1 rhs) ${2:@safe pure nothrow}\n{\n\t$2\n}",
        "doc": "",
        "grammar": "snu",
        "label": "opAssign (op=)",
        "matches": {
          "op=": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "int opCmp($1 rhs) @safe const pure nothrow\n{\n\t$2\n}",
        "doc": "",
        "grammar": "snu",
        "label": "opCmp (opCmp)",
        "matches": {
          "opCmp": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "int opApply(int delegate(ref ${1:/*iterated type/s*/}) dg)\n{\n\tint result = 0;\n\t${2:/*loop*/}\n\t{\n\t\tresult = dg(${3:/*arg/s*/});\n\t\tif(result){break;}\n\t}\n\treturn result;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "opApply (opApply)",
        "matches": {
          "opApply": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "string toString() @safe const pure nothrow\n{\n\t$1\n}",
        "doc": "",
        "grammar": "snu",
        "label": "toString (toString)",
        "matches": {
          "toString": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "// TODO: $1",
        "doc": "",
        "grammar": "snu",
        "label": "TODO (todo)",
        "matches": {
          "todo": true
        },
        "options": {}
      },
      {
        "content": "/// ${1:description}\n///\n/// ${2:details}",
        "doc": "",
        "grammar": "snu",
        "label": "generic ddoc block (doc)",
        "matches": {
          "doc": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "/// ${1:description}\n///\n/// ${2:Params:  ${3:param} = ${4:param description}\n///\t\t\t $5}\n///\n/// ${6:Returns: ${7:return value}}\n///\n/// ${8:Throws:  $9Exception $10}",
        "doc": "",
        "grammar": "snu",
        "label": "function ddoc block (fdoc)",
        "matches": {
          "fdoc": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "Params:  ${1:param} = ${2:param description}\n///\t\t\t$3",
        "doc": "",
        "grammar": "snu",
        "label": "Params (Par)",
        "matches": {
          "Par": true
        },
        "options": {}
      },
      {
        "content": "Returns:  ${1:return value/s}",
        "doc": "",
        "grammar": "snu",
        "label": "Returns (Ret)",
        "matches": {
          "Ret": true
        },
        "options": {}
      },
      {
        "content": "Throws:  $1Exception $2",
        "doc": "",
        "grammar": "snu",
        "label": "Throws (Thr)",
        "matches": {
          "Thr": true
        },
        "options": {}
      },
      {
        "content": "Examples:\n/// --------------------\n/// ${1:example code}\n/// --------------------",
        "doc": "",
        "grammar": "snu",
        "label": "Examples (Example)",
        "matches": {
          "Example": true
        },
        "options": {}
      }
    ],
    "dart": [
      {
        "content": "library ${1};\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lib": true
        },
        "options": {}
      },
      {
        "content": "import 'package:${1}/${2}.dart';\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "im": true
        },
        "options": {}
      },
      {
        "content": "new RegExp(r'${1}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rgx": true
        },
        "options": {}
      },
      {
        "content": "var ${1} = ${2};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "var": true
        },
        "options": {}
      },
      {
        "content": "main() {\n  ${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "main": true
        },
        "options": {}
      },
      {
        "content": "static ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "st": true
        },
        "options": {}
      },
      {
        "content": "final ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fi": true
        },
        "options": {}
      },
      {
        "content": "return ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "re": true
        },
        "options": {}
      },
      {
        "content": "break;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "br": true
        },
        "options": {}
      },
      {
        "content": "throw ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "th": true
        },
        "options": {}
      },
      {
        "content": "implements ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "imp": true
        },
        "options": {}
      },
      {
        "content": "extends ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ext": true
        },
        "options": {}
      },
      {
        "content": "if (${1:true}) {\n  ${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "if (${1:true}) {\n  ${2}\n} else {\n  ${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "else",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "el": true
        },
        "options": {}
      },
      {
        "content": "switch (${1}) {\n  ${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sw": true
        },
        "options": {}
      },
      {
        "content": "case ${1}:\n  ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cs": true
        },
        "options": {}
      },
      {
        "content": "default:\n  ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "de": true
        },
        "options": {}
      },
      {
        "content": "for (var ${2:i} = 0, len = ${1:things}.length; $2 < len; ${3:++}$2) {\n  ${0:$1[$2]}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "for (final ${2:item} in ${1:itemList}) {\n  ${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fore": true
        },
        "options": {}
      },
      {
        "content": "while (${1:/* condition */}) {\n  ${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh": true
        },
        "options": {}
      },
      {
        "content": "do {\n  ${0}\n} while (${0:/* condition */});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dowh": true
        },
        "options": {}
      },
      {
        "content": "assert(${0:/* condition */});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as": true
        },
        "options": {}
      },
      {
        "content": "try {\n  ${0:${VISUAL}}\n} catch (${1:Exception e}) {\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "try": true
        },
        "options": {}
      },
      {
        "content": "try {\n  ${0:${VISUAL}}\n} catch (${1:Exception e}) {\n} finally {\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tryf": true
        },
        "options": {}
      }
    ],
    "dart-flutter": [
      {
        "content": "class $1 extends StatelessWidget {\n\t@override\n\tWidget build(BuildContext context) {\n\t\treturn Container(\n\t\t\t$2\n\t\t);\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "stless": true
        },
        "options": {}
      },
      {
        "content": "class $1 extends StatefulWidget {\n\t@override\n\t_$1State createState() => _$1State();\n}\nclass _$1State extends State<$1> {\n\t@override\n\tWidget build(BuildContext context) {\n\t\treturn Container(\n\t\t\t$2\n\t\t);\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "stful": true
        },
        "options": {}
      },
      {
        "content": "class $1 extends StatefulWidget {\n\t@override\n\t_$1State createState() => _$1State();\n}\nclass _$1State extends State<$1>\n\t\twith SingleTickerProviderStateMixin {\n\tAnimationController _controller;\n\t@override\n\tvoid initState() {\n\t\tsuper.initState();\n\t\t_controller = AnimationController(vsync: this);\n\t}\n\t@override\n\tvoid dispose() {\n\t\tsuper.dispose();\n\t\t_controller.dispose();\n\t}\n\t@override\n\tWidget build(BuildContext context) {\n\t\treturn Container(\n\t\t\t$2\n\t\t);\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "stanim": true
        },
        "options": {}
      }
    ],
    "diff": [],
    "django": [
      {
        "content": "${1:FIELDNAME} = models.AutoField(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "auto": true
        },
        "options": {}
      },
      {
        "content": "${1:FIELDNAME} = models.BigIntegerField(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bigint": true
        },
        "options": {}
      },
      {
        "content": "${1:FIELDNAME} = models.BinaryField(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "binary": true
        },
        "options": {}
      },
      {
        "content": "${1:FIELDNAME} = models.BooleanField(${0:default=True})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bool": true
        },
        "options": {}
      },
      {
        "content": "${1:FIELDNAME} = models.CharField(max_length=${2}${0:, blank=True})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "char": true
        },
        "options": {}
      },
      {
        "content": "${1:FIELDNAME} = models.CommaSeparatedIntegerField(max_length=${2}${0:, blank=True})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "comma": true
        },
        "options": {}
      },
      {
        "content": "${1:FIELDNAME} = models.DateField(${2:auto_now_add=True, auto_now=True}${0:, blank=True, null=True})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "date": true
        },
        "options": {}
      },
      {
        "content": "${1:FIELDNAME} = models.DateTimeField(${2:auto_now_add=True, auto_now=True}${0:, blank=True, null=True})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "datetime": true
        },
        "options": {}
      },
      {
        "content": "${1:FIELDNAME} = models.DecimalField(max_digits=${2}, decimal_places=${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "decimal": true
        },
        "options": {}
      },
      {
        "content": "${1:FIELDNAME} = models.EmailField(max_length=${2:75}${0:, blank=True})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "email": true
        },
        "options": {}
      },
      {
        "content": "${1:FIELDNAME} = models.FileField(upload_to=${2:path/for/upload}${0:, max_length=100})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "file": true
        },
        "options": {}
      },
      {
        "content": "${1:FIELDNAME} = models.FilePathField(path=${2:\"/abs/path/to/dir\"}${3:, max_length=100}${4:, match=\"*.ext\"}${5:, recursive=True}${0:, blank=True, })",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "filepath": true
        },
        "options": {}
      },
      {
        "content": "${1:FIELDNAME} = models.FloatField(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "float": true
        },
        "options": {}
      },
      {
        "content": "${1:FIELDNAME} = models.ImageField(upload_to=${2:path/for/upload}${3:, height_field=height, width_field=width}${0:, max_length=100})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "image": true
        },
        "options": {}
      },
      {
        "content": "${1:FIELDNAME} = models.IntegerField(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "int": true
        },
        "options": {}
      },
      {
        "content": "${1:FIELDNAME} = models.IPAddressField(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ip": true
        },
        "options": {}
      },
      {
        "content": "${1:FIELDNAME} = models.NullBooleanField(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nullbool": true
        },
        "options": {}
      },
      {
        "content": "${1:FIELDNAME} = models.PositiveIntegerField(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "posint": true
        },
        "options": {}
      },
      {
        "content": "${1:FIELDNAME} = models.PositiveSmallIntegerField(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "possmallint": true
        },
        "options": {}
      },
      {
        "content": "${1:FIELDNAME} = models.SlugField(max_length=${2:50}${0:, blank=True})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "slug": true
        },
        "options": {}
      },
      {
        "content": "${1:FIELDNAME} = models.SmallIntegerField(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "smallint": true
        },
        "options": {}
      },
      {
        "content": "${1:FIELDNAME} = models.TextField(${0:blank=True})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "text": true
        },
        "options": {}
      },
      {
        "content": "${1:FIELDNAME} = models.TimeField(${2:auto_now_add=True, auto_now=True}${0:, blank=True, null=True})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "time": true
        },
        "options": {}
      },
      {
        "content": "${1:FIELDNAME} = models.URLField(${2:verify_exists=False}${3:, max_length=200}${0:, blank=True})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "url": true
        },
        "options": {}
      },
      {
        "content": "${1:FIELDNAME} = models.XMLField(schema_path=${2:None}${0:, blank=True})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "xml": true
        },
        "options": {}
      },
      {
        "content": "${1:FIELDNAME} = models.ForeignKey(${2:OtherModel}${3:, related_name=''}${4:, limit_choices_to=}${0:, to_field=''})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fk": true
        },
        "options": {}
      },
      {
        "content": "${1:FIELDNAME} = models.ManyToManyField(${2:OtherModel}${3:, related_name=''}${4:, limit_choices_to=}${5:, symmetrical=False}${6:, through=''}${0:, db_table=''})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "m2m": true
        },
        "options": {}
      },
      {
        "content": "${1:FIELDNAME} = models.OneToOneField(${2:OtherModel}${3:, parent_link=True}${4:, related_name=''}${5:, limit_choices_to=}${0:, to_field=''})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "o2o": true
        },
        "options": {}
      },
      {
        "content": "class ${1:FormName}(forms.Form):\n\t\"\"\"${2:docstring}\"\"\"\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "form": true
        },
        "options": {}
      },
      {
        "content": "class ${1:ModelName}(models.Model):\n\t\"\"\"${2:docstring}\"\"\"\n\t${3}\n\tclass Meta:\n\t\t${4}\n\tdef __unicode__(self):\n\t\t${5}\n\tdef save(self, *args, **kwargs):\n\t\t${6}\n\t@models.permalink\n\tdef get_absolute_url(self):\n\t\treturn ('${7:view_or_url_name}' ${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "model": true
        },
        "options": {}
      },
      {
        "content": "class ${1:ModelName}Admin(admin.ModelAdmin):\n\t${0}\nadmin.site.register($1, $1Admin)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "modeladmin": true
        },
        "options": {}
      },
      {
        "content": "class ${0:ModelName}Inline(admin.TabularInline):\n\tmodel = $1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tabularinline": true
        },
        "options": {}
      },
      {
        "content": "class ${0:ModelName}Inline(admin.StackedInline):\n\tmodel = $1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "stackedinline": true
        },
        "options": {}
      },
      {
        "content": "return render_to_response('${1:template.html}', {\n\t\t${2}\n\t}${0:, context_instance=RequestContext(request)}\n)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "r2r": true
        },
        "options": {}
      },
      {
        "content": "class ${1:FORMNAME}(forms.Form):\n\n\t${2:# TODO: Define form fields here}",
        "doc": "",
        "grammar": "snu",
        "label": "Form",
        "matches": {
          "form": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "class ${1:MODELNAME}Form(forms.ModelForm):\n\n\tclass Meta:\n\t\tmodel = $1",
        "doc": "",
        "grammar": "snu",
        "label": "ModelForm",
        "matches": {
          "modelform": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = forms.BooleanField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "BooleanField",
        "matches": {
          "fbool": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = forms.CharField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "CharField",
        "matches": {
          "fchar": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = forms.ChoiceField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "ChoiceField",
        "matches": {
          "fchoice": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = forms.ComboField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "ComboField",
        "matches": {
          "fcombo": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = forms.DateField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "DateField",
        "matches": {
          "fdate": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = forms.DateTimeField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "DateTimeField",
        "matches": {
          "fdatetime": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = forms.DecimalField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "DecimalField",
        "matches": {
          "fdecimal": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = forms.EmailField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "EmailField",
        "matches": {
          "fmail": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = forms.FileField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "FileField",
        "matches": {
          "ffile": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = forms.FilePathField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "FilePathField",
        "matches": {
          "ffilepath": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = forms.FloatField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "FloatField",
        "matches": {
          "ffloat": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = forms.IPAddressField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "IPAddressField",
        "matches": {
          "fip": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = forms.ImageField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "ImageField",
        "matches": {
          "fimg": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = forms.IntegerField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "IntegerField",
        "matches": {
          "fint": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = forms.ModelChoiceField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "ModelChoiceField",
        "matches": {
          "fmochoice": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = forms.ModelMultipleChoiceField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "ModelMultipleChoiceField",
        "matches": {
          "fmomuchoice": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = forms.MultiValueField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "MultiValueField",
        "matches": {
          "fmuval": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = forms.MultipleChoiceField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "MultipleChoiceField",
        "matches": {
          "fmuchoice": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = forms.NullBooleanField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "NullBooleanField",
        "matches": {
          "fnullbool": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = forms.RegexField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "RegexField",
        "matches": {
          "freg": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = forms.SlugField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "SlugField",
        "matches": {
          "fslug": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = forms.SplitDateTimeField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "SplitDateTimeField",
        "matches": {
          "fsdatetime": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = forms.TimeField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "TimeField",
        "matches": {
          "ftime": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = forms.TypedChoiceField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "TypedChoiceField",
        "matches": {
          "ftchoice": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = forms.TypedMultipleChoiceField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "TypedMultipleChoiceField",
        "matches": {
          "ftmuchoice": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = forms.URLField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "URLField",
        "matches": {
          "furl": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "class ${1:MODELNAME}(models.Model):\n\t$0\n\tclass Meta:\n\t\tverbose_name = \"$1\"\n\t\tverbose_name_plural = \"$1s\"\n\n\tdef __str__(self):\n\t\treturn super($1, self).__str__()\n",
        "doc": "",
        "grammar": "snu",
        "label": "Model",
        "matches": {
          "model": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "class ${1:MODELNAME}(models.Model):\n\t${2:# TODO: Define fields here}\n\n\tclass Meta:\n\t\tverbose_name = \"$1\"\n\t\tverbose_name_plural = \"$1s\"\n\n\tdef __str__(self):\n\t\treturn super($1, self).__str__()\n\n\tdef save(self):\n\t\treturn super($1, self).save()\n\n\tdef get_absolute_url(self):\n\t\treturn ('')\n\n\t${3:# TODO: Define custom methods here}\n",
        "doc": "",
        "grammar": "snu",
        "label": "Model",
        "matches": {
          "modelfull": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = models.AutoField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "AutoField",
        "matches": {
          "mauto": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = models.BigIntegerField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "BigIntegerField",
        "matches": {
          "mbigint": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = models.BooleanField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "BooleanField",
        "matches": {
          "mbool": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = models.CharField($2, max_length=${3:50})",
        "doc": "",
        "grammar": "snu",
        "label": "CharField",
        "matches": {
          "mchar": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = models.CommaSeparatedIntegerField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "CommaSeparatedIntegerField",
        "matches": {
          "mcoseint": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = models.DateField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "DateField",
        "matches": {
          "mdate": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = models.DateTimeField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "DateTimeField",
        "matches": {
          "mdatetime": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = models.DecimalField(max_digits=${2:10}, decimal_places=${3:2})",
        "doc": "",
        "grammar": "snu",
        "label": "DecimalField",
        "matches": {
          "mdecimal": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = models.EmailField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "EmailField",
        "matches": {
          "memail": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = models.FileField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "FileField",
        "matches": {
          "mfile": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = models.FilePathField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "FilePathField",
        "matches": {
          "mfilepath": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = models.FloatField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "FloatField",
        "matches": {
          "mfloat": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = models.ForeignKey($2)",
        "doc": "",
        "grammar": "snu",
        "label": "ForeignKey",
        "matches": {
          "fk": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = models.IPAddressField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "IPAddressField",
        "matches": {
          "mip": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = models.ImageField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "ImageField",
        "matches": {
          "mimg": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = models.IntegerField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "IntegerField",
        "matches": {
          "mint": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = models.ManyToManyField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "ManyToManyField",
        "matches": {
          "m2m": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = models.NullBooleanField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "NullBooleanField",
        "matches": {
          "mnullbool": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = models.OneToOneField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "OneToOneField",
        "matches": {
          "o2o": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = models.PhoneNumberField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "PhoneNumberField",
        "matches": {
          "mphone": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = models.PositiveIntegerField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "PositiveIntegerField",
        "matches": {
          "mposint": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = models.PositiveSmallIntegerField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "PositiveSmallIntegerField",
        "matches": {
          "mpossmallint": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = models.SlugField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "SlugField",
        "matches": {
          "mslug": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = models.SmallIntegerField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "SmallIntegerField",
        "matches": {
          "msmallint": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = models.TextField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "TextField",
        "matches": {
          "mtext": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = models.TimeField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "TimeField",
        "matches": {
          "mtime": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = models.URLField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "URLField",
        "matches": {
          "murl": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = models.USStateField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "USStateField",
        "matches": {
          "musstate": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:FIELDNAME} = models.XMLField($2)",
        "doc": "",
        "grammar": "snu",
        "label": "XMLField",
        "matches": {
          "mxml": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "class $1Admin(admin.ModelAdmin):\n\t'''\n\t\tAdmin View for $1\n\t'''\n\tlist_display = ('$2',)\n\tlist_filter = ('$3',)\n\tinlines = [\n\t\t$4Inline,\n\t]\n\traw_id_fields = ('$5',)\n\treadonly_fields = ('$6',)\n\tsearch_fields = ['$7']\nadmin.site.register($1, $1Admin)",
        "doc": "",
        "grammar": "snu",
        "label": "Model Admin View",
        "matches": {
          "adminview": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "class ${1:MODEL_NAME}CreateView(CreateView):\n\tmodel = $1\n\ttemplate_name = \"${2:TEMPLATE_NAME}\"",
        "doc": "",
        "grammar": "snu",
        "label": "Generic Create View",
        "matches": {
          "createview": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "class ${1:MODEL_NAME}DeleteView(DeleteView):\n\tmodel = $1\n\ttemplate_name = \"${2:TEMPLATE_NAME}\"",
        "doc": "",
        "grammar": "snu",
        "label": "Generic Delete View",
        "matches": {
          "deleteview": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "class ${1:MODEL_NAME}DetailView(DetailView):\n\tmodel = $1\n\ttemplate_name = \"${2:TEMPLATE_NAME}\"",
        "doc": "",
        "grammar": "snu",
        "label": "Generic Detail View",
        "matches": {
          "detailview": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "class ${1:MODEL_NAME}ListView(ListView):\n\tmodel = $1\n\ttemplate_name = \"${2:TEMPLATE_NAME}\"",
        "doc": "",
        "grammar": "snu",
        "label": "Generic List View",
        "matches": {
          "listview": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "class $1Inline(admin.StackedInline):\n\t'''\n\tStacked Inline View for $1\n\t'''\n\tmodel = ${2:$1}\n\tmin_num = ${3:3}\n\tmax_num = ${4:20}\n\textra = ${5:1}\n\traw_id_fields = ($6,)",
        "doc": "",
        "grammar": "snu",
        "label": "Stacked Inline",
        "matches": {
          "stackedinline": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "class $1Inline(admin.TabularInline):\n\t'''\n\tTabular Inline View for $1\n\t'''\n\tmodel = ${2:$1}\n\tmin_num = ${3:3}\n\tmax_num = ${4:20}\n\textra = ${5:1}\n\traw_id_fields = ($6,)",
        "doc": "",
        "grammar": "snu",
        "label": "Tabular Inline",
        "matches": {
          "tabularinline": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "class ${1:CLASS_NAME}(TemplateView):\n\ttemplate_name = \"${2:TEMPLATE_NAME}\"",
        "doc": "",
        "grammar": "snu",
        "label": "Generic Template View",
        "matches": {
          "templateview": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "class ${1:MODEL_NAME}UpdateView(UpdateView):\n\tmodel = $1\n\ttemplate_name = \"${2:TEMPLATE_NAME}\"",
        "doc": "",
        "grammar": "snu",
        "label": "Generic Update View",
        "matches": {
          "updateview": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "def dispatch(self, request, *args, **kwargs):\n\treturn super(${1:CLASS_NAME}, self).dispatch(request, *args, **kwargs)",
        "doc": "",
        "grammar": "snu",
        "label": "Dispatch View method",
        "matches": {
          "dispatch": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "def get_context_data(self, **kwargs):\n\tkwargs['extra_context'] = ${1:'New Value'}\n\treturn super(${2:CLASS_NAME}, self).get_context_data(**kwargs)",
        "doc": "",
        "grammar": "snu",
        "label": "get_context_data view method",
        "matches": {
          "context": true
        },
        "options": {
          "b": true
        }
      }
    ],
    "dockerfile": [
      {
        "content": "# Client App\nFROM johnpapa/angular-cli as client-app\nLABEL authors=\"${1:John Papa}\"\nWORKDIR /usr/src/app\nCOPY [\"package.json\", \"npm-shrinkwrap.json*\", \"./\"]\nRUN npm install --silent\nCOPY . .\nRUN ng build --prod\n\n# Node server\nFROM ${2:node:12-alpine} as node-server\nWORKDIR /usr/src/app\nCOPY [\"package.json\", \"npm-shrinkwrap.json*\", \"./\"]\nRUN npm install --production --silent && mv node_modules ../\nCOPY ${3:server.js} .\nCOPY ${4:/server} /usr/src/app/server\n\n# Final image\nFROM ${2:node:12-alpine}\nWORKDIR /usr/src/app\nCOPY --from=node-server /usr/src /usr/src\nCOPY --from=client-app /usr/src/app/dist ./\nEXPOSE ${5:3000}\n# CMD [\"node\", \"server.js\"]\nCMD [\"npm\", \"start\"]\n$0",
        "doc": "Multi-stage Node and Angular Dockerfile",
        "grammar": "lsp",
        "label": "Multi-stage Node and Angular Dockerfile",
        "matches": {
          "docker-angular-node-multi-stage": true
        },
        "options": {}
      }
    ],
    "dosini": [
      {
        "content": "; http://editorconfig.org\nroot = true\n[*]\nindent_style = ${1:space_or_tab}\nindent_size = ${2:indent_size}\nend_of_line = lf\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = true",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ec": true
        },
        "options": {}
      }
    ],
    "dotenv": [
      {
        "content": "require('dotenv').config()",
        "doc": "As early as possible in your application, require and configure dotenv.",
        "grammar": "lsp",
        "label": "dotenv-require",
        "matches": {
          "dotenv require": true
        },
        "options": {}
      },
      {
        "content": "require('dotenv').config({ path: '${1:/full/custom/path/to/your/env/vars}' })",
        "doc": "You may specify a custom path if your file containing environment variables is located elsewhere.",
        "grammar": "lsp",
        "label": "dotenv-path",
        "matches": {
          "dotenv path": true
        },
        "options": {}
      },
      {
        "content": "require('dotenv').config({ encoding: '${1:latin1}' })",
        "doc": "You may specify the encoding of your file containing environment variables.",
        "grammar": "lsp",
        "label": "dotenv-encoding",
        "matches": {
          "dotenv encoding": true
        },
        "options": {}
      },
      {
        "content": "require('dotenv').config({ debug: ${1|true,false|} })",
        "doc": "You may turn on logging to help debug why certain keys or values are not being set as you expect.",
        "grammar": "lsp",
        "label": "dotenv-debug",
        "matches": {
          "dotenv debug": true
        },
        "options": {}
      }
    ],
    "dotenv-safe": [
      {
        "content": "require('dotenv-safe').config();",
        "doc": "As early as possible in your application, require and configure dotenv-safe. This will load environment variables from .env as usual, but will also read any variables defined in .env.example. If any variables are already defined in the environment before reading from .env, they will not be overwritten. If any variables are missing from the environment, a MissingEnvVarsError will be thrown, which lists the missing variables.",
        "grammar": "lsp",
        "label": "dotenv-safe-require",
        "matches": {
          "dotenv-safe require": true
        },
        "options": {}
      },
      {
        "content": "require('dotenv-safe').config({ path: '${1:/full/custom/path/to/your/env/vars}' })",
        "doc": "You may specify a custom path if your file containing environment variables is located elsewhere.",
        "grammar": "lsp",
        "label": "dotenv-safe-path",
        "matches": {
          "dotenv-safe path": true
        },
        "options": {}
      },
      {
        "content": "require('dotenv-safe').config({ encoding: '${1:latin1}' })",
        "doc": "You may specify the encoding of your file containing environment variables.",
        "grammar": "lsp",
        "label": "dotenv-safe-encoding",
        "matches": {
          "dotenv-safe encoding": true
        },
        "options": {}
      },
      {
        "content": "require('dotenv-safe').config({ debug: ${1|true,false|} })",
        "doc": "You may turn on logging to help debug why certain keys or values are not being set as you expect.",
        "grammar": "lsp",
        "label": "dotenv-safe-debug",
        "matches": {
          "dotenv-safe debug": true
        },
        "options": {}
      },
      {
        "content": "require('dotenv-safe').config({ allowEmptyValues: ${1|true,false|} })",
        "doc": "If a variable is defined in the example file and has an empty value in the environment, enabling this option will not throw an error after loading.",
        "grammar": "lsp",
        "label": "dotenv-safe-allowemptyvalues",
        "matches": {
          "dotenv-safe allowemptyvalues": true
        },
        "options": {}
      }
    ],
    "eelixir": [
      {
        "content": "<% ${0} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "% <% %>": true
        },
        "options": {}
      },
      {
        "content": "<%= ${0} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "= <%= %>": true
        },
        "options": {}
      },
      {
        "content": "<%# ${0} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "# <%# %>": true
        },
        "options": {}
      },
      {
        "content": "<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "end": true
        },
        "options": {}
      },
      {
        "content": "<%= for ${1:item} <- ${2:items} ${3:@conn} do %>\n\t${0}\n<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "<%= if ${1} do %>\n\t${0:${VISUAL}}\n<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "<%= if ${1} do %>\n\t${2:${VISUAL}}\n<% else %>\n\t${0}\n<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "<%= cond do %>\n\t<% ${1} -> %>\n\t\t${2:${VISUAL}}\n\t<% true -> %>\n\t\t${0}\n<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cond": true
        },
        "options": {}
      },
      {
        "content": "<%= unless ${1} do %>\n\t${0:${VISUAL}}\n<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "unless": true
        },
        "options": {}
      },
      {
        "content": "<%= form_tag(${1:\"/users\"}, method: ${2::post}) %>\n\t${0}\n</form>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ft form_tag": true
        },
        "options": {}
      },
      {
        "content": "<%= select ${1:f}, :${2:field}, ${3:[{\"key\", \"value\"}]}, prompt: ${4:\"Prompt\"} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sl select": true
        },
        "options": {}
      },
      {
        "content": "<%= submit ${1:\"Submit\"} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sb submit": true
        },
        "options": {}
      },
      {
        "content": "<%= radio_button ${1:f}, :${2:field},  ${3:\"value\"} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rb radio_button": true
        },
        "options": {}
      },
      {
        "content": "<%= error_tag ${1:f}, :${2:field} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "et error_tag": true
        },
        "options": {}
      },
      {
        "content": "<%= text_input ${1:f}, :${2:field} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ti text_input": true
        },
        "options": {}
      },
      {
        "content": "<%= label ${1:f}, :${2:field}, \"${3:Label}\" %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "la label": true
        },
        "options": {}
      },
      {
        "content": "<%= password_input ${1:f}, :${2:password} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pi password_input": true
        },
        "options": {}
      },
      {
        "content": "<%= render \"${1:index}.html\", ${2:var: @var} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "render": true
        },
        "options": {}
      },
      {
        "content": "<%= link \"${1:Submit}\", to: ${2:\"/users\"}, method: ${3::delete} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lin link": true
        },
        "options": {}
      },
      {
        "content": "<%= form_for @changeset, ${1:\"/users\"}, fn f -> %>\n\t\t${0}\n\t<%= submit \"Submit\" %>\n<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ff form_for": true
        },
        "options": {}
      },
      {
        "content": "<% require IEx; IEx.pry %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pry": true
        },
        "options": {}
      },
      {
        "content": "<% $0 %>",
        "doc": "",
        "grammar": "snu",
        "label": "<% %>",
        "matches": {
          "%": true
        },
        "options": {
          "w": true
        }
      },
      {
        "content": "<%= $0 %>",
        "doc": "",
        "grammar": "snu",
        "label": "<%= %>",
        "matches": {
          "=": true
        },
        "options": {
          "w": true
        }
      },
      {
        "content": "<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": "<% end %>",
        "matches": {
          "end": true
        },
        "options": {
          "w": true
        }
      },
      {
        "content": "<%= for ${1:item} <- ${2:$1s} ${3:@conn} do %>\n\t$0\n<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "<%= form_tag(${1:\"${2:/users}\"}, method: ${3::post}) %>\n\t$0\n</form>",
        "doc": "",
        "grammar": "snu",
        "label": "form_tag",
        "matches": {
          "ft": true
        },
        "options": {
          "w": true
        }
      },
      {
        "content": "<%= link ${1:\"${2:Submit}\"}, to: ${3:\"${4:/users}\"}, method: ${5::delete} %>",
        "doc": "",
        "grammar": "snu",
        "label": "link",
        "matches": {
          "lin": true
        },
        "options": {
          "w": true
        }
      },
      {
        "content": "<%= form_for @changeset, ${1:\"${2:/users}\"}, fn f -> %>\n\t\t$0\n\n\t<%= submit \"Submit\" %>\n<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": "form_for",
        "matches": {
          "ff": true
        },
        "options": {
          "w": true
        }
      },
      {
        "content": "<%= gettext(\"${0:${VISUAL}}\") %>",
        "doc": "",
        "grammar": "snu",
        "label": "gettext",
        "matches": {
          "gt": true
        },
        "options": {
          "w": true
        }
      }
    ],
    "ejs": [
      {
        "content": "<% for (let ${1:i = 0}; ${2:i<arr.length}; ${3:i++}) { %>\n\t${0:body}\n<% } %>",
        "doc": "",
        "grammar": "snu",
        "label": "ejs for loop",
        "matches": {
          "for": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "<% ${1:array}.forEach((${2:single var}) => { %>\n\t${0:body}\n<% }) %>",
        "doc": "",
        "grammar": "snu",
        "label": "ejs for Each loop",
        "matches": {
          "forE": true
        },
        "options": {
          "b": true
        }
      }
    ],
    "elixir": [
      {
        "content": "do\n  ${1:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "do...end",
        "matches": {
          "do": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "if ${1:true} do\n  ${2:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "if .. do .. end",
        "matches": {
          "if": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "if ${1:true} do\n  ${2:ok}\nelse\n  ${3:ok}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "if .. do .. else .. end",
        "matches": {
          "ife": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "case ${1} do\n  ${2} -> ${3}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "case .. end",
        "matches": {
          "case": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "def ${1:name} do\n  ${2:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "def .. do .. end",
        "matches": {
          "def": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "defmodule ${1:module_name} do\n  ${2:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "def module",
        "matches": {
          "defm": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "defp ${1:name} do\n  ${2:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "defp .. end",
        "matches": {
          "defp": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "@doc \"\"\"${0:TARGET}\"\"\"",
        "doc": "",
        "grammar": "snu",
        "label": "@doc \"\"\"...\"\"\"",
        "matches": {
          "doc": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "@moduledoc \"\"\"${0:TARGET}\"\"\"",
        "doc": "",
        "grammar": "snu",
        "label": "@moduledoc \"\"\"...\"\"\"",
        "matches": {
          "mdoc": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "fn(${1:args}) -> ${2:TARGET} end",
        "doc": "",
        "grammar": "snu",
        "label": "fn(..) -> .. end",
        "matches": {
          "fn": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "receive do\n${1} -> ${2}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "receive .. do .. end",
        "matches": {
          "rec": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "test \"${1:test_name}\" do\n  ${2:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "test .. do .. end",
        "matches": {
          "test": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "try do\n  ${1:TARGET}\nrescue\n  ${2} -> ${3}",
        "doc": "",
        "grammar": "snu",
        "label": "try .. rescue .. end",
        "matches": {
          "try": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "with ${1}\ndo\n  ${2:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "with .. do .. end",
        "matches": {
          "with": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "describe \"${1:describe_name}\" do\n  ${2:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "describe .. do .. end",
        "matches": {
          "describe": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "IO.puts(${1})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "puts": true
        },
        "options": {}
      },
      {
        "content": "IO.inspect(${1})",
        "doc": "",
        "grammar": "snu",
        "label": "IO.inspect()",
        "matches": {
          "p": true
        },
        "options": {}
      },
      {
        "content": "defmodule Main do\n  def main do\n    ${1:TARGET}\n  end\nend\nMain.main",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "main": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "do\n\t${0:${VISUAL}}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "do": true
        },
        "options": {}
      },
      {
        "content": "IO.puts \"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "put IO.puts": true
        },
        "options": {}
      },
      {
        "content": "IO.inspect ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ins IO.inspect": true
        },
        "options": {}
      },
      {
        "content": "IO.inspect(${0}label: \"${1:label}\")",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "insl IO.inspect with label": true
        },
        "options": {}
      },
      {
        "content": "if ${1} do\n\t${0:${VISUAL}}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if if .. do .. end": true
        },
        "options": {}
      },
      {
        "content": "if ${1:condition}, do: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if: if .. do: ..": true
        },
        "options": {}
      },
      {
        "content": "if ${1:condition} do\n\t${2:${VISUAL}}\nelse\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife if .. do .. else .. end": true
        },
        "options": {}
      },
      {
        "content": "if ${1:condition}, do: ${2}, else: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife: if .. do: .. else:": true
        },
        "options": {}
      },
      {
        "content": "unless ${1} do\n\t${0:${VISUAL}}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "unless unless .. do .. end": true
        },
        "options": {}
      },
      {
        "content": "unless ${1:condition}, do: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "unless: unless .. do: ..": true
        },
        "options": {}
      },
      {
        "content": "unless ${1:condition} do\n\t${2:${VISUAL}}\nelse\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "unlesse unless .. do .. else .. end": true
        },
        "options": {}
      },
      {
        "content": "unless ${1:condition}, do: ${2}, else: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "unlesse: unless .. do: .. else:": true
        },
        "options": {}
      },
      {
        "content": "cond do\n\t${1} ->\n\t${0:${VISUAL}}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cond": true
        },
        "options": {}
      },
      {
        "content": "case ${1} do\n\t${2} ->\n\t\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case": true
        },
        "options": {}
      },
      {
        "content": "for ${1:item} <- ${2:items} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "for ${1:item} <- ${2:items}, do: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for:": true
        },
        "options": {}
      },
      {
        "content": "for ${1:item} <- ${2:items}, into: ${3} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fori": true
        },
        "options": {}
      },
      {
        "content": "with ${1:item} <- ${2:items} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wi": true
        },
        "options": {}
      },
      {
        "content": "with(\n\t${1:item} <- ${2:items}\n) do\n\t${3}\nelse\n\t${4} ->\n\t\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wie": true
        },
        "options": {}
      },
      {
        "content": "@spec ${1:name}(${2:args}) :: ${3:returns}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sp": true
        },
        "options": {}
      },
      {
        "content": "@opaque ${1:type_name} :: ${2:type}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "op": true
        },
        "options": {}
      },
      {
        "content": "@type ${1:type_name} :: ${2:type}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ty": true
        },
        "options": {}
      },
      {
        "content": "@typep ${1:type_name} :: ${2:type}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "typ": true
        },
        "options": {}
      },
      {
        "content": "@callback ${1:name}(${2:args}) :: ${3:returns}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cb": true
        },
        "options": {}
      },
      {
        "content": "def ${1:name}, do: ${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "df": true
        },
        "options": {}
      },
      {
        "content": "def ${1:name}(${2:args}) when ${3:guard}, do:",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dfw": true
        },
        "options": {}
      },
      {
        "content": "def ${1:name} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "def": true
        },
        "options": {}
      },
      {
        "content": "@doc \"\"\"\n${1:doc string}\n\"\"\"\ndef ${2:name} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defd": true
        },
        "options": {}
      },
      {
        "content": "@spec ${1:name}(${2:arg types}) :: ${3:no_return}\ndef $1(${4:args}) do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defs": true
        },
        "options": {}
      },
      {
        "content": "@doc \"\"\"\n${1:doc string}\n\"\"\"\n@spec ${2:name}(${3:arg types}) :: ${4:no_return}\ndef $2(${5:args}) do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defsd": true
        },
        "options": {}
      },
      {
        "content": "def ${1:name}(${2:args}) when ${3:guard} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defw": true
        },
        "options": {}
      },
      {
        "content": "defimpl ${1:protocol_name}, for: ${2:data_type} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defim": true
        },
        "options": {}
      },
      {
        "content": "defmacro ${1:name} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defma": true
        },
        "options": {}
      },
      {
        "content": "%__MODULE__{\n\t${1:key_name}: ${2:value}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "%M": true
        },
        "options": {}
      },
      {
        "content": "@enforce_keys [:${1:key_name}]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "enfk": true
        },
        "options": {}
      },
      {
        "content": "defp ${1:name}, do: ${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dfp": true
        },
        "options": {}
      },
      {
        "content": "defp ${1:name}(${2:args}) when ${3:guard}, do: ${4}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dfpw": true
        },
        "options": {}
      },
      {
        "content": "defp ${1:name} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defp": true
        },
        "options": {}
      },
      {
        "content": "defp ${1:name}(${2:args}) when ${3:guard} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defpw": true
        },
        "options": {}
      },
      {
        "content": "defprotocol ${1:name}, [${0:function}]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defpr": true
        },
        "options": {}
      },
      {
        "content": "defrecord ${1:record_name}, ${0:fields}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defr": true
        },
        "options": {}
      },
      {
        "content": "@doc \"\"\"\n${0}\n\"\"\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "doc": true
        },
        "options": {}
      },
      {
        "content": "@doc ~S\"\"\"\n${0}\n\"\"\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "docs": true
        },
        "options": {}
      },
      {
        "content": "@doc false",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "docf": true
        },
        "options": {}
      },
      {
        "content": "@impl true",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "im": true
        },
        "options": {}
      },
      {
        "content": "fn ${1:args} -> ${0} end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fn": true
        },
        "options": {}
      },
      {
        "content": "@moduledoc \"\"\"\n${0}\n\"\"\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mdoc": true
        },
        "options": {}
      },
      {
        "content": "@moduledoc ~S\"\"\"\n${0}\n\"\"\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mdocs": true
        },
        "options": {}
      },
      {
        "content": "@moduledoc false",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mdocf": true
        },
        "options": {}
      },
      {
        "content": "receive do\n\t${1} ->\n\t\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rec": true
        },
        "options": {}
      },
      {
        "content": "require ${0:Logger}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "req": true
        },
        "options": {}
      },
      {
        "content": "import ${0:module_name}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "imp": true
        },
        "options": {}
      },
      {
        "content": "alias ${0:module_name}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ali": true
        },
        "options": {}
      },
      {
        "content": "test \"${1:test name}\" do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "test": true
        },
        "options": {}
      },
      {
        "content": "test \"${1:test_name}\", ctx do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "testc": true
        },
        "options": {}
      },
      {
        "content": "test \"${1:test_name}\", %{${2:arg: arg}} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "testa": true
        },
        "options": {}
      },
      {
        "content": "describe \"${1:test group subject}\" do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "des": true
        },
        "options": {}
      },
      {
        "content": "@describetag :${1:describe tag}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "destag": true
        },
        "options": {}
      },
      {
        "content": "@moduletag :${1:module tag}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mtag": true
        },
        "options": {}
      },
      {
        "content": "doctest ${1:filename}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dt": true
        },
        "options": {}
      },
      {
        "content": "@tag :pending",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tp": true
        },
        "options": {}
      },
      {
        "content": "setup do\n\t${1}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "setup": true
        },
        "options": {}
      },
      {
        "content": "setup_all do\n\t${1}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "setupa": true
        },
        "options": {}
      },
      {
        "content": "try do\n\t${1:${VISUAL}}\nrescue\n\t${2} -> ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "try try .. rescue .. end": true
        },
        "options": {}
      },
      {
        "content": "require IEx; IEx.pry\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pry": true
        },
        "options": {}
      },
      {
        "content": "|> (fn x -> require IEx; IEx.pry; x end).()${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ppry": true
        },
        "options": {}
      },
      {
        "content": "quote do\n\t${1}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "qu": true
        },
        "options": {}
      },
      {
        "content": "@behaviour ${1:Mix.Task}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "beh": true
        },
        "options": {}
      },
      {
        "content": "|> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p": true
        },
        "options": {}
      },
      {
        "content": "|> Enum.each(fn ${1} -> ${0} end)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ">e pipe to each": true
        },
        "options": {}
      },
      {
        "content": "|> Enum.map(fn ${1} -> ${0} end)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ">m pipe to map": true
        },
        "options": {}
      },
      {
        "content": "|> Enum.filter(fn ${1} -> ${0} end)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ">f pipe to filter": true
        },
        "options": {}
      },
      {
        "content": "|> Enum.reduce(${1:acc}, fn ${2}, ${3:acc} -> ${0} end)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ">r pipe to reduce": true
        },
        "options": {}
      },
      {
        "content": "|> IO.inspect",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ">i pipe to inspect": true
        },
        "options": {}
      },
      {
        "content": "|> IO.inspect(label: \"${1:label}\")",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ">il pipe to inspect with label": true
        },
        "options": {}
      },
      {
        "content": "@doc false\ndef child_spec(${1:_opts}) do\n\t%{\n\t\tid: __MODULE__,\n\t\tstart: {__MODULE__, :start_link, ${2:[]}},\n\t\trestart: ${3::permanent},\n\t\tshutdown: ${4:5000},\n\t\ttype: ${5::worker}\n\t}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cs": true
        },
        "options": {}
      },
      {
        "content": "use GenServer\n@doc false\ndef start_link do\n\tGenServer.start_link(__MODULE__, ${1:Map.new})\nend\n@impl true\ndef init(state) do\n\t{:ok, state}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "genserver basic genserver structure": true
        },
        "options": {}
      },
      {
        "content": "use GenServer\n@doc false\ndef start_link, do: GenServer.start_link(__MODULE__, ${1:Map.new})\n@impl true\ndef init(state), do: {:ok, state}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "genserver: basic genserver structure": true
        },
        "options": {}
      },
      {
        "content": "@impl true\ndef ${1:name} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "impl": true
        },
        "options": {}
      },
      {
        "content": "~w(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wl word list": true
        },
        "options": {}
      },
      {
        "content": "~w(${0})a",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "al atom list": true
        },
        "options": {}
      }
    ],
    "elm": [
      {
        "content": "import ${1:String}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "import",
        "matches": {
          "imp": true,
          "import": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "import ${1} as ${2}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "import ... as ...",
        "matches": {
          "impa": true,
          "importAs": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "import ${1:Html} exposing (${2:..})\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "import ... exposing (..)",
        "matches": {
          "impe": true,
          "importExposing": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "import ${1:Html} as ${2} exposing (${2:..})\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "import ... as ... exposing (..)",
        "matches": {
          "impae": true,
          "importAsExposing": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "main : Program Never ${2:Model} ${3:Msg}\nmain =\n\t${4:Html.}program\n\t\t{ init: ${6:( model, Cmd.none )}\n\t\t, update: ${7:update}\n\t\t, subscriptions: ${8:subscriptions}\n\t\t${9:, view: ${10:view\\}}\n\t\t}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "main : Program",
        "matches": {
          "main": true,
          "prog": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "main : Program ${1:Flags} ${2:Model} ${3:Msg}\nmain =\n\t${4:Html.}programWithFlags\n\t\t{ init: ${6:initWithFlags}\n\t\t, update: ${7:update}\n\t\t, subscriptions: ${8:subscriptions}\n\t\t${9:, view: ${10:view\\}}\n\t\t}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "main : Program",
        "matches": {
          "progf mainf": true,
          "programWithFlags": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "main : Program Never ${2:Model} ${3:Msg}\nmain =\n\t${4:Html.}beginnerProgram\n\t\t{ init: ${6:init}\n\t\t, update: ${7:update}\n\t\t, subscriptions: ${8:subscriptions}\n\t\t${9:, view: ${10:view\\}}\n\t\t}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "main : Program",
        "matches": {
          "basicProgram": true,
          "progb mainb": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "case ${1:#:expression} of\n\t${2:#:value} ->\n\t\t${3:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "case ... of",
        "matches": {
          "case": true
        },
        "options": {}
      },
      {
        "content": "if ${1:#:condition} then\n\t${2}\nelse\n\t${3}",
        "doc": "",
        "grammar": "snu",
        "label": "if ... then ... else ...",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "let\n\t${1} =\n\t\t${2}\nin\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "let ... in ...",
        "matches": {
          "let": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "\\\\${1:x} -> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lambda": true
        },
        "options": {}
      },
      {
        "content": "import ${0:Http}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "imp": true
        },
        "options": {}
      },
      {
        "content": "import ${1:Html} exposing (${0:..})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "impe": true
        },
        "options": {}
      },
      {
        "content": "import ${1:Json.Encode} as ${2:Encode} exposing (${0:Value})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "impae": true
        },
        "options": {}
      },
      {
        "content": "${1:fn} : ${2:a} -> ${3:a}\n$1 ${4} =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fn": true
        },
        "options": {}
      },
      {
        "content": "${1:fn} : ${2:a} -> ${3:a}\n$1 ${4} =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fn1": true
        },
        "options": {}
      },
      {
        "content": "${1:fn} : ${2:a} -> ${3:a} -> ${4:a}\n$1 ${5} =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fn2": true
        },
        "options": {}
      },
      {
        "content": "${1:fn} : ${2:a} -> ${3:a} -> ${4:a} -> ${5:a}\n$1 ${6} =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fn3": true
        },
        "options": {}
      },
      {
        "content": "${1:fn} : ${2:a}\n$1 =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fn0": true
        },
        "options": {}
      },
      {
        "content": "case ${1} of\n\t${2} ->\n\t\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case": true
        },
        "options": {}
      },
      {
        "content": "${1} ->\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "-": true
        },
        "options": {}
      },
      {
        "content": "let\n\t${1} =\n\t\t${2}\nin\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "let": true
        },
        "options": {}
      },
      {
        "content": "if ${1} then\n\t${2:${VISUAL}}\nelse\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "type ${1:Msg}\n\t= ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ty": true
        },
        "options": {}
      },
      {
        "content": "type alias ${1:Model} =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tya": true
        },
        "options": {}
      },
      {
        "content": "test \"${1}\" <| \\_ -> $0",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "test": true
        },
        "options": {}
      },
      {
        "content": "describe \"${1}\" [ $0 ]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "desc": true
        },
        "options": {}
      },
      {
        "content": "{-| ${0}\n-}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "doc": true
        },
        "options": {}
      },
      {
        "content": "|> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p": true
        },
        "options": {}
      },
      {
        "content": "import Html exposing (Html)\ntype alias Model =\n\t{}\ntype Msg\n\t= Noop\nmain : Program Never Model Msg\nmain =\n\tHtml.program\n\t\t{ init = init\n\t\t, view = view\n\t\t, update = update\n\t\t, subscriptions = subscriptions\n\t\t}\ninit : ( Model, Cmd Msg )\ninit =\n\t{} ! []\nupdate : Msg -> Model -> ( Model, Cmd Msg )\nupdate msg model =\n\tcase msg of\n\t\tNoop ->\n\t\t\tmodel ! []\nsubscriptions : Model -> Sub Msg\nsubscriptions model =\n\tSub.none\nview : Model -> Html Msg\nview model =\n\tHtml.text \"Hello, sailor!\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "program Elm 0.18 program": true
        },
        "options": {}
      },
      {
        "content": "module Main exposing (Model, Msg(..), init, main, subscriptions, update, view)\nimport Browser\nimport Html exposing (..)\nimport Json.Encode\nmain : Program Flags Model Msg\nmain =\n\tBrowser.element\n\t\t{ init = init\n\t\t, update = update\n\t\t, subscriptions = subscriptions\n\t\t, view = view\n\t\t}\ntype alias Model =\n\t{}\ntype alias Flags =\n\tJson.Encode.Value\ninit : Flags -> ( Model, Cmd Msg )\ninit flags_ =\n\t( {}\n\t, Cmd.none\n\t)\ntype Msg\n\t= Noop\nupdate : Msg -> Model -> ( Model, Cmd Msg )\nupdate msg model =\n\tcase msg of\n\t\tNoop ->\n\t\t\t( model\n\t\t\t, Cmd.none\n\t\t\t)\nsubscriptions : Model -> Sub Msg\nsubscriptions model =\n\tSub.none\nview : Model -> Html Msg\nview model =\n\th1 [] [ text \"Hello, world!\" ]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "element": true
        },
        "options": {}
      }
    ],
    "erlang": [
      {
        "content": "main(_) -> io:format(\"Hello, world!\\n\").",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "helloworld": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "-module(${0:module}).",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "-module": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "-export([${0:f/1}]).",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "-export": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "io:format(\"${1:~w~n}\"${2:, []})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ioformat": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "main(_) -> ${0}.",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "main": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "case ${0:TARGET} of\n    ${1}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "case",
        "matches": {
          "case": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "<<\"${0:TARGET}\">>",
        "doc": "",
        "grammar": "snu",
        "label": "<<\"...\">>",
        "matches": {
          "bs": true
        },
        "options": {}
      },
      {
        "content": "erlang:display(${0}),",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d": true
        },
        "options": {}
      },
      {
        "content": "erlang:display({${1}, ${0}}),",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dt": true
        },
        "options": {}
      },
      {
        "content": "-define(${1:macro}, ${2:body}).",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "def": true
        },
        "options": {}
      },
      {
        "content": "-export([${1:function}/${0:arity}]).",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "exp": true
        },
        "options": {}
      },
      {
        "content": "-include(\"${1:file}\").",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "inc": true
        },
        "options": {}
      },
      {
        "content": "-include_lib(\"${1:lib}/include/${1}.hrl\").${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "incl": true
        },
        "options": {}
      },
      {
        "content": "-behaviour(${1:behaviour}).",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "beh": true
        },
        "options": {}
      },
      {
        "content": "-ifdef(${1:TEST}).\n${0}\n-endif.",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifd": true
        },
        "options": {}
      },
      {
        "content": "-ifndef(${1:TEST}).\n${0}\n-endif.",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifnd": true
        },
        "options": {}
      },
      {
        "content": "-undef(${1:macro}).",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "undef": true
        },
        "options": {}
      },
      {
        "content": "if\n\t${1:guard} ->\n\t\t${0:body}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "case ${1:expression} of\n\t${2:pattern} ->\n\t\t${0:body};\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case": true
        },
        "options": {}
      },
      {
        "content": "fun (${1:Parameters}) -> ${2:body} end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fun": true
        },
        "options": {}
      },
      {
        "content": "try\n\t${1:${VISUAL}}\ncatch\n\t${2:_:_} -> ${0:got_some_exception}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "try": true
        },
        "options": {}
      },
      {
        "content": "receive\n${1:\t${2:pattern}${3: when ${4:guard}} ->\n\t\t${5:body}}\n${6:after\n\t${7:expression} ->\n\t\t${8:body}}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rcv \"Receive Expression\"": true
        },
        "options": {}
      },
      {
        "content": "-record(${1:record}, {${2:field}=${3:value}}).",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rec": true
        },
        "options": {}
      },
      {
        "content": "%% TODO: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "todo": true
        },
        "options": {}
      },
      {
        "content": "%% @doc ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "%d": true
        },
        "options": {}
      },
      {
        "content": "%% @end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "%e": true
        },
        "options": {}
      },
      {
        "content": "%% @spec ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "%s": true
        },
        "options": {}
      },
      {
        "content": "%% @private",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "%p": true
        },
        "options": {}
      },
      {
        "content": "-ifdef(TEST).\n-include_lib(\"eunit/include/eunit.hrl\").\n${0}\n-endif.",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ieunit": true
        },
        "options": {}
      },
      {
        "content": "-ifdef(TEST).\n${1}_test() ->\n\t${0}\n-endif.",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "itest": true
        },
        "options": {}
      },
      {
        "content": "${1}_test() ->\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "test": true
        },
        "options": {}
      },
      {
        "content": "?assert(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as": true
        },
        "options": {}
      },
      {
        "content": "?assertNot(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asn": true
        },
        "options": {}
      },
      {
        "content": "?assertEqual(${1}, ${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "aseq": true
        },
        "options": {}
      },
      {
        "content": "?assertNotEqual(${1}, ${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asneq": true
        },
        "options": {}
      },
      {
        "content": "?assertMatch(${1:Pattern}, ${0:Expression})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asmat": true
        },
        "options": {}
      },
      {
        "content": "?assertNotMatch(${1:Pattern}, ${0:Expression})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asnmat": true
        },
        "options": {}
      },
      {
        "content": "?assertError(${1:Pattern}, ${0:Expression})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "aserr": true
        },
        "options": {}
      },
      {
        "content": "?assertExit(${1:Pattern}, ${0:Expression})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asex": true
        },
        "options": {}
      },
      {
        "content": "?assertException(${1:Class}, ${2:Pattern}, ${0:Expression})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asexc": true
        },
        "options": {}
      },
      {
        "content": "${1:pattern}${2: when ${3:guard}} ->\n\t${4:body}",
        "doc": "",
        "grammar": "snu",
        "label": "Case:Receive:Try Clause",
        "matches": {
          "pat": true
        },
        "options": {}
      },
      {
        "content": "[${1:X} || ${2:X} <- ${3:List}${4:, gen}]",
        "doc": "",
        "grammar": "snu",
        "label": "List Comprehension",
        "matches": {
          "||": true
        },
        "options": {}
      },
      {
        "content": "${1:X} <- ${2:List}${3:, gen}",
        "doc": "",
        "grammar": "snu",
        "label": "Generator Expression",
        "matches": {
          "gen": true
        },
        "options": {}
      }
    ],
    "eruby": [
      {
        "content": "<%= ${1:TARGET} %>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "<%= %>",
        "matches": {
          "ruby_print": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<% ${1:TARGET} %>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "<% %>",
        "matches": {
          "ruby_code": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<%= ${1:TARGET} -%>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "<%= -%>",
        "matches": {
          "ruby_print_nonl": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<% ${1:TARGET} -%>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "<% -%>",
        "matches": {
          "ruby_code_nonl": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<%# ${1:TARGET} %>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "<%# %>",
        "matches": {
          "comment": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<% ${0} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rc": true
        },
        "options": {}
      },
      {
        "content": "<%= ${1} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rce": true
        },
        "options": {}
      },
      {
        "content": "<% ${0} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "%": true
        },
        "options": {}
      },
      {
        "content": "<%= ${1} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "=": true
        },
        "options": {}
      },
      {
        "content": "<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "end": true
        },
        "options": {}
      },
      {
        "content": "<% ${1}.each do |${2}| %>\n\t${0}\n<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ead": true
        },
        "options": {}
      },
      {
        "content": "<% for ${2:item} in ${1} %>\n\t${0}\n<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "<%= render partial: '${0:item}' %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rp": true
        },
        "options": {}
      },
      {
        "content": "<%= render partial: '${1:item}', locals: { :${2:name} => '${3:value}'${0} } %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rpl": true
        },
        "options": {}
      },
      {
        "content": "<%= render partial: '${1:item}', status: ${0:500} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rps": true
        },
        "options": {}
      },
      {
        "content": "<%= render partial: '${1:item}', collection: ${0:items} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rpc": true
        },
        "options": {}
      },
      {
        "content": "<%= link_to '${1:link text...}', action: '${0:index}' %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lia": true
        },
        "options": {}
      },
      {
        "content": "<%= link_to '${1:link text...}', action: '${2:edit}', id: ${0:@item} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "liai": true
        },
        "options": {}
      },
      {
        "content": "<%= link_to '${1:link text...}', controller: '${0:items}' %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lic": true
        },
        "options": {}
      },
      {
        "content": "<%= link_to '${1:link text...}', controller: '${2:items}', action: '${0:index}' %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lica": true
        },
        "options": {}
      },
      {
        "content": "<%= link_to '${1:link text...}', controller: '${2:items}', action: '${3:edit}', id: ${0:@item} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "licai": true
        },
        "options": {}
      },
      {
        "content": "<%= yield ${1::content_symbol} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yield": true
        },
        "options": {}
      },
      {
        "content": "<% content_for :${1:head} do %>\n\t${0}\n<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "conf": true
        },
        "options": {}
      },
      {
        "content": "<%= collection_select(:${1:object}, :${2:method}, ${3:collection}, :${4:value_method}, :${5:text_method}, options = {${0:prompt: true}}) %>        ",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cs": true
        },
        "options": {}
      },
      {
        "content": "<%= content_tag '${1:DIV}', ${2:content}${0:,options} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ct": true
        },
        "options": {}
      },
      {
        "content": "<%= form_for @${1:model} do |f| %>\n\t${0}\n<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ff": true
        },
        "options": {}
      },
      {
        "content": "<%= ${1:f}.input :${0:attribute} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ffi": true
        },
        "options": {}
      },
      {
        "content": "<%= ${1:f}.check_box :${0:attribute} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ffcb": true
        },
        "options": {}
      },
      {
        "content": "<% error_messages_for :${1:model} %>\n<%= form_for @${2:model} do |f| %>\n\t${0}\n<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ffe": true
        },
        "options": {}
      },
      {
        "content": "<%= ${1:f}.file_field :${0:attribute} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ffff": true
        },
        "options": {}
      },
      {
        "content": "<%= ${1:f}.hidden_field :${0:attribute} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ffhf": true
        },
        "options": {}
      },
      {
        "content": "<%= ${1:f}.label :${2:attribute}, '${0:$2}' %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ffl": true
        },
        "options": {}
      },
      {
        "content": "<%= ${1:f}.password_field :${0:attribute} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ffpf": true
        },
        "options": {}
      },
      {
        "content": "<%= ${1:f}.radio_button :${2:attribute}, :${0:tag_value} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ffrb": true
        },
        "options": {}
      },
      {
        "content": "<%= ${1:f}.submit \"${0:submit}\" %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ffs": true
        },
        "options": {}
      },
      {
        "content": "<%= ${1:f}.text_area :${0:attribute} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ffta": true
        },
        "options": {}
      },
      {
        "content": "<%= ${1:f}.text_field :${0:attribute} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fftf": true
        },
        "options": {}
      },
      {
        "content": "<%= ${1:f}.collection_select(:${2:method}, ${3:collection}, :${4:value_method}, :${5:text_method}, options = {${0:prompt: true}}) %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fcs": true
        },
        "options": {}
      },
      {
        "content": "<%= fields_for :${1:model}, @$1 do |${2:f}| %>\n\t${0}\n<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fields": true
        },
        "options": {}
      },
      {
        "content": "I18n.t('${1:type.key}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "i18": true
        },
        "options": {}
      },
      {
        "content": "<%= image_tag \"${1}\"${0} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "it": true
        },
        "options": {}
      },
      {
        "content": "<%= javascript_include_tag ${0::all} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jit": true
        },
        "options": {}
      },
      {
        "content": "<%= javascript_include_tag \"${0}\" %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jsit": true
        },
        "options": {}
      },
      {
        "content": "<%= link_to ${1:model}.${2:name}, ${3:$1}_path(${0:$1}) %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lim": true
        },
        "options": {}
      },
      {
        "content": "<%= link_to \"${1:Link text...}\", ${2:parent}_${3:child}_path(${4:@$2}, ${0:@$3}) %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "linp": true
        },
        "options": {}
      },
      {
        "content": "<%= link_to \"${1:Link text...}\", ${2:parent}_${3:child}_path(${0:@$2}) %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "linpp": true
        },
        "options": {}
      },
      {
        "content": "<%= link_to \"${1:Link text...}\", ${2:model}_path(${0:@$2}) %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lip": true
        },
        "options": {}
      },
      {
        "content": "<%= link_to \"${1:Link text...}\", ${0:model}s_path %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lipp": true
        },
        "options": {}
      },
      {
        "content": "<%= link_to \"${1:name}\", ${0:dest} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lt": true
        },
        "options": {}
      },
      {
        "content": "<%= number_to_currency(${1}) %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ntc": true
        },
        "options": {}
      },
      {
        "content": "<%= options_from_collection_for_select ${1:collection}, ${2:value_method}, ${3:text_method}, ${0:selected_value} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ofcfs": true
        },
        "options": {}
      },
      {
        "content": "<%= options_for_select ${1:collection}, ${2:value_method} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ofs": true
        },
        "options": {}
      },
      {
        "content": "<%= render file: \"${1:file}\"${0} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rf": true
        },
        "options": {}
      },
      {
        "content": "<%= render template: \"${1:file}\"${0} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rt": true
        },
        "options": {}
      },
      {
        "content": "<%= stylesheet_link_tag ${1::all}, cache: ${0:true} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "slt": true
        },
        "options": {}
      },
      {
        "content": "<%= stylesheet_link_tag \"${0}\" %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sslt": true
        },
        "options": {}
      },
      {
        "content": "<% if ${1} %>\n\t${0:${VISUAL}}\n<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "<% if ${1} %>\n\t${2}\n<% else %>\n\t${0}\n<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "<% require 'pry'; binding.pry %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pry": true
        },
        "options": {}
      }
    ],
    "falcon": [
      {
        "content": "#!/usr/bin/env falcon",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#!": true
        },
        "options": {}
      },
      {
        "content": "import ${0:module}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "imp": true
        },
        "options": {}
      },
      {
        "content": "function ${2:function_name}(${3})\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fun": true
        },
        "options": {}
      },
      {
        "content": "class ${1:class_name}(${2:class_params})\n\t${0:/* members/methods */}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "class": true
        },
        "options": {}
      },
      {
        "content": "if ${1:condition}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "if ${1:condition}\n\t${0}\nelse\n    ${1}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "elif ${1:condition}\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eif": true
        },
        "options": {}
      },
      {
        "content": "switch ${1:expression}\n\tcase ${2:item}\n\tcase ${0:item}\n\tdefault\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "switch": true
        },
        "options": {}
      },
      {
        "content": "select ${1:variable}\n\tcase ${2:TypeSpec}\n\tcase ${0:TypeSpec}\n\tdefault\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "select": true
        },
        "options": {}
      },
      {
        "content": "for ${1:element} in ${2:container}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forin": true
        },
        "options": {}
      },
      {
        "content": "for ${1:lowerbound} to ${2:upperbound}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forto": true
        },
        "options": {}
      },
      {
        "content": "while ${1:conidition}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh": true
        },
        "options": {}
      }
    ],
    "fortran": [
      {
        "content": "program ${1:main}\n\t${2}\nend program $1",
        "doc": "",
        "grammar": "snu",
        "label": "program",
        "matches": {
          "pr": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "function ${1:}(${2})\n\t${3}\nend function $1",
        "doc": "",
        "grammar": "snu",
        "label": "function",
        "matches": {
          "fu": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "integer, parameter :: ",
        "doc": "",
        "grammar": "snu",
        "label": "integer parameter",
        "matches": {
          "inp": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "integer :: ",
        "doc": "",
        "grammar": "snu",
        "label": "integer",
        "matches": {
          "in": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "integer, intent(in)  :: ",
        "doc": "",
        "grammar": "snu",
        "label": "integer intent(in)",
        "matches": {
          "ini": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "integer, intent(out) :: ",
        "doc": "",
        "grammar": "snu",
        "label": "integer intent(out)",
        "matches": {
          "ino": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "real, parameter :: ",
        "doc": "",
        "grammar": "snu",
        "label": "real parameter",
        "matches": {
          "rep": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "real :: ",
        "doc": "",
        "grammar": "snu",
        "label": "real",
        "matches": {
          "re": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "real, intent(in)  :: ",
        "doc": "",
        "grammar": "snu",
        "label": "real intent(in)",
        "matches": {
          "rei": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "real, intent(out) :: ",
        "doc": "",
        "grammar": "snu",
        "label": "real intent(out)",
        "matches": {
          "reo": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "integer, dimension(${1::})${2:#:, allocatable} :: ${3}",
        "doc": "",
        "grammar": "snu",
        "label": "integer dimension",
        "matches": {
          "ind": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "integer, dimension(${1}), intent(in)  :: ${2}",
        "doc": "",
        "grammar": "snu",
        "label": "integer dimension intent(in)",
        "matches": {
          "indi": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "integer, dimension(${1}), intent(out) :: ${2}",
        "doc": "",
        "grammar": "snu",
        "label": "integer dimension intent(out)",
        "matches": {
          "indo": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "real, dimension(${1::})${2:#:, allocatable} :: ${3}",
        "doc": "",
        "grammar": "snu",
        "label": "real dimension",
        "matches": {
          "red": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "real, dimension(${1}), intent(in)  :: ${2}",
        "doc": "",
        "grammar": "snu",
        "label": "real dimension intent(in)",
        "matches": {
          "redi": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "real, dimension(${1}), intent(out) :: ${2}",
        "doc": "",
        "grammar": "snu",
        "label": "real dimension intent(out)",
        "matches": {
          "redo": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "character(${1}) :: ${2}",
        "doc": "",
        "grammar": "snu",
        "label": "character",
        "matches": {
          "ch": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "character(${1}), dimension(${2}) :: ${3}",
        "doc": "",
        "grammar": "snu",
        "label": "character dimension",
        "matches": {
          "chd": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "logical :: ${1:fileExsit}",
        "doc": "",
        "grammar": "snu",
        "label": "logical",
        "matches": {
          "lo": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "if (${1}) ${2}",
        "doc": "",
        "grammar": "snu",
        "label": "if",
        "matches": {
          "if": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "if (${1}) then\n\t${2}\nend if",
        "doc": "",
        "grammar": "snu",
        "label": "if then",
        "matches": {
          "ift": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "read(${1:*},${2:*}) ${3}",
        "doc": "",
        "grammar": "snu",
        "label": "read",
        "matches": {
          "read": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "write(${1:*},${2:*}) ${3}",
        "doc": "",
        "grammar": "snu",
        "label": "write",
        "matches": {
          "wr": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "open(${1:11},file=${2},status=${3:#:old}${4:#:,position='append'})\n${5}\nclose($1)",
        "doc": "",
        "grammar": "snu",
        "label": "open",
        "matches": {
          "op": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "select case (${1})\n${2}\nend select",
        "doc": "",
        "grammar": "snu",
        "label": "select case",
        "matches": {
          "se": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "case(${1})\n\t${2}",
        "doc": "",
        "grammar": "snu",
        "label": "case",
        "matches": {
          "case": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "do ${1}\nend do",
        "doc": "",
        "grammar": "snu",
        "label": "do",
        "matches": {
          "do": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "type ${1:}\n\t${2}\nend type $1",
        "doc": "",
        "grammar": "snu",
        "label": "type",
        "matches": {
          "ty": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "type(${1}), dimension(${2::}), allcatable :: ${3}",
        "doc": "",
        "grammar": "snu",
        "label": "type dimension",
        "matches": {
          "tyd": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "implicit none\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "impl": true
        },
        "options": {}
      },
      {
        "content": "program ${1:main}\n\t${0}\nend program $1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prog": true
        },
        "options": {}
      },
      {
        "content": "module ${1:modulename}\n\t${0}\nend module $1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mod": true
        },
        "options": {}
      },
      {
        "content": "procedure ${1:name}\n\t${0}\nend procedure $1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "proc": true
        },
        "options": {}
      },
      {
        "content": "interface ${1:name}\n\t${0}\nend interface $1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "iface": true
        },
        "options": {}
      },
      {
        "content": "!> @param[${1}]${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "doxp": true
        },
        "options": {}
      },
      {
        "content": "logical :: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bool": true
        },
        "options": {}
      },
      {
        "content": "integer :: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "int": true
        },
        "options": {}
      },
      {
        "content": "real :: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "real": true
        },
        "options": {}
      },
      {
        "content": "double precision :: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "double": true
        },
        "options": {}
      },
      {
        "content": "character(len=${1:*}) :: ${0:}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "str": true
        },
        "options": {}
      },
      {
        "content": "type(${1:name})\n\t${0}\nend type",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "type": true
        },
        "options": {}
      },
      {
        "content": "${1:type}, parameter :: $2 = ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "const": true
        },
        "options": {}
      },
      {
        "content": "${1:type}, ${2:allocatable, }dimension(${3::}) :: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "arr": true
        },
        "options": {}
      },
      {
        "content": "${1:type}, intent(inout) :: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "intent": true
        },
        "options": {}
      },
      {
        "content": "(/ $1 /) ${2:,&} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "/": true
        },
        "options": {}
      },
      {
        "content": "if (${1:condition}) then\n\t${0}\nend if",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "select case (${1:expr})\n\tcase ($2)\n\tcase default\n\t\t$3\nend select ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case": true
        },
        "options": {}
      },
      {
        "content": "do ${1:i} = ${2:start}, ${3:end}, ${4:incr}\n\t${0}\nend do",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "do": true
        },
        "options": {}
      },
      {
        "content": "do while (${1:condition})\n\t$2\nend do",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dow": true
        },
        "options": {}
      },
      {
        "content": "subroutine ${1:name}($2)\n\t${0}\nend subroutine $1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sub": true
        },
        "options": {}
      },
      {
        "content": "function ${1:name}($2) result($3)\n\t${0}\nend function $1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "func": true
        },
        "options": {}
      },
      {
        "content": "write(*,*) ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pr": true
        },
        "options": {}
      },
      {
        "content": "write(*,*) '$1 = ', $1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dpr": true
        },
        "options": {}
      },
      {
        "content": "read(unit = ${1:fp}, file = ${2:filename}, iostat = ${3:ierr}) ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "read": true
        },
        "options": {}
      },
      {
        "content": "write(unit = ${1:fp}, file = ${2:filename}, iostat = ${3:ierr}) ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "write": true
        },
        "options": {}
      },
      {
        "content": "open(unit = ${1:fp}, file = ${2:filename}, status = ${3:unknown}, iostat = ${4:ierr}) ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "open": true
        },
        "options": {}
      },
      {
        "content": "close(unit = ${1:fp}) ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "close": true
        },
        "options": {}
      }
    ],
    "framer-motion": [
      {
        "content": "import { motion } from 'framer-motion'",
        "doc": "",
        "grammar": "lsp",
        "label": "framer-import",
        "matches": {
          "framer-motion import": true
        },
        "options": {}
      },
      {
        "content": "<motion.${1:div}\n  initial=\"${2:hidden}\"\n  animate=\"${3:visible}\"\n></motion.${1:div}>",
        "doc": "",
        "grammar": "lsp",
        "label": "framer-motion",
        "matches": {
          "framer-motion motion": true,
          "motion": true
        },
        "options": {}
      },
      {
        "content": "const ${1:variants} = {\n  ${2:hidden}: {\n    ${3:style}\n  },\n  ${4:visible}: {\n    ${5:style}\n  },\n};",
        "doc": "",
        "grammar": "lsp",
        "label": "framer-variants",
        "matches": {
          "framer-motion variants": true,
          "variants": true
        },
        "options": {}
      },
      {
        "content": "const ${1:sequence} = async () => {\n  await ${2:animateControls}.start({ ${5:opacity: 1} })\n}",
        "doc": "sequence for animation controls",
        "grammar": "lsp",
        "label": "framer-sequence",
        "matches": {
          "framer-motion sequence": true,
          "sequence": true
        },
        "options": {}
      },
      {
        "content": "const ${controls} = useAnimation()",
        "doc": "useAnimation()\nuseAnimation hook can be used to create a set of imperative AnimationControls with a start and stop method.",
        "grammar": "lsp",
        "label": "framer-use-animation",
        "matches": {
          "framer-motion use-animation": true,
          "use-animation": true
        },
        "options": {}
      },
      {
        "content": "${1:controls}.start({ ${2:opacity: 1} })",
        "doc": "AnimationControls with a start and stop method",
        "grammar": "lsp",
        "label": "framer-animation-controls",
        "matches": {
          "controls": true,
          "framer-motion controls": true
        },
        "options": {}
      },
      {
        "content": "const ${1:scale} = useMotionValue(${2:1})",
        "doc": "useMotionValue()\nCreates a MotionValue to track the state and velocity of a value.",
        "grammar": "lsp",
        "label": "framer-use-motion-value",
        "matches": {
          "framer-motion use-motion-value": true,
          "use-motion-value": true
        },
        "options": {}
      },
      {
        "content": "const ${1:y} = useTransform(${2:x}, ${3:value => value * 2})",
        "doc": "useTransform()\nCreate a MotionValue that transforms the output of another MotionValue through a function.",
        "grammar": "lsp",
        "label": "framer-use-transform",
        "matches": {
          "framer-motion use-transform": true,
          "use-transform": true
        },
        "options": {}
      },
      {
        "content": "const ${1:x} = useSpring(${2:0}, { ${3:stiffness}: ${4:300} })",
        "doc": "useSpring()\nCreates a MotionValue that, when set, will use a spring animation to animate to its new state.",
        "grammar": "lsp",
        "label": "framer-use-spring",
        "matches": {
          "framer-motion use-spring": true,
          "use-spring": true
        },
        "options": {}
      },
      {
        "content": "const { ${1:scrollYProgress} } = useElementScroll(${2:ref})",
        "doc": "useElementScroll(ref): Returns MotionValues that update when the provided element scrolls.",
        "grammar": "lsp",
        "label": "framer-use-element-scroll",
        "matches": {
          "framer-motion use-element-scroll": true,
          "use-element-scroll": true
        },
        "options": {}
      },
      {
        "content": "const { ${scrollYProgress} } = useViewportScroll()",
        "doc": "useViewportScroll(): ScrollMotionValues Returns MotionValues that update when the viewport scrolls.",
        "grammar": "lsp",
        "label": "framer-use-viewport-scroll",
        "matches": {
          "framer-motion use-viewport-scroll": true,
          "use-viewport-scroll": true
        },
        "options": {}
      },
      {
        "content": "const { ${1:scaleX}, ${2:scaleY} } = useInvertedScale()",
        "doc": "useInvertedScale(scale): ScaleMotionValues Returns a MotionValue each for scaleX and scaleY that update with the inverse of their respective parent scales.",
        "grammar": "lsp",
        "label": "framer-use-inverted-scale",
        "matches": {
          "framer-motion use-inverted-scale": true,
          "use-inverted-scale": true
        },
        "options": {}
      },
      {
        "content": "const [${1:x}, ${2:cycleX}] = useCycle(${3:0}, ${4:50}, ${5:100})",
        "doc": "useCycle(items): CycleState It works similar to useState in React. It is provided an initial array of possible states, and returns an array of two arguments.",
        "grammar": "lsp",
        "label": "framer-use-cycle",
        "matches": {
          "framer-motion use-cycle": true,
          "use-cycle": true
        },
        "options": {}
      },
      {
        "content": "const ${shouldReduceMotion} = useReducedMotion()",
        "doc": "A hook that returns true if we should be using reduced motion based on the current device's Reduced Motion setting.",
        "grammar": "lsp",
        "label": "framer-use-reduce-motion",
        "matches": {
          "framer-motion use-reduce-motion": true,
          "use-reduce-motion": true
        },
        "options": {}
      },
      {
        "content": "const [${1:isPresent}, ${2:safeToRemove}] = usePresence()",
        "doc": "usePresence()\nIf isPresent is false, it means that a component has been removed the tree, but AnimatePresence won't really remove it until safeToRemove has been called.",
        "grammar": "lsp",
        "label": "framer-use-presence",
        "matches": {
          "framer-motion use-presence": true,
          "use-presence": true
        },
        "options": {}
      },
      {
        "content": "const ${dragControls} = useDragControls()",
        "doc": "useDragControls()\nBy creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop.",
        "grammar": "lsp",
        "label": "framer-use-drag-controls",
        "matches": {
          "framer-motion use-drag-controls": true,
          "use-drag-controls": true
        },
        "options": {}
      },
      {
        "content": "import { motion, AnimatePresence } from \"framer-motion\"",
        "doc": "",
        "grammar": "lsp",
        "label": "framer-animate-presence-import",
        "matches": {
          "animate-presence": true,
          "framer-motion import animate-presence": true
        },
        "options": {}
      },
      {
        "content": "<AnimatePresence>\n    {${1:isVisible} && (\n      <motion.div\n        initial={{ ${3:style} }}\n        animate={{ ${4:style} }}\n        exit={{ ${5:style} }}\n      />\n    )}\n</AnimatePresence>",
        "doc": "AnimatePresence allows components to animate out when they're removed from the React tree.",
        "grammar": "lsp",
        "label": "framer-animate-presence",
        "matches": {
          "animate-presence": true,
          "framer-motion animate-presence": true
        },
        "options": {}
      },
      {
        "content": "import { motion, AnimateSharedLayout } from \"framer-motion\"",
        "doc": "",
        "grammar": "lsp",
        "label": "framer-import-animate-shared-layout",
        "matches": {
          "animate-presence": true,
          "framer-motion import animate-shared-layout": true
        },
        "options": {}
      },
      {
        "content": "<AnimateSharedLayout>\n</AnimateSharedLayout>",
        "doc": "Animate between different components that share a layout ID",
        "grammar": "lsp",
        "label": "framer-animate-shared-layout",
        "matches": {
          "animate-shared-layout": true,
          "framer-motion animate-shared-layout": true
        },
        "options": {}
      }
    ],
    "freemarker": [
      {
        "content": "\\${.version}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ver \"${.version}\"": true
        },
        "options": {}
      },
      {
        "content": "\\${${0:interpolation${VISUAL}}\\}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "int \"${interpolation}\"": true
        },
        "options": {}
      },
      {
        "content": "\\${${0:interpolation${VISUAL}}!\"${1:default_string}\"\\}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "intd \"${interpolation!\"default_string\"}\"": true
        },
        "options": {}
      },
      {
        "content": "<#-- ${0:comment${VISUAL}} -->",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "com \"<#-- comment -->\"": true
        },
        "options": {}
      },
      {
        "content": "<#assign ${1:variable_name} = ${0:value${VISUAL}} />",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ass \"<#assign variable_name = value />\"": true
        },
        "options": {}
      },
      {
        "content": "<#assign\n\t${1:variable_name} = ${0:value${VISUAL}}\n/>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "assm \"<#assign <#-- multiple lines --> />\"": true
        },
        "options": {}
      },
      {
        "content": "<#local ${1:variable_name} = ${0:value${VISUAL}} />",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "loc \"<#local variable_name = value />\"": true
        },
        "options": {}
      },
      {
        "content": "<#local\n\t${1:variable_name} = ${0:value${VISUAL}}\n/>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "locm \"<#local <#-- multiple lines --> />\"": true
        },
        "options": {}
      },
      {
        "content": "<#include \"${0:file.ftl${VISUAL}}\" />",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "inc \"<#include \\\"file.ftl\\\" />\"": true
        },
        "options": {}
      },
      {
        "content": "<#if ${1:true}>\n\t${0:${VISUAL}}\n</#if>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if \"<#if condition>...</#if>\"": true
        },
        "options": {}
      },
      {
        "content": "<#if ${1:true}>\n\t${0:${VISUAL}}\n<#else>\n\t${2}\n</#if>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife \"<#if condition>...<#else>...</#if>\"": true
        },
        "options": {}
      },
      {
        "content": "<#list ${1:sequence} as ${2:element}>\n\t${0:${VISUAL}}\n</#list>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lis \"<#list sequence as element>...</#list>\"": true
        },
        "options": {}
      },
      {
        "content": "<#list ${1:hashmap}?keys as ${2:key}>\n\t\\${$2\\}: \\${$1[$2]\\}${0:${VISUAL}}\n</#list>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lish \"<#list hashmap?keys as element>...</#list>\"": true
        },
        "options": {}
      },
      {
        "content": "<#macro ${1:macro_name} ${2:param1}>\n\t${0:${VISUAL}}\n</#macro>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mac \"<#macro macro_name param1>...</#macro>\"": true
        },
        "options": {}
      },
      {
        "content": "<#function ${1:function_name} ${2:param1}>\n\t${0:${VISUAL}}\n</#function>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fun \"<#function function_name param1>...</#function>\"": true
        },
        "options": {}
      },
      {
        "content": "<#attempt>\n\t${0:${VISUAL}}\n<#recover>\n</#attempt>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "att \"<#attempt>...<#recover></#attempt>\"": true
        },
        "options": {}
      },
      {
        "content": "?then(${1:true}, ${0:false${VISUAL}})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "?th \"?then(true, false)\"": true
        },
        "options": {}
      }
    ],
    "fsharp": [
      {
        "content": "if ${1:TARGET}\nthen ${2}\nelse ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "if..then..else",
        "matches": {
          "If": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "if ${1:TARGET} then ${2} else ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "if..then..else - oneline",
        "matches": {
          "if": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "match ${1:TARGET} with\n| ${2} -> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "match",
        "matches": {
          "match": true
        },
        "options": {}
      },
      {
        "content": "(fun ${1:x} -> ${2:x})",
        "doc": "",
        "grammar": "snu",
        "label": "(fun x -> ..)",
        "matches": {
          "fun": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "[| ${0:TARGET} |]",
        "doc": "",
        "grammar": "snu",
        "label": "array literal [| |]",
        "matches": {
          "arl": true
        },
        "options": {}
      },
      {
        "content": "[<${0:TARGET}>]",
        "doc": "",
        "grammar": "snu",
        "label": "attribute [<..>]",
        "matches": {
          "att": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "#if ${1}\n  ${2:TARGET}\n#endif",
        "doc": "",
        "grammar": "snu",
        "label": "#if .. #endif",
        "matches": {
          "#if": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "#if ${1}\n  ${2}\nelse\n  #{3}\n#endif",
        "doc": "",
        "grammar": "snu",
        "label": "#if .. else .. #endif",
        "matches": {
          "#ife": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "__SOURCE_DIRECTORY__",
        "doc": "",
        "grammar": "snu",
        "label": "__SOURCE_DIRECTORY__",
        "matches": {
          "sourced": true
        },
        "options": {}
      },
      {
        "content": "__LINE__",
        "doc": "",
        "grammar": "snu",
        "label": "__LINE__",
        "matches": {
          "line": true
        },
        "options": {}
      },
      {
        "content": "__SOURCE_FILE__",
        "doc": "",
        "grammar": "snu",
        "label": "__FILE__",
        "matches": {
          "sourcef": true
        },
        "options": {}
      },
      {
        "content": "/// ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "doc": true
        },
        "options": {}
      },
      {
        "content": "// ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "comment": true
        },
        "options": {}
      },
      {
        "content": "let ${1} = ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "let": true
        },
        "options": {}
      },
      {
        "content": "[<Literal>]\nlet ${1} = ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lit": true
        },
        "options": {}
      },
      {
        "content": "type ${1} = { ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rec": true
        },
        "options": {}
      },
      {
        "content": "{| ${0} |}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "arec": true
        },
        "options": {}
      },
      {
        "content": "let ${1} =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fn": true
        },
        "options": {}
      },
      {
        "content": "let rec ${1} =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fnr": true
        },
        "options": {}
      },
      {
        "content": "(fun ${1} -> ${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lam": true
        },
        "options": {}
      },
      {
        "content": "module ${1} =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mod": true
        },
        "options": {}
      },
      {
        "content": "for ${1} in ${2} do\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "if ${1} then\n\t${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "if ${1} then\n\t${2}\nelse\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "if ${1} then\n\t${2}\nelif ${3} then\n\t${4}\nelse\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifee": true
        },
        "options": {}
      },
      {
        "content": "elif ${1} then\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eif": true
        },
        "options": {}
      },
      {
        "content": "else\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "el": true
        },
        "options": {}
      },
      {
        "content": "try\n\t${1}\nwith ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "try": true
        },
        "options": {}
      },
      {
        "content": "match ${1} with\n| ${2} -> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "match": true
        },
        "options": {}
      },
      {
        "content": "| ${1} -> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "|": true
        },
        "options": {}
      },
      {
        "content": "|> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p": true
        },
        "options": {}
      },
      {
        "content": "printfn \"${1}\" ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pr": true
        },
        "options": {}
      },
      {
        "content": "printfn \\$\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pri": true
        },
        "options": {}
      },
      {
        "content": "|> Array.map (fun ${1} -> ${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "amap": true
        },
        "options": {}
      },
      {
        "content": "|> List.map (fun ${1} -> ${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lmap": true
        },
        "options": {}
      },
      {
        "content": "|> Seq.map (fun ${1} -> ${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "smap": true
        },
        "options": {}
      },
      {
        "content": "|> Array.map (fun x -> printfn \"%A\" x; x) // tap",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "atap": true
        },
        "options": {}
      },
      {
        "content": "|> List.map (fun x -> printfn \"%A\" x; x) // tap",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ltap": true
        },
        "options": {}
      },
      {
        "content": "|> Seq.map (fun x -> printfn \"%A\" x; x) // tap",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "stap": true
        },
        "options": {}
      },
      {
        "content": "[<EntryPoint>]\nlet main argv =\n\t${0}\n\t0",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "main": true
        },
        "options": {}
      }
    ],
    "gatsby": [
      {
        "content": "import { graphql } from 'gatsby';",
        "doc": "",
        "grammar": "lsp",
        "label": "gatsby-graphql-import",
        "matches": {
          "gatsby import graphql": true
        },
        "options": {}
      },
      {
        "content": "import { useStaticQuery, graphql } from \"gatsby\"",
        "doc": "",
        "grammar": "lsp",
        "label": "gatsby-usestaticquery-import",
        "matches": {
          "gatsby import usestaticquery": true
        },
        "options": {}
      },
      {
        "content": "const {${1:site}} = useStaticQuery(\n  graphql`${2:query}`\n);",
        "doc": "",
        "grammar": "lsp",
        "label": "gatsby-usestatic-query",
        "matches": {
          "gatsby usestaticquery": true
        },
        "options": {}
      },
      {
        "content": "export const query = graphql`${1:query}`;",
        "doc": "Gatsby uses the concept of a page query, which is a query for a specific page in a site.Note that you can only have one page query per file.",
        "grammar": "lsp",
        "label": "gatsby-export-query",
        "matches": {
          "gatsby export query": true
        },
        "options": {}
      },
      {
        "content": "<Link to=\"${1:/blog}\">${2:Text}</Link>",
        "doc": "",
        "grammar": "lsp",
        "label": "gatsby-link",
        "matches": {
          "gatsby link": true
        },
        "options": {}
      },
      {
        "content": "<Link to=\"${1:/blog}\" activeStyle={{ ${2:color}: \"${3:red}\" }} >Text</Link>",
        "doc": "",
        "grammar": "lsp",
        "label": "gatsby-link-activestyle",
        "matches": {
          "gatsby link activestyle": true
        },
        "options": {}
      },
      {
        "content": "<Link to=\"${1:/blog}\" activeClassName={\"${2:myActiveClassName}\"} >Text</Link>",
        "doc": "",
        "grammar": "lsp",
        "label": "gatsby-link-activeclassname",
        "matches": {
          "gatsby link activeclassname": true
        },
        "options": {}
      },
      {
        "content": "import { Link } from \"gatsby\"",
        "doc": "",
        "grammar": "lsp",
        "label": "gatsby-link-import",
        "matches": {
          "gatsby link import": true
        },
        "options": {}
      }
    ],
    "gatsby-image": [
      {
        "content": "const {\n  ${1:queryName}: { childImageSharp: {fluid: ${2:imageFluid}}}\n} = useStaticQuery(graphql`\n  query {\n    ${1:queryName}: file(relativePath: { eq: \"${3:imagePath.png}\" }) {\n      childImageSharp {\n        fluid(maxWidth: ${4:300}) {\n          ...${5|GatsbyImageSharpFluid,GatsbyImageSharpFluid_noBase64,GatsbyImageSharpFluid_tracedSVG,GatsbyImageSharpFluid_withWebp,GatsbyImageSharpFluid_withWebp_noBase64,GatsbyImageSharpFluid_withWebp_tracedSVG|}\n        }\n      }\n    }\n  }\n`)",
        "doc": "",
        "grammar": "lsp",
        "label": "gatsby-image-usestaticquery-fluid",
        "matches": {
          "gatsby-image usestaticquery fluid": true
        },
        "options": {}
      },
      {
        "content": "const {\n  ${1:queryName}: { childImageSharp: {fixed: ${2:imageFixed}}}\n} = useStaticQuery(graphql`\n  query {\n    ${1:queryName}: file(relativePath: { eq: \"${3:imagePath.png}\" }) {\n      childImageSharp {\n        fixed(width: ${4:300}) {\n          ...${5|GatsbyImageSharpFixed,GatsbyImageSharpFixed_noBase64,GatsbyImageSharpFixed_tracedSVG,GatsbyImageSharpFixed_withWebp,GatsbyImageSharpFixed_withWebp_noBase64,GatsbyImageSharpFixed_withWebp_tracedSVG|}\n        }\n      }\n    }\n  }\n`)",
        "doc": "",
        "grammar": "lsp",
        "label": "gatsby-image-usestaticquery-fixed",
        "matches": {
          "gatsby-image usestaticquery fixed": true
        },
        "options": {}
      },
      {
        "content": "import ${1:Img} from 'gatsby-image';",
        "doc": "",
        "grammar": "lsp",
        "label": "gatsby-image-import",
        "matches": {
          "gatsby-image import": true
        },
        "options": {}
      },
      {
        "content": "import ${1:Img} from \"gatsby-image/withIEPolyfill\"",
        "doc": "",
        "grammar": "lsp",
        "label": "gatsby-image-import-withiepolyfill",
        "matches": {
          "gatsby-image import withiepolyfill": true
        },
        "options": {}
      }
    ],
    "gitcommit": [
      {
        "content": "Co-authored-by: ${1} <${2}>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "co": true
        },
        "options": {}
      },
      {
        "content": "fix(${1:scope}): ${2:title}\n\n${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "fix conventional commit",
        "matches": {
          "fix": true
        },
        "options": {}
      },
      {
        "content": "feat(${1:scope}): ${2:title}\n\n${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "feat conventional commit",
        "matches": {
          "feat": true
        },
        "options": {}
      },
      {
        "content": "chore(${1:scope}): ${2:title}\n\n${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "chore conventional commit",
        "matches": {
          "chore": true
        },
        "options": {}
      },
      {
        "content": "docs(${1:scope}): ${2:title}\n\n${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "docs conventional commit",
        "matches": {
          "docs": true
        },
        "options": {}
      },
      {
        "content": "improvement(${1:scope}): ${2:title}\n\n${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "improvement conventional commit",
        "matches": {
          "improvement": true
        },
        "options": {}
      },
      {
        "content": "perf(${1:scope}): ${2:title}\n\n${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "perf conventional commit",
        "matches": {
          "perf": true
        },
        "options": {}
      },
      {
        "content": "refactor(${1:scope}): ${2:title}\n\n${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "refactor conventional commit",
        "matches": {
          "refactor": true
        },
        "options": {}
      },
      {
        "content": "test(${1:scope}): ${2:title}\n\n${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "test conventional commit",
        "matches": {
          "test": true
        },
        "options": {}
      },
      {
        "content": "ci(${1:scope}): ${2:title}\n\n${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "ci conventional commit",
        "matches": {
          "ci": true
        },
        "options": {}
      },
      {
        "content": "build(${1:scope}): ${2:title}\n\n${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "build conventional commit",
        "matches": {
          "build": true
        },
        "options": {}
      }
    ],
    "gnuplot": [
      {
        "content": "set ${1:#:axis}range [${2:*}:${3:*}]",
        "doc": "",
        "grammar": "snu",
        "label": "set x/y range.",
        "matches": {
          "range": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "set xrange [${1:*}:${2:*}]",
        "doc": "",
        "grammar": "snu",
        "label": "set xrange [X1:X2]",
        "matches": {
          "xrange": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "set yrange [${1:*}:${2:*}]",
        "doc": "",
        "grammar": "snu",
        "label": "set yrange [Y1:Y2]",
        "matches": {
          "yrange": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "set title ${1:#:title}",
        "doc": "",
        "grammar": "snu",
        "label": "set title '...'",
        "matches": {
          "title": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "set ${1:#:axis}label ${2:#:label}",
        "doc": "",
        "grammar": "snu",
        "label": "set title '...'",
        "matches": {
          "labelaxis": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "set ${1:#:axis}tics ${2:#:start}, ${3:#:incr}, ${4:#:end}",
        "doc": "",
        "grammar": "snu",
        "label": "set x/y tics start, incr, end",
        "matches": {
          "tics": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "set xtics ${1:#:start}, ${2:#:incr}, ${3:#:end}",
        "doc": "",
        "grammar": "snu",
        "label": "set xtics start, incr, end",
        "matches": {
          "xtics": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "set ytics ${1:#:start}, ${2:#:incr}, ${3:#:end}",
        "doc": "",
        "grammar": "snu",
        "label": "set ytics start, incr, end",
        "matches": {
          "ytics": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "set datafile separator '${1:#:separator}'",
        "doc": "",
        "grammar": "snu",
        "label": "set datafile separator 'separator'",
        "matches": {
          "datasep": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "set terminal ${1:#:terminal}",
        "doc": "",
        "grammar": "snu",
        "label": "set terminal",
        "matches": {
          "term": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "set output '${1:#:filename}'",
        "doc": "",
        "grammar": "snu",
        "label": "set output 'filename'",
        "matches": {
          "out": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "set key",
        "doc": "",
        "grammar": "snu",
        "label": "set key",
        "matches": {
          "key": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "unset key",
        "doc": "",
        "grammar": "snu",
        "label": "unset key",
        "matches": {
          "key!": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "set grid",
        "doc": "",
        "grammar": "snu",
        "label": "set grid",
        "matches": {
          "grid": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "unset grid",
        "doc": "",
        "grammar": "snu",
        "label": "unset grid",
        "matches": {
          "grid!": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "set border",
        "doc": "",
        "grammar": "snu",
        "label": "set border",
        "matches": {
          "border": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "print(${1:#:string}}",
        "doc": "",
        "grammar": "snu",
        "label": "print",
        "matches": {
          "print": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "sprintf('${1:#:format}', ${2:#:vars})",
        "doc": "",
        "grammar": "snu",
        "label": "sprintf",
        "matches": {
          "sprintf": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "set multiplot\n${1:#:plot code}\nunset multiplot",
        "doc": "",
        "grammar": "snu",
        "label": "set multiplot ... unset multiplot",
        "matches": {
          "multiplot": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "if (${1:#:condition}) {\n    ${2:#:commands}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if (...) {...}",
        "matches": {
          "if": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "else {\n    ${1:#:commands}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "else {...}",
        "matches": {
          "else": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "if (${1:#:condition}) {\n    ${2:#:commands}\n} else {\n    ${3:#:commands}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if (...) {...} else {...}",
        "matches": {
          "ifelse": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "while (${1:#:expression}) {\n    ${2:#:commands}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "while (...) {...}",
        "matches": {
          "while": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "do for ${1:#:iter} {\n    ${2:#:commands}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "do for <iter> {...}",
        "matches": {
          "do": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "for [${1:str} in '${2:#:string list}']",
        "doc": "",
        "grammar": "snu",
        "label": "for [string in \"A B C...\"]",
        "matches": {
          "fors": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "for [${1:i} = ${2:#:start}, ${3:#:end}, ${4:1}",
        "doc": "",
        "grammar": "snu",
        "label": "for [intvar = start, end, incr]",
        "matches": {
          "fori": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "set logscale ${1:#:axis}",
        "doc": "",
        "grammar": "snu",
        "label": "set logscale <axis>",
        "matches": {
          "logscale": true
        },
        "options": {
          "head": true
        }
      }
    ],
    "go": [
      {
        "content": "package main\nimport (\n  \"fmt\"\n)\nfunc main() {\n  fmt.Printf(\"Hello, world\\n\")\n}",
        "doc": "",
        "grammar": "snu",
        "label": "package main\\nimport fmt...",
        "matches": {
          "helloworld": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "func ${1:fname}(${2}) ${3:int }{\n  ${0:TARGET:return }\n}",
        "doc": "",
        "grammar": "snu",
        "label": "func ...() { ... }",
        "matches": {
          "fn": true,
          "func": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "import (\n  \"${1:fmt}\"\n)\n${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "im": true,
          "import": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "package ${1:main}\n${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "package": true,
          "pk": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "fmt.Printf(\"${1}\\n\"${2:})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pf": true,
          "printf": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "fmt.Println(${0:TARGET})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pl": true,
          "println": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "type ${1} struct {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "struct": true,
          "ts": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "type ${1} interface {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "interface": true,
          "ti": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "for ${1} {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "for ${1:v} := range ${2:#:iterator} {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "for range",
        "matches": {
          "range": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "if ${1:#:condition} {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "switch ${1:#:v} {\ncase ${2:#:condition}:\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "switch {}",
        "matches": {
          "switch": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "select {\ncase ${1:#:condition}:\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "select {}",
        "matches": {
          "select": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "case ${1:#:condition}:\n  ${2:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "func Test${1} (${2:t *testing.T}) {\n  for i := 0; i < ${3:t.N}; i++ {\n    ${4}\n  }\n}",
        "doc": "",
        "grammar": "snu",
        "label": "func Test... (t *testing.T) { ... }",
        "matches": {
          "funcTest": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "func Benchmark${1} (${2:b *testing.B}) {\n  for i := 0; i < ${3:b.N}; i++ {\n    ${4}\n  }\n}",
        "doc": "",
        "grammar": "snu",
        "label": "func Benchmark... (b *testing.B) { ... }",
        "matches": {
          "funcbench": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "var tests = []struct {\n    name string\n    expected string\n    given string\n}{\n    {\"${2}\", \"${3}\", \"${4}\",},\n}\nfor _, tt := range tests {\n    tt := tt\n    t.Run(tt.name, func(t *testing.T){\n        actual := ${1:Function}(tt.given)\n        if actual != tt.expected {\n            t.Errorf(\"given(%s): expected %s, actual %s\", tt.given, tt.expected, actual)\n        }\n    })\n}",
        "doc": "",
        "grammar": "snu",
        "label": "var test = {...}{...} for {t.Run(){...}}",
        "matches": {
          "testtable": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "${1} := ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "v := value",
        "matches": {
          ":": true
        },
        "options": {}
      },
      {
        "content": "${1:fn} := func() {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "fn := func() { ... }",
        "matches": {
          "anon": true
        },
        "options": {}
      },
      {
        "content": "append(${1:slice}, ${0:value})",
        "doc": "",
        "grammar": "snu",
        "label": "append(slice, value)",
        "matches": {
          "ap": true
        },
        "options": {}
      },
      {
        "content": "${1:slice} = append($1, ${0:value})",
        "doc": "",
        "grammar": "snu",
        "label": "slice = append(slice, value)",
        "matches": {
          "ap=": true
        },
        "options": {}
      },
      {
        "content": "break",
        "doc": "",
        "grammar": "snu",
        "label": "break",
        "matches": {
          "br": true
        },
        "options": {}
      },
      {
        "content": "chan ${0:int}",
        "doc": "",
        "grammar": "snu",
        "label": "chan Type",
        "matches": {
          "ch": true
        },
        "options": {}
      },
      {
        "content": "case ${1:value}:\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "case ...:",
        "matches": {
          "case": true
        },
        "options": {}
      },
      {
        "content": "const ${1:NAME} ${2:Type} = ${0:0}",
        "doc": "",
        "grammar": "snu",
        "label": "const XXX Type = ...",
        "matches": {
          "con": true
        },
        "options": {}
      },
      {
        "content": "const (\n\t${1:NAME} ${2:Type} = ${3:value}\n\t${0}\n)",
        "doc": "",
        "grammar": "snu",
        "label": "const ( ... )",
        "matches": {
          "cons": true
        },
        "options": {}
      },
      {
        "content": "const (\n\t${1:NAME} ${2:Type} = iota\n\t${0}\n)",
        "doc": "",
        "grammar": "snu",
        "label": "const ( ... = iota )",
        "matches": {
          "iota": true
        },
        "options": {}
      },
      {
        "content": "continue",
        "doc": "",
        "grammar": "snu",
        "label": "continue",
        "matches": {
          "cn": true
        },
        "options": {}
      },
      {
        "content": "default:\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "default: ...",
        "matches": {
          "default": true
        },
        "options": {}
      },
      {
        "content": "defer ${1:func}(${2})\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "defer someFunction()",
        "matches": {
          "df": true
        },
        "options": {}
      },
      {
        "content": "defer func() {\n\t${0}\n}()",
        "doc": "",
        "grammar": "snu",
        "label": "defer func() { ... }",
        "matches": {
          "def": true
        },
        "options": {}
      },
      {
        "content": "defer func() {\n\tif err := recover(); err != nil {\n\t\t${0}\n\t}\n}()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defr": true
        },
        "options": {}
      },
      {
        "content": "import (\n\t\"${1:package}\"\n)",
        "doc": "",
        "grammar": "snu",
        "label": "import ( ... )",
        "matches": {
          "import": true
        },
        "options": {}
      },
      {
        "content": "type ${1:Interface} interface {\n\t${2:/* TODO: add methods */}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "interface I { ... }",
        "matches": {
          "interface": true
        },
        "options": {}
      },
      {
        "content": "if ${1:condition} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "else { ... }",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "else {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "else": true
        },
        "options": {}
      },
      {
        "content": "if err := ${1:condition}; err != nil {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if err := ...; err != nil { ... }",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "if err != nil {\n\treturn err\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "if err != nil { return err }",
        "matches": {
          "errn": true
        },
        "options": {}
      },
      {
        "content": "if err != nil {\n\tt.Fatal(err)\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if err != nil { t.Fatal(err) }",
        "matches": {
          "errt": true
        },
        "options": {}
      },
      {
        "content": "if err != nil {\n\tlog.Fatal(err)\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if err != nil { log.Fatal(err) }",
        "matches": {
          "errl": true
        },
        "options": {}
      },
      {
        "content": "if err != nil {\n\treturn ${1:nil}, err\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "if err != nil { return [...], err }",
        "matches": {
          "errn,": true
        },
        "options": {}
      },
      {
        "content": "if err != nil {\n\t${1}\n\treturn\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "if err != nil { ... return }",
        "matches": {
          "errh": true
        },
        "options": {}
      },
      {
        "content": "if err != nil {\n\tpanic(${1})\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "if err != nil { panic(...) }",
        "matches": {
          "errp": true
        },
        "options": {}
      },
      {
        "content": "fallthrough",
        "doc": "",
        "grammar": "snu",
        "label": "fallthrough",
        "matches": {
          "ft": true
        },
        "options": {}
      },
      {
        "content": "for ${1} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "for ... { ... }",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "for ${1:i} := 0; $1 < ${2:N}; $1++ {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "for 0..N-1 { ... }",
        "matches": {
          "fori": true
        },
        "options": {}
      },
      {
        "content": "for ${2:k}, ${3:v} := range ${1} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "for k, v := range items { ... }",
        "matches": {
          "forr": true
        },
        "options": {}
      },
      {
        "content": "func ${1:function}(${2}) ${3:error }{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "func function(...) [error] { ... }",
        "matches": {
          "func": true
        },
        "options": {}
      },
      {
        "content": "fmt.Printf(\"${1} = %+v\\n\", $1)\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "fmt.Printf(...)",
        "matches": {
          "ff": true
        },
        "options": {}
      },
      {
        "content": "fmt.Println(\"${1}\")",
        "doc": "",
        "grammar": "snu",
        "label": "fmt.Println(...)",
        "matches": {
          "fn": true
        },
        "options": {}
      },
      {
        "content": "fmt.Errorf(\"${1}\")",
        "doc": "",
        "grammar": "snu",
        "label": "fmt.Errorf(...)",
        "matches": {
          "fe": true
        },
        "options": {}
      },
      {
        "content": "log.Printf(\"${1} = %+v\\n\", $1)",
        "doc": "",
        "grammar": "snu",
        "label": "log.Printf(...)",
        "matches": {
          "lf": true
        },
        "options": {}
      },
      {
        "content": "log.Println(\"${1}\")",
        "doc": "",
        "grammar": "snu",
        "label": "log.Println(...)",
        "matches": {
          "ln": true
        },
        "options": {}
      },
      {
        "content": "make(${1:[]string}, ${2:0})${0}",
        "doc": "",
        "grammar": "snu",
        "label": "make(Type, size)",
        "matches": {
          "make": true
        },
        "options": {}
      },
      {
        "content": "map[${1:string}]${0:int}",
        "doc": "",
        "grammar": "snu",
        "label": "map[Type]Type",
        "matches": {
          "map": true
        },
        "options": {}
      },
      {
        "content": "func main() {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "func main() { ... }",
        "matches": {
          "main": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "func (${1:self} ${2:Type}) ${3:Do}(${4}) ${5:error }{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "func (self Type) Method(...) [error] { ... }",
        "matches": {
          "meth": true
        },
        "options": {}
      },
      {
        "content": "if !ok {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if !ok { ... }",
        "matches": {
          "ok": true
        },
        "options": {}
      },
      {
        "content": "// Package $1 provides ${2:...}\npackage ${1:main}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "package ...",
        "matches": {
          "package": true
        },
        "options": {}
      },
      {
        "content": "panic(\"${0}\")",
        "doc": "",
        "grammar": "snu",
        "label": "panic(\"...\")",
        "matches": {
          "panic": true,
          "pn": true
        },
        "options": {}
      },
      {
        "content": "return ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "return ...",
        "matches": {
          "return": true,
          "rt": true
        },
        "options": {}
      },
      {
        "content": "select {\ncase ${1:v1} := <-${2:chan1}\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "select { case a := <-chan: ... }",
        "matches": {
          "select": true
        },
        "options": {}
      },
      {
        "content": "type ${1:Type} struct {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "type T struct { ... }",
        "matches": {
          "st": true
        },
        "options": {}
      },
      {
        "content": "switch ${1:var} {\ncase ${2:value1}:\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "switch x { ... }",
        "matches": {
          "switch": true
        },
        "options": {}
      },
      {
        "content": "fmt.Sprintf(\"%${1:s}\", ${2:var})",
        "doc": "",
        "grammar": "snu",
        "label": "fmt.Sprintf(...)",
        "matches": {
          "sp": true
        },
        "options": {}
      },
      {
        "content": "go ${1:funcName}(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "go someFunc(...)",
        "matches": {
          "go": true
        },
        "options": {}
      },
      {
        "content": "go func(${1}) {\n\t${3:/* TODO */}\n}(${2})",
        "doc": "",
        "grammar": "snu",
        "label": "go func(...) { ... }(...)",
        "matches": {
          "gof": true
        },
        "options": {}
      },
      {
        "content": "func Test${1:Function}(t *testing.T) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "func TestXYZ(t *testing.T) { ... }",
        "matches": {
          "test": true
        },
        "options": {}
      },
      {
        "content": "t.Run(\"${0}\", func(t *testing.T){\n})",
        "doc": "",
        "grammar": "snu",
        "label": "t.Run(\"test name\", func(t *testing.T){ ... })",
        "matches": {
          "tr": true
        },
        "options": {}
      },
      {
        "content": "var tests = []struct {\n    name string\n    expected string\n    given string\n}{\n    {\"${2}\", \"${3}\", \"${4}\",},\n}\nfor _, tt := range tests {\n    tt := tt\n    t.Run(tt.name, func(t *testing.T){\n        actual := ${1:Function}(tt.given)\n        if actual != tt.expected {\n            t.Errorf(\"given(%s): expected %s, actual %s\", tt.given, tt.expected, actual)\n        }\n    })\n}",
        "doc": "",
        "grammar": "snu",
        "label": "var test = {...}{...} for {t.Run(){...}}",
        "matches": {
          "tt": true
        },
        "options": {}
      },
      {
        "content": "if err != nil {\n  t.Errorf(\"${1}\")\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if err != nil { t.Errorf(...) }",
        "matches": {
          "ter": true
        },
        "options": {}
      },
      {
        "content": "if err != nil {\n  t.Fatalf(\"${1}\")\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if err != nil { t.Fatalf(...) }",
        "matches": {
          "terf": true
        },
        "options": {}
      },
      {
        "content": "func Example${1:Method}() {\n\t${0}\n\t// Output:\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "example": true
        },
        "options": {}
      },
      {
        "content": "func Benchmark${1:Method}(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\t${0}\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "benchmark": true
        },
        "options": {}
      },
      {
        "content": "if !reflect.DeepEqual(${1:expected}, ${2:actual}) {\n\t_, file, line, _ := runtime.Caller(0)\n\tfmt.Printf(\"%s:%d:\\n\\n\\texp: %#v\\n\\n\\tgot: %#v\\n\\n\", filepath.Base(file), line, $1, $2)\n\tt.FailNow()\n}",
        "doc": "",
        "grammar": "snu",
        "label": "equals: test two identifiers with DeepEqual",
        "matches": {
          "eq": true
        },
        "options": {}
      },
      {
        "content": "func ${1:handler}(w http.ResponseWriter, r *http.Request) {\n  ${0:fmt.Fprintf(w, \"hello world\")}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "http.HandlerFunc",
        "matches": {
          "hf": true
        },
        "options": {}
      },
      {
        "content": "${1:http}.HandleFunc(\"${2:/}\", func(w http.ResponseWriter, r *http.Request) {\n  ${0:fmt.Fprintf(w, \"hello world\")}\n})",
        "doc": "",
        "grammar": "snu",
        "label": "mux.HandleFunc(...)",
        "matches": {
          "hhf": true
        },
        "options": {}
      },
      {
        "content": "${1} := ${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "v \"shorthand variable declaration\"": true
        },
        "options": {}
      },
      {
        "content": "var ${1:t} ${0:string}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vr \"variable initialization\"": true
        },
        "options": {}
      },
      {
        "content": "var ${1} ${2} = ${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "var \"variable declaration\"": true
        },
        "options": {}
      },
      {
        "content": "var (\n\t${1} ${2} = ${3}\n)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vars \"variables declaration\"": true
        },
        "options": {}
      },
      {
        "content": "append(${1:slice}, ${0:value})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ap \"append\"": true
        },
        "options": {}
      },
      {
        "content": "bool",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bl \"bool\"": true
        },
        "options": {}
      },
      {
        "content": "byte",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bt \"byte\"": true
        },
        "options": {}
      },
      {
        "content": "break",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "br \"break\"": true
        },
        "options": {}
      },
      {
        "content": "chan ${0:int}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ch \"channel\"": true
        },
        "options": {}
      },
      {
        "content": "case ${1:value}:\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cs \"case\"": true
        },
        "options": {}
      },
      {
        "content": "const (\n\t${1:NAME1} = iota\n\t${0:NAME2}\n)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "co \"constants with iota\"": true
        },
        "options": {}
      },
      {
        "content": "continue",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cn \"continue\"": true
        },
        "options": {}
      },
      {
        "content": "defer ${0:func}()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "df \"defer\"": true
        },
        "options": {}
      },
      {
        "content": "defer func() {\n\tif err := recover(); err != nil {\n\t\t${0:${VISUAL}}\n\t}\n}()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dfr \"defer recover\"": true
        },
        "options": {}
      },
      {
        "content": "import (\n\t\"${1:package}\"\n)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "im \"import\"": true
        },
        "options": {}
      },
      {
        "content": "interface{}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "in \"interface\"": true
        },
        "options": {}
      },
      {
        "content": "interface ${1:name} {\n\t${2:/* methods */}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "inf \"full interface \"": true
        },
        "options": {}
      },
      {
        "content": "if ${1:/* condition */} {\n\t${2:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if \"if condition\"": true
        },
        "options": {}
      },
      {
        "content": "if ${1:/* condition */} {\n\t${2:${VISUAL}}\n} else {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife \"if else condition\"": true
        },
        "options": {}
      },
      {
        "content": "else {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "el \"else\"": true
        },
        "options": {}
      },
      {
        "content": "if err != nil {\n\treturn err\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ir \"if error not nil, return err\"": true
        },
        "options": {}
      },
      {
        "content": "false",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "f \"false\"": true
        },
        "options": {}
      },
      {
        "content": "fallthrough",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ft \"fallthrough\"": true
        },
        "options": {}
      },
      {
        "content": "float32",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fl \"float\"": true
        },
        "options": {}
      },
      {
        "content": "float32",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "f3 \"float32\"": true
        },
        "options": {}
      },
      {
        "content": "float64",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "f6 \"float64\"": true
        },
        "options": {}
      },
      {
        "content": "for ${1}{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for \"for loop\"": true
        },
        "options": {}
      },
      {
        "content": "for ${2:i} := 0; $2 < ${1:count}; $2${3:++} {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fori \"for int loop\"": true
        },
        "options": {}
      },
      {
        "content": "for ${1:e} := range ${2:collection} {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forr \"for range loop\"": true
        },
        "options": {}
      },
      {
        "content": "func ${1:funcName}(${2}) ${3:error} {\n\t${4}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fun \"function\"": true
        },
        "options": {}
      },
      {
        "content": "func (${1:receiver} ${2:type}) ${3:funcName}(${4}) ${5:error} {\n\t${6}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fum \"method\"": true
        },
        "options": {}
      },
      {
        "content": "func (${1:receiver} ${2:type}) ${3:funcName}(${4:w} http.ResponseWriter, ${5:r} *http.Request) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fumh \"http handler function on receiver\"": true
        },
        "options": {}
      },
      {
        "content": "log.Printf(\"%${1:s}\", ${2:var})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lf \"log printf\"": true
        },
        "options": {}
      },
      {
        "content": "log.Println(\"${1}\")",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lp \"log println\"": true
        },
        "options": {}
      },
      {
        "content": "make(${1:[]string}, ${0:0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mk \"make\"": true
        },
        "options": {}
      },
      {
        "content": "map[${1:string}]${0:int}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mp \"map\"": true
        },
        "options": {}
      },
      {
        "content": "func main() {\n\t${1}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "main \"func main()\"": true
        },
        "options": {}
      },
      {
        "content": "new(${0:type})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nw \"new\"": true
        },
        "options": {}
      },
      {
        "content": "package ${1:main}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pa \"package\"": true
        },
        "options": {}
      },
      {
        "content": "panic(\"${0:msg}\")",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pn \"panic\"": true
        },
        "options": {}
      },
      {
        "content": "fmt.Printf(\"%${1:s}\\n\", ${2:var})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pf \"fmt.Printf()\"": true
        },
        "options": {}
      },
      {
        "content": "fmt.Println(\"${1:s}\")",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pl \"fmt.Println()\"": true
        },
        "options": {}
      },
      {
        "content": "range ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rn \"range\"": true
        },
        "options": {}
      },
      {
        "content": "return ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rt \"return\"": true
        },
        "options": {}
      },
      {
        "content": "result",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rs \"result\"": true
        },
        "options": {}
      },
      {
        "content": "select {\ncase ${1:v1} := <-${2:chan1}\n\t${3}\ndefault:\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sl \"select\"": true
        },
        "options": {}
      },
      {
        "content": "string",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sr \"string\"": true
        },
        "options": {}
      },
      {
        "content": "struct ${1:name} {\n\t${2:/* data */}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "st \"struct\"": true
        },
        "options": {}
      },
      {
        "content": "switch ${1:var} {\ncase ${2:value1}:\n\t${3}\ncase ${4:value2}:\n\t${5}\ndefault:\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sw \"switch\"": true
        },
        "options": {}
      },
      {
        "content": "fmt.Sprintf(\"%${1:s}\", ${2:var})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ps \"fmt.Sprintf\"": true
        },
        "options": {}
      },
      {
        "content": "true",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "t \"true\"": true
        },
        "options": {}
      },
      {
        "content": "go ${1:funcName}(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "g \"goroutine named function\"": true
        },
        "options": {}
      },
      {
        "content": "go func(${1} ${2:type}) {\n\t${3:/* code */}\n}(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ga \"goroutine anonymous function\"": true
        },
        "options": {}
      },
      {
        "content": "func Test${1:name}(t *testing.T) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "test \"test function\"": true
        },
        "options": {}
      },
      {
        "content": "func Test${1:name}(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t}{\n\t\t{\n\t\t\tname: \"${2:test name}\",\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t${0:${VISUAL}}\n\t\t})\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "testt \"table test function\"": true
        },
        "options": {}
      },
      {
        "content": "func Benchmark${1:name}(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\t${2}\n\t}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bench \"benchmark function\"": true
        },
        "options": {}
      },
      {
        "content": "type ${1:name} struct {\n\t${2:attrName} ${3:attrType}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cl \"composite literals\"": true
        },
        "options": {}
      },
      {
        "content": "if ${1:value}, ok := ${2:map}[${3:key}]; ok == true {\n\t${4:/* code */}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "om \"if key in a map\"": true
        },
        "options": {}
      },
      {
        "content": "var ${1:var} = struct{\n\t${2:name} ${3:type}\n}{\n\t$2: ${4:value},\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gg \"Grouped globals with anonymous struct\"": true
        },
        "options": {}
      },
      {
        "content": "type ${1:parentType}Alias $1\nfunc (p *$1) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(&struct{ *$1Alias }{(*$1Alias)(p)})\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ja \"Marshalable json alias\"": true
        },
        "options": {}
      },
      {
        "content": "if ${1}err != nil {\n\treturn errors.Wrap(err, \"${2}\")\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "errwr \"Error handling with errors.Wrap\"": true
        },
        "options": {}
      },
      {
        "content": "${1} := ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "v := value",
        "matches": {
          ":": true
        },
        "options": {}
      },
      {
        "content": "${1:fn} := func() {\n\t${2:${VISUAL}}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "fn := func() { ... }",
        "matches": {
          "anon": true
        },
        "options": {}
      },
      {
        "content": "append(${1:slice}, ${0:value})",
        "doc": "",
        "grammar": "snu",
        "label": "append(slice, value)",
        "matches": {
          "ap": true
        },
        "options": {}
      },
      {
        "content": "${1:slice} = append($1, ${0:value})",
        "doc": "",
        "grammar": "snu",
        "label": "a = append(a, value)",
        "matches": {
          "ap=": true
        },
        "options": {}
      },
      {
        "content": "break",
        "doc": "",
        "grammar": "snu",
        "label": "break",
        "matches": {
          "br": true
        },
        "options": {}
      },
      {
        "content": "chan ${0:int}",
        "doc": "",
        "grammar": "snu",
        "label": "chan Type",
        "matches": {
          "ch": true
        },
        "options": {}
      },
      {
        "content": "case ${1:value}:\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "case ...:",
        "matches": {
          "case": true
        },
        "options": {}
      },
      {
        "content": "const ${1:NAME} ${2:Type} = ${0:0}",
        "doc": "",
        "grammar": "snu",
        "label": "const XXX Type = ...",
        "matches": {
          "con": true
        },
        "options": {}
      },
      {
        "content": "const (\n\t${1:NAME} ${2:Type} = ${3:value}\n\t${0}\n)",
        "doc": "",
        "grammar": "snu",
        "label": "const ( ... )",
        "matches": {
          "cons": true
        },
        "options": {}
      },
      {
        "content": "const (\n\t${1:NAME} ${2:Type} = iota\n\t${0}\n)",
        "doc": "",
        "grammar": "snu",
        "label": "const ( ... = iota )",
        "matches": {
          "iota": true
        },
        "options": {}
      },
      {
        "content": "continue",
        "doc": "",
        "grammar": "snu",
        "label": "continue",
        "matches": {
          "cn": true
        },
        "options": {}
      },
      {
        "content": "default:\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "default: ...",
        "matches": {
          "default": true
        },
        "options": {}
      },
      {
        "content": "defer ${1:func}(${2})\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "defer someFunction()",
        "matches": {
          "df": true
        },
        "options": {}
      },
      {
        "content": "defer func() {\n\t${0:${VISUAL}}\n}()",
        "doc": "",
        "grammar": "snu",
        "label": "defer func() { ... }",
        "matches": {
          "def": true
        },
        "options": {}
      },
      {
        "content": "defer func() {\n\tif err := recover(); err != nil {\n\t\t${0:${VISUAL}}\n\t}\n}()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defr": true
        },
        "options": {}
      },
      {
        "content": "import (\n\t\"${1:package}\"\n)",
        "doc": "",
        "grammar": "snu",
        "label": "import ( ... )",
        "matches": {
          "import": true
        },
        "options": {}
      },
      {
        "content": "type ${1:Interface} interface {\n\t${2:/* TODO: add methods */}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "interface I { ... }",
        "matches": {
          "interface": true
        },
        "options": {}
      },
      {
        "content": "if ${1:condition} {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if ... { ... }",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "else {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "else": true
        },
        "options": {}
      },
      {
        "content": "if err := ${1:condition}; err != nil {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "If with inline error",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "errors.Wrap(${1:err}, \"${2:message}\")",
        "doc": "",
        "grammar": "snu",
        "label": "errors.Wrap",
        "matches": {
          "ew": true
        },
        "options": {}
      },
      {
        "content": "errors.Wrapf(${1:err}, \"${2:message %v}\", ${3:args...})",
        "doc": "",
        "grammar": "snu",
        "label": "errors.Wrapf",
        "matches": {
          "ewf": true
        },
        "options": {}
      },
      {
        "content": "if err != nil {\n\treturn err\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "Error return",
        "matches": {
          "errn": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "if err != nil {\n\treturn errors.Wrap(err, \"${1:message}\")\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "Error return wrap",
        "matches": {
          "errnw": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "if err != nil {\n\treturn errors.Wrapf(err, \"${1:message %v}\", ${2:args...})\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "Error return wrapf",
        "matches": {
          "errnwf": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "if err != nil {\n\tlog.Fatal(err)\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "Error with log.Fatal(err)",
        "matches": {
          "errl": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "if err != nil {\n\treturn ${1:nil}, ${2:err}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "Error return with two return values",
        "matches": {
          "errn,": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "if err != nil {\n\treturn nil, errors.Wrap(err, \"${1:message}\")\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "Error return wrap with two return values",
        "matches": {
          "errn,w": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "if err != nil {\n\treturn nil, errors.Wrapf(err, \"${1:message %v}\", ${2:args...})\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "Error return wrapf with two return values",
        "matches": {
          "errn,wf": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "if err != nil {\n\tpanic(${1})\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "Error panic",
        "matches": {
          "errp": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "if err != nil {\n\tt.Fatal(err)\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "Error test fatal ",
        "matches": {
          "errt": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "if err != nil {\n\t${1}\n\treturn\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "Error handle and return",
        "matches": {
          "errh": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "fallthrough",
        "doc": "",
        "grammar": "snu",
        "label": "fallthrough",
        "matches": {
          "ft": true
        },
        "options": {}
      },
      {
        "content": "for ${1} {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "for ... { ... }",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "for ${1:i} := 0; $1 < ${2:N}; $1++ {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "for 0..N-1 { ... }",
        "matches": {
          "fori": true
        },
        "options": {}
      },
      {
        "content": "for ${2:k}, ${3:v} := range ${1} {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "for k, v := range items { ... }",
        "matches": {
          "forr": true
        },
        "options": {}
      },
      {
        "content": "for {\n\tselect {\n\t\tcase ${2:${1:result} := }<- ${3:channel}:\n\t\t\t${0}\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "for select",
        "matches": {
          "forsel": true
        },
        "options": {}
      },
      {
        "content": "case ${1:${2:var} := }<-${3:channel}:\n  ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "select case",
        "matches": {
          "selc": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "fmt.Printf(\"$1 = %+v\\n\", ${1:${VISUAL}})",
        "doc": "",
        "grammar": "snu",
        "label": "fmt.Printf(...)",
        "matches": {
          "ff": true
        },
        "options": {}
      },
      {
        "content": "fmt.Printf(\"$1 = %#v\\n\", ${1:${VISUAL}})",
        "doc": "",
        "grammar": "snu",
        "label": "fmt.Printf(#...) hash",
        "matches": {
          "ffh": true
        },
        "options": {}
      },
      {
        "content": "fmt.Println(\"${1:${VISUAL}}\")",
        "doc": "",
        "grammar": "snu",
        "label": "fmt.Println(...)",
        "matches": {
          "fn": true
        },
        "options": {}
      },
      {
        "content": "fmt.Errorf(\"${1:${VISUAL}}\")",
        "doc": "",
        "grammar": "snu",
        "label": "fmt.Errorf(...)",
        "matches": {
          "fe": true
        },
        "options": {}
      },
      {
        "content": "log.Printf(\"${1:${VISUAL}} = %+v\\n\", $1)",
        "doc": "",
        "grammar": "snu",
        "label": "log.Printf(...)",
        "matches": {
          "lf": true
        },
        "options": {}
      },
      {
        "content": "log.Println(\"${1:${VISUAL}}\")",
        "doc": "",
        "grammar": "snu",
        "label": "log.Println(...)",
        "matches": {
          "ln": true
        },
        "options": {}
      },
      {
        "content": "make(${1:[]string}, ${2:0})${0}",
        "doc": "",
        "grammar": "snu",
        "label": "make(Type, size)",
        "matches": {
          "make": true
        },
        "options": {}
      },
      {
        "content": "map[${1:string}]${0:int}",
        "doc": "",
        "grammar": "snu",
        "label": "map[Type]Type",
        "matches": {
          "map": true
        },
        "options": {}
      },
      {
        "content": "func main() {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "func main() { ... }",
        "matches": {
          "main": true
        },
        "options": {}
      },
      {
        "content": "if !ok {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if !ok { ... }",
        "matches": {
          "ok": true
        },
        "options": {}
      },
      {
        "content": "// Package $1 provides ${2:...}\npackage ${1:main}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "package ...",
        "matches": {
          "package": true
        },
        "options": {}
      },
      {
        "content": "panic(\"${0:msg}\")",
        "doc": "",
        "grammar": "snu",
        "label": "panic()",
        "matches": {
          "pn": true
        },
        "options": {}
      },
      {
        "content": "return ${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "return",
        "matches": {
          "rt": true
        },
        "options": {}
      },
      {
        "content": "select {\ncase ${1:v1} := <-${2:chan1}:\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "select { case a := <-chan: ... }",
        "matches": {
          "select": true
        },
        "options": {}
      },
      {
        "content": "type ${1:Type} struct {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "type T struct { ... }",
        "matches": {
          "st": true
        },
        "options": {}
      },
      {
        "content": "switch ${1:var} {\ncase ${2:value1}:\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "switch x { ... }",
        "matches": {
          "switch": true
        },
        "options": {}
      },
      {
        "content": "switch ${2:$1 := }${1:v}.(type) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "type switch x { ... }",
        "matches": {
          "tswitch": true
        },
        "options": {}
      },
      {
        "content": "fmt.Sprintf(\"%${1:s}\", ${2:var})",
        "doc": "",
        "grammar": "snu",
        "label": "fmt.Sprintf(...)",
        "matches": {
          "sp": true
        },
        "options": {}
      },
      {
        "content": "go ${1:funcName}(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "go someFunc(...)",
        "matches": {
          "go": true
        },
        "options": {}
      },
      {
        "content": "go func() {\n\t${1:${VISUAL}}\n}()\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "go func() { ... }()",
        "matches": {
          "gof": true
        },
        "options": {}
      },
      {
        "content": "func Test${1:Function}(t *testing.T) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "func TestXYZ(t *testing.T) { ... }",
        "matches": {
          "test": true
        },
        "options": {}
      },
      {
        "content": "t.Run(\"${0}\", func(t *testing.T){\n\n})",
        "doc": "",
        "grammar": "snu",
        "label": "t.Run(XYZ, func(t *testing.T){ ... })",
        "matches": {
          "tr": true
        },
        "options": {}
      },
      {
        "content": "var tests = []struct {\n\tname string\n\texpected string\n\tgiven string\n}{\n\t{\"${1}\", \"${2}\", \"${3}\",},\n}\nfor _, tt := range tests {\n\ttt := tt\n\tt.Run(tt.name, func(t *testing.T){\n\t\tactual := ${0:${VISUAL}}(tt.given)\n\t\tif actual != tt.expected {\n\t\t\t\tt.Errorf(\"$0(%s): expected %s, actual %s\", tt.given, tt.expected, actual)\n\t\t}\n\n\t})\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tt": true
        },
        "options": {}
      },
      {
        "content": "func ${1:handler}(w http.ResponseWriter, r *http.Request) {\n\t${0:fmt.Fprintf(w, \"hello world\")}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "http.HandlerFunc",
        "matches": {
          "hf": true
        },
        "options": {}
      },
      {
        "content": "${1:http}.HandleFunc(\"${2:/}\", func(w http.ResponseWriter, r *http.Request) {\n\t${0:fmt.Fprintf(w, \"hello world\")}\n})",
        "doc": "",
        "grammar": "snu",
        "label": "mux.HandleFunc",
        "matches": {
          "hhf": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "if err != nil {\n\tt.Errorf(\"${0:message}\")\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if err != nil { t.Errorf(...) }",
        "matches": {
          "ter": true
        },
        "options": {}
      },
      {
        "content": "if err != nil {\n\tt.Fatalf(\"${0:message}\")\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if err != nil { t.Fatalf(...) }",
        "matches": {
          "terf": true
        },
        "options": {}
      },
      {
        "content": "func Example${1:Method}() {\n\t${0:${VISUAL}}\n\t// Output:\n}",
        "doc": "",
        "grammar": "snu",
        "label": "func ExampleXYZ() { ... }",
        "matches": {
          "example": true
        },
        "options": {}
      },
      {
        "content": "func Benchmark${1:Method}(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\t${0:${VISUAL}}\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "func BenchmarkXYZ(b *testing.B) { ... }",
        "matches": {
          "benchmark": true
        },
        "options": {}
      },
      {
        "content": "var ${1:x} ${2:Type}${3: = ${0:value}}",
        "doc": "",
        "grammar": "snu",
        "label": "var x Type [= ...]",
        "matches": {
          "var": true
        },
        "options": {}
      },
      {
        "content": "var (\n\t${1:x} ${2:Type}${3: = ${0:value}}\n)",
        "doc": "",
        "grammar": "snu",
        "label": "var ( ... )",
        "matches": {
          "vars": true
        },
        "options": {}
      },
      {
        "content": "if !reflect.DeepEqual(${1:expected}, ${2:actual}) {\n\t_, file, line, _ := runtime.Caller(0)\n\tfmt.Printf(\"%s:%d:\\n\\n\\texp: %#v\\n\\n\\tgot: %#v\\n\\n\", filepath.Base(file), line, $1, $2)\n\tt.FailNow()\n}",
        "doc": "",
        "grammar": "snu",
        "label": "equals: test two identifiers with DeepEqual",
        "matches": {
          "eq": true
        },
        "options": {}
      },
      {
        "content": "import (\n\t\"${1:package}\"\n)",
        "doc": "",
        "grammar": "snu",
        "label": "Import declaration",
        "matches": {
          "/^import/": true
        },
        "options": {
          "r": true
        }
      },
      {
        "content": "// Package $1 provides ...\npackage ${1:main}",
        "doc": "",
        "grammar": "snu",
        "label": "Package declaration",
        "matches": {
          "/^package/": true
        },
        "options": {
          "r": true
        }
      },
      {
        "content": "type ${1:Struct} struct {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "Struct declaration",
        "matches": {
          "struct": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "type ${1:Interface} interface {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "Interface declaration",
        "matches": {
          "interface": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "func main() {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "Main function",
        "matches": {
          "/^main/": true
        },
        "options": {
          "r": true
        }
      },
      {
        "content": "func ${1:handler}(${2:w} http.ResponseWriter, ${3:r} *http.Request) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "HTTP handler",
        "matches": {
          "funch": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "map[${1:keytype}]${2:valtype}",
        "doc": "",
        "grammar": "snu",
        "label": "Map type",
        "matches": {
          "map": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${1:name} := ${0:value}",
        "doc": "",
        "grammar": "snu",
        "label": "Variable declaration :=",
        "matches": {
          ":": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "if err != nil {\n\tlog.${1:Fatal}(err)\n}",
        "doc": "",
        "grammar": "snu",
        "label": "Basic error handling",
        "matches": {
          "err": true
        },
        "options": {
          "b": true
        }
      }
    ],
    "graphql-request": [
      {
        "content": "import { request } from 'graphql-request';",
        "doc": "",
        "grammar": "lsp",
        "label": "graphql-request-import-request",
        "matches": {
          "graphql-request import request": true
        },
        "options": {}
      },
      {
        "content": "const { GraphQLClient } = require('graphql-request');",
        "doc": "",
        "grammar": "lsp",
        "label": "graphql-request-require-client",
        "matches": {
          "graphql-request require client": true
        },
        "options": {}
      },
      {
        "content": "const { request } = require('graphql-request');",
        "doc": "",
        "grammar": "lsp",
        "label": "graphql-request-require-request",
        "matches": {
          "graphql-request require request": true
        },
        "options": {}
      },
      {
        "content": "import { GraphQLClient } from 'graphql-request';",
        "doc": "",
        "grammar": "lsp",
        "label": "graphql-request-import-client",
        "matches": {
          "graphql-request import client": true
        },
        "options": {}
      },
      {
        "content": "const ${1:client} = new GraphQLClient(\n  ${2:url},\n  {\n    headers: {\n      ${3:key}: ${4:value}\n    },\n  }\n);",
        "doc": "",
        "grammar": "lsp",
        "label": "graphql-request-client",
        "matches": {
          "graphql-request client": true
        },
        "options": {}
      },
      {
        "content": "const ${1:results} = await request(\n  ${2:url},\n  ${3:query}\n);",
        "doc": "",
        "grammar": "lsp",
        "label": "graphql-request-request",
        "matches": {
          "graphql-request request": true
        },
        "options": {}
      },
      {
        "content": "const ${1:results} = await request(\n  ${2:url},\n  ${3:query},\n  ${4:variables}\n);",
        "doc": "",
        "grammar": "lsp",
        "label": "graphql-request-request-variables",
        "matches": {
          "graphql-request request variables": true
        },
        "options": {}
      },
      {
        "content": "const ${1:queryName} = `query ${1:queryName} {\n  ${2:query}\n}\n`;",
        "doc": "",
        "grammar": "lsp",
        "label": "graphql-request-query",
        "matches": {
          "graphql-request query": true
        },
        "options": {}
      },
      {
        "content": "const ${1:results} = await ${2:client}.request(\n  ${3:query}\n);",
        "doc": "",
        "grammar": "lsp",
        "label": "graphql-request-client-request",
        "matches": {
          "graphql-request client request": true
        },
        "options": {}
      },
      {
        "content": "const ${1:results} = await ${2:client}.request(\n  ${3:query},\n  ${4:variables}\n);",
        "doc": "",
        "grammar": "lsp",
        "label": "graphql-request-client-request-variables",
        "matches": {
          "graphql-request client request variables": true
        },
        "options": {}
      }
    ],
    "groovy": [
      {
        "content": "package ${1:com.github.ujihisa}\nclass ${2:TARGET} {\n  public static void main(String[] args) {\n    println(\"Hello world!\")\n  }\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "helloworld": true
        },
        "options": {
          "head": true
        }
      }
    ],
    "haml": [
      {
        "content": "%table\n\t%tr\n\t\t%th\n\t\t\t${1:headers}\n\t%tr\n\t\t%td\n\t\t\t${0:headers}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "t": true
        },
        "options": {}
      },
      {
        "content": "%ul\n\t%li\n\t\t${0:item}\n\t%li",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ul": true
        },
        "options": {}
      },
      {
        "content": "= render :partial => \"${0:item}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rp": true
        },
        "options": {}
      },
      {
        "content": "= render :partial => \"${1:item}\", :collection => ${0:@$1s}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rpc": true
        },
        "options": {}
      },
      {
        "content": "= render :partial => \"${1:item}\", :locals => { :${2:$1} => ${0:@$1} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rpl": true
        },
        "options": {}
      },
      {
        "content": "= render :partial => \"${1:item}\", :object => ${0:@$1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rpo": true
        },
        "options": {}
      },
      {
        "content": "= link_to ${1:name}, ${2:dest}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lt": true
        },
        "options": {}
      },
      {
        "content": "= mail_to ${1:email_address}, ${2:name}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mt": true
        },
        "options": {}
      },
      {
        "content": "= mail_to ${1:email_address}, ${2:name}, :subject => ${3}, :body => ${4}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mts": true
        },
        "options": {}
      },
      {
        "content": "- if ${1:condition}\n\t${2:${VISUAL}}\n- else\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "- if ${1:condition}.presence?\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifp": true
        },
        "options": {}
      },
      {
        "content": "= number_to_currency(${1})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ntc": true
        },
        "options": {}
      }
    ],
    "handlebars": [
      {
        "content": "{{#if ${1:value}}}\n${0:${VISUAL}}\n{{/if}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if # {{#if value}} ... {{/if}}": true
        },
        "options": {}
      },
      {
        "content": "{{#unless ${1:value}}}\n${0:${VISUAL}}\n{{/unless}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifn # {{#unless value}} ... {{/unless}}": true
        },
        "options": {}
      },
      {
        "content": "{{#if ${1:value}}}\n${2:${VISUAL}}\n{{else}}\n${3}\n{{/if}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife # {{#if value}} ... {{else}} .. {{/if}}": true
        },
        "options": {}
      }
    ],
    "haskell": [
      {
        "content": "import qualified ${1} as ${2}",
        "doc": "",
        "grammar": "snu",
        "label": "import qualified ... as ...",
        "matches": {
          "import": true
        },
        "options": {}
      },
      {
        "content": "import ${1} (${2})",
        "doc": "",
        "grammar": "snu",
        "label": "import ... (...)",
        "matches": {
          "importOnly": true
        },
        "options": {}
      },
      {
        "content": "{-# LANGUAGE ${1} #-}",
        "doc": "",
        "grammar": "snu",
        "label": "{-# LANGUAGE ... #-}",
        "matches": {
          "language": true
        },
        "options": {}
      },
      {
        "content": "case ${1} of\n\t${2} -> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "case ... of",
        "matches": {
          "case": true
        },
        "options": {}
      },
      {
        "content": "main = do\n  ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "main = do",
        "matches": {
          "main": true
        },
        "options": {}
      },
      {
        "content": "class ${1:Class} ${2:a} where\n  ${3:function} :: ${4:Type}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "class": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "instance ${1:Class} ${2:Type} where\n  ${3:function} ${4:self} = ${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "instance": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "\\ ${1:x} -> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lambda": true
        },
        "options": {}
      },
      {
        "content": "{-# LANGUAGE ${0:OverloadedStrings} #-}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lang": true
        },
        "options": {}
      },
      {
        "content": "{-# OPTIONS_HADDOCK ${0:hide} #-}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "haddock": true
        },
        "options": {}
      },
      {
        "content": "{-# OPTIONS_GHC ${0:-fno-warn-unused-imports} #-}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ghc": true
        },
        "options": {}
      },
      {
        "content": "{-# INLINE ${0:name} #-}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "inline": true
        },
        "options": {}
      },
      {
        "content": "import ${0:Data.Text}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "imp": true
        },
        "options": {}
      },
      {
        "content": "import ${0:Data.Text}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "import": true
        },
        "options": {}
      },
      {
        "content": "import ${1:Data.Text} (${0:head})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "import2": true
        },
        "options": {}
      },
      {
        "content": "import qualified ${1:Data.Text} as ${0:T}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "impq": true
        },
        "options": {}
      },
      {
        "content": "import qualified ${1:Data.Text} as ${0:T}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "importq": true
        },
        "options": {}
      },
      {
        "content": "instance ${1:Monoid} ${2:Type} where\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "inst": true
        },
        "options": {}
      },
      {
        "content": "type ${1:Type} = ${0:Type}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ty": true
        },
        "options": {}
      },
      {
        "content": "type ${1:Type} = ${0:Type}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "type": true
        },
        "options": {}
      },
      {
        "content": "data ${1:Type} = ${2:$1} ${0:Int}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "da": true
        },
        "options": {}
      },
      {
        "content": "data ${1:Type} = ${2:$1} ${0:Int}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "data": true
        },
        "options": {}
      },
      {
        "content": "newtype ${1:Type} = ${2:$1} ${0:Int}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "newtype": true
        },
        "options": {}
      },
      {
        "content": "class ${1:Class} a where\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "class": true
        },
        "options": {}
      },
      {
        "content": "main :: IO ()\nmain = ${0:undefined}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "main": true
        },
        "options": {}
      },
      {
        "content": "${1:name} :: ${2:a}\n$1 = ${0:undefined}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "const": true
        },
        "options": {}
      },
      {
        "content": "${1:fn} :: ${2:a} -> ${3:a}\n$1 ${4} = ${0:undefined}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fn": true
        },
        "options": {}
      },
      {
        "content": "${1:fn} :: ${2:a}\n$1 = ${0:undefined}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fn0": true
        },
        "options": {}
      },
      {
        "content": "${1:fn} :: ${2:a} -> ${3:a}\n$1 ${4} = ${0:undefined}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fn1": true
        },
        "options": {}
      },
      {
        "content": "${1:fn} :: ${2:a} -> ${3:a} -> ${4:a}\n$1 ${5} = ${0:undefined}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fn2": true
        },
        "options": {}
      },
      {
        "content": "${1:fn} :: ${2:a} -> ${3:a} -> ${4:a} -> ${5:a}\n$1 ${6} = ${0:undefined}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fn3": true
        },
        "options": {}
      },
      {
        "content": "(${1:Class} ${2:a}) => $2",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "=> \"Type constraint\"": true
        },
        "options": {}
      },
      {
        "content": "${1:map} ${2:fn} ${0:list}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ap": true
        },
        "options": {}
      },
      {
        "content": "\\\\${1:x} -> ${0:expression}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\": true
        },
        "options": {}
      },
      {
        "content": "(\\\\${1:x} -> ${0:expression})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "(\\": true
        },
        "options": {}
      },
      {
        "content": "${1:a} <- ${0:m a}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "<-": true
        },
        "options": {}
      },
      {
        "content": "${1:m a} -> ${0:a}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "->": true
        },
        "options": {}
      },
      {
        "content": "(${1:a}, ${0:b})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tup": true
        },
        "options": {}
      },
      {
        "content": "(${1:a}, ${2:b}, ${0:c})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tup2": true
        },
        "options": {}
      },
      {
        "content": "(${1:a}, ${2:b}, ${3:c}, ${0:d})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tup3": true
        },
        "options": {}
      },
      {
        "content": "${1:Record} { ${2:recFieldA} = ${3:undefined}\n\t\t\t, ${4:recFieldB} = ${0:undefined}\n\t\t\t}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rec": true
        },
        "options": {}
      },
      {
        "content": "case ${1:something} of\n\t${2} -> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case": true
        },
        "options": {}
      },
      {
        "content": "let ${1} = ${2}\nin ${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "let": true
        },
        "options": {}
      },
      {
        "content": "where\n\t${1:fn} = ${0:undefined}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "where": true
        },
        "options": {}
      },
      {
        "content": "describe \"${1}\" $ do\n\t$0",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "desc": true
        },
        "options": {}
      },
      {
        "content": "it \"${1}\" $\n\t$0",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "it": true
        },
        "options": {}
      },
      {
        "content": "it \"${1}\" $ property $\n\t$0",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "itp": true
        },
        "options": {}
      },
      {
        "content": "{-| ${0}\n-}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "doc": true
        },
        "options": {}
      },
      {
        "content": "import ${1:${2:Data}.${0:Text}}",
        "doc": "",
        "grammar": "snu",
        "label": "Simple import",
        "matches": {
          "imp": true
        },
        "options": {}
      },
      {
        "content": "import ${1:${2:Data}.${3:Text}} (${4})${0}",
        "doc": "",
        "grammar": "snu",
        "label": "Selective import",
        "matches": {
          "imp2": true
        },
        "options": {
          "b": true
        }
      }
    ],
    "helm": [
      {
        "content": "apiVersion: v1\nkind: Service\nmetadata:\n{{- if .Values.$1.service.annotations }}\n  annotations:\n{{ toYaml .Values.$1.service.annotations | indent 4 }}\n{{- end }}\n  labels:\n{{- if .Values.$1.service.labels }}\n{{ toYaml .Values.$1.service.labels | indent 4 }}\n{{- end }}\n\tapp: {{ template \"$2.name\" . }}\n\tchart: {{ .Chart.Name }}-{{ .Chart.Version }}\n\tcomponent: \"{{ .Values.$1.name }}\"\n\theritage: {{ .Release.Service }}\n\trelease: {{ .Release.Name }}\n  name: {{ template \"$2.$1.fullname\" . }}\nspec:\n  clusterIP: \"{{ .Values.$1.service.clusterIP }}\"\n{{- if .Values.$1.service.externalIPs }}\n  externalIPs:\n{{ toYaml .Values.$1.service.externalIPs | indent 4 }}\n{{- end }}\n{{- if .Values.$1.service.loadBalancerIP }}\n  loadBalancerIP: \"{{ .Values.$1.service.loadBalancerIP }}\"\n{{- end }}\n{{- if .Values.$1.service.loadBalancerSourceRanges }}\n  loadBalancerSourceRanges:\n{{ toYaml .Values.$1.service.loadBalancerSourceRanges | indent 4 }}\n{{- end }}\n  healthCheckNodePort: {{ .Values.$1.service.healthCheckNodePort }}\n  ports:\n\t- name: http\n\t  port: 80\n\t  protocol: TCP\n\t  targetPort: {{ .Values.$1.service.targetPorts.http }}\n\t  {{- if (and (eq .Values.$1.service.type \"NodePort\") (not (empty .Values.$1.service.nodePorts.http))) }}\n\t  nodePort: {{ .Values.$1.service.nodePorts.http }}\n\t  {{- end }}\n\t- name: https\n\t  port: 443\n\t  protocol: TCP\n\t  targetPort: {{ .Values.$1.service.targetPorts.https }}\n\t  {{- if (and (eq .Values.$1.service.type \"NodePort\") (not (empty .Values.$1.service.nodePorts.https))) }}\n\t  nodePort: {{ .Values.$1.service.nodePorts.https }}\n\t  {{- end }}\n  {{- range $key, $value := .Values.tcp }}\n\t- name: \"{{ $key }}-tcp\"\n\t  port: {{ $key }}\n\t  protocol: TCP\n\t  targetPort: \"{{ $key }}-tcp\"\n  {{- end }}\n  {{- range $key, $value := .Values.udp }}\n\t- name: \"{{ $key }}-udp\"\n\t  port: {{ $key }}\n\t  protocol: UDP\n\t  targetPort: \"{{ $key }}-udp\"\n  {{- end }}\n  selector:\n\tapp: {{ template \"${2:chartName}.name\" . }}\n\tcomponent: \"{{ .Values.$1.name }}\"\n\trelease: {{ .Release.Name }}\n  type: \"{{ .Values.${1:value_key}.service.type }}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "service_sample_spec": true
        },
        "options": {}
      },
      {
        "content": "apiVersion: v1\nkind: Service\nmetadata:\n{{- if .Values.$1.service.annotations }}\n  annotations:\n{{ toYaml .Values.$1.service.annotations | indent 4 }}\n{{- end }}\n  labels:\n{{- if .Values.$1.service.labels }}\n{{ toYaml .Values.$1.service.labels | indent 4 }}\n{{- end }}\n\tapp: {{ template \"$2.name\" . }}\n\tchart: {{ .Chart.Name }}-{{ .Chart.Version }}\n\tcomponent: \"{{ .Values.$1.name }}\"\n\theritage: {{ .Release.Service }}\n\trelease: {{ .Release.Name }}\n  name: {{ template \"${2:chartName}.${1:value_key}.fullname\" . }}\n# spec\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "service_spec": true
        },
        "options": {}
      },
      {
        "content": "{{- if .Values.$1.service.annotations }}\n  annotations:\n{{ toYaml .Values.${1:value_key}.service.annotations | indent 4 }}\n{{- end }}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "annotations_spec": true
        },
        "options": {}
      },
      {
        "content": " labels:\n{{- if .Values.$1.service.labels }}\n{{ toYaml .Values.$1.service.labels | indent 4 }}\n{{- end }}\n\tapp: {{ template \"$2.name\" . }}\n\tchart: {{ .Chart.Name }}-{{ .Chart.Version }}\n\tcomponent: \"{{ .Values.$1.name }}\"\n\theritage: {{ .Release.Service }}\n\trelease: {{ .Release.Name }}\n  name: {{ template \"${2:chartName}.${1:value_key}.fullname\" . }}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "labels_spec": true
        },
        "options": {}
      },
      {
        "content": "spec:\n  type: \"{{ .Values.$1.service.type }}\"\n  clusterIP: \"{{ .Values.$1.service.clusterIP }}\"\n{{- if .Values.$1.service.externalIPs }}\n  externalIPs:\n{{ toYaml .Values.$1.service.externalIPs | indent 4 }}\n{{- end }}\n{{- if .Values.$1.service.loadBalancerIP }}\n  loadBalancerIP: \"{{ .Values.$1.service.loadBalancerIP }}\"\n{{- end }}\n{{- if .Values.$1.service.loadBalancerSourceRanges }}\n  loadBalancerSourceRanges:\n{{ toYaml .Values.$1.service.loadBalancerSourceRanges | indent 4 }}\n{{- end }}\n{{- if and (semverCompare \">=1.7-0\" .Capabilities.KubeVersion.GitVersion) (.Values.$1.service.externalTrafficPolicy) }}\n  externalTrafficPolicy: \"{{ .Values.$1.service.externalTrafficPolicy }}\"\n{{- end }}\n{{- if and (semverCompare \">=1.7-0\" .Capabilities.KubeVersion.GitVersion) (.Values.$1.service.healthCheckNodePort) }}\n  healthCheckNodePort: {{ .Values.${1:value_key}.service.healthCheckNodePort }}\n{{- end }}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "service_spec": true
        },
        "options": {}
      },
      {
        "content": "ports:\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ports_spec": true
        },
        "options": {}
      },
      {
        "content": "- name: http\n  port: 80\n  protocol: TCP\n  targetPort: {{ .Values.$1.service.targetPorts.http }}\n  {{- if (and (eq .Values.$1.service.type \"NodePort\") (not (empty .Values.$1.service.nodePorts.http))) }}\n  nodePort: {{ .Values.${1:value_key}.service.nodePorts.http }}\n  {{- end }}\n  ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "portHTTP_spec": true
        },
        "options": {}
      },
      {
        "content": "- name: https\n  port: 443\n  protocol: TCP\n  targetPort: {{ .Values.$1.service.targetPorts.https }}\n  {{- if (and (eq .Values.$1.service.type \"NodePort\") (not (empty .Values.$1.service.nodePorts.https))) }}\n  nodePort: {{ .Values.${1:value_key}.service.nodePorts.https }}\n  {{- end }}\n  ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "portHTTPS_spec": true
        },
        "options": {}
      },
      {
        "content": "{{- range $key, $value := .Values.tcp }}\n  - name: \"{{ $key }}-tcp\"\n\tport: {{ $key }}\n\tprotocol: TCP\n\ttargetPort: \"{{ $key }}-tcp\"\n{{- end }}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "portTCP_spec": true
        },
        "options": {}
      },
      {
        "content": "{{- range $key, $value := .Values.udp }}\n  - name: \"{{ $key }}-udp\"\n\tport: {{ $key }}\n\tprotocol: UDP\n\ttargetPort: \"{{ $key }}-udp\"\n{{- end }}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "portUDP_spec": true
        },
        "options": {}
      },
      {
        "content": "selector:\n  app: {{ template \"${2:chartName}.name\" . }}\n  component: \"{{ .Values.${1:value_key}.name }}\"\n  release: {{ .Release.Name }}\n  ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "selector_spec": true
        },
        "options": {}
      },
      {
        "content": "{{- if .Values.$1.enabled }}\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  labels:\n\tapp: {{ template \"$2.name\" . }}\n\tchart: {{ .Chart.Name }}-{{ .Chart.Version }}\n\tcomponent: \"{{ .Values.$1.name }}\"\n\theritage: {{ .Release.Service }}\n\trelease: {{ .Release.Name }}\n  name: {{ template \"$2.$1.fullname\" . }}\nspec:\n  replicas: {{ .Values.$1.replicaCount }}\n  revisionHistoryLimit: {{ .Values.revisionHistoryLimit }}\n  template:\n\tmetadata:\n\t{{- if .Values.$1.podAnnotations }}\n\t  annotations:\n{{ toYaml .Values.$1.podAnnotations | indent 8 }}\n\t{{- end }}\n\t  labels:\n\t\tapp: {{ template \"$2.name\" . }}\n\t\tcomponent: \"{{ .Values.$1.name }}\"\n\t\trelease: {{ .Release.Name }}\n\t\t{{- if .Values.$1.podLabels }}\n{{ toYaml .Values.$1.podLabels | indent 8 }}\n\t\t{{- end }}\n\tspec:\n\t  {{- if .Values.imagePullSecrets }}\n\t  imagePullSecrets:\n{{ toYaml .Values.imagePullSecrets | indent 8 }}\n\t  {{- end }}\n\t  containers:\n\t\t- name: {{ template \"${2:chartName}.name\" . }}-{{ .Values.$1.name }}\n\t\t  image: \"{{ .Values.$1.image.repository }}:{{ .Values.$1.image.tag }}\"\n\t\t  imagePullPolicy: \"{{ .Values.$1.image.pullPolicy }}\"\n\t\t  args:\n\t\t  {{- range $key, $value := .Values.$1.extraArgs }}\n\t\t\t{{- if $value }}\n\t\t\t- --{{ $key }}={{ $value }}\n\t\t\t{{- else }}\n\t\t\t- --{{ $key }}\n\t\t\t{{- end }}\n\t\t  {{- end }}\n\t\t  livenessProbe:\n\t\t\thttpGet:\n\t\t\t  path: /healthz\n\t\t\t  port: 8080\n\t\t\t  scheme: HTTP\n\t\t\tinitialDelaySeconds: 30\n\t\t\ttimeoutSeconds: 5\n\t\t  ports:\n\t\t\t- name: http\n\t\t\t  containerPort: 8080\n\t\t\t  protocol: TCP\n\t\t  resources:\n{{ toYaml .Values.$1.resources | indent 12 }}\n\t{{- if .Values.$1.nodeSelector }}\n\t  nodeSelector:\n{{ toYaml .Values.$1.nodeSelector | indent 8 }}\n\t{{- end }}\n\t{{- if .Values.$1.tolerations }}\n\t  tolerations:\n{{ toYaml .Values.$1.tolerations | indent 8 }}\n\t{{- end }}\n\t{{- if .Values.$1.affinity }}\n\t  affinity:\n{{ toYaml .Values.${1:value_key}.affinity | indent 8 }}\n\t{{- end }}\n\t  terminationGracePeriodSeconds: 60\n{{- end }}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "deploy_sample_spec": true
        },
        "options": {}
      },
      {
        "content": "{{- if .Values.$1.enabled }}\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  labels:\n\tapp: {{ template \"$2.name\" . }}\n\tchart: {{ .Chart.Name }}-{{ .Chart.Version }}\n\tcomponent: \"{{ .Values.$1.name }}\"\n\theritage: {{ .Release.Service }}\n\trelease: {{ .Release.Name }}\n  name: {{ template \"${2:chartName}.${1:value_key}.fullname\" . }}\n# spec\n\t# containers_spec\n\t# livenessProbe_spec\n\t# PersistentVolumeClaim_spec\n\t# initContainers_spec\n\t# resources_spec\n\t# nodeselector_spec\n\t# tolerations_spec\n\t# affinity_spec\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "deploy_spec": true
        },
        "options": {}
      },
      {
        "content": "spec:\n  replicas: {{ .Values.$1.replicaCount }}\n  revisionHistoryLimit: {{ .Values.revisionHistoryLimit }}\n  template:\n\tmetadata:\n\t{{- if .Values.$1.podAnnotations }}\n\t  annotations:\n{{ toYaml .Values.$1.podAnnotations | indent 8 }}\n\t{{- end }}\n\t  labels:\n\t\tapp: {{ template \"${2:chartName}.name\" . }}\n\t\tcomponent: \"{{ .Values.$1.name }}\"\n\t\trelease: {{ .Release.Name }}\n\t\t{{- if .Values.$1.podLabels }}\n{{ toYaml .Values.${1:value_key}.podLabels | indent 8 }}\n\t\t{{- end }}\n\tspec:\n\t  {{- if .Values.imagePullSecrets }}\n\t  imagePullSecrets:\n{{ toYaml .Values.imagePullSecrets | indent 8 }}\n\t  {{- end }}\n\t  ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "spec_spec": true
        },
        "options": {}
      },
      {
        "content": "\t  {{- if .Values.imagePullSecrets }}\n\t  imagePullSecrets:\n{{ toYaml .Values.imagePullSecrets | indent 8 }}\n\t  {{- end }}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "imagePullSecrets_spec": true
        },
        "options": {}
      },
      {
        "content": "imagePullPolicy: ${1:imagePullPolicy}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "imagePullPolicy_spec": true
        },
        "options": {}
      },
      {
        "content": "containers:\n  - name: {{ template \"${2:chartName}.name\" . }}-{{ .Values.$1.name }}\n\timage: \"{{ .Values.$1.image.repository }}:{{ .Values.$1.image.tag }}\"\n\timagePullPolicy: \"{{ .Values.${1:value_key}.image.pullPolicy }}\"\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "containers_spec": true
        },
        "options": {}
      },
      {
        "content": "args:\n{{- range $key, $value := .Values.${1:value_key}.extraArgs }}\n  {{- if $value }}\n  - --{{ $key }}={{ $value }}\n  {{- else }}\n  - --{{ $key }}\n  {{- end }}\n{{- end }}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "args_spec": true
        },
        "options": {}
      },
      {
        "content": "livenessProbe:\n  httpGet:\n\tpath: /healthz\n\tport: 8080\n\tscheme: HTTP\n  initialDelaySeconds: 30\n  timeoutSeconds: 5\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "livenessProbe_spec": true
        },
        "options": {}
      },
      {
        "content": "readinessProbe:\n  httpGet:\n\tpath: /go/api/v1/health\n\tport: 8153\n  initialDelaySeconds: {{ .Values.$1.healthCheck.initialDelaySeconds }}\n  periodSeconds: {{ .Values.$1.healthCheck.periodSeconds }}\n  failureThreshold: {{ .Values.$1.healthCheck.failureThreshold }}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "readinessProbe_spec": true
        },
        "options": {}
      },
      {
        "content": "resources:\n{{ toYaml .Values.${1:value_key}.resources | indent 12 }}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "resources_spec": true
        },
        "options": {}
      },
      {
        "content": "{{- if .Values.$1.nodeSelector }}\n  nodeSelector:\n{{ toYaml .Values.${1:value_key}.nodeSelector | indent 8 }}\n{{- end }}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nodeselector_spec": true
        },
        "options": {}
      },
      {
        "content": "{{- if .Values.$1.tolerations }}\n  tolerations:\n{{ toYaml .Values.${1:value_key}.tolerations | indent 8 }}\n{{- end }}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tolerations_spec": true
        },
        "options": {}
      },
      {
        "content": "{{- if .Values.$1.affinity }}\n  affinity:\n{{ toYaml .Values.${1:value_key}.affinity | indent 8 }}\n{{- end }}\n  terminationGracePeriodSeconds: 60\n{{- end }}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "affinity_spec": true
        },
        "options": {}
      },
      {
        "content": "kind: PersistentVolumeClaim\napiVersion: v1\nmetadata:\n  name: {{ template \"${2}.$1.fullname\" . }}\n  labels:\n\tapp: {{ template \"${2:chartName}.name\" . }}\n\tchart: \"{{ .Chart.Name }}-{{ .Chart.Version }}\"\n\trelease: \"{{ .Release.Name }}\"\n\theritage: \"{{ .Release.Service }}\"\nspec:\n  accessModes:\n\t- {{ .Values.$1.persistence.accessMode | quote }}\n  resources:\n\trequests:\n\t  storage: {{ .Values.$1.persistence.size | quote }}\n{{- if .Values.$1.persistence.storageClass }}\n{{- if (eq \"-\" .Values.$1.persistence.storageClass) }}\n  storageClassName: \"\"\n{{- else }}\n  storageClassName: \"{{ .Values.${1:value_key}.persistence.storageClass }}\"\n{{- end }}\n{{- end }}\n{{- end }}\n{{- end }}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "PersistentVolumeClaim_spec": true
        },
        "options": {}
      },
      {
        "content": "{{- if .Values.artifactory.enabled -}}\n  apiVersion: v1\n  kind: ConfigMap\n  metadata:\n\tname: {{ template \"${2:chartName}.fullname\" . }}-${1:value_key}-config\n\tlabels:\n\t  app: {{ template \"${2}.name\" . }}\n\t  chart: {{ .Chart.Name }}-{{ .Chart.Version }}\n\t  heritage: {{ .Release.Service }}\n\t  release: {{ .Release.Name }}\n  data:\n\t${3:nameOfConfigFile}.conf: |\n\t  # data goes here\n{{- end -}}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "configMap_spec": true
        },
        "options": {}
      },
      {
        "content": "{{- if .Values.$1.initContainers }}\n\t  initContainers:\n\t  - name: wait-workers\n\t\timage: \"{{ .Values.$1.image.repository }}:{{ .Values.$1.image.tag }}\"\n\t\timagePullPolicy: {{ .Values.${1:value_key}.image.pullPolicy }}\n\t\t# env\n\t\tcommand:\n\t\t  - sh\n\t\t  - -c\n\t\t  - |\n\t\t\tuntil printf \".\" && nc -z -w 2 {{ template \"${2:chartName}.fullname\" . }} {{ .Values.postgresql.service.port }}; do\n\t\t\t\tsleep 2;\n\t\t\tdone;\n\t\t\techo 'PostgreSQL OK '\n\t\t# args\n{{- end }}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "initContainers_spec": true
        },
        "options": {}
      },
      {
        "content": "kind: PersistentVolumeClaim\napiVersion: v1\nmetadata:\n  name: {{ template \"$2.fullname\" . }}\n  labels:\n\tchart: \"{{ .Chart.Name }}-{{ .Chart.Version }}\"\n\trelease: \"{{ .Release.Name }}\"\n\theritage: \"{{ .Release.Service }}\"\n\tapp: {{ template \"${2:chartName}.fullname\" . }}\nspec:\n  accessModes:\n\t- {{ .Values.persistence.accessMode | quote }}\n  resources:\n\trequests:\n\t  storage: {{ .Values.persistence.size | quote }}\n{{- if .Values.persistence.storageClass }}\n{{- if (eq \"-\" .Values.persistence.storageClass) }}\n  storageClassName: \"\"\n{{- else }}\n  storageClassName: \"{{ .Values.persistence.storageClass }}\"\n{{- end }}\n{{- end }}\n{{- end }}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pvc_spec": true
        },
        "options": {}
      },
      {
        "content": "apiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: {{ template \"$2.fullname\" . }}-data-pv\n  labels:\n\tapp: {{ template \"$2.name\" . }}\n\tchart: {{ .Chart.Name }}-{{ .Chart.Version }}\n\theritage: {{ .Release.Service }}\n\trelease: {{ .Release.Name }}\n\tid: {{ template \"${2:chartName}.name\" . }}-data-pv\n\ttype: nfs-volume\nspec:\n  capacity:\n\tstorage: {{ .Values.$1.persistence.nfs.capacity }}\n  accessModes:\n  - ReadWriteOnce\n  persistentVolumeReclaimPolicy: Retain\n  nfs:\n\tserver: {{ .Values.$1.persistence.nfs.ip }}\n\tpath: \"{{ .Values.${1:value_key}.persistence.nfs.haDataMount }}\"\n\treadOnly: false\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pv_nfs_spec": true
        },
        "options": {}
      },
      {
        "content": "{{- if and .Values.persistence.enabled .Values.persistence.$1.hostPath (not\n.Values.persistence.$1.existingClaim) -}}\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: {{ template \"${2:chartName}.fullname\" . }}-$1\nspec:\n  accessModes:\n\t- {{ .Values.persistence.$1.accessMode | quote }}\n  capacity:\n\tstorage: {{ .Values.persistence.$1.size | quote }}\n  hostPath:\n\tpath: {{ .Values.persistence.${1:value_key}.hostPath | quote }}\n{{- end -}}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pvc_hostpath_spec": true
        },
        "options": {}
      },
      {
        "content": "$1:\n  name: ${1:value_key}\n  image:\n\trepository: \n\ttag: \n\tpullPolicy: IfNotPresent\n  hostNetwork: false\n  dnsPolicy: ClusterFirst\n  daemonset:\n\tuseHostPort: false\n  podLabels: {}\n  scope:\n\tenabled: false\n\tnamespace: \"\"   # defaults to .Release.Namespace\n  extraArgs: {}\n  extraEnvs: []\n  kind: Deployment\n  updateStrategy: {}\n  minReadySeconds: 0\n  tolerations: []\n  affinity: {}\n  nodeSelector: {}\n  podAnnotations: {}\n  replicaCount: 1\n  minAvailable: 1\n  resources: {}\n  autoscaling:\n\tenabled: false\n  extraContainers: {}\n  extraVolumeMounts: {}\n  extraVolumes: {}\n  extraInitContainers: []\n  lifecycle: {}\nrevisionHistoryLimit: 10\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "deploy_values": true
        },
        "options": {}
      },
      {
        "content": "${1:value_key}:\nrbac:\n  create: true\nserviceAccount:\n  create: true\n  name:\nimagePullSecrets: []\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rbac_values": true
        },
        "options": {}
      },
      {
        "content": "${1:value_key}:\n  service:\n\tannotations: {}\n\tlabels: {}\n\tclusterIP: \"\"\n\texternalIPs: []\n\tloadBalancerIP: \"\"\n\tloadBalancerSourceRanges: []\n\texternalTrafficPolicy: \"\"\n\thealthCheckNodePort: 0\n\ttargetPorts:\n\t  http: http\n\t  https: https\n\ttype: LoadBalancer\n\tnodePorts:\n\t  http: \"\"\n\t  https: \"\"\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "service_values": true
        },
        "options": {}
      },
      {
        "content": "${1:value_key}:\n  readinessProbe:\n\tfailureThreshold: 3\n\tinitialDelaySeconds: 10\n\tperiodSeconds: 10\n\tsuccessThreshold: 1\n\ttimeoutSeconds: 1\n\tport: 10254\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "readinessProbe_values": true
        },
        "options": {}
      },
      {
        "content": "${1:value_key}:\n  livenessProbe:\n\tfailureThreshold: 3\n\tinitialDelaySeconds: 10\n\tperiodSeconds: 10\n\tsuccessThreshold: 1\n\ttimeoutSeconds: 1\n\tport: 10254\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "livenessProbe_values": true
        },
        "options": {}
      }
    ],
    "help": [],
    "html": [
      {
        "content": "[class]=\"${1:expression}\"",
        "doc": "Angular [class] binding",
        "grammar": "lsp",
        "label": "class",
        "matches": {
          "a-class": true
        },
        "options": {}
      },
      {
        "content": "[style.${1:property}]=\"${2:expression}\"",
        "doc": "Angular [style] binding",
        "grammar": "lsp",
        "label": "style",
        "matches": {
          "a-style": true
        },
        "options": {}
      },
      {
        "content": "[ngClass]=\"{${1:cssClass}: ${2:expression}}\"",
        "doc": "Angular ngClass",
        "grammar": "lsp",
        "label": "ngClass",
        "matches": {
          "a-ngClass": true
        },
        "options": {}
      },
      {
        "content": "*ngFor=\"let ${1:item} of ${2:list}\"${0}",
        "doc": "Angular *ngFor",
        "grammar": "lsp",
        "label": "ngFor",
        "matches": {
          "a-ngFor": true
        },
        "options": {}
      },
      {
        "content": "*ngFor=\"let ${1:item} of ${2:list}; trackBy:${1:item}.id\"${0}",
        "doc": "Angular *ngFor with trackBy",
        "grammar": "lsp",
        "label": "ngFor with trackBy",
        "matches": {
          "a-ngFor-trackBy": true
        },
        "options": {}
      },
      {
        "content": "*ngFor=\"let ${1:item} of ${2:stream} | async as ${3:list}\"${0}",
        "doc": "Angular *ngForAsync",
        "grammar": "lsp",
        "label": "ngForAsync",
        "matches": {
          "a-ngForAsync": true
        },
        "options": {}
      },
      {
        "content": "<form (ngSubmit)=\"onSubmit()\" #${1:form}=\"ngForm\">\n</form>",
        "doc": "Form with ngSubmit and form attributes",
        "grammar": "lsp",
        "label": "ngForm",
        "matches": {
          "a-form": true
        },
        "options": {}
      },
      {
        "content": "formArrayName=\"${1:control}\"",
        "doc": "Angular formArrayName",
        "grammar": "lsp",
        "label": "ngFormArrayName",
        "matches": {
          "a-formArrayName": true
        },
        "options": {}
      },
      {
        "content": "formControlName=\"${1:control}\"",
        "doc": "Angular formControlName",
        "grammar": "lsp",
        "label": "ngFormControlName",
        "matches": {
          "a-formControlName": true
        },
        "options": {}
      },
      {
        "content": "[formGroup]=\"${1:form}\"",
        "doc": "Angular formGroup",
        "grammar": "lsp",
        "label": "ngFormGroup",
        "matches": {
          "a-formGroup": true
        },
        "options": {}
      },
      {
        "content": "[formGroupName]=\"${1:name}\"",
        "doc": "Angular formGroupName",
        "grammar": "lsp",
        "label": "ngFormGroupName",
        "matches": {
          "a-formGroupName": true
        },
        "options": {}
      },
      {
        "content": "<button type=\"submit\" [disabled]=\"!${1:form}.form.valid\">\n\tSave\n</button>",
        "doc": "Angular form submit",
        "grammar": "lsp",
        "label": "ngFormSubmit",
        "matches": {
          "a-form-submit": true
        },
        "options": {}
      },
      {
        "content": "*ngIf=\"${1:expression}\"",
        "doc": "Angular *ngIf",
        "grammar": "lsp",
        "label": "ngIf",
        "matches": {
          "a-ngIf": true
        },
        "options": {}
      },
      {
        "content": "*ngIf=\"${1:expression};else ${2:templateName}\"",
        "doc": "Angular *ngIfElse",
        "grammar": "lsp",
        "label": "ngIfElse",
        "matches": {
          "a-ngIfElse": true
        },
        "options": {}
      },
      {
        "content": "[(ngModel)]=\"${1:binding}\"",
        "doc": "Angular ngModel",
        "grammar": "lsp",
        "label": "ngModel",
        "matches": {
          "a-ngModel": true
        },
        "options": {}
      },
      {
        "content": "[routerLink]=\"['/${1:routePath}']\" routerLinkActive=\"${2:router-link-active}\" $0",
        "doc": "Angular routerLink",
        "grammar": "lsp",
        "label": "ngRouterLink",
        "matches": {
          "a-routerLink": true
        },
        "options": {}
      },
      {
        "content": "[routerLink]=\"['${1:routePath}', ${2:routeParameterValue}]\"\nrouterLinkActive=\"${3:router-link-active}\"$0",
        "doc": "Angular routerLink with a route parameter",
        "grammar": "lsp",
        "label": "ngRouterLinkWithParameter",
        "matches": {
          "a-routerLink-param": true
        },
        "options": {}
      },
      {
        "content": "<select [(ngModel)]=\"${1:model}\">\n\t<option *ngFor=\"let ${2:item} of ${3:list}\" [value]=\"${2:item}\">{{${2:item}}}</option>\n</select>",
        "doc": "<select> control with ngModel",
        "grammar": "lsp",
        "label": "ngSelect",
        "matches": {
          "a-select": true
        },
        "options": {}
      },
      {
        "content": "[ngStyle]=\"{${1:style}: ${2:expression}}\"",
        "doc": "Angular ngStyle",
        "grammar": "lsp",
        "label": "ngStyle",
        "matches": {
          "a-ngStyle": true
        },
        "options": {}
      },
      {
        "content": "<div [ngSwitch]=\"${1:conditionExpression}\">\n\t<div *ngSwitchCase=\"${2:expression}\">${3:output}</div>\n\t<div *ngSwitchDefault>${4:output2}</div>\n</div>",
        "doc": "Angular ngSwitch",
        "grammar": "lsp",
        "label": "ngSwitch",
        "matches": {
          "a-ngSwitch": true
        },
        "options": {}
      },
      {
        "content": "<pre>{{${1:model} | json}}</pre>$0",
        "doc": "Angular pre debug | json",
        "grammar": "lsp",
        "label": "pre w/ json",
        "matches": {
          "a-prej": true
        },
        "options": {}
      },
      {
        "content": "<pre>{{${1:model} | async | json}}</pre>$0",
        "doc": "Angular pre debug | async | json",
        "grammar": "lsp",
        "label": "pre w/ async json",
        "matches": {
          "a-preja": true
        },
        "options": {}
      },
      {
        "content": "<ng-container $0></ng-container>",
        "doc": "Angular ng-container",
        "grammar": "lsp",
        "label": "ng-container",
        "matches": {
          "a-ng-container": true
        },
        "options": {}
      },
      {
        "content": "<ng-template [ngTemplateOutlet]=\"${1:outlet}\" [ngOutletContext]=\"${2:context}\"></ng-template>",
        "doc": "Angular ng-template",
        "grammar": "lsp",
        "label": "ng-template",
        "matches": {
          "a-ng-template": true
        },
        "options": {}
      },
      {
        "content": "<ng-content select=\"${0:selector}\"></ng-content>",
        "doc": "Angular ng-content",
        "grammar": "lsp",
        "label": "ng-content",
        "matches": {
          "a-ng-content": true
        },
        "options": {}
      },
      {
        "content": "<!DOCTYPE html\nPUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\n\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "doctypetransitional": true
        },
        "options": {}
      },
      {
        "content": "<!DOCTYPE html\nPUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\n\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "doctypeframeset": true
        },
        "options": {}
      },
      {
        "content": "<!DOCTYPE html\nPUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\n\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "doctypestrict": true
        },
        "options": {}
      },
      {
        "content": "<!doctype html>\n<html lang=\"${1:en}\">\n    <head>\n        <meta charset=\"${2:utf-8}\">\n        <meta name=\"viewport\" content=\"${3:width=device-width, initial-scale=1}\">\n        <title>${4}</title>\n    </head>\n    <body>\n        ${5}\n    </body>\n</html>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "html5": true
        },
        "options": {}
      },
      {
        "content": "<head>\n    <meta charset=\"${1:utf-8}\">\n    <title>${2}</title>\n<style>\n    ${3}\n</style>\n    ${4}\n</head>${5}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "head": true
        },
        "options": {}
      },
      {
        "content": "<meta name=\"author\" content=\"${1}\">${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "metaauthor": true
        },
        "options": {}
      },
      {
        "content": "<meta name=\"keywords\" content=\"${1}\">${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "keywords": true
        },
        "options": {}
      },
      {
        "content": "<meta name=\"others\" content=\"${1}\">${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "metaothers": true
        },
        "options": {}
      },
      {
        "content": "<meta name=\"generator\" content=\"${1}\">${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "metagenerator": true
        },
        "options": {}
      },
      {
        "content": "<meta name=\"description\" content=\"${1}\">${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "metadescription": true
        },
        "options": {}
      },
      {
        "content": "<meta name=\"viewport\" content=\"${1:width=device-width, initial-scale=1}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "metaviewport": true
        },
        "options": {}
      },
      {
        "content": "<meta name=\"theme-color\" content=\"#${1}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "metatheme": true
        },
        "options": {}
      },
      {
        "content": "<script charset=\"${1:UTF-8}\">\n${2:TARGET}\n</script>${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "scriptcharset": true
        },
        "options": {}
      },
      {
        "content": "<script>\n${1:TARGET}\n</script>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "script": true
        },
        "options": {}
      },
      {
        "content": "<script src=\"${1}\"${2: defer}></script>${3}",
        "doc": "",
        "grammar": "snu",
        "label": "js",
        "matches": {
          "scriptsrc": true
        },
        "options": {}
      },
      {
        "content": "<body>\n   ${1:TARGET}\n</body>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "body": true
        },
        "options": {}
      },
      {
        "content": "<h${1:1}>${2}</h$1>${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "h": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<p>${1}</p>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<br>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "br": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<hr>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "hr": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<!--${1:TARGET}-->${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "comment": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<b>${1:TARGET}</b>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "b": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<small>${1:TARGET}</small>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "small": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<strong>${1:TARGET}</strong>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "strong": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<sub>${1:TARGET}</sub>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sub": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<sup>${1:TARGET}</sup>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sup": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<ins>${1:TARGET}</ins>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ins": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<del>${1:TARGET}</del>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "del": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<em>${1:TARGET}</em>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "em": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<bdo dir=\"${1:rtl}\">${2:TARGET}</bdo>${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdo": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<pre>\n${1:TARGET}\n</pre>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pre": true
        },
        "options": {}
      },
      {
        "content": "<blockquote>\n${1}\n</blockquote>\n${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "blockquote": true
        },
        "options": {}
      },
      {
        "content": "<link rel=\"${1:stylesheet}\" href=\"${2}.css\"${3}>${4}",
        "doc": "",
        "grammar": "snu",
        "label": "link stylesheet css",
        "matches": {
          "link": true
        },
        "options": {}
      },
      {
        "content": "<link rel=\"manifest\" href=\"${1:manifest.json}\">${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "manifest": true
        },
        "options": {}
      },
      {
        "content": "text-align=\"left\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "alignl": true
        },
        "options": {}
      },
      {
        "content": "text-align=\"right\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "alignr": true
        },
        "options": {}
      },
      {
        "content": "text-align=\"center\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "alignc": true
        },
        "options": {}
      },
      {
        "content": "bgcolor=\"${1}\"${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgcolor": true
        },
        "options": {}
      },
      {
        "content": "<a href=\"${1}\">${2:TARGET}</a>${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ahref": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<a href=\"${1}\" target=\"_blank\" rel=\"noopener\">${2:TARGET}</a>${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ahref_blank": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<a href=\"${1}\" target=\"_parent\">${2:TARGET}</a>${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ahref_parent": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<a href=\"${1}\" target=\"_top\">${2:TARGET}</a>${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ahref_top": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<a name=\"${1}\">${2:TARGET}</a>${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "aname": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<frameset cols=\"${1}\">\n${2:TARGET}\n</frameset>${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "framesetcols": true
        },
        "options": {}
      },
      {
        "content": "<frameset rows=\"${1}\"\n${2:TARGET}\n</frameset>${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "framesetrows": true
        },
        "options": {}
      },
      {
        "content": "<iframe src=\"${1}\"></iframe>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "iframe": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<table border=\"${1}\">\n${2:TARGET}\n</table>${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "table": true
        },
        "options": {}
      },
      {
        "content": "<th>${1:TARGET}</th>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "th": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<ul type=\"square\">${1:TARGET}</ul>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ulsquare": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<ul type=\"circle\">${1:TARGET}</ul>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ulcircle": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<ul type=\"disc\">${1:TARGET}</ul>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "uldisc": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<ol>${1:TARGET}</ol>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ol": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<ol type=\"A\">${1:TARGET}</ol>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "olA": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<ol type=\"a\">${1:TARGET}</ol>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ola": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<ol type=\"I\">${1:TARGET}</ol>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "olI": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<ol type=\"i\">${1:TARGET}</ol>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "oli": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<li>${1:TARGET}</li>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "li": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<dl>${1:TARGET}</dl>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dl": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<dt>${1:TARGET}</dt>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dt": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<dd>${1:TARGET}</dd>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dd": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<form>\n${1:TARGET}\n</form>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "form": true
        },
        "options": {}
      },
      {
        "content": "<input type=\"text\" name=\"${1:user}\">${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "inputtext": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<input type=\"password\" name=\"${1:password}\">${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "inputpassword": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<input type=\"radio\" name=\"${1}\" value=\"value\">${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "inputradio": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<input type=\"checkbox\" name=\"${1}\">${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "inputcheckbox": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<textarea rows=\"${1}\" cols=\"${2}\">\n${3:TARGET}\n</textarea>\n${4}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "textarea": true
        },
        "options": {}
      },
      {
        "content": "<button>${1:TARGET}</button>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "button": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<button type=\"submit\">${1:TARGET}</button>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "buttonsubmit": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<select>${1:TARGET}</select>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "select": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<optgroup label=\"${1}\">\n${2:TARGET}\n<optgroup>${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "optgroup": true
        },
        "options": {}
      },
      {
        "content": "<option value=\"${1}\">${2:TARGET}</option>${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "option": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<label>${1}: <input type=\"${2:TARGET}\" /></label>${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "label": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<label for=\"${1}:id\">${2:TARGET}</label>${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "labelfor": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<fieldset>${1:TARGET}</fieldset>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fieldset": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<legend>${1:TARGET}</legend>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "legend": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "id=\"${1}\"${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "id": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "class=\"${1}\"${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "class": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<p class=\"${1}\">${2:TARGET}</p>${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pclass": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<p id=\"${1}\">${2:TARGET}</p>${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pid": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<div id=\"${1}\">${2:TARGET}</div>${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "divid": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<div class=\"${1}\">${2:TARGET}</div>${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "divclass": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<img src=\"${1}\" alt=\"${2}\">${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "img": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<header>\n    ${1}\n</header>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "header": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<nav>\n    ${1}\n</nav>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nav": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<main>\n    ${1}\n</main>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "main": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<footer>\n    ${1}\n</footer>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "footer": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<details${2}>\n    <summary>${1}</summary>\n    ${3}\n</details>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "details": true
        },
        "options": {}
      },
      {
        "content": "&nbsp;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nbs": true
        },
        "options": {}
      },
      {
        "content": "&#x2190;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "left": true
        },
        "options": {}
      },
      {
        "content": "&#x2192;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "right": true
        },
        "options": {}
      },
      {
        "content": "&#x2191;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "up": true
        },
        "options": {}
      },
      {
        "content": "&#x2193;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "down": true
        },
        "options": {}
      },
      {
        "content": "&#x21A9;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "return": true
        },
        "options": {}
      },
      {
        "content": "&#x21E4;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "backtab": true
        },
        "options": {}
      },
      {
        "content": "&#x21E5;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tab": true
        },
        "options": {}
      },
      {
        "content": "&#x21E7;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "shift": true
        },
        "options": {}
      },
      {
        "content": "&#x2303;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ctrl": true
        },
        "options": {}
      },
      {
        "content": "&#x2305;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "enter": true
        },
        "options": {}
      },
      {
        "content": "&#x2318;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cmd": true
        },
        "options": {}
      },
      {
        "content": "&#x2325;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "option": true
        },
        "options": {}
      },
      {
        "content": "&#x2326;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "delete": true
        },
        "options": {}
      },
      {
        "content": "&#x232B;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "backspace": true
        },
        "options": {}
      },
      {
        "content": "&#x238B;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "esc": true
        },
        "options": {}
      },
      {
        "content": "<!-- ${1} -->${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "//": true
        },
        "options": {}
      },
      {
        "content": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\"\n\"http://www.w3.org/TR/html4/strict.dtd\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "docts": true
        },
        "options": {}
      },
      {
        "content": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n\"http://www.w3.org/TR/html4/loose.dtd\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "doct": true
        },
        "options": {}
      },
      {
        "content": "<!DOCTYPE HTML>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "doct5": true
        },
        "options": {}
      },
      {
        "content": "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\"\n\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "docxf": true
        },
        "options": {}
      },
      {
        "content": "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\n\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "docxs": true
        },
        "options": {}
      },
      {
        "content": "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "docxt": true
        },
        "options": {}
      },
      {
        "content": "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\"\n\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "docx": true
        },
        "options": {}
      },
      {
        "content": "${1:attribute}=\"${0:property}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "attr": true
        },
        "options": {}
      },
      {
        "content": "${1:attribute}=\"${2:property}\" attr+",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "attr+": true
        },
        "options": {}
      },
      {
        "content": "class=\"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ".": true
        },
        "options": {}
      },
      {
        "content": "id=\"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#": true
        },
        "options": {}
      },
      {
        "content": "alt=\"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "alt": true
        },
        "options": {}
      },
      {
        "content": "charset=\"${1:utf-8}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "charset": true
        },
        "options": {}
      },
      {
        "content": "data-${1}=\"${2:$1}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "data": true
        },
        "options": {}
      },
      {
        "content": "for=\"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "height=\"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "height": true
        },
        "options": {}
      },
      {
        "content": "href=\"${1:#}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "href": true
        },
        "options": {}
      },
      {
        "content": "lang=\"${1:en}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lang": true
        },
        "options": {}
      },
      {
        "content": "media=\"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "media": true
        },
        "options": {}
      },
      {
        "content": "name=\"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "name": true
        },
        "options": {}
      },
      {
        "content": "rel=\"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rel": true
        },
        "options": {}
      },
      {
        "content": "scope=\"${1:row}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "scope": true
        },
        "options": {}
      },
      {
        "content": "src=\"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "src": true
        },
        "options": {}
      },
      {
        "content": "title=\"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "title=": true
        },
        "options": {}
      },
      {
        "content": "type=\"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "type": true
        },
        "options": {}
      },
      {
        "content": "value=\"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "value": true
        },
        "options": {}
      },
      {
        "content": "width=\"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "width": true
        },
        "options": {}
      },
      {
        "content": "<a href=\"${1:#}\">${0:$1}</a>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "a": true
        },
        "options": {}
      },
      {
        "content": "<a class=\"${1}\" href=\"${2:#}\">${0:$1}</a>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "a.": true
        },
        "options": {}
      },
      {
        "content": "<a id=\"${1}\" href=\"${2:#}\">${0:$1}</a>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "a#": true
        },
        "options": {}
      },
      {
        "content": "<a href=\"http://${1:example.com}\">${0:$1}</a>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "a:ext": true
        },
        "options": {}
      },
      {
        "content": "<a href=\"mailto:${1:joe@example.com}?subject=${2:feedback}\">${0:email me}</a>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "a:mail": true
        },
        "options": {}
      },
      {
        "content": "<abbr title=\"${1}\">${0}</abbr>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "abbr": true
        },
        "options": {}
      },
      {
        "content": "<address>\n\t${0}\n</address>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "address": true
        },
        "options": {}
      },
      {
        "content": "<area shape=\"${1:rect}\" coords=\"${2}\" href=\"${3}\" alt=\"${0}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "area": true
        },
        "options": {}
      },
      {
        "content": "<area shape=\"${1:rect}\" coords=\"${2}\" href=\"${3}\" alt=\"${4}\">\narea+",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "area+": true
        },
        "options": {}
      },
      {
        "content": "<area shape=\"circle\" coords=\"${1}\" href=\"${2}\" alt=\"${0}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "area:c": true
        },
        "options": {}
      },
      {
        "content": "<area shape=\"default\" coords=\"${1}\" href=\"${2}\" alt=\"${0}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "area:d": true
        },
        "options": {}
      },
      {
        "content": "<area shape=\"poly\" coords=\"${1}\" href=\"${2}\" alt=\"${0}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "area:p": true
        },
        "options": {}
      },
      {
        "content": "<area shape=\"rect\" coords=\"${1}\" href=\"${2}\" alt=\"${0}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "area:r": true
        },
        "options": {}
      },
      {
        "content": "<article>\n\t${0}\n</article>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "article": true
        },
        "options": {}
      },
      {
        "content": "<article class=\"${1}\">\n\t${0}\n</article>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "article.": true
        },
        "options": {}
      },
      {
        "content": "<article id=\"${1}\">\n\t${0}\n</article>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "article#": true
        },
        "options": {}
      },
      {
        "content": "<aside>\n\t${0}\n</aside>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "aside": true
        },
        "options": {}
      },
      {
        "content": "<aside class=\"${1}\">\n\t${0}\n</aside>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "aside.": true
        },
        "options": {}
      },
      {
        "content": "<aside id=\"${1}\">\n\t${0}\n</aside>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "aside#": true
        },
        "options": {}
      },
      {
        "content": "<audio src=\"${1}\">${0}</audio>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "audio": true
        },
        "options": {}
      },
      {
        "content": "<b>${0}</b>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "b": true
        },
        "options": {}
      },
      {
        "content": "<base href=\"${1}\" target=\"${0}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "base": true
        },
        "options": {}
      },
      {
        "content": "<bdi>${0}</bdo>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdi": true
        },
        "options": {}
      },
      {
        "content": "<bdo dir=\"${1}\">${0}</bdo>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdo": true
        },
        "options": {}
      },
      {
        "content": "<bdo dir=\"ltr\">${0}</bdo>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdo:l": true
        },
        "options": {}
      },
      {
        "content": "<bdo dir=\"rtl\">${0}</bdo>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdo:r": true
        },
        "options": {}
      },
      {
        "content": "<blockquote>\n\t${0}\n</blockquote>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "blockquote": true
        },
        "options": {}
      },
      {
        "content": "<body>\n\t${0}\n</body>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "body": true
        },
        "options": {}
      },
      {
        "content": "<br>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "br": true
        },
        "options": {}
      },
      {
        "content": "<button type=\"${1:submit}\">${0}</button>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "button": true
        },
        "options": {}
      },
      {
        "content": "<button class=\"${1:button}\" type=\"${2:submit}\">${0}</button>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "button.": true
        },
        "options": {}
      },
      {
        "content": "<button id=\"${1}\" type=\"${2:submit}\">${0}</button>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "button#": true
        },
        "options": {}
      },
      {
        "content": "<button type=\"submit\">${0}</button>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "button:s": true
        },
        "options": {}
      },
      {
        "content": "<button type=\"reset\">${0}</button>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "button:r": true
        },
        "options": {}
      },
      {
        "content": "<canvas>\n\t${0}\n</canvas>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "canvas": true
        },
        "options": {}
      },
      {
        "content": "<caption>${0}</caption>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "caption": true
        },
        "options": {}
      },
      {
        "content": "<cite>${0}</cite>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cite": true
        },
        "options": {}
      },
      {
        "content": "<code>${0}</code>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "code": true
        },
        "options": {}
      },
      {
        "content": "<col>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "col": true
        },
        "options": {}
      },
      {
        "content": "<colgroup>\n\t${0}\n</colgroup>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "colgroup": true
        },
        "options": {}
      },
      {
        "content": "<colgroup>\n\t<col>\n\tcol+${0}\n</colgroup>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "colgroup+": true
        },
        "options": {}
      },
      {
        "content": "<command type=\"command\" label=\"${1}\" icon=\"${0}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "command": true
        },
        "options": {}
      },
      {
        "content": "<command type=\"checkbox\" label=\"${1}\" icon=\"${0}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "command:c": true
        },
        "options": {}
      },
      {
        "content": "<command type=\"radio\" radiogroup=\"${1}\" label=\"${2}\" icon=\"${0}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "command:r": true
        },
        "options": {}
      },
      {
        "content": "<datagrid>\n\t${0}\n</datagrid>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "datagrid": true
        },
        "options": {}
      },
      {
        "content": "<datalist>\n\t${0}\n</datalist>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "datalist": true
        },
        "options": {}
      },
      {
        "content": "<datatemplate>\n\t${0}\n</datatemplate>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "datatemplate": true
        },
        "options": {}
      },
      {
        "content": "<dd>${0}</dd>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dd": true
        },
        "options": {}
      },
      {
        "content": "<dd class=\"${1}\">${0}</dd>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dd.": true
        },
        "options": {}
      },
      {
        "content": "<dd id=\"${1}\">${0}</dd>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dd#": true
        },
        "options": {}
      },
      {
        "content": "<del>${0}</del>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "del": true
        },
        "options": {}
      },
      {
        "content": "<details>${0}</details>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "details": true
        },
        "options": {}
      },
      {
        "content": "<dfn>${0}</dfn>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dfn": true
        },
        "options": {}
      },
      {
        "content": "<dialog>\n\t${0}\n</dialog>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dialog": true
        },
        "options": {}
      },
      {
        "content": "<div>\n\t${0}\n</div>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "div": true
        },
        "options": {}
      },
      {
        "content": "<div class=\"${1}\">\n\t${0}\n</div>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "div.": true
        },
        "options": {}
      },
      {
        "content": "<div id=\"${1}\">\n\t${0}\n</div>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "div#": true
        },
        "options": {}
      },
      {
        "content": "<dl>\n\t${0}\n</dl>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dl": true
        },
        "options": {}
      },
      {
        "content": "<dl class=\"${1}\">\n\t${0}\n</dl>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dl.": true
        },
        "options": {}
      },
      {
        "content": "<dl id=\"${1}\">\n\t${0}\n</dl>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dl#": true
        },
        "options": {}
      },
      {
        "content": "<dl>\n\t<dt>${1}</dt>\n\t<dd>${2}</dd>\n\tdt+${0}\n</dl>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dl+": true
        },
        "options": {}
      },
      {
        "content": "<dt>${0}</dt>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dt": true
        },
        "options": {}
      },
      {
        "content": "<dt class=\"${1}\">${0}</dt>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dt.": true
        },
        "options": {}
      },
      {
        "content": "<dt id=\"${1}\">${0}</dt>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dt#": true
        },
        "options": {}
      },
      {
        "content": "<dt>${1}</dt>\n<dd>${2}</dd>\ndt+${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dt+": true
        },
        "options": {}
      },
      {
        "content": "<em>${0}</em>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "em": true
        },
        "options": {}
      },
      {
        "content": "<embed src=\"${1}\" type=\"${0}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "embed": true
        },
        "options": {}
      },
      {
        "content": "<fieldset>\n\t${0}\n</fieldset>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fieldset": true
        },
        "options": {}
      },
      {
        "content": "<fieldset class=\"${1}\">\n\t${0}\n</fieldset>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fieldset.": true
        },
        "options": {}
      },
      {
        "content": "<fieldset id=\"${1}\">\n\t${0}\n</fieldset>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fieldset#": true
        },
        "options": {}
      },
      {
        "content": "<fieldset>\n\t<legend><span>${1}</span></legend>\n\t${2}\n</fieldset>\nfieldset+${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fieldset+": true
        },
        "options": {}
      },
      {
        "content": "<figcaption>${0}</figcaption>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "figcaption": true
        },
        "options": {}
      },
      {
        "content": "<figure>${0}</figure>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "figure": true
        },
        "options": {}
      },
      {
        "content": "<figure id=\"${1}\">\n\t${0}\n</figure>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "figure#": true
        },
        "options": {}
      },
      {
        "content": "<figure class=\"${1}\">\n\t${0}\n</figure>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "figure.": true
        },
        "options": {}
      },
      {
        "content": "<footer>\n\t${0}\n</footer>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "footer": true
        },
        "options": {}
      },
      {
        "content": "<footer class=\"${1}\">\n\t${0}\n</footer>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "footer.": true
        },
        "options": {}
      },
      {
        "content": "<footer id=\"${1}\">\n\t${0}\n</footer>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "footer#": true
        },
        "options": {}
      },
      {
        "content": "<form action=\"${1}\" method=\"${2:post}\">\n\t${0}\n</form>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "form": true
        },
        "options": {}
      },
      {
        "content": "<form class=\"${1}\" action=\"${2}\" method=\"${3:post}\">\n\t${0}\n</form>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "form.": true
        },
        "options": {}
      },
      {
        "content": "<form id=\"${1}\" action=\"${2}\" method=\"${3:post}\">\n\t${0}\n</form>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "form#": true
        },
        "options": {}
      },
      {
        "content": "<h1>${0}</h1>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "h1": true
        },
        "options": {}
      },
      {
        "content": "<h1 class=\"${1}\">${0}</h1>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "h1.": true
        },
        "options": {}
      },
      {
        "content": "<h1 id=\"${1}\">${0}</h1>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "h1#": true
        },
        "options": {}
      },
      {
        "content": "<h2>${0}</h2>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "h2": true
        },
        "options": {}
      },
      {
        "content": "<h2 class=\"${1}\">${0}</h2>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "h2.": true
        },
        "options": {}
      },
      {
        "content": "<h2 id=\"${1}\">${0}</h2>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "h2#": true
        },
        "options": {}
      },
      {
        "content": "<h3>${0}</h3>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "h3": true
        },
        "options": {}
      },
      {
        "content": "<h3 class=\"${1}\">${0}</h3>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "h3.": true
        },
        "options": {}
      },
      {
        "content": "<h3 id=\"${1}\">${0}</h3>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "h3#": true
        },
        "options": {}
      },
      {
        "content": "<h4>${0}</h4>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "h4": true
        },
        "options": {}
      },
      {
        "content": "<h4 class=\"${1}\">${0}</h4>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "h4.": true
        },
        "options": {}
      },
      {
        "content": "<h4 id=\"${1}\">${0}</h4>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "h4#": true
        },
        "options": {}
      },
      {
        "content": "<h5>${0}</h5>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "h5": true
        },
        "options": {}
      },
      {
        "content": "<h5 class=\"${1}\">${0}</h5>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "h5.": true
        },
        "options": {}
      },
      {
        "content": "<h5 id=\"${1}\">${0}</h5>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "h5#": true
        },
        "options": {}
      },
      {
        "content": "<h6>${0}</h6>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "h6": true
        },
        "options": {}
      },
      {
        "content": "<h6 class=\"${1}\">${0}</h6>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "h6.": true
        },
        "options": {}
      },
      {
        "content": "<h6 id=\"${1}\">${0}</h6>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "h6#": true
        },
        "options": {}
      },
      {
        "content": "<header>\n\t${0}\n</header>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "header": true
        },
        "options": {}
      },
      {
        "content": "<header class=\"${1}\">\n\t${0}\n</header>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "header.": true
        },
        "options": {}
      },
      {
        "content": "<header id=\"${1}\">\n\t${0}\n</header>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "header#": true
        },
        "options": {}
      },
      {
        "content": "<hgroup>\n\t${0}\n</hgroup>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "hgroup": true
        },
        "options": {}
      },
      {
        "content": "<hgroup class=\"${1}>\n\t${0}\n</hgroup>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "hgroup.": true
        },
        "options": {}
      },
      {
        "content": "<hr>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "hr": true
        },
        "options": {}
      },
      {
        "content": "<html>\n${0}\n</html>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "html": true
        },
        "options": {}
      },
      {
        "content": "<html xmlns=\"http://www.w3.org/1999/xhtml\">\n${0}\n</html>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "xhtml": true
        },
        "options": {}
      },
      {
        "content": "<i>${0}</i>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "i": true
        },
        "options": {}
      },
      {
        "content": "<iframe src=\"${1}\" frameborder=\"0\"></iframe>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "iframe": true
        },
        "options": {}
      },
      {
        "content": "<iframe class=\"${1}\" src=\"${2}\" frameborder=\"0\"></iframe>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "iframe.": true
        },
        "options": {}
      },
      {
        "content": "<iframe id=\"${1}\" src=\"${2}\" frameborder=\"0\"></iframe>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "iframe#": true
        },
        "options": {}
      },
      {
        "content": "<img src=\"${1}\" alt=\"${2}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "img": true
        },
        "options": {}
      },
      {
        "content": "<img class=\"${1}\" src=\"${2}\" alt=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "img.": true
        },
        "options": {}
      },
      {
        "content": "<img id=\"${1}\" src=\"${2}\" alt=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "img#": true
        },
        "options": {}
      },
      {
        "content": "<input type=\"${1:text/submit/hidden/button/image}\" name=\"${2}\" id=\"${3:$2}\" value=\"${4}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "input": true
        },
        "options": {}
      },
      {
        "content": "<input class=\"${1}\" type=\"${2:text/submit/hidden/button/image}\" name=\"${3}\" id=\"${4:$3}\" value=\"${5}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "input.": true
        },
        "options": {}
      },
      {
        "content": "<input type=\"text\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "input:text": true
        },
        "options": {}
      },
      {
        "content": "<input type=\"submit\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "input:submit": true
        },
        "options": {}
      },
      {
        "content": "<input type=\"hidden\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "input:hidden": true
        },
        "options": {}
      },
      {
        "content": "<input type=\"button\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "input:button": true
        },
        "options": {}
      },
      {
        "content": "<input type=\"image\" name=\"${1}\" id=\"${2:$1}\" src=\"${3}\" alt=\"${4}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "input:image": true
        },
        "options": {}
      },
      {
        "content": "<input type=\"checkbox\" name=\"${1}\" id=\"${2:$1}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "input:checkbox": true
        },
        "options": {}
      },
      {
        "content": "<input type=\"radio\" name=\"${1}\" id=\"${2:$1}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "input:radio": true
        },
        "options": {}
      },
      {
        "content": "<input type=\"color\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "input:color": true
        },
        "options": {}
      },
      {
        "content": "<input type=\"date\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "input:date": true
        },
        "options": {}
      },
      {
        "content": "<input type=\"datetime\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "input:datetime": true
        },
        "options": {}
      },
      {
        "content": "<input type=\"datetime-local\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "input:datetime-local": true
        },
        "options": {}
      },
      {
        "content": "<input type=\"email\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "input:email": true
        },
        "options": {}
      },
      {
        "content": "<input type=\"file\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "input:file": true
        },
        "options": {}
      },
      {
        "content": "<input type=\"month\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "input:month": true
        },
        "options": {}
      },
      {
        "content": "<input type=\"number\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "input:number": true
        },
        "options": {}
      },
      {
        "content": "<input type=\"password\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "input:password": true
        },
        "options": {}
      },
      {
        "content": "<input type=\"range\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "input:range": true
        },
        "options": {}
      },
      {
        "content": "<input type=\"reset\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "input:reset": true
        },
        "options": {}
      },
      {
        "content": "<input type=\"search\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "input:search": true
        },
        "options": {}
      },
      {
        "content": "<input type=\"time\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "input:time": true
        },
        "options": {}
      },
      {
        "content": "<input type=\"url\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "input:url": true
        },
        "options": {}
      },
      {
        "content": "<input type=\"week\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "input:week": true
        },
        "options": {}
      },
      {
        "content": "<ins>${0}</ins>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ins": true
        },
        "options": {}
      },
      {
        "content": "<kbd>${0}</kbd>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "kbd": true
        },
        "options": {}
      },
      {
        "content": "<label for=\"${0:$1}\">${1}</label>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "label": true
        },
        "options": {}
      },
      {
        "content": "<label for=\"${2:$1}\">${1}</label>\n<input type=\"${3:text/submit/hidden/button}\" name=\"${4:$2}\" id=\"${5:$2}\" value=\"${6}\" />",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "label:i": true
        },
        "options": {}
      },
      {
        "content": "<label for=\"${2:$1}\">${1}</label>\n<select name=\"${3:$2}\" id=\"${4:$2}\">\n\t<option value=\"${5}\">${0:$5}</option>\n</select>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "label:s": true
        },
        "options": {}
      },
      {
        "content": "<legend>${0}</legend>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "legend": true
        },
        "options": {}
      },
      {
        "content": "<legend><span>${0}</span></legend>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "legend+": true
        },
        "options": {}
      },
      {
        "content": "<li>${0}</li>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "li": true
        },
        "options": {}
      },
      {
        "content": "<li class=\"${1}\">${0}</li>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "li.": true
        },
        "options": {}
      },
      {
        "content": "<li>${1}</li>\nli+",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "li+": true
        },
        "options": {}
      },
      {
        "content": "<li><a href=\"${0:#}\">${1}</a></li>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lia": true
        },
        "options": {}
      },
      {
        "content": "<li><a href=\"${2:#}\">${1}</a></li>\nlia+",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lia+": true
        },
        "options": {}
      },
      {
        "content": "<link rel=\"${1}\" href=\"${2}\" title=\"${3}\" type=\"${4}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "link": true
        },
        "options": {}
      },
      {
        "content": "<link rel=\"alternate\" href=\"${1:atom.xml}\" title=\"Atom\" type=\"application/atom+xml\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "link:atom": true
        },
        "options": {}
      },
      {
        "content": "<link rel=\"stylesheet\" href=\"${1:style.css}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "link:s": true
        },
        "options": {}
      },
      {
        "content": "<link rel=\"stylesheet\" href=\"${1:style.css}\" type=\"text/css\" media=\"${2:all}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "link:css": true
        },
        "options": {}
      },
      {
        "content": "<link rel=\"shortcut icon\" href=\"${1:favicon.ico}\" type=\"image/x-icon\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "link:favicon": true
        },
        "options": {}
      },
      {
        "content": "<link rel=\"alternate\" href=\"${1:rss.xml}\" title=\"RSS\" type=\"application/atom+xml\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "link:rss": true
        },
        "options": {}
      },
      {
        "content": "<link rel=\"apple-touch-icon\" href=\"${1:favicon.png}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "link:touch": true
        },
        "options": {}
      },
      {
        "content": "<main role=\"main\">\n\t${0}\n</main>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "main": true
        },
        "options": {}
      },
      {
        "content": "<map name=\"${1}\">\n\t${0}\n</map>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "map": true
        },
        "options": {}
      },
      {
        "content": "<map class=\"${1}\" name=\"${2}\">\n\t${0}\n</map>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "map.": true
        },
        "options": {}
      },
      {
        "content": "<map name=\"${1}\" id=\"${2:$1}>\n\t${0}\n</map>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "map#": true
        },
        "options": {}
      },
      {
        "content": "<map name=\"${1}\">\n\t<area shape=\"${2}\" coords=\"${3}\" href=\"${4}\" alt=\"${5}\" />${6}\n</map>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "map+": true
        },
        "options": {}
      },
      {
        "content": "<mark>${0}</mark>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mark": true
        },
        "options": {}
      },
      {
        "content": "<menu>\n\t${0}\n</menu>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "menu": true
        },
        "options": {}
      },
      {
        "content": "<menu type=\"context\">\n\t${0}\n</menu>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "menu:c": true
        },
        "options": {}
      },
      {
        "content": "<menu type=\"toolbar\">\n\t${0}\n</menu>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "menu:t": true
        },
        "options": {}
      },
      {
        "content": "<meta http-equiv=\"${1}\" content=\"${2}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "meta": true
        },
        "options": {}
      },
      {
        "content": "<meta ${0}>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "meta:s": true
        },
        "options": {}
      },
      {
        "content": "<meta name=\"description\" content=\"${0}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "meta:d": true
        },
        "options": {}
      },
      {
        "content": "<meta http-equiv=\"X-UA-Compatible\" content=\"IE=${1:7,8,edge}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "meta:compat": true
        },
        "options": {}
      },
      {
        "content": "<meta http-equiv=\"refresh\" content=\"text/html;charset=UTF-8\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "meta:refresh": true
        },
        "options": {}
      },
      {
        "content": "<meta http-equiv=\"content-type\" content=\"text/html;charset=UTF-8\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "meta:utf": true
        },
        "options": {}
      },
      {
        "content": "<meter>${0}</meter>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "meter": true
        },
        "options": {}
      },
      {
        "content": "<nav>\n\t${0}\n</nav>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nav": true
        },
        "options": {}
      },
      {
        "content": "<nav class=\"${1}\">\n\t${0}\n</nav>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nav.": true
        },
        "options": {}
      },
      {
        "content": "<nav id=\"${1}\">\n\t${0}\n</nav>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nav#": true
        },
        "options": {}
      },
      {
        "content": "<noscript>\n\t${0}\n</noscript>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "noscript": true
        },
        "options": {}
      },
      {
        "content": "<object data=\"${1}\" type=\"${2}\">\n\t${3}\n</object>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "object": true
        },
        "options": {}
      },
      {
        "content": "<object width=\"$2\" height=\"$3\" classid=\"clsid:02BF25D5-8C17-4B23-BC80-D3488ABDDC6B\"\ncodebase=\"http://www.apple.com/qtactivex/qtplugin.cab\">\n\t<param name=\"src\" value=\"$1\">\n\t<param name=\"controller\" value=\"$4\">\n\t<param name=\"autoplay\" value=\"$5\">\n\t<embed src=\"${1:movie.mov}\"\n\t\twidth=\"${2:320}\" height=\"${3:240}\"\n\t\tcontroller=\"${4:true}\" autoplay=\"${5:true}\"\n\t\tscale=\"tofit\" cache=\"true\"\n\t\tpluginspage=\"http://www.apple.com/quicktime/download/\">\n</object>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "movie": true
        },
        "options": {}
      },
      {
        "content": "<ol>\n\t${0}\n</ol>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ol": true
        },
        "options": {}
      },
      {
        "content": "<ol class=\"${1}\">\n\t${0}\n</ol>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ol.": true
        },
        "options": {}
      },
      {
        "content": "<ol id=\"${1}\">\n\t${0}\n</ol>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ol#": true
        },
        "options": {}
      },
      {
        "content": "<ol>\n\t<li>${1}</li>\n\tli+${0}\n</ol>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ol+": true
        },
        "options": {}
      },
      {
        "content": "<option value=\"${1}\">${0:$1}</option>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "opt": true
        },
        "options": {}
      },
      {
        "content": "<option value=\"${1}\">${2:$1}</option>\nopt+${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "opt+": true
        },
        "options": {}
      },
      {
        "content": "<option>${0}</option>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "optt": true
        },
        "options": {}
      },
      {
        "content": "<optgroup>\n\t<option value=\"${1}\">${2:$1}</option>\n\topt+${0}\n</optgroup>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "optgroup": true
        },
        "options": {}
      },
      {
        "content": "<output>${0}</output>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "output": true
        },
        "options": {}
      },
      {
        "content": "<p>${0}</p>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p": true
        },
        "options": {}
      },
      {
        "content": "<p class=\"${1}\">${0}</p>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p.": true
        },
        "options": {}
      },
      {
        "content": "<p id=\"${1}\">${0}</p>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p#": true
        },
        "options": {}
      },
      {
        "content": "<param name=\"${1}\" value=\"${2}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "param": true
        },
        "options": {}
      },
      {
        "content": "<pre>\n\t${0}\n</pre>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pre": true
        },
        "options": {}
      },
      {
        "content": "<progress>${0}</progress>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "progress": true
        },
        "options": {}
      },
      {
        "content": "<q>${0}</q>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "q": true
        },
        "options": {}
      },
      {
        "content": "<rp>${0}</rp>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rp": true
        },
        "options": {}
      },
      {
        "content": "<rt>${0}</rt>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rt": true
        },
        "options": {}
      },
      {
        "content": "<ruby>\n\t<rp><rt>${0}</rt></rp>\n</ruby>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ruby": true
        },
        "options": {}
      },
      {
        "content": "<s>${0}</s>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "s": true
        },
        "options": {}
      },
      {
        "content": "<samp>\n\t${0}\n</samp>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "samp": true
        },
        "options": {}
      },
      {
        "content": "<script>\n\t${0}\n</script>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "script": true
        },
        "options": {}
      },
      {
        "content": "<script src=\"${0}.js\"></script>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "scripts": true
        },
        "options": {}
      },
      {
        "content": "<script type=\"${1}\" id=\"${2}\">\n\t${0}\n</script>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "scriptt": true
        },
        "options": {}
      },
      {
        "content": "<script src=\"${0}.js\" charset=\"utf-8\"></script>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "scriptsrc": true
        },
        "options": {}
      },
      {
        "content": "<section>\n\t${0}\n</section>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "section": true
        },
        "options": {}
      },
      {
        "content": "<section class=\"${1}\">\n\t${0}\n</section>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "section.": true
        },
        "options": {}
      },
      {
        "content": "<section id=\"${1}\">\n\t${0}\n</section>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "section#": true
        },
        "options": {}
      },
      {
        "content": "<select name=\"${1}\" id=\"${2:$1}\">\n\t${0}\n</select>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "select": true
        },
        "options": {}
      },
      {
        "content": "<select name=\"${1}\" id=\"${2:$1}\" class=\"${3}>\n\t${0}\n</select>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "select.": true
        },
        "options": {}
      },
      {
        "content": "<select name=\"${1}\" id=\"${2:$1}\">\n\t<option value=\"${3}\">${4:$3}</option>\n\topt+${0}\n</select>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "select+": true
        },
        "options": {}
      },
      {
        "content": "<small>${0}</small>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "small": true
        },
        "options": {}
      },
      {
        "content": "<source src=\"${1}\" type=\"${2}\" media=\"${0}\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "source": true
        },
        "options": {}
      },
      {
        "content": "<span>${0}</span>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "span": true
        },
        "options": {}
      },
      {
        "content": "<span class=\"${1}\">${0}</span>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "span.": true
        },
        "options": {}
      },
      {
        "content": "<span id=\"${1}\">${0}</span>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "span#": true
        },
        "options": {}
      },
      {
        "content": "<strong>${0}</strong>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "strong": true
        },
        "options": {}
      },
      {
        "content": "<style type=\"text/css\" media=\"${1:all}\">\n\t${0}\n</style>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "style": true
        },
        "options": {}
      },
      {
        "content": "<sub>${0}</sub>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sub": true
        },
        "options": {}
      },
      {
        "content": "<summary>\n\t${0}\n</summary>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "summary": true
        },
        "options": {}
      },
      {
        "content": "<sup>${0}</sup>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sup": true
        },
        "options": {}
      },
      {
        "content": "<table>\n\t${0}\n</table>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "table": true
        },
        "options": {}
      },
      {
        "content": "<table class=\"${1}\">\n\t${0}\n</table>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "table.": true
        },
        "options": {}
      },
      {
        "content": "<table id=\"${1}\">\n\t${0}\n</table>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "table#": true
        },
        "options": {}
      },
      {
        "content": "<tbody>\n\t${0}\n</tbody>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tbody": true
        },
        "options": {}
      },
      {
        "content": "<td>${0}</td>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "td": true
        },
        "options": {}
      },
      {
        "content": "<td class=\"${1}\">${0}</td>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "td.": true
        },
        "options": {}
      },
      {
        "content": "<td id=\"${1}\">${0}</td>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "td#": true
        },
        "options": {}
      },
      {
        "content": "<td>${1}</td>\ntd+${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "td+": true
        },
        "options": {}
      },
      {
        "content": "<textarea name=\"${1}\" id=\"${2:$1}\" rows=\"${3:8}\" cols=\"${4:40}\">${5}</textarea>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "textarea": true
        },
        "options": {}
      },
      {
        "content": "<tfoot>\n\t${0}\n</tfoot>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tfoot": true
        },
        "options": {}
      },
      {
        "content": "<th>${0}</th>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "th": true
        },
        "options": {}
      },
      {
        "content": "<th class=\"${1}\">${0}</th>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "th.": true
        },
        "options": {}
      },
      {
        "content": "<th id=\"${1}\">${0}</th>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "th#": true
        },
        "options": {}
      },
      {
        "content": "<th>${1}</th>\nth+${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "th+": true
        },
        "options": {}
      },
      {
        "content": "<thead>\n\t${0}\n</thead>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "thead": true
        },
        "options": {}
      },
      {
        "content": "<time datetime=\"${1}\" pubdate=\"${2:$1}\">${0:$1}</time>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "time": true
        },
        "options": {}
      },
      {
        "content": "<tr>\n\t${0}\n</tr>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tr": true
        },
        "options": {}
      },
      {
        "content": "<tr>\n\t<td>${1}</td>\n\ttd+${0}\n</tr>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tr+": true
        },
        "options": {}
      },
      {
        "content": "<track src=\"${1}\" srclang=\"${2}\" label=\"${3}\" default=\"${4:default}>${5}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "track": true
        },
        "options": {}
      },
      {
        "content": "<ul>\n\t${0}\n</ul>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ul": true
        },
        "options": {}
      },
      {
        "content": "<ul class=\"${1}\">\n\t${0}\n</ul>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ul.": true
        },
        "options": {}
      },
      {
        "content": "<ul id=\"${1}\">\n\t${0}\n</ul>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ul#": true
        },
        "options": {}
      },
      {
        "content": "<ul>\n\t<li>${1}</li>\n\tli+${0}\n</ul>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ul+": true
        },
        "options": {}
      },
      {
        "content": "<var>${0}</var>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "var": true
        },
        "options": {}
      },
      {
        "content": "<video src=\"${1}\" height=\"${2}\" width=\"${3}\" preload=\"${4:none}\" autoplay=\"${5:autoplay}\">${6}</video>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "video": true
        },
        "options": {}
      },
      {
        "content": "<video class=\"${1}\" src=\"${2}\" height=\"${3}\" width=\"${4}\" preload=\"${5:none}\" autoplay=\"${6:autoplay}\">${7}</video>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "video.": true
        },
        "options": {}
      },
      {
        "content": "<wbr>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wbr": true
        },
        "options": {}
      },
      {
        "content": "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "viewport": true
        },
        "options": {}
      }
    ],
    "html_minimal": [
      {
        "content": "id=\"$1\"$2",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "id": true
        },
        "options": {}
      },
      {
        "content": "id=\"$1\" name=\"${2:$1}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "idn": true
        },
        "options": {}
      },
      {
        "content": "<label for=\"${2:$1}\">$1</label>\n<input type=\"${3:text}\" name=\"${4:$2}\"${5: id=\"${6:$2}\"} value=\"$7\" />$8",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "label_and_input": true
        },
        "options": {}
      },
      {
        "content": "<input type=\"${1:text}\" value=\"$2\" name=\"$3\"${4: id=\"${5:$3}\"}/>$7",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "input": true
        },
        "options": {}
      },
      {
        "content": "<input type=\"submit\" value=\"$2\" $3/>$7",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "submit": true
        },
        "options": {}
      },
      {
        "content": "<textarea name=\"$2\"${3: id=\"$4\"}>$5</textarea>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "textarea": true
        },
        "options": {}
      },
      {
        "content": "<img src=\"$1\"${2: alt=\"$3\"}/>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "img": true
        },
        "options": {}
      }
    ],
    "htmldjango": [
      {
        "content": "{% ${1} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "%": true
        },
        "options": {}
      },
      {
        "content": "{% ${1:tag_name} %}\n${0}\n{% end$1 %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "%%": true
        },
        "options": {}
      },
      {
        "content": "{{ ${1} }}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "{": true
        },
        "options": {}
      },
      {
        "content": "{% autoescape ${1:off} %}\n\t${0}\n{% endautoescape %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "autoescape": true
        },
        "options": {}
      },
      {
        "content": "{% block ${1} %}\n\t${0}\n{% endblock %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "block": true
        },
        "options": {}
      },
      {
        "content": "{# ${0:comment} #}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#": true
        },
        "options": {}
      },
      {
        "content": "{% comment %}\n\t${0}\n{% endcomment %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "comment": true
        },
        "options": {}
      },
      {
        "content": "{% cycle ${1:val1} ${2:val2} ${3:as ${4}} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cycle": true
        },
        "options": {}
      },
      {
        "content": "{% debug %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "debug": true
        },
        "options": {}
      },
      {
        "content": "{% extends \"${0:base.html}\" %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "extends": true
        },
        "options": {}
      },
      {
        "content": "{% filter ${1} %}\n\t${0}\n{% endfilter %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "filter": true
        },
        "options": {}
      },
      {
        "content": "{% firstof ${1} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "firstof": true
        },
        "options": {}
      },
      {
        "content": "{% for ${1} in ${2} %}\n\t${0}\n{% endfor %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "{% empty %}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "empty": true
        },
        "options": {}
      },
      {
        "content": "{% if ${1} %}\n\t${0}\n{% endif %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "{% else %}\n\t${1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "el": true
        },
        "options": {}
      },
      {
        "content": "{% elif ${1} %}\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eif": true
        },
        "options": {}
      },
      {
        "content": "{% ifchanged %}${1}{% endifchanged %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifchanged": true
        },
        "options": {}
      },
      {
        "content": "{% ifequal ${1} ${2} %}\n\t${0}\n{% endifequal %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifequal": true
        },
        "options": {}
      },
      {
        "content": "{% ifnotequal ${1} ${2} %}\n\t${0}\n{% endifnotequal %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifnotequal": true
        },
        "options": {}
      },
      {
        "content": "{% include \"${0}\" %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "include": true
        },
        "options": {}
      },
      {
        "content": "{% load ${0} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "load": true
        },
        "options": {}
      },
      {
        "content": "{% now \"${0:jS F Y H:i}\" %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "now": true
        },
        "options": {}
      },
      {
        "content": "{% regroup ${1} by ${2} as ${0} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "regroup": true
        },
        "options": {}
      },
      {
        "content": "{% spaceless %}${0}{% endspaceless %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "spaceless": true
        },
        "options": {}
      },
      {
        "content": "{% ssi ${0} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ssi": true
        },
        "options": {}
      },
      {
        "content": "{% trans \"${0:string}\" %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "trans": true
        },
        "options": {}
      },
      {
        "content": "{% url ${1} as ${0} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "url": true
        },
        "options": {}
      },
      {
        "content": "{% widthratio ${1:this_value} ${2:max_value} ${0:100} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "widthratio": true
        },
        "options": {}
      },
      {
        "content": "{% with ${1} as ${2} %}\n\t${0}\n{% endwith %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "with": true
        },
        "options": {}
      },
      {
        "content": "add:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "add": true
        },
        "options": {}
      },
      {
        "content": "center:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "center": true
        },
        "options": {}
      },
      {
        "content": "cut:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cut": true
        },
        "options": {}
      },
      {
        "content": "date:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "date": true
        },
        "options": {}
      },
      {
        "content": "default:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "default": true
        },
        "options": {}
      },
      {
        "content": "default_if_none:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defaultifnone": true
        },
        "options": {}
      },
      {
        "content": "dictsort:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dictsort": true
        },
        "options": {}
      },
      {
        "content": "dictsortreversed:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dictsortrev": true
        },
        "options": {}
      },
      {
        "content": "divisibleby:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "divisibleby": true
        },
        "options": {}
      },
      {
        "content": "floatformat:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "floatformat": true
        },
        "options": {}
      },
      {
        "content": "get_digit:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "getdigit": true
        },
        "options": {}
      },
      {
        "content": "join:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "join": true
        },
        "options": {}
      },
      {
        "content": "length_is:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lengthis": true
        },
        "options": {}
      },
      {
        "content": "pluralize:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pluralize": true
        },
        "options": {}
      },
      {
        "content": "removetags:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "removetags": true
        },
        "options": {}
      },
      {
        "content": "slice:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "slice": true
        },
        "options": {}
      },
      {
        "content": "stringformat:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "stringformat": true
        },
        "options": {}
      },
      {
        "content": "time:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "time": true
        },
        "options": {}
      },
      {
        "content": "truncatewords:${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "truncatewords": true
        },
        "options": {}
      },
      {
        "content": "truncatewords_html:${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "truncatewordshtml": true
        },
        "options": {}
      },
      {
        "content": "urlizetrunc:${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "urlizetrunc": true
        },
        "options": {}
      },
      {
        "content": "wordwrap:${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wordwrap": true
        },
        "options": {}
      },
      {
        "content": "{% $1 %}$2",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "%": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% ${1:tag_name} %}\n\t$2\n{% end$1 %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "%%": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{{ $1 }}$2",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "{": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% autoescape ${1:off} %}\n\t$2\n{% endautoescape %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "autoescape": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% block $1 %}\n\t$2\n{% endblock $1 %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "block": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{# ${1:comment} #}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% comment %}\n\t$1\n{% endcomment %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "comment": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% cycle ${1:val1} ${2:val2} ${3:as $4} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cycle": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% debug %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "debug": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% extends \"${1:base.html}\" %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "extends": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% filter $1 %}\n\t$2\n{% endfilter %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "filter": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% firstof $1 %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "firstof": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% for $1 in $2 %}\n\t$3\n{% endfor %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% empty %}\n\t$1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "empty": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% if $1 %}\n\t$2\n{% endif %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% if $1 %}$2{% endif %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "iif": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% else %}$1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ielse": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% else %}\n\t$1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "else": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% elif %}$1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ielif": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% elif %}\n\t$1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "elif": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% ifchanged %}$1{% endifchanged %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifchanged": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% ifequal $1 $2 %}\n\t$3\n{% endifequal %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifequal": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% ifnotequal $1 $2 %}\n\t$3\n{% endifnotequal %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifnotequal": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% include \"$1\" %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "include": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% load $1 %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "load": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% now \"${1:jS F Y H:i}\" %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "now": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% regroup $1 by $2 as $3 %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "regroup": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% spaceless %}$1{% endspaceless %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "spaceless": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% ssi $1 %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ssi": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% trans \"${1:string}\" %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "trans": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% url $1 as $2 %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "url": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% widthratio ${1:this_value} ${2:max_value} ${3:100} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "widthratio": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% with $1 as $2 %}\n\t${VISUAL}\n{% endwith %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "with": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% verbatim %}\n\t${VISUAL}\n{% endverbatim %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "verbatim": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{{ block.super }}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "super": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{{ STATIC_URL }}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "staticu": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% static \"${VISUAL}\" %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "static": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{{ MEDIA_URL }}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mediau": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% block ${1:blockname} %}${VISUAL}{% endblock $1 %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "iblock": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% csrf_token %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "csrf": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% blocktrans %}\n    ${VISUAL}\n{% endblocktrans %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "blocktrans": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "{% lorem $1 %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lorem": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "add:\"$1\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "add": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "center:\"$1\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "center": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "cut:\"$1\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cut": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "date:\"$1\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "date": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "default:\"$1\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "default": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "default_if_none:\"$1\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defaultifnone": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "dictsort:\"$1\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dictsort": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "dictsortreversed:\"$1\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dictsortrev": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "divisibleby:\"$1\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "divisibleby": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "floatformat:\"$1\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "floatformat": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "get_digit:\"$1\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "getdigit": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "join:\"$1\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "join": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "length_is:\"$1\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lengthis": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "pluralize:\"$1\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pluralize": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "removetags:\"$1\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "removetags": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "slice:\"$1\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "slice": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "stringformat:\"$1\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "stringformat": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "time:\"$1\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "time": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "truncatewords:$1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "truncatewords": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "truncatewords_html:$1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "truncatewordshtml": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "urlizetrunc:$1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "urlizetrunc": true
        },
        "options": {
          "b": true,
          "i": true
        }
      },
      {
        "content": "wordwrap:$1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wordwrap": true
        },
        "options": {
          "b": true,
          "i": true
        }
      }
    ],
    "htmljinja": [],
    "htmltornado": [
      {
        "content": "{{ ${0} }}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "{": true
        },
        "options": {}
      },
      {
        "content": "{% extends \"${0:base.html}\" %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "extends": true
        },
        "options": {}
      },
      {
        "content": "{% autoescape ${0:xhtml_escape | None} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "autoescape": true
        },
        "options": {}
      },
      {
        "content": "{% apply ${1:function} %}\n  ${0}\n{% end %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "apply": true
        },
        "options": {}
      },
      {
        "content": "{% block ${1} %}\n  ${0}\n{% end %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "block": true
        },
        "options": {}
      },
      {
        "content": "{% for ${1:item} in ${2} %}\n  ${0}\n{% end %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "{% from ${1:x} import ${0:y} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "from": true
        },
        "options": {}
      },
      {
        "content": "{% if ${1:condition} %}\n  ${0}\n{% end %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "{% elif ${0:condition} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eif": true
        },
        "options": {}
      },
      {
        "content": "{% else %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "el": true
        },
        "options": {}
      },
      {
        "content": "{% import ${0:module} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "import": true
        },
        "options": {}
      },
      {
        "content": "{% include \"${0:filename}\" %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "include": true
        },
        "options": {}
      },
      {
        "content": "{% module ${0:expression} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "module": true
        },
        "options": {}
      },
      {
        "content": "{% raw ${0:expression} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "raw": true
        },
        "options": {}
      },
      {
        "content": "{% set ${1:x} = ${0:y} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "set": true
        },
        "options": {}
      },
      {
        "content": "{% try %}\n  ${1:${VISUAL}}\n{% except %}\n  ${2}\n{% finallly %}\n  ${0}\n{% end %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "try": true
        },
        "options": {}
      },
      {
        "content": "{% while ${1:condition} %}\n  ${0}\n{% end %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh": true
        },
        "options": {}
      }
    ],
    "idris": [
      {
        "content": "import ${0:List}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "imp": true
        },
        "options": {}
      },
      {
        "content": "${1:fn} : ${2:a} -> ${3:a}\n$1 ${4} =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fn": true
        },
        "options": {}
      },
      {
        "content": "${1:fn} : ${2:a} -> ${3:a}\n$1 ${4} =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fn1": true
        },
        "options": {}
      },
      {
        "content": "${1:fn} : ${2:a} -> ${3:a} -> ${4:a}\n$1 ${5} =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fn2": true
        },
        "options": {}
      },
      {
        "content": "${1:fn} : ${2:a} -> ${3:a} -> ${4:a} -> ${5:a}\n$1 ${6} =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fn3": true
        },
        "options": {}
      },
      {
        "content": "${1:fn} : ${2:a}\n$1 =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fn0": true
        },
        "options": {}
      },
      {
        "content": "case ${1} of\n\t${2} =>\n\t\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case": true
        },
        "options": {}
      },
      {
        "content": "let\n\t${1} =\n\t\t${2}\nin\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "let": true
        },
        "options": {}
      },
      {
        "content": "where\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh": true
        },
        "options": {}
      },
      {
        "content": "if ${1} then\n\t${2:${VISUAL}}\nelse\n\t${0}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "(\\\\${1:_} => ${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\ \"Lambda function (\\x => ...)\"": true
        },
        "options": {}
      }
    ],
    "ignore": [
      {
        "content": "### OSX ###\n*.DS_Store\n.AppleDouble\n.LSOverride\n\n# Icon must end with two \r\nIcon\n# Thumbnails\n._*\n# Files that might appear in the root of a volume\n.DocumentRevisions-V100\n.fseventsd\n.Spotlight-V100\n.TemporaryItems\n.Trashes\n.VolumeIcon.icns\n.com.apple.timemachine.donotpresent\n# Directories potentially created on remote AFP share\n.AppleDB\n.AppleDesktop\nNetwork Trash Folder\nTemporary Items\n.apdisk\n\n### Node ###\n# Logs\nlogs\n*.log\nnpm-debug.log*\n\n# Runtime data\npids\n*.pid\n*.seed\n*.pid.lock\n\n# Directory for instrumented libs generated by jscoverage/JSCover\nlib-cov\n\n# Coverage directory used by tools like istanbul\ncoverage\n\n# nyc test coverage\n.nyc_output\n\n# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)\n.grunt\n\n# node-waf configuration\n.lock-wscript\n\n# Compiled binary addons (http://nodejs.org/api/addons.html)\nbuild/Release\n\n# Dependency directories\nnode_modules\njspm_packages\n\n# Optional npm cache directory\n.npm\n\n# Optional eslint cache\n.eslintcache\n\n# Optional REPL history\n.node_repl_history\n\n# Output of 'npm pack'\n*.tgz\n\n# Yarn Integrity file\n.yarn-integrity\n\n# Nuxt build\n.nuxt\n\n# Nuxt generate\ndist",
        "doc": "gitignore file",
        "grammar": "lsp",
        "label": "Gitignore",
        "matches": {
          "gitignore": true
        },
        "options": {}
      }
    ],
    "jade": [
      {
        "content": "div(ng-repeat='${1} in ${2}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rep": true
        },
        "options": {}
      },
      {
        "content": "div(ng-repeat='${1} in ${2}' | ${3})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "repf": true
        },
        "options": {}
      },
      {
        "content": "div(ng-repeat='${1} in ${2}' track by $index)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "repi": true
        },
        "options": {}
      },
      {
        "content": "div(ng-hide='${1}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "hide": true
        },
        "options": {}
      },
      {
        "content": "div(ng-show='${1}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "show": true
        },
        "options": {}
      },
      {
        "content": "div(ng-if='${1}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      }
    ],
    "java": [
      {
        "content": "class ${1} ${2:#:extends_or_implements}{\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "class": true
        },
        "options": {}
      },
      {
        "content": "interface ${1} ${2:#:extends}{\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "interface": true
        },
        "options": {}
      },
      {
        "content": "${1:void} ${2:#:method}(${3}) ${4:throws} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "method": true
        },
        "options": {}
      },
      {
        "content": "enum ${1:#:name} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "enum {}",
        "matches": {
          "enum": true
        },
        "options": {}
      },
      {
        "content": "public void set${1:Name}(${2:String} ${3:name}) {\nthis.$3 = $3;\n}${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "set": true
        },
        "options": {}
      },
      {
        "content": "public ${1:String} get${2:Name}() {\nreturn $2;\n}${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "get": true
        },
        "options": {}
      },
      {
        "content": "public void set${1:Name}(${2:String} ${3:name}) {\nthis.$3 = $3;\n}\npublic $2 get$1() {\nreturn $1;\n}${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "setget": true
        },
        "options": {}
      },
      {
        "content": "${1:#:type} ${2:#:var}${3};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "var": true
        },
        "options": {}
      },
      {
        "content": "static public final ${1:#:type} ${2:#:var} = ${3};${4}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "const": true
        },
        "options": {}
      },
      {
        "content": "static public final String ${1:var} = \"${2}\";${4}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "const_string": true
        },
        "options": {}
      },
      {
        "content": "public final ${1:#:type} ${2:#:var} = ${3};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "final": true
        },
        "options": {}
      },
      {
        "content": "assert ${1:#:test} : ${2:#:Failure message};${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "assert": true
        },
        "options": {}
      },
      {
        "content": "if (${1}) {\n    ${2:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "else {\n    ${1:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "else": true
        },
        "options": {}
      },
      {
        "content": "else if (${1}) {\n    ${2:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "elif": true,
          "elseif": true
        },
        "options": {}
      },
      {
        "content": "while (${1}) {\n    ${2:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "while": true
        },
        "options": {}
      },
      {
        "content": "for (${1}; ${2}; ${3}) {\n    ${4:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "for (${1} : ${2}) {\n    ${3:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fore": true,
          "foreach": true
        },
        "options": {}
      },
      {
        "content": "switch (${1}) {\n    ${2:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "switch": true
        },
        "options": {}
      },
      {
        "content": "case ${1}:\n    ${2:TARGET}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case": true
        },
        "options": {}
      },
      {
        "content": "break;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "br": true
        },
        "options": {}
      },
      {
        "content": "default:\n    ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "de": true,
          "default": true
        },
        "options": {}
      },
      {
        "content": "try {\n    ${0:TARGET}\n} catch (${1:Exception} ${2:e}) {\n    ${3:e.printStackTrace();}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "try": true
        },
        "options": {}
      },
      {
        "content": "try (${1:#:Resources}) {\n    ${0:TARGET}\n} catch (${2:Exception} ${3:e}) {\n    ${4:e.printStackTrace();}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "try_resources": true
        },
        "options": {}
      },
      {
        "content": "try {\n    ${0:TARGET}\n} catch (${1:Exception} ${2:e}) {\n    ${3:e.printStackTrace();}\n} finally {\n    ${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "try_finally": true
        },
        "options": {}
      },
      {
        "content": "catch (${1:Exception} ${2:e}) {\n    ${0:e.printStackTrace();}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "catch": true
        },
        "options": {}
      },
      {
        "content": "finally {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "finally": true
        },
        "options": {}
      },
      {
        "content": "throw ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "th": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "synchronized",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sy": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "public class ${1} extends ${2:TestCase} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tc": true,
          "testclass": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "public void test${1:#:Name}() throws Exception {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "test": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "import ${1};\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "import": true,
          "imt": true
        },
        "options": {}
      },
      {
        "content": "java.util.",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "j.u": true
        },
        "options": {}
      },
      {
        "content": "java.io.",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "j.i": true
        },
        "options": {}
      },
      {
        "content": "java.beans.",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "j.b": true
        },
        "options": {}
      },
      {
        "content": "java.net",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "j.n": true
        },
        "options": {}
      },
      {
        "content": "java.math.",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "j.m": true
        },
        "options": {}
      },
      {
        "content": "System.out.println(${1});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "println": true,
          "sout": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "System.out.printf(\"${1}\", ${2});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "printf": true,
          "souf": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "System.out.print(${1});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "print": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "System.out.format(${1});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "format": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "/**\n * ${0:TARGET}\n */",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "comment": true
        },
        "options": {}
      },
      {
        "content": "@author ${0:$TM_FULLNAME}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "author": true
        },
        "options": {}
      },
      {
        "content": "{@code ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "{code": true
        },
        "options": {}
      },
      {
        "content": "@deprecated ${0:#:description}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "deprecated": true
        },
        "options": {}
      },
      {
        "content": "{@docRoot",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "{docRoot": true
        },
        "options": {}
      },
      {
        "content": "{@inheritDoc",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "{inheritDoc": true
        },
        "options": {}
      },
      {
        "content": "{@link ${1:#:target} ${0:#:label}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "{link": true
        },
        "options": {}
      },
      {
        "content": "{@linkplain ${1:#:target} ${0:#:label}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "{linkplain": true
        },
        "options": {}
      },
      {
        "content": "{@literal ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "{literal": true
        },
        "options": {}
      },
      {
        "content": "@param ${1:#:var} ${0:#:description}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "param": true
        },
        "options": {}
      },
      {
        "content": "@return ${0:#:description}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "return": true
        },
        "options": {}
      },
      {
        "content": "@see ${0:#:reference}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "see": true
        },
        "options": {}
      },
      {
        "content": "@serial ${0:#:description}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "serial": true
        },
        "options": {}
      },
      {
        "content": "@serialField ${0:#:description}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sd": true
        },
        "options": {}
      },
      {
        "content": "@serialField ${1:#:name} ${2:#:type} ${0:#:description}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sf": true
        },
        "options": {}
      },
      {
        "content": "@since ${0:#:version}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "since": true
        },
        "options": {}
      },
      {
        "content": "@throws ${1:#:class} ${0:#:description}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "throws": true
        },
        "options": {}
      },
      {
        "content": "{@value ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "{value": true
        },
        "options": {}
      },
      {
        "content": "@version ${0:#:version}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ver": true,
          "version": true
        },
        "options": {}
      },
      {
        "content": "public class ${1:Hello} {\n  static public void main(String args[]) {\n    System.out.println(\"Hello, world!\");\n  }\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "helloworld": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "protected ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "po": true
        },
        "options": {}
      },
      {
        "content": "public ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pu": true
        },
        "options": {}
      },
      {
        "content": "private ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pr": true
        },
        "options": {}
      },
      {
        "content": "@Before\nstatic void ${1:intercept}(${2:args}) { ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "before": true
        },
        "options": {}
      },
      {
        "content": "@ManyToMany\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mm": true
        },
        "options": {}
      },
      {
        "content": "@ManyToOne\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mo": true
        },
        "options": {}
      },
      {
        "content": "@OneToMany${1:(cascade=CascadeType.ALL)}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "om": true
        },
        "options": {}
      },
      {
        "content": "@OneToOne\n${1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "oo": true
        },
        "options": {}
      },
      {
        "content": "import ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "im": true
        },
        "options": {}
      },
      {
        "content": "java.beans.",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "j.b": true
        },
        "options": {}
      },
      {
        "content": "java.io.",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "j.i": true
        },
        "options": {}
      },
      {
        "content": "java.math.",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "j.m": true
        },
        "options": {}
      },
      {
        "content": "java.net.",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "j.n": true
        },
        "options": {}
      },
      {
        "content": "java.util.",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "j.u": true
        },
        "options": {}
      },
      {
        "content": "extends ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ext": true
        },
        "options": {}
      },
      {
        "content": "implements ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "imp": true
        },
        "options": {}
      },
      {
        "content": "/*\n * ${0}\n */",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "/*": true
        },
        "options": {}
      },
      {
        "content": "static public final ${1:String} ${2:var} = ${3};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "co": true
        },
        "options": {}
      },
      {
        "content": "static public final String ${1:var} = \"${2}\";",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cos": true
        },
        "options": {}
      },
      {
        "content": "case ${1}:\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case": true
        },
        "options": {}
      },
      {
        "content": "default:\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "def": true
        },
        "options": {}
      },
      {
        "content": "else",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "el": true
        },
        "options": {}
      },
      {
        "content": "else if (${1}) ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eif": true
        },
        "options": {}
      },
      {
        "content": "if (${1}) ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "switch (${1}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sw": true
        },
        "options": {}
      },
      {
        "content": "${1:void} ${2:method}(${3}) ${4:throws }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "m": true
        },
        "options": {}
      },
      {
        "content": "${1:String} ${2:var}${3: = null}${4};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "v": true
        },
        "options": {}
      },
      {
        "content": "List<${1:Object}> ${2:list} = new ArrayList<$1>();${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d.al": true
        },
        "options": {}
      },
      {
        "content": "Map<${1:Object}, ${2:Object}> ${3:map} = new HashMap<$1, $2>();${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d.hm": true
        },
        "options": {}
      },
      {
        "content": "Set<${1:Object}> ${2:set} = new HashSet<$1>();${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d.hs": true
        },
        "options": {}
      },
      {
        "content": "Stack<${1:Object}> ${2:stack} = new Stack<$1>();${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d.st": true
        },
        "options": {}
      },
      {
        "content": "abstract ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ab": true
        },
        "options": {}
      },
      {
        "content": "final ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fi": true
        },
        "options": {}
      },
      {
        "content": "static ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "st": true
        },
        "options": {}
      },
      {
        "content": "synchronized ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sy": true
        },
        "options": {}
      },
      {
        "content": "System.err.print(\"${0:Message}\");",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "err": true
        },
        "options": {}
      },
      {
        "content": "System.err.printf(\"${1:Message}\", ${0:exception});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "errf": true
        },
        "options": {}
      },
      {
        "content": "System.err.println(\"${0:Message}\");",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "errln": true
        },
        "options": {}
      },
      {
        "content": "assert ${1:test} : \"${2:Failure message}\";",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as": true
        },
        "options": {}
      },
      {
        "content": "assertEquals(\"${1:Failure message}\", ${2:expected}, ${3:actual});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ae": true
        },
        "options": {}
      },
      {
        "content": "assertArrayEquals(\"${1:Failure message}\", ${2:expecteds}, ${3:actuals});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "aae": true
        },
        "options": {}
      },
      {
        "content": "assertFalse(\"${1:Failure message}\", ${2:condition});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "af": true
        },
        "options": {}
      },
      {
        "content": "assertTrue(\"${1:Failure message}\", ${2:condition});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "at": true
        },
        "options": {}
      },
      {
        "content": "assertNull(\"${1:Failure message}\", ${2:object});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "an": true
        },
        "options": {}
      },
      {
        "content": "assertNotNull(\"${1:Failure message}\", ${2:object});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ann": true
        },
        "options": {}
      },
      {
        "content": "assertSame(\"${1:Failure message}\", ${2:expected}, ${3:actual});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ass": true
        },
        "options": {}
      },
      {
        "content": "assertNotSame(\"${1:Failure message}\", ${2:expected}, ${3:actual});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asns": true
        },
        "options": {}
      },
      {
        "content": "fail(\"${1:Failure message}\");",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fa": true
        },
        "options": {}
      },
      {
        "content": "catch(${1:Exception} ${2:e}) ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ca": true
        },
        "options": {}
      },
      {
        "content": "throw ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "thr": true
        },
        "options": {}
      },
      {
        "content": "throws ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ths": true
        },
        "options": {}
      },
      {
        "content": "try {\n\t${0:${VISUAL}}\n} catch(${1:Exception} ${2:e}) {\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "try": true
        },
        "options": {}
      },
      {
        "content": "try {\n\t${0:${VISUAL}}\n} catch(${1:Exception} ${2:e}) {\n} finally {\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tryf": true
        },
        "options": {}
      },
      {
        "content": "List<${1:listName}> ${2:items} = $1.findAll();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "findall": true
        },
        "options": {}
      },
      {
        "content": "${1:var} ${2:item} = $1.findById(${3});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "findbyid": true
        },
        "options": {}
      },
      {
        "content": "/**\n * ${0}\n */",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "/**": true
        },
        "options": {}
      },
      {
        "content": "@brief ${0:Description}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@br": true
        },
        "options": {}
      },
      {
        "content": "@param ${0:param}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@pa": true
        },
        "options": {}
      },
      {
        "content": "@return ${0:param}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@re": true
        },
        "options": {}
      },
      {
        "content": "Logger.debug(${1:param});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "debug": true
        },
        "options": {}
      },
      {
        "content": "Logger.error(${1:param});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "error": true
        },
        "options": {}
      },
      {
        "content": "Logger.info(${1:param});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "info": true
        },
        "options": {}
      },
      {
        "content": "Logger.warn(${1:param});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "warn": true
        },
        "options": {}
      },
      {
        "content": "for (${1} : ${2}) ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "enfor": true
        },
        "options": {}
      },
      {
        "content": "for (${1}; ${2}; ${3}) ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "while (${1}) ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh": true
        },
        "options": {}
      },
      {
        "content": "public static void main (String[] args) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "psvm": true
        },
        "options": {}
      },
      {
        "content": "public static void main (String[] args) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "main": true
        },
        "options": {}
      },
      {
        "content": "System.out.println(${0});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sout": true
        },
        "options": {}
      },
      {
        "content": "System.err.println(${0});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "serr": true
        },
        "options": {}
      },
      {
        "content": "System.out.print(\"${0:Message}\");",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "print": true
        },
        "options": {}
      },
      {
        "content": "System.out.printf(\"${1:Message}\", ${0:args});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "printf": true
        },
        "options": {}
      },
      {
        "content": "System.out.println(${0});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "println": true
        },
        "options": {}
      },
      {
        "content": "System.out.println(Arrays.toString(${0}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "printlna": true
        },
        "options": {}
      },
      {
        "content": "render(${1:param});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ren": true
        },
        "options": {}
      },
      {
        "content": "renderArgs.put(\"${1}\", ${2});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rena": true
        },
        "options": {}
      },
      {
        "content": "renderBinary(${1:param});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "renb": true
        },
        "options": {}
      },
      {
        "content": "renderJSON(${1:param});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "renj": true
        },
        "options": {}
      },
      {
        "content": "renderXml(${1:param});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "renx": true
        },
        "options": {}
      },
      {
        "content": "${1:public} void set${3:}(${2:String} ${0:}){\n\tthis.$4 = $4;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "set": true
        },
        "options": {}
      },
      {
        "content": "${1:public} ${2:String} get${3:}(){\n\treturn this.${0:};\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "get": true
        },
        "options": {}
      },
      {
        "content": "return ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "re": true
        },
        "options": {}
      },
      {
        "content": "break;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "br": true
        },
        "options": {}
      },
      {
        "content": "public void test${1:Name}() throws Exception {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "t": true
        },
        "options": {}
      },
      {
        "content": "@Test\npublic void test${1:Name}() throws Exception {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "test": true
        },
        "options": {}
      },
      {
        "content": "Scanner",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Sc": true
        },
        "options": {}
      },
      {
        "content": "public static void ${1:index}(${2:args}) { ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "action": true
        },
        "options": {}
      },
      {
        "content": "notFound(${1:param});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rnf": true
        },
        "options": {}
      },
      {
        "content": "notFoundIfNull(${1:param});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rnfin": true
        },
        "options": {}
      },
      {
        "content": "redirect(${1:param});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rr": true
        },
        "options": {}
      },
      {
        "content": "unauthorized(${1:param});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ru": true
        },
        "options": {}
      },
      {
        "content": "(unless=${1:param});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "unless": true
        },
        "options": {}
      }
    ],
    "javascript": [
      {
        "content": "const express = require('express');\nconst app = express();\nconst port = process.env.PORT || ${1:port};\nconst www = process.env.WWW || '${2:./}';\napp.use(express.static(www));\nconsole.log(`serving \\${www}`);\napp.get('*', (req, res) => {\n\tres.sendFile(`index.html`, { root: www });\n});\napp.listen(port, () => console.log(`listening on http://localhost:\\${port}`));\n$0",
        "doc": "Node.js Express Server",
        "grammar": "lsp",
        "label": "Node.js Express Server",
        "matches": {
          "ex-node-server-simple": true
        },
        "options": {}
      },
      {
        "content": "${1:#:method_name}: function(${2:#:attribute}) {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":f": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "function ${1:#:function_name}(${2:#:argument}) {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "func",
        "matches": {
          "function": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "function ${1:function_name}(${2:argument}) {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "func2",
        "matches": {
          "function2": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "${1:#:class_name}.prototype.${2:#:method_name} = function(${3:#:first_argument}) {\n  ${0:TARGET}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "proto": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "function(${1}) { ${0:TARGET} };",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "f": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "if (${1:true}) {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "if (${1:#:condition}) {\n  ${2:TARGET}\n} else {\n  ${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "ife",
        "matches": {
          "if-else": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "for (let ${1:i} = 0; $1 < ${2:#:Things}.length; ++$1) {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "for (let ${1:i} in ${2:#:Things}) {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forin": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "for (let ${1:i} of ${2:#:Things}) {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forof": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "while (${1:true}) {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "while": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "switch (${1:#:let}) {\n  case ${2:#:val}:\n    ${0:TARGET}\n    break;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "switch": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "try {\n  ${1:TARGET}\n} catch (${2:e}) {\n  ${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "try": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "try {\n  ${1:TARGET}\n} catch (${2:e}) {\n  ${3}\n} finally {\n  ${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "try_finally": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "${1:#:value_name}: ${0:#:value},",
        "doc": "",
        "grammar": "snu",
        "label": ":,",
        "matches": {
          "key-value": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "setTimeout(function() { ${0} }, ${1:10});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "setTimeout-function": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "debugger;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "db": true,
          "debugger": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "console.log(${0:TARGET});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cl": true,
          "console-log": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "console.trace();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "console-trace": true,
          "ct": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "console.error(${0:TARGET});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ce": true,
          "console-error": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "console.warn(${0:TARGET});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "console-warn": true,
          "cw": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "console.info(${0:TARGET});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci": true,
          "console-info": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "(function(${1}) {\n  'use strict';\n  ${0:TARGET}\n})(${2});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "iife": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "JSON.stringify(${1:TARGET}, null, 2);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "js": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "console.log(JSON.stringify(${1:TARGET}, null, 2));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jsc": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "class ${1:#:NAME} {\n  constructor(${2:#:ARGS}) {\n    ${0:TARGET}\n  }\n}",
        "doc": "",
        "grammar": "snu",
        "label": "class {...}",
        "matches": {
          "class": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "class ${1:#:NAME} extends ${2:#:SuperClass} {\n  constructor(${3:#:ARGS}) {\n    ${0:TARGET}\n  }\n}",
        "doc": "",
        "grammar": "snu",
        "label": "class extends {...}",
        "matches": {
          "class-extends": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "static ${1:#:NAME}(${2:#:ARGS}) {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "static": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "set ${1:#:NAME}(${2:#:ARGS}) {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "set": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "get ${1:#:NAME}() {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "get": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "import { ${1:MEMBERS} } from \"${0:TARGET}\";",
        "doc": "",
        "grammar": "snu",
        "label": "import { member, ... } from \"module-name\";",
        "matches": {
          "import": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "import ${1:defaultMember} from \"${0:TARGET}\";",
        "doc": "",
        "grammar": "snu",
        "label": "import defaultMember from \"module-name\";",
        "matches": {
          "import-default": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "import * as ${1:NAME} from \"${0:TARGET}\";",
        "doc": "",
        "grammar": "snu",
        "label": "import * as NAME from \"...\";",
        "matches": {
          "import-all": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "import ${1:defaultMember}, { ${2:MEMBERS} } from \"${0:TARGET}\";",
        "doc": "",
        "grammar": "snu",
        "label": "import defaultMember, { member, ... } from \"module-name\";",
        "matches": {
          "import-default-member": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "${1:class_name}.prototype.${2:method_name} = function(${3}) {\n\t${0:${VISUAL}}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "proto": true
        },
        "options": {}
      },
      {
        "content": "function ${1:function_name}(${2}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fun \"function\"": true
        },
        "options": {}
      },
      {
        "content": "async function ${1:function_name}(${2}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asf \"async function\"": true
        },
        "options": {}
      },
      {
        "content": "function(${1}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "anf \"\" w": true
        },
        "options": {}
      },
      {
        "content": "var ${1:function_name} = function(${2}) {\n\t${0:${VISUAL}}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vaf": true
        },
        "options": {}
      },
      {
        "content": "var ${1:function_name} = function $1(${2}) {\n\t${0:${VISUAL}}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vf": true
        },
        "options": {}
      },
      {
        "content": "(function(${1}) {\n\t${0:${VISUAL}}\n}(${2}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "(f": true
        },
        "options": {}
      },
      {
        "content": ";(function(${1}) {\n\t${0:${VISUAL}}\n}(${2}))",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ";fe": true
        },
        "options": {}
      },
      {
        "content": "var ${1:function_name} = function (${2:argument}) {\n\t${3}\n\t$1 = function ($2) {\n\t\t${0:${VISUAL}}\n\t};\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sdf": true
        },
        "options": {}
      },
      {
        "content": "if (${1:true}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if \"if (condition) { ... }\"": true
        },
        "options": {}
      },
      {
        "content": "if (${1:true}) {\n\t${0:${VISUAL}}\n} else {\n\t${2}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife \"if (condition) { ... } else { ... }\"": true
        },
        "options": {}
      },
      {
        "content": "${1:/* condition */} ? ${2:/* if true */} : ${0:/* if false */}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ter": true
        },
        "options": {}
      },
      {
        "content": "switch (${1:expression}) {\n\tcase '${3:case}':\n\t\t${4}\n\t\tbreak;\n\t${0}\n\tdefault:\n\t\t${2}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "switch": true
        },
        "options": {}
      },
      {
        "content": "case '${1:case}':\n\t${0:${VISUAL}}\n\tbreak;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case \"case 'xyz': ... break\"": true
        },
        "options": {}
      },
      {
        "content": "try {\n\t${0:${VISUAL}}\n} catch (${1:e}) {\n\t${2:/* handle error */}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "try \"try { ... } catch(e) { ... }\"": true
        },
        "options": {}
      },
      {
        "content": "try {\n\t${0:${VISUAL}}\n} catch (${1:e}) {\n\t${2:/* handle error */}\n} finally {\n\t${3:/* be executed regardless of the try / catch result*/}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tryf \"try { ... } catch(e) { ... } finally { ... }\"": true
        },
        "options": {}
      },
      {
        "content": "throw new Error('${1:error message}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "terr": true
        },
        "options": {}
      },
      {
        "content": "return ${0:result};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ret": true
        },
        "options": {}
      },
      {
        "content": "for (let ${1:i} = 0, ${2:len} = ${3:Things.length}; $1 < $2; $1++) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for \"for (...) {...}\"": true
        },
        "options": {}
      },
      {
        "content": "for (let ${2:i} = ${1:Things.length} - 1; $2 >= 0; $2--) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forr \"reversed for (...) {...}\"": true
        },
        "options": {}
      },
      {
        "content": "while (${1:/* condition */}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh \"(condition) { ... }\"": true
        },
        "options": {}
      },
      {
        "content": "do {\n\t${0:${VISUAL}}\n} while (${1:/* condition */});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "do \"do { ... } while (condition)\"": true
        },
        "options": {}
      },
      {
        "content": "for (let ${1:prop} in ${2:object}) {\n\t${0:$2[$1]}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fori": true
        },
        "options": {}
      },
      {
        "content": "${1:method_name}: function (${2:attribute}) {\n\t${0:${VISUAL}}\n},",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":f": true
        },
        "options": {}
      },
      {
        "content": "hasOwnProperty(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "has": true
        },
        "options": {}
      },
      {
        "content": "function ${1:Singleton} (${2:argument}) {\n\t// the cached instance\n\tvar instance;\n\t// rewrite the constructor\n\t$1 = function $1($2) {\n\t\treturn instance;\n\t};\n\t// carry over the prototype properties\n\t$1.prototype = this;\n\t// the instance\n\tinstance = new $1();\n\t// reset the constructor pointer\n\tinstance.constructor = $1;\n\t${0}\n\treturn instance;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sing": true
        },
        "options": {}
      },
      {
        "content": "function object(o) {\n\tfunction F() {}\n\tF.prototype = o;\n\treturn new F();\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "obj": true
        },
        "options": {}
      },
      {
        "content": "var ${1:my_object} = Object.defineProperties(\n\t${2:new Object()},\n\t{\n\t\t${3:property} : {\n\t\t\tget : function $1_$3_getter() {\n\t\t\t\t// getter code\n\t\t\t},\n\t\t\tset : function $1_$3_setter(value) {\n\t\t\t\t// setter code\n\t\t\t},\n\t\t\tvalue        : ${4:value},\n\t\t\twriteable    : ${5:boolean},\n\t\t\tenumerable   : ${6:boolean},\n\t\t\tconfigurable : ${0:boolean}\n\t\t}\n\t}\n);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "props": true
        },
        "options": {}
      },
      {
        "content": "Object.defineProperty(\n\t${1:object},\n\t'${2:property}',\n\t{\n\t\tget : function $1_$2_getter() {\n\t\t\t// getter code\n\t\t},\n\t\tset : function $1_$2_setter(value) {\n\t\t\t// setter code\n\t\t},\n\t\tvalue        : ${3:value},\n\t\twriteable    : ${4:boolean},\n\t\tenumerable   : ${5:boolean},\n\t\tconfigurable : ${0:boolean}\n\t}\n);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prop": true
        },
        "options": {}
      },
      {
        "content": "/**\n * ${0:description}\n *\n */",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "/**": true
        },
        "options": {}
      },
      {
        "content": "@param {${1:type}} ${2:name} ${0:description}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@par": true
        },
        "options": {}
      },
      {
        "content": "@return {${1:type}} ${0:description}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@ret": true
        },
        "options": {}
      },
      {
        "content": "JSON.parse(${0:jstr});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jsonp": true
        },
        "options": {}
      },
      {
        "content": "JSON.stringify(${0:object});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jsons": true
        },
        "options": {}
      },
      {
        "content": "getElementsBy${1:TagName}('${0}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "get": true
        },
        "options": {}
      },
      {
        "content": "getElementBy${1:Id}('${0}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gett": true
        },
        "options": {}
      },
      {
        "content": "${1:document}.getElementsByClassName('${0:class}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "by.": true
        },
        "options": {}
      },
      {
        "content": "${1:document}.getElementById('${0:element ID}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "by#": true
        },
        "options": {}
      },
      {
        "content": "${1:document}.querySelector('${0:CSS selector}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "qs": true
        },
        "options": {}
      },
      {
        "content": "${1:document}.querySelectorAll('${0:CSS selector}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "qsa": true
        },
        "options": {}
      },
      {
        "content": "debugger;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "de": true
        },
        "options": {}
      },
      {
        "content": "console.log(${0});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cl \"console.log\"": true
        },
        "options": {}
      },
      {
        "content": "console.debug(${0});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cd \"console.debug\"": true
        },
        "options": {}
      },
      {
        "content": "console.error(${0});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ce \"console.error\"": true
        },
        "options": {}
      },
      {
        "content": "console.warn(${0});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cw \"console.warn\"": true
        },
        "options": {}
      },
      {
        "content": "console.info(${0});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ci \"console.info\"": true
        },
        "options": {}
      },
      {
        "content": "console.trace(${0:label});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ct \"console.trace\"": true
        },
        "options": {}
      },
      {
        "content": "console.time(\"${1:label}\");\n${0:${VISUAL}}\nconsole.timeEnd(\"$1\");",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ctime \"console.time ... console.timeEnd\"": true
        },
        "options": {}
      },
      {
        "content": "console.timeStamp(\"${1:label}\");",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ctimestamp \"console.timeStamp\"": true
        },
        "options": {}
      },
      {
        "content": "console.assert(${1:expression}, ${0:obj});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ca \"console.assert\"": true
        },
        "options": {}
      },
      {
        "content": "console.clear();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cclear \"console.clear\"": true
        },
        "options": {}
      },
      {
        "content": "console.dir(${0:obj});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cdir \"console.dir\"": true
        },
        "options": {}
      },
      {
        "content": "console.dirxml(${1:object});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cdirx \"console.dirxml\"": true
        },
        "options": {}
      },
      {
        "content": "console.group(\"${1:label}\");\n${0:${VISUAL}}\nconsole.groupEnd();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cgroup \"console.group\"": true
        },
        "options": {}
      },
      {
        "content": "console.groupCollapsed(\"${1:label}\");\n${0:${VISUAL}}\nconsole.groupEnd();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cgroupc \"console.groupCollapsed\"": true
        },
        "options": {}
      },
      {
        "content": "console.profile(\"${1:label}\");\n${0:${VISUAL}}\nconsole.profileEnd();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cprof \"console.profile\"": true
        },
        "options": {}
      },
      {
        "content": "console.table(${1:\"${2:value}\"});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ctable \"console.table\"": true
        },
        "options": {}
      },
      {
        "content": "console.log(JSON.stringify(${0}, null, 2));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "clstr \"console.log stringified\"": true
        },
        "options": {}
      },
      {
        "content": "'use strict';",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "us": true
        },
        "options": {}
      },
      {
        "content": "setTimeout(function () {${0}}${2}, ${1:10});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "timeout": true
        },
        "options": {}
      },
      {
        "content": "const ${1} = ${0};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "const": true
        },
        "options": {}
      },
      {
        "content": "const ${1} = new ${0};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "constn": true
        },
        "options": {}
      },
      {
        "content": "let ${1} = ${0};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "let": true
        },
        "options": {}
      },
      {
        "content": "import ${1} from '${2:$1}';",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "im \"import xyz from 'xyz'\"": true
        },
        "options": {}
      },
      {
        "content": "import * as ${1} from '${2:$1}';",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "imas \"import * as xyz from 'xyz'\"": true
        },
        "options": {}
      },
      {
        "content": "import { ${1} } from '${2}';",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "imm \"import { member } from 'xyz'\"": true
        },
        "options": {}
      },
      {
        "content": "class ${1} {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cla": true
        },
        "options": {}
      },
      {
        "content": "class ${1} extends ${2} {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "clax": true
        },
        "options": {}
      },
      {
        "content": "class ${1} {\n\tconstructor(${2}) {\n\t\t${0:${VISUAL}}\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "clac": true
        },
        "options": {}
      },
      {
        "content": "for (const ${1:prop} of ${2:object}) {\n\t${0:$1}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "foro \"for (const prop of object}) { ... }\"": true
        },
        "options": {}
      },
      {
        "content": "for (let ${1:prop} of ${2:object}) {\n\t${0:$1}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forl \"for (let prop of object}) { ... }\"": true
        },
        "options": {}
      },
      {
        "content": "function* ${1:function_name}(${2}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fun*": true
        },
        "options": {}
      },
      {
        "content": "const ${1:function_name} = (${2}) => {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "c=>": true
        },
        "options": {}
      },
      {
        "content": "const ${1:function_name} = async (${2}) => {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ca=>": true
        },
        "options": {}
      },
      {
        "content": "const ${1:function_name} = (${2}) => {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "caf": true
        },
        "options": {}
      },
      {
        "content": "const ${1:function_name} = async (${2}) => {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "casf": true
        },
        "options": {}
      },
      {
        "content": "(${1}) => {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "=>": true
        },
        "options": {}
      },
      {
        "content": "(${1}) => ${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "af \"() =>\"": true
        },
        "options": {}
      },
      {
        "content": "(${1}) => {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "afb \"() => {}\"": true
        },
        "options": {}
      },
      {
        "content": "const ${1} = Symbol('${0}');",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sym": true
        },
        "options": {}
      },
      {
        "content": "export default ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ed": true
        },
        "options": {}
      },
      {
        "content": "${${1}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "${": true
        },
        "options": {}
      },
      {
        "content": "async ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as \"async\"": true
        },
        "options": {}
      },
      {
        "content": "await ${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "aw \"await\"": true
        },
        "options": {}
      }
    ],
    "javascript-angular": [
      {
        "content": "it('${1:description}', inject(function($2) {\n\t$0\n}));",
        "doc": "",
        "grammar": "snu",
        "label": "it (js, inject)",
        "matches": {
          "iti": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "beforeEach(inject(function($1) {\n\t$0\n}));",
        "doc": "",
        "grammar": "snu",
        "label": "before each (js, inject)",
        "matches": {
          "befi": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "config(function($1) {\n\t$0\n});",
        "doc": "",
        "grammar": "snu",
        "label": "angular config",
        "matches": {
          "aconf": true
        },
        "options": {
          "i": true
        }
      }
    ],
    "javascript-bemjson": [
      {
        "content": "{\n\tblock : '${1:name}',\n\tcontent : [\n\t\t'${2:content}'\n\t]\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "b": true
        },
        "options": {}
      },
      {
        "content": "{\n\t block : '${1:name}',\n\t content: '${2:content}'\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "btc": true
        },
        "options": {}
      },
      {
        "content": "{\n\tblock : '${1:name}',\n\tmods: { ${2:modName}: '${3:modVal}' },\n\tcontent : [\n\t\t'${4:content}'\n\t]\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bwm": true
        },
        "options": {}
      },
      {
        "content": "{\n\telem : '${1:name}',\n\tcontent : [\n\t\t'${2:content}'\n\t]\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "e": true
        },
        "options": {}
      },
      {
        "content": "mods : { ${1:modName} : '${2:modVal}' },",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mo": true
        },
        "options": {}
      },
      {
        "content": "mix : [ { ${1:block} : '${2:block}' } ],",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mi": true
        },
        "options": {}
      },
      {
        "content": "attrs : { ${1:attr} : '${2:val}' },",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "a": true
        },
        "options": {}
      }
    ],
    "javascript-d3": [
      {
        "content": ".attr(\"${1}\", ${2})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ".attr": true
        },
        "options": {}
      },
      {
        "content": ".style(\"${1}\", ${2})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ".style": true
        },
        "options": {}
      },
      {
        "content": "d3.svg.axis()\n  .orient(${1})\n  .scale(${2})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "axis": true
        },
        "options": {}
      },
      {
        "content": "function(d) { ${1} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fd": true
        },
        "options": {}
      },
      {
        "content": "function(d, i) { ${1} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fdi": true
        },
        "options": {}
      },
      {
        "content": "var ${1:margin} = { top: ${2:10}, right: ${3:10}, bottom: ${4:10}, left: ${5:10} };\nvar ${6:width} = ${7:970} - $1.left - $1.right;\nvar ${8:height} = ${9:500} - $1.top - $1.bottom;\nvar ${10:svg} = d3.select(\"${11}\").append(\"svg\")\n  .attr(\"width\", $6 + $1.left + $1.right)\n  .attr(\"height\", $8 + $1.top + $1.bottom)\n    .append(\"g\")\n  .attr(\"transform\", \"translate(\" + $1.left + \",\" + $1.top + \")\")",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "marginconvention": true
        },
        "options": {}
      },
      {
        "content": "d3.nest()\n  .key(${1})\n  .entries(${2})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nest": true
        },
        "options": {}
      },
      {
        "content": "d3.scale.linear()\n  .domain(${1})\n  .range(${2})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "scale": true
        },
        "options": {}
      }
    ],
    "javascript-ember": [
      {
        "content": "import Application from '@ember/application';\n\nexport default Application.extend({\n\t${0://Properties here...}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "App.Name = Ember.Application.create({});",
        "matches": {
          "eapp": true
        },
        "options": {}
      },
      {
        "content": "import DS from 'ember-data';\n\nexport default DS.Model.extend({\n\t${0://Properties here...}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "import DS from 'ember-data';",
        "matches": {
          "emod": true
        },
        "options": {}
      },
      {
        "content": "import Controller from '@ember/controller';\n\nexport default Controller.extend({\n\t${0://Properties here...}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "import Controller from '@ember/controller';",
        "matches": {
          "econtroller": true
        },
        "options": {}
      },
      {
        "content": "import Route from '@ember/routing/route';\n\nexport default Route.extend({\n\t${0://Properties here...}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "import Route from '@ember/routing/route';",
        "matches": {
          "eroute": true
        },
        "options": {}
      },
      {
        "content": "import Component from '@ember/component';\n\nexport default Component.extend({\n\t${0://Properties here...}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "import Component from '@ember/component';",
        "matches": {
          "ecomponent": true
        },
        "options": {}
      },
      {
        "content": "import EmberObject from '@ember/object';\n\nexport default EmberObject.extend({\n\t${0://Properties here...}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "import EmberObject from '@ember/object';",
        "matches": {
          "eobj": true
        },
        "options": {}
      },
      {
        "content": "import Mixin from '@ember/object/mixin';\n\nexport default Mixin.create({\n\t${0://Properties here...}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "App.MixinName = Ember.Model.extend({...});",
        "matches": {
          "emix": true
        },
        "options": {}
      },
      {
        "content": "${1:this}.get('${2:property}');",
        "doc": "",
        "grammar": "snu",
        "label": "this.get('property');",
        "matches": {
          "eget": true
        },
        "options": {}
      },
      {
        "content": "${1:this}.set('${2:property}', ${3:value});",
        "doc": "",
        "grammar": "snu",
        "label": "this.set('property', value);",
        "matches": {
          "eset": true
        },
        "options": {}
      },
      {
        "content": "import { computed } from '@ember/object';",
        "doc": "",
        "grammar": "snu",
        "label": "import { computed } from '@ember/object';",
        "matches": {
          "cproimport": true
        },
        "options": {}
      },
      {
        "content": "${1:property_name}: computed('${3:argument}', function() {\n\t${0://body...}\n}),",
        "doc": "",
        "grammar": "snu",
        "label": "property_name: computed('...', function() {...}),",
        "matches": {
          "cpro": true
        },
        "options": {}
      },
      {
        "content": "import { observer } from '@ember/object';",
        "doc": "",
        "grammar": "snu",
        "label": "import { observer } from '@ember/object';",
        "matches": {
          "prooimport": true
        },
        "options": {}
      },
      {
        "content": "${1:property_name}: observer('${3:argument}', function() {\n\t${0://body...}\n}),",
        "doc": "",
        "grammar": "snu",
        "label": "property_name: observer('...', function() {...}),",
        "matches": {
          "proo": true
        },
        "options": {}
      }
    ],
    "javascript-jasmine": [
      {
        "content": "describe('${1:description}', function() {\n\t$0\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "des \"Describe (js)\"": true
        },
        "options": {}
      },
      {
        "content": "it('${1:description}', function() {\n\t$0\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "it \"it (js)\"": true
        },
        "options": {}
      },
      {
        "content": "beforeEach(function() {\n\t$0\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bef \"before each (js)\"": true
        },
        "options": {}
      },
      {
        "content": "afterEach(function() {\n\t$0\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "aft \"after each (js)\"": true
        },
        "options": {}
      },
      {
        "content": "beforeAll(function() {\n\t$0\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "befa \"before all (js)\"": true
        },
        "options": {}
      },
      {
        "content": "afterAll(function() {\n\t$0\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "afta \"after all (js)\"": true
        },
        "options": {}
      },
      {
        "content": "jasmine.any($1)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "any \"any (js)\"": true
        },
        "options": {}
      },
      {
        "content": "jasmine.anything()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "anyt \"anything (js)\"": true
        },
        "options": {}
      },
      {
        "content": "jasmine.objectContaining({\n\t${VISUAL}$0\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "objc \"object containing (js)\"": true
        },
        "options": {}
      },
      {
        "content": "jasmine.arrayContaining([${1:value1}]);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "arrc \"array containing (js)\"": true
        },
        "options": {}
      },
      {
        "content": "jasmine.stringMatching(\"${1:matcher}\")",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "strm \"string matching (js)\"": true
        },
        "options": {}
      },
      {
        "content": "runs(function() {\n\t$0\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ru \"runs (js)\"": true
        },
        "options": {}
      },
      {
        "content": "waits($1);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wa \"waits (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target})$0;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ex \"expect (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).toEqual(${2:value});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ee \"expect to equal (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).toBeLessThan(${2:value});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "el \"expect to be less than (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).toBeGreaterThan(${2:value});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eg \"expect to be greater than (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).toBe(${2:value});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eb \"expect to be (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).toMatch(${2:pattern});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "em \"expect to match (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).toHaveAttr('${2:attr}'${3:, '${4:value}'});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eha \"expect to have attribute (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).toBeTruthy();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "et \"expect to be truthy (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).toBeFalsy();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ef \"expect to be falsy (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).toBeDefined();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "etbd \"expect to be defined (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).toBeUndefined();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eud \"expect to be defined (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).toBeNull();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "en \"expect to be null (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).toContain(${2:value});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ec \"expect to contain (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).toBeVisible();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ev \"expect to be visible (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).toBeHidden();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eh \"expect to be hidden (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).toThrow(${2:value});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eth \"expect to throw (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).toThrowError(${2:value});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ethe \"expect to throw error (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).not$0;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "notx \"expect not (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).not.toEqual(${2:value});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "note \"expect not to equal (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).not.toBeLessThan(${2:value});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "notl \"expect to not be less than (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).not.toBeGreaterThan(${2:value});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "notg \"expect to not be greater than (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).not.toMatch(${2:pattern});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "notm \"expect not to match (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).not.toHaveAttr('${2:attr}'${3:, '${4:value}'});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "notha \"expect to not have attribute (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).not.toBeTruthy();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nott \"expect not to be truthy (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).not.toBeFalsy();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "notf \"expect not to be falsy (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).not.toBeDefined();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "notd \"expect not to be defined (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).not.toBeNull();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "notn \"expect not to be null (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).not.toContain(${2:value});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "notc \"expect not to contain (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).not.toBeVisible();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "notv \"expect not to be visible (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).not.toBeHidden();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "noth \"expect not to be hidden (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).not.toThrow(${2:value});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "notth \"expect not to throw (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).not.toThrowError(${2:value});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "notthe \"expect not to throw error (js)\"": true
        },
        "options": {}
      },
      {
        "content": "spyOn(${1:object}, '${2:method}')$0;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "s \"spy on (js)\"": true
        },
        "options": {}
      },
      {
        "content": "spyOn(${1:object}, '${2:method}').and.returnValue(${3:arguments});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sr \"spy on and return (js)\"": true
        },
        "options": {}
      },
      {
        "content": "spyOn(${1:object}, '${2:method}').and.throwError(${3:exception});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "st \"spy on and throw (js)\"": true
        },
        "options": {}
      },
      {
        "content": "spyOn(${1:object}, '${2:method}').and.callThrough();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sct \"spy on and call through (js)\"": true
        },
        "options": {}
      },
      {
        "content": "spyOn(${1:object}, '${2:method}').and.callFake(${3:function});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "scf \"spy on and call fake (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).toHaveBeenCalled();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ethbc \"expect to have been called (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).not.toHaveBeenCalled();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nthbc \"expect not to have been called (js)\"": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:target}).toHaveBeenCalledWith(${2:arguments});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ethbcw \"expect to have been called with (js)\"": true
        },
        "options": {}
      }
    ],
    "javascript-jasmine-arrow": [
      {
        "content": "describe('${1:description}', () => {\n\t$0\n});",
        "doc": "",
        "grammar": "snu",
        "label": "Describe (js)",
        "matches": {
          "des": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "it('${1:description}', () => {\n\t$0\n});",
        "doc": "",
        "grammar": "snu",
        "label": "it (js)",
        "matches": {
          "it": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "beforeEach(() => {\n\t$0\n});",
        "doc": "",
        "grammar": "snu",
        "label": "before each (js)",
        "matches": {
          "bef": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "afterEach(() => {\n\t$0\n});",
        "doc": "",
        "grammar": "snu",
        "label": "after each (js)",
        "matches": {
          "aft": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "beforeAll(() => {\n\t$0\n});",
        "doc": "",
        "grammar": "snu",
        "label": "before all (js)",
        "matches": {
          "befa": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "afterAll(() => {\n\t$0\n});",
        "doc": "",
        "grammar": "snu",
        "label": "after all (js)",
        "matches": {
          "afta": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "runs(() => {\n\t$0\n});",
        "doc": "",
        "grammar": "snu",
        "label": "runs (js)",
        "matches": {
          "ru": true
        },
        "options": {
          "b": true
        }
      }
    ],
    "javascript-jquery": [
      {
        "content": "${1:obj}.add('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "add": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.addClass('${2:class name}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "addClass": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.after('${2:Some text <b>and bold!</b>}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "after": true
        },
        "options": {}
      },
      {
        "content": "$.ajax({\n\turl: '${1:mydomain.com/url}',\n\ttype: '${2:POST}',\n\tdataType: '${3:xml/html/script/json}',\n\tdata: $.param( $('${4:Element or Expression}') ),\n\tcomplete: function (jqXHR, textStatus) {\n\t\t${5:// callback}\n\t},\n\tsuccess: function (data, textStatus, jqXHR) {\n\t\t${6:// success callback}\n\t},\n\terror: function (jqXHR, textStatus, errorThrown) {\n\t\t${0:// error callback}\n\t}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ajax": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.ajaxComplete(function (${1:e}, xhr, settings) {\n\t${0:// callback}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ajaxcomplete": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.ajaxError(function (${1:e}, xhr, settings, thrownError) {\n\t${2:// error callback}\n});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ajaxerror": true
        },
        "options": {}
      },
      {
        "content": "$.get('${1:mydomain.com/url}',\n\t${2:{ param1: value1 },}\n\tfunction (data, textStatus, jqXHR) {\n\t\t${0:// success callback}\n\t}\n);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ajaxget": true
        },
        "options": {}
      },
      {
        "content": "$.post('${1:mydomain.com/url}',\n\t${2:{ param1: value1 },}\n\tfunction (data, textStatus, jqXHR) {\n\t\t${0:// success callback}\n\t}\n);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ajaxpost": true
        },
        "options": {}
      },
      {
        "content": "$.ajaxPrefilter(function (${1:options}, ${2:originalOptions}, jqXHR) {\n\t${0: // Modify options, control originalOptions, store jqXHR, etc}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ajaxprefilter": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.ajaxSend(function (${1:request, settings}) {\n\t${2:// error callback}\n});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ajaxsend": true
        },
        "options": {}
      },
      {
        "content": "$.ajaxSetup({\n\turl: \"${1:mydomain.com/url}\",\n\ttype: \"${2:POST}\",\n\tdataType: \"${3:xml/html/script/json}\",\n\tdata: $.param( $(\"${4:Element or Expression}\") ),\n\tcomplete: function (jqXHR, textStatus) {\n\t\t${5:// callback}\n\t},\n\tsuccess: function (data, textStatus, jqXHR) {\n\t\t${6:// success callback}\n\t},\n\terror: function (jqXHR, textStatus, errorThrown) {\n\t\t${0:// error callback}\n\t}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ajaxsetup": true
        },
        "options": {}
      },
      {
        "content": "$.ajaxStart(function () {\n\t${1:// handler for when an AJAX call is started and no other AJAX calls are in progress};\n});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ajaxstart": true
        },
        "options": {}
      },
      {
        "content": "$.ajaxStop(function () {\n\t${1:// handler for when all AJAX calls have been completed};\n});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ajaxstop": true
        },
        "options": {}
      },
      {
        "content": "$.ajaxSuccess(function (${1:e}, xhr, settings) {\n\t${2:// handler for when any AJAX call is successfully completed};\n});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ajaxsuccess": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.andSelf()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "andself": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.animate({${2:param1: value1, param2: value2}}, ${3:speed})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "animate": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.append('${2:Some text <b>and bold!</b>}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "append": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.appendTo('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "appendTo": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.attr('${2:attribute}', '${3:value}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "attr": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.attr({'${2:attr1}': '${3:value1}', '${4:attr2}': '${5:value2}'})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "attrm": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.before('${2:Some text <b>and bold!</b>}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "before": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.bind('${2:event name}', function (${3:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bind": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.blur(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "blur": true
        },
        "options": {}
      },
      {
        "content": "$.Callbacks()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "C": true
        },
        "options": {}
      },
      {
        "content": "${1:callbacks}.add(${2:callbacks})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Cadd": true
        },
        "options": {}
      },
      {
        "content": "${1:callbacks}.disable()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Cdis": true
        },
        "options": {}
      },
      {
        "content": "${1:callbacks}.empty()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Cempty": true
        },
        "options": {}
      },
      {
        "content": "${1:callbacks}.fire(${2:args})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Cfire": true
        },
        "options": {}
      },
      {
        "content": "${1:callbacks}.fired()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Cfired": true
        },
        "options": {}
      },
      {
        "content": "${1:callbacks}.fireWith(${2:this}, ${3:args})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Cfirew": true
        },
        "options": {}
      },
      {
        "content": "${1:callbacks}.has(${2:callback})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Chas": true
        },
        "options": {}
      },
      {
        "content": "${1:callbacks}.lock()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Clock": true
        },
        "options": {}
      },
      {
        "content": "${1:callbacks}.locked()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Clocked": true
        },
        "options": {}
      },
      {
        "content": "${1:callbacks}.remove(${2:callbacks})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Crem": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.change(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "change": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.children('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "children": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.clearQueue(${2:'queue name'})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "clearq": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.click(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "click": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.clone()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "clone": true
        },
        "options": {}
      },
      {
        "content": "$.contains(${1:container}, ${0:contents});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "contains": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.css('${2:attribute}', '${3:value}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "css": true
        },
        "options": {}
      },
      {
        "content": "$.cssHooks['${1:CSS prop}'] = {\n\tget: function (elem, computed, extra) {\n\t\t${2: // handle getting the CSS property}\n\t},\n\tset: function (elem, value) {\n\t\t${0: // handle setting the CSS value}\n\t}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "csshooks": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.css({${2:attribute1}: '${3:value1}', ${4:attribute2}: '${5:value2}'})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cssm": true
        },
        "options": {}
      },
      {
        "content": "$.Deferred()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "D": true
        },
        "options": {}
      },
      {
        "content": "${1:deferred}.always(${2:callbacks})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Dalways": true
        },
        "options": {}
      },
      {
        "content": "${1:deferred}.done(${2:callbacks})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Ddone": true
        },
        "options": {}
      },
      {
        "content": "${1:deferred}.fail(${2:callbacks})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Dfail": true
        },
        "options": {}
      },
      {
        "content": "${1:deferred}.isRejected()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Disrej": true
        },
        "options": {}
      },
      {
        "content": "${1:deferred}.isResolved()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Disres": true
        },
        "options": {}
      },
      {
        "content": "${1:deferred}.notify(${2:args})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Dnotify": true
        },
        "options": {}
      },
      {
        "content": "${1:deferred}.notifyWith(${2:this}, ${3:args})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Dnotifyw": true
        },
        "options": {}
      },
      {
        "content": "${1:deferred}.then(${2:doneFilter}, ${3:failFilter}, ${4:progressFilter})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Dpipe": true
        },
        "options": {}
      },
      {
        "content": "${1:deferred}.progress(${2:callbacks})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Dprog": true
        },
        "options": {}
      },
      {
        "content": "${1:deferred}.promise(${2:target})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Dprom": true
        },
        "options": {}
      },
      {
        "content": "${1:deferred}.reject(${2:args})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Drej": true
        },
        "options": {}
      },
      {
        "content": "${1:deferred}.rejectWith(${2:this}, ${3:args})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Drejw": true
        },
        "options": {}
      },
      {
        "content": "${1:deferred}.resolve(${2:args})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Dres": true
        },
        "options": {}
      },
      {
        "content": "${1:deferred}.resolveWith(${2:this}, ${3:args})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Dresw": true
        },
        "options": {}
      },
      {
        "content": "${1:deferred}.state()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Dstate": true
        },
        "options": {}
      },
      {
        "content": "${1:deferred}.then(${2:doneCallbacks}, ${3:failCallbacks}, ${4:progressCallbacks})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Dthen": true
        },
        "options": {}
      },
      {
        "content": "$.when(${1:deferreds})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Dwhen": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.data(${2:obj})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "data": true
        },
        "options": {}
      },
      {
        "content": "$.data('${1:selector expression}', '${2:key}'${3:, 'value'})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dataa": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.dblclick(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dblclick": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.delay('${2:slow/400/fast}'${3:, 'queue name'})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "delay": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.delegate('${2:selector expression}', '${3:event name}', function (${4:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dele": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.dequeue(${2:'queue name'})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "deq": true
        },
        "options": {}
      },
      {
        "content": "$.dequeue('${1:selector expression}'${2:, 'queue name'})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "deqq": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.detach('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "detach": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.die(${2:event}, ${3:handler})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "die": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.each(function (index) {\n\t${0:this.innerHTML = this + \" is the element, \" + index + \" is the position\";}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "each": true
        },
        "options": {}
      },
      {
        "content": "$('<${1}/>'${2:, {}})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "el": true
        },
        "options": {}
      },
      {
        "content": "$.trim('${1:string}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eltrim": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.empty()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "empty": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.end()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "end": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.eq(${2:element index})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eq": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.error(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "error": true
        },
        "options": {}
      },
      {
        "content": "{\n\t:f${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eventsmap": true
        },
        "options": {}
      },
      {
        "content": "$.extend(${1:true, }${2:target}, ${3:obj})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "extend": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.fadeIn('${2:slow/400/fast}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fadein": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.fadeIn('slow/400/fast', function () {\n\t${0:// callback};\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fadeinc": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.fadeOut('${2:slow/400/fast}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fadeout": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.fadeOut('slow/400/fast', function () {\n\t${0:// callback};\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fadeoutc": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.fadeTo('${2:slow/400/fast}', ${3:0.5})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fadeto": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.fadeTo('slow/400/fast', ${2:0.5}, function () {\n\t${0:// callback};\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fadetoc": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.filter('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "filter": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.filter(function (${2:index}) {\n\t${3}\n})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "filtert": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.find('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "find": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.focus(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "focus": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.focusIn(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "focusin": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.focusOut(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "focusout": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.get(${2:element index})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "get": true
        },
        "options": {}
      },
      {
        "content": "$.getJSON('${1:mydomain.com/url}',\n\t${2:{ param1: value1 },}\n\tfunction (data, textStatus, jqXHR) {\n\t\t${0:// success callback}\n\t}\n);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "getjson": true
        },
        "options": {}
      },
      {
        "content": "$.getScript('${1:mydomain.com/url}', function (script, textStatus, jqXHR) {\n\t${0:// callback}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "getscript": true
        },
        "options": {}
      },
      {
        "content": "$.grep(${1:array}, function (item, index) {\n\t${2}\n}${0:, true});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "grep": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.hasClass('${2:className}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "hasc": true
        },
        "options": {}
      },
      {
        "content": "$.hasData('${0:selector expression}');",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "hasd": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.height(${2:integer})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "height": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.hide('${2:slow/400/fast}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "hide": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.hide('${2:slow/400/fast}', function () {\n\t${0:// callback}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "hidec": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.hover(function (${2:e}) {\n\t${3:// event handler}\n}, function ($2) {\n\t${4:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "hover": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.html('${2:Some text <b>and bold!</b>}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "html": true
        },
        "options": {}
      },
      {
        "content": "$.inArray(${1:value}, ${0:array});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "inarr": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.insertAfter('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "insa": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.insertBefore('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "insb": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.is('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "is": true
        },
        "options": {}
      },
      {
        "content": "$.isArray(${1:obj})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isarr": true
        },
        "options": {}
      },
      {
        "content": "$.isEmptyObject(${1:obj})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isempty": true
        },
        "options": {}
      },
      {
        "content": "$.isFunction(${1:obj})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isfunc": true
        },
        "options": {}
      },
      {
        "content": "$.isNumeric(${1:value})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isnum": true
        },
        "options": {}
      },
      {
        "content": "$.isPlainObject(${1:obj})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isobj": true
        },
        "options": {}
      },
      {
        "content": "$.isWindow(${1:obj})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "iswin": true
        },
        "options": {}
      },
      {
        "content": "$.isXMLDoc(${1:node})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isxml": true
        },
        "options": {}
      },
      {
        "content": "$('${1:selector}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jj": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.keydown(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "kdown": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.keypress(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "kpress": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.keyup(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "kup": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.last('${1:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "last": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.live('${2:events}', function (${3:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "live": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.load(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "load": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.load('${2:mydomain.com/url}',\n\t${2:{ param1: value1 },}\n\tfunction (responseText, textStatus, xhr) {\n\t\t${0:// success callback}\n\t}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "loadf": true
        },
        "options": {}
      },
      {
        "content": "$.makeArray(${0:obj});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "makearray": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.map(function (${2:index}, ${3:element}) {\n\t${0:// callback}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "map": true
        },
        "options": {}
      },
      {
        "content": "$.map(${1:arrayOrObject}, function (${2:value}, ${3:indexOrKey}) {\n\t${0:// callback}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mapp": true
        },
        "options": {}
      },
      {
        "content": "$.merge(${1:target}, ${0:original});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "merge": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.mousedown(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mdown": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.mouseenter(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "menter": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.mouseleave(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mleave": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.mousemove(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mmove": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.mouseout(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mout": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.mouseover(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mover": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.mouseup(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mup": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.next('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "next": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.nextAll('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nexta": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.nextUntil('${2:selector expression}'${3:, 'filter expression'})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nextu": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.not('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "not": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.off('${2:events}', '${3:selector expression}'${4:, handler})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "off": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.offset()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "offset": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.offsetParent()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "offsetp": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.on('${2:events}', '${3:selector expression}', function (${4:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "on": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.one('${2:event name}', function (${3:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "one": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.outerHeight()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "outerh": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.outerWidth()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "outerw": true
        },
        "options": {}
      },
      {
        "content": "$.param(${1:obj})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "param": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.parent('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "parent": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.parents('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "parents": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.parentsUntil('${2:selector expression}'${3:, 'filter expression'})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "parentsu": true
        },
        "options": {}
      },
      {
        "content": "$.parseJSON(${1:data})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "parsejson": true
        },
        "options": {}
      },
      {
        "content": "$.parseXML(${1:data})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "parsexml": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.position()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pos": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.prepend('${2:Some text <b>and bold!</b>}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prepend": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.prependTo('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prependto": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.prev('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prev": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.prevAll('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "preva": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.prevUntil('${2:selector expression}'${3:, 'filter expression'})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prevu": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.promise(${2:'fx'}, ${3:target})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "promise": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.prop('${2:property name}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prop": true
        },
        "options": {}
      },
      {
        "content": "$.proxy(${1:function}, ${2:this})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "proxy": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.pushStack(${2:elements})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pushstack": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.queue(${2:name}${3:, newQueue})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "queue": true
        },
        "options": {}
      },
      {
        "content": "$.queue(${1:element}${2:, name}${3:, newQueue})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "queuee": true
        },
        "options": {}
      },
      {
        "content": "$(function () {\n\t${0}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ready": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.remove()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rem": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.removeAttr('${2:attribute name}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rema": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.removeClass('${2:class name}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "remc": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.removeData('${2:key name}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "remd": true
        },
        "options": {}
      },
      {
        "content": "$.removeData(${1:element}${2:, 'key name}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "remdd": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.removeProp('${2:property name}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "remp": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.replaceAll(${2:target})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "repa": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.replaceWith(${2:content})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "repw": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.reset(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "reset": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.resize(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "resize": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.scroll(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "scroll": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.scrollLeft(${2:value})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "scrolll": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.scrollTop(${2:value})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "scrollt": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.slideDown('${2:slow/400/fast}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sdown": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.slideDown('${2:slow/400/fast}', function () {\n\t${0:// callback};\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sdownc": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.select(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "select": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.serialize()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "serialize": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.serializeArray()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "serializea": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.show('${2:slow/400/fast}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "show": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.show('${2:slow/400/fast}', function () {\n\t${0:// callback}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "showc": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.siblings('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sib": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.size()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "size": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.slice(${2:start}${3:, end})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "slice": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.slideToggle('${2:slow/400/fast}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "stoggle": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.stop('${2:queue}', ${3:false}, ${4:false})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "stop": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.submit(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "submit": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.slideUp('${2:slow/400/fast}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sup": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.slideUp('${2:slow/400/fast}', function () {\n\t${0:// callback};\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "supc": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.text(${2:'some text'})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "text": true
        },
        "options": {}
      },
      {
        "content": "$(this)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "this": true
        },
        "options": {}
      },
      {
        "content": "${0:obj}.toArray()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "toarr": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.toggle(function (${2:e}) {\n\t${3:// event handler}\n}, function ($2) {\n\t${4:// event handler}\n});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tog": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.toggleClass('${2:class name}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "togclass": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.toggle('${2:slow/400/fast}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "togsh": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.trigger('${2:event name}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "trig": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.triggerHandler('${2:event name}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "trigh": true
        },
        "options": {}
      },
      {
        "content": "$.trim(${1:str})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "$trim": true
        },
        "options": {}
      },
      {
        "content": "$.type(${1:obj})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "$type": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.unbind('${2:event name}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "unbind": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.undelegate(${2:selector expression}, ${3:event}, ${4:handler})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "undele": true
        },
        "options": {}
      },
      {
        "content": "$.unique(${1:array})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "uniq": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.unload(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "unload": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.unwrap()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "unwrap": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.val('${2:text}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "val": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.width(${2:integer})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "width": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.wrap('${2:&lt;div class=\"extra-wrapper\"&gt;&lt;/div&gt;}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wrap": true
        },
        "options": {}
      }
    ],
    "javascript-jsdoc": [
      {
        "content": "/**\n * ${1:${VISUAL}}$0\n */",
        "doc": "",
        "grammar": "snu",
        "label": "A JSDoc comment",
        "matches": {
          "/*": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "@license ${1:MIT}$0",
        "doc": "",
        "grammar": "snu",
        "label": "@license Description",
        "matches": {
          "@li": true
        },
        "options": {}
      },
      {
        "content": "@version ${1:0.1.0}$0",
        "doc": "",
        "grammar": "snu",
        "label": "@version Semantic version",
        "matches": {
          "@ver": true
        },
        "options": {}
      },
      {
        "content": "@constructor",
        "doc": "",
        "grammar": "snu",
        "label": "@constructor",
        "matches": {
          "@constr": true
        },
        "options": {}
      },
      {
        "content": "@param {${1:Type}} ${2:varname} ${3:Description}",
        "doc": "",
        "grammar": "snu",
        "label": "@param {Type} varname Description",
        "matches": {
          "@p": true
        },
        "options": {}
      },
      {
        "content": "@return {${1:Type}} ${2:Description}",
        "doc": "",
        "grammar": "snu",
        "label": "@return {Type} Description",
        "matches": {
          "@ret": true
        },
        "options": {}
      },
      {
        "content": "@private",
        "doc": "",
        "grammar": "snu",
        "label": "@private",
        "matches": {
          "@pri": true
        },
        "options": {}
      },
      {
        "content": "@override",
        "doc": "",
        "grammar": "snu",
        "label": "@override",
        "matches": {
          "@over": true
        },
        "options": {}
      },
      {
        "content": "@protected",
        "doc": "",
        "grammar": "snu",
        "label": "@protected",
        "matches": {
          "@pro": true
        },
        "options": {}
      }
    ],
    "javascript-mocha": [
      {
        "content": "describe('${1:}', () => {\n\t${0:${VISUAL}}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "des \"describe('thing', () => { ... })\" b": true
        },
        "options": {}
      },
      {
        "content": "it('${1:}', () => {\n\t${0:${VISUAL}}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "it \"it('should do', () => { ... })\" b": true
        },
        "options": {}
      },
      {
        "content": "xit('${1:}', () => {\n\t${0:${VISUAL}}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "xit \"xit('should do', () => { ... })\" b": true
        },
        "options": {}
      },
      {
        "content": "before(() => {\n\t${0:${VISUAL}}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bef \"before(() => { ... })\" b": true
        },
        "options": {}
      },
      {
        "content": "beforeEach(() => {\n\t${0:${VISUAL}}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "befe \"beforeEach(() => { ... })\" b": true
        },
        "options": {}
      },
      {
        "content": "after(() => {\n\t${0:${VISUAL}}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "aft \"after(() => { ... })\" b": true
        },
        "options": {}
      },
      {
        "content": "afterEach(() => {\n\t${0:${VISUAL}}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "afte \"afterEach(() => { ... })\" b": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:})${0};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "exp \"expect(...)\" b": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:}).to.equal(${0});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "expe \"expect(...).to.equal(...)\" b": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:}).to.deep.equal(${0});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "expd \"expect(...).to.deep.equal(...)\" b": true
        },
        "options": {}
      }
    ],
    "javascript-node": [
      {
        "content": "#!/usr/bin/env node",
        "doc": "",
        "grammar": "snu",
        "label": "#!/usr/bin/env node",
        "matches": {
          "#!": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "module.exports = $1;",
        "doc": "",
        "grammar": "snu",
        "label": "module.exports",
        "matches": {
          "ex": true
        },
        "options": {}
      },
      {
        "content": "http.createServer($1).listen($2);",
        "doc": "",
        "grammar": "snu",
        "label": "http.createServer",
        "matches": {
          "hcs": true
        },
        "options": {}
      },
      {
        "content": "net.createServer(function(${1:socket}){\n\t$1.on('data', function(${3:data}){\n\t\t$4\n\t});\n\t$1.on('end', function(){\n\t\t$5\n\t});\n}).listen(${6:8124});",
        "doc": "",
        "grammar": "snu",
        "label": "net.createServer",
        "matches": {
          "ncs": true
        },
        "options": {}
      },
      {
        "content": "pipe(${1:stream})$2",
        "doc": "",
        "grammar": "snu",
        "label": "pipe",
        "matches": {
          "pipe": true
        },
        "options": {}
      },
      {
        "content": "${1:app}.get('$2', $3);",
        "doc": "",
        "grammar": "snu",
        "label": "express GET",
        "matches": {
          "eget": true
        },
        "options": {}
      },
      {
        "content": "${1:app}.post('$2', $3);",
        "doc": "",
        "grammar": "snu",
        "label": "express POST",
        "matches": {
          "epost": true
        },
        "options": {}
      },
      {
        "content": "${1:app}.put('$2', $3);",
        "doc": "",
        "grammar": "snu",
        "label": "express PUT",
        "matches": {
          "eput": true
        },
        "options": {}
      },
      {
        "content": "${1:app}.delete('$2', $3);",
        "doc": "",
        "grammar": "snu",
        "label": "express DELETE",
        "matches": {
          "edelete": true
        },
        "options": {}
      },
      {
        "content": "process.stdout",
        "doc": "",
        "grammar": "snu",
        "label": "stdout",
        "matches": {
          "stdout": true
        },
        "options": {}
      },
      {
        "content": "process.stdin",
        "doc": "",
        "grammar": "snu",
        "label": "stdin",
        "matches": {
          "stdin": true
        },
        "options": {}
      },
      {
        "content": "process.stderr",
        "doc": "",
        "grammar": "snu",
        "label": "stderr",
        "matches": {
          "stderr": true
        },
        "options": {}
      }
    ],
    "javascript-openui5": [
      {
        "content": "var $1 = new sap.m.Label({\n\t\t\tdesign : $2,\n\t\t\ttext : $3,\n\t\t\tvisible : $4,\n\t\t\ttextAlign : $5,\n\t\t\ttextDirection : $6,\n\t\t\twidth : $7,\n\t\t\trequired : $7\n\t\t});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sapmlabel": true
        },
        "options": {}
      },
      {
        "content": "var $1 = new sap.m.Text({\n\t\t\ttext :$2,\n\t\t\ttextDirection :$3,\n\t\t\tvisible :$4,\n\t\t\twrapping : $5,\n\t\t\ttextAlign : $6,\n\t\t\twidth :$7,\n\t\t\tmaxLines :$8\n\t\t});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sapmtext": true
        },
        "options": {}
      },
      {
        "content": "var $1 = new sap.m.Button({\n\t\t\ttext : $2,\n\t\t\ttype : $3,\n\t\t\twidth : $4,\n\t\t\tenabled :$5,\n\t\t\tvisible :$6,\n\t\t\ticon : $7,\n\t\t\ticonFirst : $8,\n\t\t\tactiveIcon :$9,\n\t\t\ticonDensityAware : $10,\n\t\t});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sapmbutton": true
        },
        "options": {}
      },
      {
        "content": "var $1 = new sap.m.FlexBox({\n\t\t\tvisible : $2,\n\t\t\theight : $3,\n\t\t\twidth : $4,\n\t\t\tdisplayInline :$5,\n\t\t\tdirection :$6,\n\t\t\tfitContainer : $7,\n\t\t\trenderType : $8,\n\t\t\tjustifyContent :$9,\n\t\t\talignItems : $10,\n\t\t\titems:[]\n\t\t});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sapmflexbox": true
        },
        "options": {}
      },
      {
        "content": "var $1 = new sap.m.HBox({\n\t\t\tvisible : $2,\n\t\t\theight : $3,\n\t\t\twidth : $4,\n\t\t\tdisplayInline :$5,\n\t\t\tdirection :$6,\n\t\t\tfitContainer : $7,\n\t\t\trenderType : $8,\n\t\t\tjustifyContent :$9,\n\t\t\talignItems : $10,\n\t\t\titems:[]\n\t\t});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sapmhbox": true
        },
        "options": {}
      },
      {
        "content": "var $1 = new sap.m.VBox({\n\t\t\tvisible : $2,\n\t\t\theight : $3,\n\t\t\twidth : $4,\n\t\t\tdisplayInline :$5,\n\t\t\tdirection :$6,\n\t\t\tfitContainer : $7,\n\t\t\trenderType : $8,\n\t\t\tjustifyContent :$9,\n\t\t\talignItems : $10,\n\t\t\titems:[]\n\t\t});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sapmvbox": true
        },
        "options": {}
      },
      {
        "content": "sap.ui.controller(\"$1\", {\n   onInit: function(){\n   },\n   onAfterRendering: function() {\n   },\n   onAfterRendering: function() {\n   },\n   onExit: function() {\n   },\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sapcomponent": true
        },
        "options": {}
      },
      {
        "content": "var $1 = new sap.m.Input({\n\tvalue :$2,\n\twidth : $3,\n\tenabled :$4,\n\tvisible :$5,\n\tvalueState :$6,\n\tname : $7,\n\tplaceholder : $8,\n\teditable : $9,\n\ttype : $10,\n\tmaxLength :$11,\n\tvalueStateText :$12,\n\tshowValueStateMessage :$13,\n\tdateFormat :$14,\n\tshowValueHelp :$15,\n\tshowSuggestion :$16,\n\tvalueHelpOnly :$17,\n\tfilterSuggests :$18,\n\tmaxSuggestionWidth :$19,\n\tstartSuggestion : $20,\n\tshowTableSuggestionValueHelp : $21,\n\tdescription : $22,\n\tfieldWidth : $23,\n\tvalueLiveUpdate :$24,\n\tsuggestionItems  :[$25],\n\tsuggestionColumns : [$26],\n\tsuggestionRows : [$27],\n\tliveChange : $28,\n\tvalueHelpRequest :$29,\n\tsuggest : $30,\n\tsuggestionItemSelected : $31\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sapminput": true
        },
        "options": {}
      },
      {
        "content": "var _self = this;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "_sthis": true
        },
        "options": {}
      },
      {
        "content": "var $1 = new sap.m.ResponsivePopover({\n\t\t\tplacement :$2 ,//sap.m.PlacementType (default: sap.m.PlacementType.Right)\n\t\t\tshowHeader :$3 ,//boolean (default: true)\n\t\t\ttitle : $4,//string\n\t\t\ticon :$5 ,//sap.ui.core.URI\n\t\t\tmodal :$6 ,// boolean\n\t\t\toffsetX :$7, //int\n\t\t\toffsetY :$8, //int\n\t\t\tcontentWidth : $9,//sap.ui.core.CSSSize\n\t\t\tcontentHeight :$10, //sap.ui.core.CSSSize\n\t\t\thorizontalScrolling :$11, //boolean\n\t\t\tverticalScrolling :$12, //boolean\n\t\t\tshowCloseButton :$13, //boolean (default: true)\n\t\t\t//Aggregations\n\t\t\tcontent :$14,  //sap.ui.core.Control[]\n\t\t\tcustomHeader :$15,  //sap.m.IBar\n\t\t\tsubHeader : $16, //sap.m.IBar\n\t\t\tbeginButton :$17,  //sap.m.Button\n\t\t\tendButton : $18, //sap.m.Button\n\t\t\t//Associations\n\t\t\tinitialFocus : $19, //string | sap.ui.core.Control\n\t\t\t//Events\n\t\t\tbeforeOpen :$20,  //fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]\n\t\t\tafterOpen : $21, //fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]\n\t\t\tbeforeClose : $22, //fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]\n\t\t\tafterClose : $23 //fnList\n\t\t});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sapmresponsivepopup": true
        },
        "options": {}
      },
      {
        "content": "var $1 = new sap.ui.core.Icon({\n\t\t\t\tsrc :$2 , //sap.ui.core.URI\n\t\t\t\tsize :$3 , //sap.ui.core.CSSSize\n\t\t\t\tcolor :$4 , //sap.ui.core.CSSColor\n\t\t\t\thoverColor : $5 ,  // sap.ui.core.CSSColor\n\t\t\t\tactiveColor :$6 , //sap.ui.core.CSSColor\n\t\t\t\twidth :$7 , //sap.ui.core.CSSSize\n\t\t\t\theight : $8 ,//sap.ui.core.CSSSize\n\t\t\t\tbackgroundColor :$8 , //sap.ui.core.CSSColor\n\t\t\t\thoverBackgroundColor :$9 , //sap.ui.core.CSSColor\n\t\t\t\tactiveBackgroundColor :$10 , //sap.ui.core.CSSColor\n\t\t\t\tvisible :$11 , //boolean (default: true)\n\t\t\t\tdecorative : $12 ,//boolean (default: true)\n\t\t\t});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sapicon": true
        },
        "options": {}
      },
      {
        "content": "sap.ui.layout.VerticalLayout.extend(\"$1\", {\n    metadata: {\n\tproperties: {\n\t  \t$2\n\t},\n\taggregations: {\n\t\t$3\n\t},\n\tevents: {\n\t\t$4\n\t}\n    },\n   init: function(){\n\t$5\n    },\n    renderer: \"$6\"\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "extendVerticalL": true
        },
        "options": {}
      },
      {
        "content": "sap.ui.layout.HorizontalLayout.extend(\"$1\", {\n    metadata: {\n\tproperties: {\n\t  \t$2\n\t},\n\taggregations: {\n\t\t$3\n\t},\n\tevents: {\n\t\t$4\n\t}\n    },\n   init: function(){\n\t$5\n    },\n    renderer: \"$6\"\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "extendHorizontalL": true
        },
        "options": {}
      }
    ],
    "javascript-react": [
      {
        "content": "import React from 'react';",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ir import React": true
        },
        "options": {}
      },
      {
        "content": "import React, { Component } from 'react';",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "irc import React and Component": true
        },
        "options": {}
      },
      {
        "content": "import { use$1 } from 'react';",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "irh import React hooks": true
        },
        "options": {}
      },
      {
        "content": "import ReactDOM from 'react-dom';",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ird import ReactDOM": true
        },
        "options": {}
      },
      {
        "content": "import PropTypes from 'prop-types';",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "irp import PropTypes": true
        },
        "options": {}
      },
      {
        "content": "componentDidMount() {\n\t${1}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cdm componentDidMount": true
        },
        "options": {}
      },
      {
        "content": "componentDidUpdate(prevProps, prevState) {\n\t${1}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cdup componentDidUpdate": true
        },
        "options": {}
      },
      {
        "content": "componentWillMount() {\n\t${1}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cwm componentWillMount": true
        },
        "options": {}
      },
      {
        "content": "componentWillReceiveProps(nextProps) {\n\t${1}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cwr componentWillReceiveProps": true
        },
        "options": {}
      },
      {
        "content": "componentWillUnmount() {\n\t${1}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cwun componentWillUnmount": true
        },
        "options": {}
      },
      {
        "content": "componentWillUpdate(nextProps, nextState) {\n\t${1}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cwu componentWillUpdate": true
        },
        "options": {}
      },
      {
        "content": "shouldComponentUpdate(nextProps, nextState) {\n\t${1}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "scu shouldComponentUpdate": true
        },
        "options": {}
      },
      {
        "content": "static propTypes = {\n\t${1}: PropTypes.${2}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "spt static propTypes": true
        },
        "options": {}
      },
      {
        "content": "${1}.propTypes = {\n\t${2}: PropTypes.${2}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pt propTypes": true
        },
        "options": {}
      },
      {
        "content": "static defaultProps = {\n\t${1}: ${2}\t\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sdp static defaultProps": true
        },
        "options": {}
      },
      {
        "content": "${1}.defaultProps = {\n\t${2}: ${3}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dp defaultProps": true
        },
        "options": {}
      },
      {
        "content": "props.${1};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pp props": true
        },
        "options": {}
      },
      {
        "content": "this.props.${1};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tp this props": true
        },
        "options": {}
      },
      {
        "content": "state = {\n\t${1}: ${2},\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "st": true
        },
        "options": {}
      },
      {
        "content": "this.setState({\n\t${1}: ${2}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sst": true
        },
        "options": {}
      },
      {
        "content": "this.state.${1};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tst": true
        },
        "options": {}
      },
      {
        "content": "const ${1:ComponentName} = (${2:props}) => {\n\t${3:state}\n\treturn (\n\t\t<>\n\t\t\t${4}\n\t\t</>\n\t);\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "raf": true
        },
        "options": {}
      },
      {
        "content": "class ${1:ClassName} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<>\n\t\t\t\t${2}\n\t\t\t</>\n\t\t);\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rcla": true
        },
        "options": {}
      },
      {
        "content": "export default class ${1:ClassName} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<>\n\t\t\t\t${2}\n\t\t\t</>\n\t\t);\n\t};\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ercla": true
        },
        "options": {}
      },
      {
        "content": "constructor() {\n\tsuper();\n\t${1:state}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ctor": true
        },
        "options": {}
      },
      {
        "content": "render() {\n\treturn (\n\t\t<>\n\t\t\t${2}\n\t\t</>\n\t);\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ren": true
        },
        "options": {}
      },
      {
        "content": "forceUpdate(${1:callback});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fup": true
        },
        "options": {}
      },
      {
        "content": "const [${1:state}, set${2}] = useState(${3:initialState});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "uses useState": true
        },
        "options": {}
      },
      {
        "content": "useEffect(() => {\n\t${1}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "usee useEffect": true
        },
        "options": {}
      },
      {
        "content": "const [${1:state}, ${2:dispatch}] = useReducer(${3:reducer});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "userd useReducer": true
        },
        "options": {}
      },
      {
        "content": "const ${1:refContainer} = useRef(${2:initialValue});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "userf useRef": true
        },
        "options": {}
      },
      {
        "content": "const ${1:value} = useContext(${2:MyContext});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "usect useContext": true
        },
        "options": {}
      },
      {
        "content": "const ${1:memoizedCallback} = useCallback(\n() => {\n\t${2}(${3})\n},\n[$3]\n);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "usecb useCallback": true
        },
        "options": {}
      },
      {
        "content": "const ${1:memoizedCallback} = useMemo(() => ${2}(${3}), [$3]);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "usem useMemo": true
        },
        "options": {}
      },
      {
        "content": "useImperativeHandle(${1:ref}, ${2:createHandle});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "usei useImperativeHandle": true
        },
        "options": {}
      },
      {
        "content": "useDebugValue(${1:value});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "used useDebugValue": true
        },
        "options": {}
      },
      {
        "content": "ReactDOM.render(${1}, ${2});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rdr ReactDOM.render": true
        },
        "options": {}
      },
      {
        "content": "ReactDOM.hydrate(${1:element}, ${2:container}[, ${3:callback}]);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rdh ReactDOM.hydrate": true
        },
        "options": {}
      },
      {
        "content": "ReactDOM.createPortal(${1:child}, ${2:container});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rdcp ReactDOM.createPortal": true
        },
        "options": {}
      }
    ],
    "javascript-redux": [
      {
        "content": "import { createStore } from 'redux';",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ist": true
        },
        "options": {}
      },
      {
        "content": "connect(${1:mapStateToProps}, ${2:mapDispatchToProps})(<${3:VISUAL}/>);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "con": true
        },
        "options": {}
      },
      {
        "content": "const ${1:actionName} = (${2:arg}) => {\n\treturn {\n\t\ttype: ${3:VISUAL},\n\t\t$2\n\t};\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "act": true
        },
        "options": {}
      },
      {
        "content": "const ${1:reducerName} = (state={}, action) => {\n\tswitch(action.type) {\n\t\tcase ${1:action}:\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\t$2\n\t\t\t};\n\t\tdefault:\n\t\t\treturn state;\n\t};\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rdc": true
        },
        "options": {}
      },
      {
        "content": "const mapStateToProps = (state) => {\n\treturn {\n\t\t${1:propName}: state.$1,\n\t};\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mstp": true
        },
        "options": {}
      },
      {
        "content": "const mapDispatchToProps = (dispatch) => {\n\treturn {\n\t\t${1:propName}: () => {\n\t\t\tdispatch(${2:actionName}());\n\t\t},\n\t};\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mdtp": true
        },
        "options": {}
      }
    ],
    "javascript-requirejs": [
      {
        "content": "define([\"${1:#dependencies1}\"], function (${2:#dependencies2}) {\n\treturn ${0:TARGET};\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "def": true
        },
        "options": {}
      },
      {
        "content": "define(\"${1:#name}\", [\"${2:#dependencies1}\"], function (${3:#dependencies2}) {\n\treturn ${0:TARGET};\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defn": true
        },
        "options": {}
      },
      {
        "content": "require([\"${1:#dependencies1}\"], function (${2:#dependencies2}) {\n\treturn ${0:TARGET};\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "reqjs": true
        },
        "options": {}
      }
    ],
    "javascript.node": [
      {
        "content": "#!/usr/bin/env node",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#!": true
        },
        "options": {}
      },
      {
        "content": "module.exports = ${1};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ex": true
        },
        "options": {}
      },
      {
        "content": "${1:const} ${2} = require('${3:module_name}');",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "re": true
        },
        "options": {}
      },
      {
        "content": "on('${1:event_name}', function(${2:stream}) {\n  ${3}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "on": true
        },
        "options": {}
      },
      {
        "content": "emit('${1:event_name}', ${2:args});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "emit": true
        },
        "options": {}
      },
      {
        "content": "once('${1:event_name}', function(${2:stream}) {\n  ${3}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "once": true
        },
        "options": {}
      },
      {
        "content": "http.createServer(${1:handler}).listen(${2:port_number});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "http": true
        },
        "options": {}
      },
      {
        "content": "net.createServer(function(${1:socket}){\n\t${1}.on('data', function('data'){\n\t  ${2}\n\t]});\n\t${1}.on('end', function(){\n\t  ${3}\n\t});\n}).listen(${4:8124});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "net": true
        },
        "options": {}
      },
      {
        "content": "pipe(${1:stream})${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pipe": true
        },
        "options": {}
      },
      {
        "content": "${1:app}.get('${2:route}', ${3:handler});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eget": true
        },
        "options": {}
      },
      {
        "content": "${1:app}.post('${2:route}', ${3:handler});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "epost": true
        },
        "options": {}
      },
      {
        "content": "${1:app}.put('${2:route}', ${3:handler});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eput": true
        },
        "options": {}
      },
      {
        "content": "${1:app}.delete('${2:route}', ${3:handler});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "edel": true
        },
        "options": {}
      },
      {
        "content": "process.stdin",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "stdin": true
        },
        "options": {}
      },
      {
        "content": "process.stdout",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "stdout": true
        },
        "options": {}
      },
      {
        "content": "process.stderr",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "stderr": true
        },
        "options": {}
      }
    ],
    "javascript_react": [],
    "jenkins": [
      {
        "content": "steps {\n\tsh '${1:make check}'\n\tjunit '${2:reports/**/*.xml}' \n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "steps": true
        },
        "options": {}
      },
      {
        "content": "stage('${1:Test}'){\n\tsteps {\n\t\tsh '${2:make check}'\n\t\tjunit '${3:reports/**/*.xml}' \n\t}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "stage": true
        },
        "options": {}
      },
      {
        "content": "pipeline {\n\tagent any \n\tstages {\n\t\tstage('${1:Build}') { \n\t\t\tsteps { \n\t\t\t\tsh '${2:make}' \n\t\t\t}\n\t\t}\n\t}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pipeline": true
        },
        "options": {}
      },
      {
        "content": "pipeline {\n\tagent any \n\tstages {\n\t\tstage('${1:Build}') { \n\t\t\tsteps { \n\t\t\t\tsh '${2:make}' \n\t\t\t}\n\t\t}\n\t\tstage('${3:Test}'){\n\t\t\tsteps {\n\t\t\t\tsh '${4:make check}'\n\t\t\t\tjunit '${5:reports/**/*.xml}' \n\t\t\t}\n\t\t}\n\t\tstage('${6:Deploy}') {\n\t\t\tsteps {\n\t\t\t\tsh '${7:make publish}'\n\t\t\t}\n\t\t}\n\t}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pipeline_sample": true
        },
        "options": {}
      },
      {
        "content": "docker {\n\timage '${1:myregistry.com/node'}'\n\tlabel '${2:my-defined-label'}'\n\tregistryUrl '${3:https://myregistry.com/'}'\n\tregistryCredentialsId '${4:myPredefinedCredentialsInJenkins'}'\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d": true
        },
        "options": {}
      },
      {
        "content": "dockerfile {\n\tfilename '${1:Dockerfile.build}'\n\tdir '${2:build}'\n\tlabel '${3:my-defined-label}'\n\tregistryUrl '${4:https://myregistry.com/}'\n\tregistryCredentialsId '${5:myPredefinedCredentialsInJenkins}'\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "df": true
        },
        "options": {}
      },
      {
        "content": "post { \n\talways { \n\t\t${1}\n\t}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pa": true
        },
        "options": {}
      },
      {
        "content": "post { \n\tchanged { \n\t\t${1}\n\t}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc": true
        },
        "options": {}
      },
      {
        "content": "post { \n\tfixed { \n\t\t${1}\n\t}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pf": true
        },
        "options": {}
      },
      {
        "content": "post { \n\tregression { \n\t\t${1}\n\t}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pr": true
        },
        "options": {}
      },
      {
        "content": "post { \n\taborted { \n\t\t${1}\n\t}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pab": true
        },
        "options": {}
      },
      {
        "content": "post { \n\tfailure { \n\t\t${1}\n\t}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pfa": true
        },
        "options": {}
      },
      {
        "content": "post { \n\tsuccess { \n\t\t${1}\n\t}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ps": true
        },
        "options": {}
      },
      {
        "content": "post { \n\tunstable { \n\t\t${1}\n\t}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pu": true
        },
        "options": {}
      },
      {
        "content": "post { \n\tcleanup { \n\t\t${1}\n\t}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc": true
        },
        "options": {}
      },
      {
        "content": "pipeline {\n\tagent any \n\tstages {\n\t\tstage('${1:Build}') { \n\t\t\tsteps { \n\t\t\t\tsh '${2:make}' \n\t\t\t}\n\t\t}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "psss": true
        },
        "options": {}
      },
      {
        "content": "stages {\n\tstage('${1:Build}') { \n\t\tsteps { \n\t\t\tsh '${2:make}' \n\t\t}\n\t}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sss": true
        },
        "options": {}
      },
      {
        "content": "parameters{ \n\t${1}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "parameters": true
        },
        "options": {}
      },
      {
        "content": "text(name: \"${1:BIOGRAPHY}\" , defaultValue: \"${2:default}\" , description: \"${3:Enter some information about the person}\")\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "paramtext": true
        },
        "options": {}
      },
      {
        "content": "booleanParam(name: \"${1:TOGGLE}\" , defaultValue: ${2:default}, description: \"${3:Toggle this value}\")\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "parambool": true
        },
        "options": {}
      },
      {
        "content": "choice(name: \"${1:CHOICE}\" , choices: [\"${2:Choices}\",] , description: \"${3:Pick something}\") \n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "paramchoice": true
        },
        "options": {}
      },
      {
        "content": "password(name: \"${1:PASSWORD}\" , defaultValue: \"${2:SECRET}\" , description: \"${3:Enter a password}\")\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "parampassword": true
        },
        "options": {}
      },
      {
        "content": "file(name: \"${1:FILE}\" , description: \"${2:Choose a file to upload}\")${0}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "paramfile": true
        },
        "options": {}
      },
      {
        "content": "triggers {\n\tcron('${1:H */4 * * 1-5}')\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "triggers": true
        },
        "options": {}
      },
      {
        "content": "input {\n\tmessage '${1:Should we continue?}'\n\tok '${2:Yes, we should.}'\n\tsubmitter '${3:alice,bob}'\n\tparameters { \n\t\tstring(name: '${4:PERSON}' , defaultValue: '${5:Mr Jenkins}' , description: '${6:Who should I say hello to?}')\n\t}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "input": true
        },
        "options": {}
      },
      {
        "content": "when {\n\tbranch '${1:branch}'\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whenbranch": true
        },
        "options": {}
      },
      {
        "content": "when {\n\tbuildingTag '${1:tag}'\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whenbuildingTag": true
        },
        "options": {}
      },
      {
        "content": "when {\n\tchangelog '${1:changelog}'\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whenchangelog": true
        },
        "options": {}
      },
      {
        "content": "when {\n\tchangeset '${1:changeSet}'\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whenchangeset": true
        },
        "options": {}
      },
      {
        "content": "when {\n\tchangeRequest '${1:changeRequest}'\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whenchangeRequest": true
        },
        "options": {}
      },
      {
        "content": "when {\n\tenvironment '${1:environment}'\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whenenvironment": true
        },
        "options": {}
      },
      {
        "content": "when {\n\tequals '${1:equals}'\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whenequals": true
        },
        "options": {}
      },
      {
        "content": "when {\n\texpression '${1:expression}'\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whenexpression": true
        },
        "options": {}
      },
      {
        "content": "when {\n\ttag '${1:tag}'\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whentag": true
        },
        "options": {}
      },
      {
        "content": "when {\n\tnot '${1:not}'\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whennot": true
        },
        "options": {}
      },
      {
        "content": "when {\n\tallOf '${1:allOf}'\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whenallOf": true
        },
        "options": {}
      },
      {
        "content": "when {\n\tanyOf '${1:anyOf}'\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whenanyOf": true
        },
        "options": {}
      }
    ],
    "jest": [
      {
        "content": "afterAll(() => {\n\t$0\n});",
        "doc": "afterAll function is called once after all specs",
        "grammar": "lsp",
        "label": "jest-afterall",
        "matches": {
          "aa": true,
          "jest afterall": true
        },
        "options": {}
      },
      {
        "content": "afterEach(() => {\n\t$0\n});",
        "doc": "afterEach function is called once after each spec",
        "grammar": "lsp",
        "label": "jest-aftereach",
        "matches": {
          "ae": true,
          "jest aftereach": true
        },
        "options": {}
      },
      {
        "content": "beforeAll(() => {\n\t$0\n});",
        "doc": "beforeAll function is called once before all specs",
        "grammar": "lsp",
        "label": "jest-beforeall",
        "matches": {
          "ba": true,
          "jest beforeall": true
        },
        "options": {}
      },
      {
        "content": "beforeEach(() => {\n\t$0\n});",
        "doc": "beforeEach function is called once before each spec",
        "grammar": "lsp",
        "label": "jest-beforeeach",
        "matches": {
          "be": true,
          "jest beforeeach": true
        },
        "options": {}
      },
      {
        "content": "describe('${1:Name of the group}', () => {\n\t$0\n});",
        "doc": "creates a describe block",
        "grammar": "lsp",
        "label": "jest-describe",
        "matches": {
          "desc": true,
          "jest describe": true
        },
        "options": {}
      },
      {
        "content": "describe.each([${1:[1, 2], [2, 4]}])(\n\t'${2:double(%d)}',\n\t(${3:input, expected}) => {\n\t\ttest(`returns \\${expected}`, () => {\n\t\t\t${4:expect(double(input)).toBe(expected);}\n\t\t});\n\t}\n);",
        "doc": "creates a describe block with different test data sets",
        "grammar": "lsp",
        "label": "jest-describe-each",
        "matches": {
          "desce": true,
          "jest describe each": true
        },
        "options": {}
      },
      {
        "content": "describe.only('${1:Name of the group}', () => {\n\t$0\n});",
        "doc": "creates a describe block that runs only",
        "grammar": "lsp",
        "label": "jest-describe-only",
        "matches": {
          "desco": true,
          "jest describe only": true
        },
        "options": {}
      },
      {
        "content": "describe.skip('${1:Name of the group}', () => {\n\t$0\n});",
        "doc": "creates a describe block that will be skipped",
        "grammar": "lsp",
        "label": "jest-describe-skip",
        "matches": {
          "descs": true,
          "jest describe skip": true
        },
        "options": {}
      },
      {
        "content": "expect($0)",
        "doc": "expect actual value",
        "grammar": "lsp",
        "label": "jest-expect",
        "matches": {
          "exp": true,
          "jest expect": true
        },
        "options": {}
      },
      {
        "content": "expect.assertions($0);",
        "doc": "expects the test to make the indicated number of assertions (useful for async)",
        "grammar": "lsp",
        "label": "jest-expect-assertions",
        "matches": {
          "expas": true,
          "jest expect assertions": true
        },
        "options": {}
      },
      {
        "content": "expect.hasAssertions();$0",
        "doc": "expects the test to make at least one assertion (useful for async)",
        "grammar": "lsp",
        "label": "jest-expect-hasassertions",
        "matches": {
          "expha": true,
          "jest expect hasassertions": true
        },
        "options": {}
      },
      {
        "content": "expect($1).rejects$0",
        "doc": "expect promise rejects to",
        "grammar": "lsp",
        "label": "jest-expect-rejects",
        "matches": {
          "exprj": true,
          "jest expect rejects": true
        },
        "options": {}
      },
      {
        "content": "expect($1).resolves$0",
        "doc": "expect promise resolves to",
        "grammar": "lsp",
        "label": "jest-expect-resolves",
        "matches": {
          "expr": true,
          "jest expect resolves": true
        },
        "options": {}
      },
      {
        "content": "it('${1:should }', () => {\n\t$0\n});",
        "doc": "creates an it block",
        "grammar": "lsp",
        "label": "jest-it",
        "matches": {
          "it": true,
          "jest it": true
        },
        "options": {}
      },
      {
        "content": "it.each([${1:[1, 2], [2, 4]}])(\n\t'${2:double(%d)}',\n\t(${3:input, expected}) => {\n\t\t${0:expect(double(input)).toBe(expected);}\n\t}\n);",
        "doc": "creates an it block with different test data sets",
        "grammar": "lsp",
        "label": "jest-it-each",
        "matches": {
          "ite": true,
          "jest it each": true
        },
        "options": {}
      },
      {
        "content": "it.only('${1:should }', () => {\n\t$0\n});",
        "doc": "creates an it block that runs only",
        "grammar": "lsp",
        "label": "jest-it-only",
        "matches": {
          "ito": true,
          "jest it only": true
        },
        "options": {}
      },
      {
        "content": "it.skip('${1:should }', () => {\n\t$0\n});",
        "doc": "creates an it block that will be skipped",
        "grammar": "lsp",
        "label": "jest-it-skip",
        "matches": {
          "its": true,
          "jest it skip": true
        },
        "options": {}
      },
      {
        "content": "it.todo('${1:should }');",
        "doc": "creates a test placeholder",
        "grammar": "lsp",
        "label": "jest-it-todo",
        "matches": {
          "itt": true,
          "jest it todo": true
        },
        "options": {}
      },
      {
        "content": "it('${1:should }', async () => {\n\t$0\n});",
        "doc": "creates an it block with async callback function",
        "grammar": "lsp",
        "label": "jest-it-async",
        "matches": {
          "ita": true,
          "jest it async": true
        },
        "options": {}
      },
      {
        "content": "jest.fn($0)",
        "doc": "creates jest.fn()",
        "grammar": "lsp",
        "label": "jest-jest-fn",
        "matches": {
          "jest fn": true,
          "jfn": true
        },
        "options": {}
      },
      {
        "content": "describe('${1:Name of the group}', () => {\n\n\tlet ${2:cut};\n\n\tbeforeEach(() => {\n\t\t$2 = $3;\n\t});\n\n\ttest('${1:should }', () => {\n\t\texpect($2).toBe($0);\n\t});\n\n});",
        "doc": "creates a template to test a class under test",
        "grammar": "lsp",
        "label": "jest-template-cut",
        "matches": {
          "cut": true,
          "jest template cut": true
        },
        "options": {}
      },
      {
        "content": "test('${1:should }', () => {\n\t$0\n});",
        "doc": "creates a test block",
        "grammar": "lsp",
        "label": "jest-test",
        "matches": {
          "jest test": true,
          "test": true
        },
        "options": {}
      },
      {
        "content": "test.each([${1:[1, 2], [2, 4]}])(\n\t'${2:double(%d)}',\n\t(${3:input, expected}) => {\n\t\t${0:expect(double(input)).toBe(expected);}\n\t}\n);",
        "doc": "creates an test block with different test data sets",
        "grammar": "lsp",
        "label": "jest-test-each",
        "matches": {
          "jest test each": true,
          "teste": true
        },
        "options": {}
      },
      {
        "content": "test.only('${1:should }', () => {\n\t$0\n});",
        "doc": "creates a test block  that runs only",
        "grammar": "lsp",
        "label": "jest-test-only",
        "matches": {
          "jest test only": true,
          "testo": true
        },
        "options": {}
      },
      {
        "content": "test.skip('${1:should }', () => {\n\t$0\n});",
        "doc": "creates a test block that will be skipped",
        "grammar": "lsp",
        "label": "jest-test-skip",
        "matches": {
          "jest test skip": true,
          "tests": true
        },
        "options": {}
      },
      {
        "content": "test.todo('${1:should }');",
        "doc": "creates a test placeholder",
        "grammar": "lsp",
        "label": "jest-test-todo",
        "matches": {
          "jest test todo": true,
          "testt": true
        },
        "options": {}
      },
      {
        "content": "test('${1:should }', async () => {\n\t$0\n});",
        "doc": "creates an test block with async callback function",
        "grammar": "lsp",
        "label": "jest-test-async",
        "matches": {
          "jest test async": true,
          "testa": true
        },
        "options": {}
      },
      {
        "content": "expect($1).toBe($0);",
        "doc": "expects the first argument to be equal with the second one",
        "grammar": "lsp",
        "label": "jest-tobe",
        "matches": {
          "jest expect tobe": true,
          "tb": true
        },
        "options": {}
      },
      {
        "content": "expect($1).toBeCloseTo(${2:number}, ${3:delta});$0",
        "doc": "expects the first argument to be close to the second one base on the delta",
        "grammar": "lsp",
        "label": "jest-tobecloseto",
        "matches": {
          "jest expect tobecloseto": true,
          "tbct": true
        },
        "options": {}
      },
      {
        "content": "expect($1).toBeDefined();$0",
        "doc": "expects the argument is defined",
        "grammar": "lsp",
        "label": "jest-tobedefined",
        "matches": {
          "jest expect tobedefined": true,
          "tbd": true
        },
        "options": {}
      },
      {
        "content": "expect($1).toBeFalsy();$0",
        "doc": "expects the argument is falsy",
        "grammar": "lsp",
        "label": "jest-tobefalsy",
        "matches": {
          "jest expect tobefalsy": true,
          "tbf": true
        },
        "options": {}
      },
      {
        "content": "expect($1).toBeGreaterThan($0);",
        "doc": "expects the argument is greater than or equal",
        "grammar": "lsp",
        "label": "jest-tobegreaterthan",
        "matches": {
          "jest expect tobegreaterthan": true,
          "tbgt": true
        },
        "options": {}
      },
      {
        "content": "expect($1).toBeGreaterThanOrEqual($0);",
        "doc": "expects the argument is greater than",
        "grammar": "lsp",
        "label": "jest-tobegreaterthanorequal",
        "matches": {
          "jest expect tobegreaterthanorequal": true,
          "tbgte": true
        },
        "options": {}
      },
      {
        "content": "expect($1).toBeInstanceOf($0);",
        "doc": "expects the argument is less than",
        "grammar": "lsp",
        "label": "jest-tobeinstanceof",
        "matches": {
          "jest expect tobeinstanceof": true,
          "tbi": true
        },
        "options": {}
      },
      {
        "content": "expect($1).toBeLessThan($0);",
        "doc": "expects the argument is less than",
        "grammar": "lsp",
        "label": "jest-tobelessthan",
        "matches": {
          "jest expect tobelessthan": true,
          "tblt": true
        },
        "options": {}
      },
      {
        "content": "expect($1).toBeLessThanOrEqual($0);",
        "doc": "expects the argument is less than or equal",
        "grammar": "lsp",
        "label": "jest-tobelessthanorequal",
        "matches": {
          "jest expect tobelessthanorequal": true,
          "tblte": true
        },
        "options": {}
      },
      {
        "content": "expect($1).toBeNull();$0",
        "doc": "expects the argument is null",
        "grammar": "lsp",
        "label": "jest-tobenull",
        "matches": {
          "jest expect tobenull": true,
          "tbn": true
        },
        "options": {}
      },
      {
        "content": "expect($1).toBeTruthy();$0",
        "doc": "expects the argument is truthy",
        "grammar": "lsp",
        "label": "jest-tobetruthy",
        "matches": {
          "jest expect tobetruthy": true,
          "tbt": true
        },
        "options": {}
      },
      {
        "content": "expect($1).toBeUndefined();$0",
        "doc": "expects the argument is undefined",
        "grammar": "lsp",
        "label": "jest-tobeundefined",
        "matches": {
          "jest expect tobeundefined": true,
          "tbu": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:list}).toContain($0);",
        "doc": "expects the list contains the item (===)",
        "grammar": "lsp",
        "label": "jest-tocontain",
        "matches": {
          "jest expect tocontain": true,
          "tc": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:list}).toContainEqual($0);",
        "doc": "expects the list contains the item (equals)",
        "grammar": "lsp",
        "label": "jest-tocontainequal",
        "matches": {
          "jest expect tocontainequal": true,
          "tce": true
        },
        "options": {}
      },
      {
        "content": "expect($1).toEqual($0);",
        "doc": "expects the first argument to be equal with the second one",
        "grammar": "lsp",
        "label": "jest-toequal",
        "matches": {
          "jest expect toequal": true,
          "te": true
        },
        "options": {}
      },
      {
        "content": "expect($1).toHaveBeenCalled();$0",
        "doc": "returns true if the spy was called",
        "grammar": "lsp",
        "label": "jest-tohavebeencalled",
        "matches": {
          "jest expect tohavebeencalled": true,
          "thbc": true
        },
        "options": {}
      },
      {
        "content": "expect($1).toHaveBeenCalledTimes($0);",
        "doc": "returns true if the spy has been called given times",
        "grammar": "lsp",
        "label": "jest-tohavebeencalledtimes",
        "matches": {
          "jest expect tohavebeencalledtimes": true,
          "thbct": true
        },
        "options": {}
      },
      {
        "content": "expect($1).toHaveBeenCalledWith($0);",
        "doc": "returns true if the spy has been called with",
        "grammar": "lsp",
        "label": "jest-tohavebeencalledwith",
        "matches": {
          "jest expect tohavebeencalledwith": true,
          "thbcw": true
        },
        "options": {}
      },
      {
        "content": "expect($1).toHaveBeenLastCalledWith($0);",
        "doc": "returns true if the spy has been last called with",
        "grammar": "lsp",
        "label": "jest-tohavebeenlastcalledwith",
        "matches": {
          "jest expect tohavebeenlastcalledwith": true,
          "thblcw": true
        },
        "options": {}
      },
      {
        "content": "expect($1).toHaveLength($0);",
        "doc": "expects the object to have length",
        "grammar": "lsp",
        "label": "jest-tohavelength",
        "matches": {
          "jest expect tohavelength": true,
          "thl": true
        },
        "options": {}
      },
      {
        "content": "expect($1).toHaveProperty(${2:keyPath}, ${3:value});$0",
        "doc": "returns true if the argument matches the second object",
        "grammar": "lsp",
        "label": "jest-tohaveproperty",
        "matches": {
          "jest expect tohaveproperty": true,
          "thp": true
        },
        "options": {}
      },
      {
        "content": "expect($1).toMatch($0);",
        "doc": "returns true if the argument matches the second value",
        "grammar": "lsp",
        "label": "jest-tomatch",
        "matches": {
          "jest expect tomatch": true,
          "tm": true
        },
        "options": {}
      },
      {
        "content": "expect($1).toMatchInlineSnapshot($0);",
        "doc": "returns true if the argument matches the most recent inline snapshot",
        "grammar": "lsp",
        "label": "jest-tomatchinlinesnapshot",
        "matches": {
          "jest expect tomatchinlinesnapshot": true,
          "tmis": true
        },
        "options": {}
      },
      {
        "content": "expect($1).toMatchObject($0);",
        "doc": "returns true if the argument matches the second object",
        "grammar": "lsp",
        "label": "jest-tomatchobject",
        "matches": {
          "jest expect tomatchobject": true,
          "tmo": true
        },
        "options": {}
      },
      {
        "content": "expect($1).toMatchSnapshot($0);",
        "doc": "returns true if the argument matches the most recent snapshot",
        "grammar": "lsp",
        "label": "jest-tomatchsnapshot",
        "matches": {
          "jest expect tomatchsnapshot": true,
          "tms": true
        },
        "options": {}
      },
      {
        "content": "expect($1).toStrictEqual($0);",
        "doc": "expects the first argument to be strictly equal with the second one",
        "grammar": "lsp",
        "label": "jest-tostrictequal",
        "matches": {
          "jest expect tostrictequal": true,
          "tse": true
        },
        "options": {}
      },
      {
        "content": "expect(() => {\n\t$0\n}).toThrow($1);",
        "doc": "expects that the method will throw an error",
        "grammar": "lsp",
        "label": "jest-tothrow",
        "matches": {
          "jest expect tothrow": true,
          "tt": true
        },
        "options": {}
      },
      {
        "content": "expect(() => {\n\t$0\n}).toThrowError($1);",
        "doc": "expects that the method will throw an error",
        "grammar": "lsp",
        "label": "jest-tothrowerror",
        "matches": {
          "jest expect tothrowerror": true,
          "tte": true
        },
        "options": {}
      },
      {
        "content": "expect(() => {\n\t$0\n}).toThrowErrorMatchingInlineSnapshot();",
        "doc": "expects that the method will throw an error matching the inline snapshot",
        "grammar": "lsp",
        "label": "jest-tothrowerrormatchinginlinesnapshot",
        "matches": {
          "jest expect tothrowerrormatchinginlinesnapshot": true,
          "ttemis": true
        },
        "options": {}
      },
      {
        "content": "expect(() => {\n\t$0\n}).toThrowErrorMatchingSnapshot();",
        "doc": "expects that the method will throw an error mathing the snapshpot",
        "grammar": "lsp",
        "label": "jest-tothrowerrormatchingsnapshot",
        "matches": {
          "jest expect tothrowerrormatchingsnapshot": true,
          "ttems": true
        },
        "options": {}
      }
    ],
    "jinja": [
      {
        "content": "{% ${1} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "%": true
        },
        "options": {}
      },
      {
        "content": "{% ${1:tag_name} %}\n${0}\n{% end$1 %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "%%": true
        },
        "options": {}
      },
      {
        "content": "{{ ${1} }}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "{": true
        },
        "options": {}
      },
      {
        "content": "{% autoescape ${1:off} %}\n\t${0}\n{% endautoescape %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "autoescape": true
        },
        "options": {}
      },
      {
        "content": "{% block ${1} %}\n\t${0}\n{% endblock %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "block": true
        },
        "options": {}
      },
      {
        "content": "{# ${0:comment} #}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#": true
        },
        "options": {}
      },
      {
        "content": "{% comment %}\n\t${0}\n{% endcomment %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "comment": true
        },
        "options": {}
      },
      {
        "content": "{% cycle ${1:val1} ${2:val2} ${3:as ${4}} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cycle": true
        },
        "options": {}
      },
      {
        "content": "{% debug %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "debug": true
        },
        "options": {}
      },
      {
        "content": "{% extends \"${0:base.html}\" %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "extends": true
        },
        "options": {}
      },
      {
        "content": "{% filter ${1} %}\n\t${0}\n{% endfilter %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "filter": true
        },
        "options": {}
      },
      {
        "content": "{% firstof ${1} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "firstof": true
        },
        "options": {}
      },
      {
        "content": "{% for ${1} in ${2} %}\n\t${0}\n{% endfor %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "{% empty %}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "empty": true
        },
        "options": {}
      },
      {
        "content": "{% if ${1} %}\n\t${0}\n{% endif %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "{% else %}\n\t${1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "el": true
        },
        "options": {}
      },
      {
        "content": "{% elif ${1} %}\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eif": true
        },
        "options": {}
      },
      {
        "content": "{% ifchanged %}${1}{% endifchanged %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifchanged": true
        },
        "options": {}
      },
      {
        "content": "{% ifequal ${1} ${2} %}\n\t${0}\n{% endifequal %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifequal": true
        },
        "options": {}
      },
      {
        "content": "{% ifnotequal ${1} ${2} %}\n\t${0}\n{% endifnotequal %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifnotequal": true
        },
        "options": {}
      },
      {
        "content": "{% include \"${0}\" %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "include": true
        },
        "options": {}
      },
      {
        "content": "{% load ${0} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "load": true
        },
        "options": {}
      },
      {
        "content": "{% now \"${0:jS F Y H:i}\" %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "now": true
        },
        "options": {}
      },
      {
        "content": "{% regroup ${1} by ${2} as ${0} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "regroup": true
        },
        "options": {}
      },
      {
        "content": "{% spaceless %}${0}{% endspaceless %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "spaceless": true
        },
        "options": {}
      },
      {
        "content": "{% ssi ${0} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ssi": true
        },
        "options": {}
      },
      {
        "content": "{% trans %}${0}{% endtrans %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "trans": true
        },
        "options": {}
      },
      {
        "content": "{% url ${1} as ${0} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "url": true
        },
        "options": {}
      },
      {
        "content": "{% widthratio ${1:this_value} ${2:max_value} ${0:100} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "widthratio": true
        },
        "options": {}
      },
      {
        "content": "{% with ${1} as ${2} %}\n\t${0}\n{% endwith %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "with": true
        },
        "options": {}
      },
      {
        "content": "add:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "add": true
        },
        "options": {}
      },
      {
        "content": "center:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "center": true
        },
        "options": {}
      },
      {
        "content": "cut:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cut": true
        },
        "options": {}
      },
      {
        "content": "date:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "date": true
        },
        "options": {}
      },
      {
        "content": "default:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "default": true
        },
        "options": {}
      },
      {
        "content": "default_if_none:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defaultifnone": true
        },
        "options": {}
      },
      {
        "content": "dictsort:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dictsort": true
        },
        "options": {}
      },
      {
        "content": "dictsortreversed:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dictsortrev": true
        },
        "options": {}
      },
      {
        "content": "divisibleby:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "divisibleby": true
        },
        "options": {}
      },
      {
        "content": "floatformat:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "floatformat": true
        },
        "options": {}
      },
      {
        "content": "get_digit:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "getdigit": true
        },
        "options": {}
      },
      {
        "content": "join:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "join": true
        },
        "options": {}
      },
      {
        "content": "length_is:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lengthis": true
        },
        "options": {}
      },
      {
        "content": "pluralize:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pluralize": true
        },
        "options": {}
      },
      {
        "content": "removetags:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "removetags": true
        },
        "options": {}
      },
      {
        "content": "slice:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "slice": true
        },
        "options": {}
      },
      {
        "content": "stringformat:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "stringformat": true
        },
        "options": {}
      },
      {
        "content": "time:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "time": true
        },
        "options": {}
      },
      {
        "content": "truncatewords:${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "truncatewords": true
        },
        "options": {}
      },
      {
        "content": "truncatewords_html:${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "truncatewordshtml": true
        },
        "options": {}
      },
      {
        "content": "urlizetrunc:${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "urlizetrunc": true
        },
        "options": {}
      },
      {
        "content": "wordwrap:${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wordwrap": true
        },
        "options": {}
      }
    ],
    "jinja2": [
      {
        "content": "{% block ${1:name} %}\n\t\t$2\n{% endblock $1 %}",
        "doc": "",
        "grammar": "snu",
        "label": "block",
        "matches": {
          "block": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "{{ $1 }}",
        "doc": "",
        "grammar": "snu",
        "label": "variable",
        "matches": {
          "{{": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "{# $1 #}",
        "doc": "",
        "grammar": "snu",
        "label": "comment",
        "matches": {
          "{#": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "{# $1 #}",
        "doc": "",
        "grammar": "snu",
        "label": "comment",
        "matches": {
          "#": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "{% raw %}\n\t\t$1\n{% endraw %}",
        "doc": "",
        "grammar": "snu",
        "label": "escaped block",
        "matches": {
          "raw": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "{% extends \"${1:template}\" %}",
        "doc": "",
        "grammar": "snu",
        "label": "extends",
        "matches": {
          "extends": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "{% include \"${1:template}\" %}",
        "doc": "",
        "grammar": "snu",
        "label": "include",
        "matches": {
          "include": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "{% import \"${1:template}\" %}",
        "doc": "",
        "grammar": "snu",
        "label": "import",
        "matches": {
          "import": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "{% from \"${1:template}\" import ${2:name}${3: as ${4:$2}} %}",
        "doc": "",
        "grammar": "snu",
        "label": "from/import/as",
        "matches": {
          "from": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "{% filter ${1:filter} %}\n\t$2\n{% endfilter %}",
        "doc": "",
        "grammar": "snu",
        "label": "filter",
        "matches": {
          "filter": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "{% for ${1:item} in ${2:sequence} %}\n\t$3\n{% endfor %}",
        "doc": "",
        "grammar": "snu",
        "label": "for",
        "matches": {
          "for": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "{% for ${1:item} in ${2:sequence} %}\n\t$3\n{% else %}\n\t$4\n{% endfor %}",
        "doc": "",
        "grammar": "snu",
        "label": "for/else",
        "matches": {
          "for": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "{% if ${1:expr} %}\n\t$2\n{% endif %}",
        "doc": "",
        "grammar": "snu",
        "label": "if",
        "matches": {
          "if": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "{% if ${1:expr} %}\n\t$2\n{% else %}\n\t$3\n{% endif %}",
        "doc": "",
        "grammar": "snu",
        "label": "if/else",
        "matches": {
          "if": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "{% if ${1:expr} %}\n\t$2\n{% elif %}\n\t$3\n{% else %}\n\t$4\n{% endif %}",
        "doc": "",
        "grammar": "snu",
        "label": "if/elif/else",
        "matches": {
          "if": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "{% macro ${1:name}(${2:args}) %}\n\t$3\n{% endmacro %}",
        "doc": "",
        "grammar": "snu",
        "label": "macro",
        "matches": {
          "macro": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "{% call ${1:name}(${2:args}) %}\n\t$3\n{% endcall %}",
        "doc": "",
        "grammar": "snu",
        "label": "call",
        "matches": {
          "call": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "{% set ${1:name} = ${2:'value'} %}",
        "doc": "",
        "grammar": "snu",
        "label": "set",
        "matches": {
          "set": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "{% trans %}\n\t$1\n{% endtrans %}",
        "doc": "",
        "grammar": "snu",
        "label": "translation",
        "matches": {
          "trans": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "{% with %}\n\t$1\n{% endwith %}",
        "doc": "",
        "grammar": "snu",
        "label": "with",
        "matches": {
          "with": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "{% autoescape ${1:true} %}\n\t$2\n{% endautoescape %}",
        "doc": "",
        "grammar": "snu",
        "label": "autoescape",
        "matches": {
          "autoescape": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "batch(linecount=$1, fill_with=${2:None})",
        "doc": "",
        "grammar": "snu",
        "label": "batch items",
        "matches": {
          "batch": true
        },
        "options": {
          "w": true
        }
      },
      {
        "content": "dictsort(case_sensitive=${1:False}, by=${2:'key'})",
        "doc": "",
        "grammar": "snu",
        "label": "sort and yield (key, value) pairs",
        "matches": {
          "dictsort": true
        },
        "options": {
          "w": true
        }
      },
      {
        "content": "round(precision=${1:0}, method=${2:'common|ceil|floor'})",
        "doc": "",
        "grammar": "snu",
        "label": "round number",
        "matches": {
          "round": true
        },
        "options": {
          "w": true
        }
      },
      {
        "content": "urlize(trim_url_limit=${1:None}, nofollow=${2:False})",
        "doc": "",
        "grammar": "snu",
        "label": "convert plain-text url to <a/>",
        "matches": {
          "urlize": true
        },
        "options": {
          "w": true
        }
      },
      {
        "content": "wordwrap(width=${1:79}, break_long_words=${2:True})",
        "doc": "",
        "grammar": "snu",
        "label": "wordwrap",
        "matches": {
          "wordwrap": true
        },
        "options": {
          "w": true
        }
      },
      {
        "content": "truncate(lenght=${1:79}, killwords=${2:False}, end=${3:'...''})",
        "doc": "",
        "grammar": "snu",
        "label": "truncate",
        "matches": {
          "truncate": true
        },
        "options": {
          "w": true
        }
      },
      {
        "content": "sum(attribute=${1:None}, start=${2:0})",
        "doc": "",
        "grammar": "snu",
        "label": "sum of sequence of numbers + start",
        "matches": {
          "sum": true
        },
        "options": {
          "w": true
        }
      },
      {
        "content": "sort(reverse=${1:False}, case_sensitive=${2:False}, attribute=${3:None})",
        "doc": "",
        "grammar": "snu",
        "label": "sort an iterable",
        "matches": {
          "sort": true
        },
        "options": {
          "w": true
        }
      },
      {
        "content": "indent(width=${1:4}, indentfirst=${2:False})",
        "doc": "",
        "grammar": "snu",
        "label": "indent",
        "matches": {
          "indent": true
        },
        "options": {
          "w": true
        }
      }
    ],
    "jquery_coffee": [
      {
        "content": "${1:obj}.add('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "add": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.addClass('${2:class name}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "addClass": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.after('${2:Some text <b>and bold!</b>}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "after": true
        },
        "options": {}
      },
      {
        "content": "$.ajax\n  url: \"${1:mydomain.com/url}\"\n  type: \"${2:POST}\"\n  dataType: \"${3:xml/html/script/json}\"\n  data: ${4:data}\n  complete: (jqXHR, textStatus) ->\n\t${5:// callback}\n  success: (data, textStatus, jqXHR) ->\n\t${6:// success callback}\n  error: (jqXHR, textStatus, errorThrown) ->\n\t${0:// error callback}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ajax": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.ajaxComplete (${1:e}, xhr, settings) ->\n\t${0:// callback}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ajaxcomplete": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.ajaxError (${1:e}, xhr, settings, thrownError) ->\n\t${2:// error callback}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ajaxerror": true
        },
        "options": {}
      },
      {
        "content": "$.get '${1:mydomain.com/url}',\n\t${2:{ param1: value1 },}\n\t(data, textStatus, jqXHR) ->\n\t\t${0:// success callback}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ajaxget": true
        },
        "options": {}
      },
      {
        "content": "$.post '${1:mydomain.com/url}',\n\t${2:{ param1: value1 },}\n\t(data, textStatus, jqXHR) ->\n\t\t${0:// success callback}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ajaxpost": true
        },
        "options": {}
      },
      {
        "content": "$.ajaxPrefilter (${1:options}, ${2:originalOptions}, jqXHR) ->\n\t${0: // Modify options, control originalOptions, store jqXHR, etc}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ajaxprefilter": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.ajaxSend (${1:request, settings}) ->\n\t${2:// error callback}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ajaxsend": true
        },
        "options": {}
      },
      {
        "content": "$.ajaxSetup({\n\turl: \"${1:mydomain.com/url}\",\n\ttype: \"${2:POST}\",\n\tdataType: \"${3:xml/html/script/json}\",\n\tdata: $.param( $(\"${4:Element or Expression}\") ),\n\tcomplete: (jqXHR, textStatus) ->\n\t\t${5:// callback}\n\t,\n\tsuccess: (data, textStatus, jqXHR) ->\n\t\t${6:// success callback}\n\t,\n\terror: (jqXHR, textStatus, errorThrown) ->\n\t\t${0:// error callback}\n})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ajaxsetup": true
        },
        "options": {}
      },
      {
        "content": "$.ajaxStart ->\n\t${1:// handler for when an AJAX call is started and no other AJAX calls are in progress}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ajaxstart": true
        },
        "options": {}
      },
      {
        "content": "$.ajaxStop ->\n\t${1:// handler for when all AJAX calls have been completed}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ajaxstop": true
        },
        "options": {}
      },
      {
        "content": "$.ajaxSuccess (${1:e}, xhr, settings) ->\n\t${2:// handler for when any AJAX call is successfully completed}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ajaxsuccess": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.andSelf()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "andself": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.animate({${2:param1: value1, param2: value2}}, ${3:speed})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "animate": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.append('${2:Some text <b>and bold!</b>}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "append": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.appendTo('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "appendTo": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.attr('${2:attribute}', '${3:value}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "attr": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.attr({'${2:attr1}': '${3:value1}', '${4:attr2}': '${5:value2}'})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "attrm": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.before('${2:Some text <b>and bold!</b>}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "before": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.bind('${2:event name}', (${3:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bind": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.blur (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "blur": true
        },
        "options": {}
      },
      {
        "content": "$.Callbacks()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "C": true
        },
        "options": {}
      },
      {
        "content": "${1:callbacks}.add(${2:callbacks})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Cadd": true
        },
        "options": {}
      },
      {
        "content": "${1:callbacks}.disable()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Cdis": true
        },
        "options": {}
      },
      {
        "content": "${1:callbacks}.empty()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Cempty": true
        },
        "options": {}
      },
      {
        "content": "${1:callbacks}.fire(${2:args})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Cfire": true
        },
        "options": {}
      },
      {
        "content": "${1:callbacks}.fired()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Cfired": true
        },
        "options": {}
      },
      {
        "content": "${1:callbacks}.fireWith(${2:this}, ${3:args})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Cfirew": true
        },
        "options": {}
      },
      {
        "content": "${1:callbacks}.has(${2:callback})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Chas": true
        },
        "options": {}
      },
      {
        "content": "${1:callbacks}.lock()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Clock": true
        },
        "options": {}
      },
      {
        "content": "${1:callbacks}.locked()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Clocked": true
        },
        "options": {}
      },
      {
        "content": "${1:callbacks}.remove(${2:callbacks})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Crem": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.change (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "change": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.children('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "children": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.clearQueue(${2:'queue name'})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "clearq": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.click (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "click": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.clone()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "clone": true
        },
        "options": {}
      },
      {
        "content": "$.contains(${1:container}, ${0:contents})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "contains": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.css('${2:attribute}', '${3:value}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "css": true
        },
        "options": {}
      },
      {
        "content": "$.cssHooks['${1:CSS prop}'] = {\n\tget: (elem, computed, extra) ->\n\t\t${2: // handle getting the CSS property}\n\tset: (elem, value) ->\n\t\t${0: // handle setting the CSS value}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "csshooks": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.css({${2:attribute1}: '${3:value1}', ${4:attribute2}: '${5:value2}'})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cssm": true
        },
        "options": {}
      },
      {
        "content": "$.Deferred()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "D": true
        },
        "options": {}
      },
      {
        "content": "${1:deferred}.always(${2:callbacks})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Dalways": true
        },
        "options": {}
      },
      {
        "content": "${1:deferred}.done(${2:callbacks})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Ddone": true
        },
        "options": {}
      },
      {
        "content": "${1:deferred}.fail(${2:callbacks})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Dfail": true
        },
        "options": {}
      },
      {
        "content": "${1:deferred}.isRejected()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Disrej": true
        },
        "options": {}
      },
      {
        "content": "${1:deferred}.isResolved()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Disres": true
        },
        "options": {}
      },
      {
        "content": "${1:deferred}.notify(${2:args})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Dnotify": true
        },
        "options": {}
      },
      {
        "content": "${1:deferred}.notifyWith(${2:this}, ${3:args})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Dnotifyw": true
        },
        "options": {}
      },
      {
        "content": "${1:deferred}.then(${2:doneFilter}, ${3:failFilter}, ${4:progressFilter})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Dpipe": true
        },
        "options": {}
      },
      {
        "content": "${1:deferred}.progress(${2:callbacks})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Dprog": true
        },
        "options": {}
      },
      {
        "content": "${1:deferred}.promise(${2:target})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Dprom": true
        },
        "options": {}
      },
      {
        "content": "${1:deferred}.reject(${2:args})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Drej": true
        },
        "options": {}
      },
      {
        "content": "${1:deferred}.rejectWith(${2:this}, ${3:args})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Drejw": true
        },
        "options": {}
      },
      {
        "content": "${1:deferred}.resolve(${2:args})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Dres": true
        },
        "options": {}
      },
      {
        "content": "${1:deferred}.resolveWith(${2:this}, ${3:args})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Dresw": true
        },
        "options": {}
      },
      {
        "content": "${1:deferred}.state()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Dstate": true
        },
        "options": {}
      },
      {
        "content": "${1:deferred}.then(${2:doneCallbacks}, ${3:failCallbacks}, ${4:progressCallbacks})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Dthen": true
        },
        "options": {}
      },
      {
        "content": "$.when(${1:deferreds})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Dwhen": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.data(${2:obj})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "data": true
        },
        "options": {}
      },
      {
        "content": "$.data('${1:selector expression}', '${2:key}'${3:, 'value'})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dataa": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.dblclick (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dblclick": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.delay('${2:slow/400/fast}'${3:, 'queue name'})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "delay": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.delegate '${2:selector expression}', '${3:event name}', (${4:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dele": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.dequeue(${2:'queue name'})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "deq": true
        },
        "options": {}
      },
      {
        "content": "$.dequeue('${1:selector expression}'${2:, 'queue name'})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "deqq": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.detach('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "detach": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.die(${2:event}, ${3:handler})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "die": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.each (index) ->\n\t${0:this.innerHTML = this + \" is the element, \" + index + \" is the position\"}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "each": true
        },
        "options": {}
      },
      {
        "content": "$('<${1}/>'${2:, {}})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "el": true
        },
        "options": {}
      },
      {
        "content": "$.trim('${1:string}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eltrim": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.empty()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "empty": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.end()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "end": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.eq(${2:element index})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eq": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.error (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "error": true
        },
        "options": {}
      },
      {
        "content": "{\n\t:f${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eventsmap": true
        },
        "options": {}
      },
      {
        "content": "$.extend(${1:true, }${2:target}, ${3:obj})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "extend": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.fadeIn('${2:slow/400/fast}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fadein": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.fadeIn 'slow/400/fast', ->\n\t${0:// callback}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fadeinc": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.fadeOut('${2:slow/400/fast}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fadeout": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.fadeOut 'slow/400/fast', ->\n\t${0:// callback}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fadeoutc": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.fadeTo('${2:slow/400/fast}', ${3:0.5})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fadeto": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.fadeTo 'slow/400/fast', ${2:0.5}, ->\n\t${0:// callback}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fadetoc": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.filter('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "filter": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.filter (${2:index}) ->\n\t${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "filtert": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.find('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "find": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.focus (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "focus": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.focusIn (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "focusin": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.focusOut (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "focusout": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.get(${2:element index})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "get": true
        },
        "options": {}
      },
      {
        "content": "$.getJSON '${1:mydomain.com/url}',\n\t${2:{ param1: value1 },}\n\t(data, textStatus, jqXHR) ->\n\t\t${0:// success callback}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "getjson": true
        },
        "options": {}
      },
      {
        "content": "$.getScript '${1:mydomain.com/url}', (script, textStatus, jqXHR) ->\n\t${0:// callback}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "getscript": true
        },
        "options": {}
      },
      {
        "content": "$.grep(${1:array}, (item, index) >\n\t${2}\n${0:, true})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "grep": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.hasClass('${2:className}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "hasc": true
        },
        "options": {}
      },
      {
        "content": "$.hasData('${0:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "hasd": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.height(${2:integer})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "height": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.hide('${2:slow/400/fast}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "hide": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.hide '${2:slow/400/fast}', ->\n\t${0:// callback}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "hidec": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.hover (${2:e}) ->\n\t${3:// event handler}\n, ($2) ->\n\t${4:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "hover": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.html('${2:Some text <b>and bold!</b>}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "html": true
        },
        "options": {}
      },
      {
        "content": "$.inArray(${1:value}, ${0:array})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "inarr": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.insertAfter('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "insa": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.insertBefore('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "insb": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.is('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "is": true
        },
        "options": {}
      },
      {
        "content": "$.isArray(${1:obj})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isarr": true
        },
        "options": {}
      },
      {
        "content": "$.isEmptyObject(${1:obj})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isempty": true
        },
        "options": {}
      },
      {
        "content": "$.isFunction(${1:obj})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isfunc": true
        },
        "options": {}
      },
      {
        "content": "$.isNumeric(${1:value})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isnum": true
        },
        "options": {}
      },
      {
        "content": "$.isPlainObject(${1:obj})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isobj": true
        },
        "options": {}
      },
      {
        "content": "$.isWindow(${1:obj})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "iswin": true
        },
        "options": {}
      },
      {
        "content": "$.isXMLDoc(${1:node})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isxml": true
        },
        "options": {}
      },
      {
        "content": "$('${1:selector}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jj": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.keydown (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "kdown": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.keypress (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "kpress": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.keyup (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "kup": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.last('${1:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "last": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.live '${2:events}', (${3:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "live": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.load (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "load": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.load('${2:mydomain.com/url}',\n\t${2:{ param1: value1 },}\n\t(responseText, textStatus, xhr) ->\n\t\t${0:// success callback}\n})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "loadf": true
        },
        "options": {}
      },
      {
        "content": "$.makeArray(${0:obj})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "makearray": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.map (${2:index}, ${3:element}) ->\n\t${0:// callback}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "map": true
        },
        "options": {}
      },
      {
        "content": "$.map ${1:arrayOrObject}, (${2:value}, ${3:indexOrKey}) ->\n\t${0:// callback}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mapp": true
        },
        "options": {}
      },
      {
        "content": "$.merge(${1:target}, ${0:original})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "merge": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.mousedown (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mdown": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.mouseenter (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "menter": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.mouseleave (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mleave": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.mousemove (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mmove": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.mouseout (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mout": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.mouseover (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mover": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.mouseup (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mup": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.next('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "next": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.nextAll('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nexta": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.nextUntil('${2:selector expression}'${3:, 'filter expression'})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nextu": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.not('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "not": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.off('${2:events}', '${3:selector expression}'${4:, handler})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "off": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.offset()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "offset": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.offsetParent()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "offsetp": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.on '${2:events}', '${3:selector expression}', (${4:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "on": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.one '${2:event name}', (${3:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "one": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.outerHeight()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "outerh": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.outerWidth()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "outerw": true
        },
        "options": {}
      },
      {
        "content": "$.param(${1:obj})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "param": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.parent('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "parent": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.parents('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "parents": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.parentsUntil('${2:selector expression}'${3:, 'filter expression'})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "parentsu": true
        },
        "options": {}
      },
      {
        "content": "$.parseJSON(${1:data})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "parsejson": true
        },
        "options": {}
      },
      {
        "content": "$.parseXML(${1:data})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "parsexml": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.position()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pos": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.prepend('${2:Some text <b>and bold!</b>}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prepend": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.prependTo('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prependto": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.prev('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prev": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.prevAll('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "preva": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.prevUntil('${2:selector expression}'${3:, 'filter expression'})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prevu": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.promise(${2:'fx'}, ${3:target})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "promise": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.prop('${2:property name}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prop": true
        },
        "options": {}
      },
      {
        "content": "$.proxy(${1:function}, ${2:this})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "proxy": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.pushStack(${2:elements})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pushstack": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.queue(${2:name}${3:, newQueue})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "queue": true
        },
        "options": {}
      },
      {
        "content": "$.queue(${1:element}${2:, name}${3:, newQueue})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "queuee": true
        },
        "options": {}
      },
      {
        "content": "$(() ->\n\t${0}\n)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ready": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.remove()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rem": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.removeAttr('${2:attribute name}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rema": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.removeClass('${2:class name}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "remc": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.removeData('${2:key name}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "remd": true
        },
        "options": {}
      },
      {
        "content": "$.removeData(${1:element}${2:, 'key name}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "remdd": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.removeProp('${2:property name}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "remp": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.replaceAll(${2:target})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "repa": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.replaceWith(${2:content})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "repw": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.reset (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "reset": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.resize (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "resize": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.scroll (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "scroll": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.scrollLeft(${2:value})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "scrolll": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.scrollTop(${2:value})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "scrollt": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.slideDown('${2:slow/400/fast}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sdown": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.slideDown('${2:slow/400/fast}', ->\n\t${0:// callback}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sdownc": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.select (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "select": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.serialize()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "serialize": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.serializeArray()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "serializea": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.show('${2:slow/400/fast}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "show": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.show '${2:slow/400/fast}', ->\n\t${0:// callback}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "showc": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.siblings('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sib": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.size()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "size": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.slice(${2:start}${3:, end})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "slice": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.slideToggle('${2:slow/400/fast}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "stoggle": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.stop('${2:queue}', ${3:false}, ${4:false})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "stop": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.submit (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "submit": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.slideUp('${2:slow/400/fast}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sup": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.slideUp '${2:slow/400/fast}', ->\n\t${0:// callback}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "supc": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.text(${2:'some text'})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "text": true
        },
        "options": {}
      },
      {
        "content": "$(this)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "this": true
        },
        "options": {}
      },
      {
        "content": "${0:obj}.toArray()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "toarr": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.toggle  (${2:e}) ->\n\t${3:// event handler}\n, ($2) ->\n\t${4:// event handler}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tog": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.toggleClass('${2:class name}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "togclass": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.toggle('${2:slow/400/fast}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "togsh": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.trigger('${2:event name}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "trig": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.triggerHandler('${2:event name}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "trigh": true
        },
        "options": {}
      },
      {
        "content": "$.trim(${1:str})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "$trim": true
        },
        "options": {}
      },
      {
        "content": "$.type(${1:obj})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "$type": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.unbind('${2:event name}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "unbind": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.undelegate(${2:selector expression}, ${3:event}, ${4:handler})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "undele": true
        },
        "options": {}
      },
      {
        "content": "$.unique(${1:array})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "uniq": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.unload (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "unload": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.unwrap()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "unwrap": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.val('${2:text}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "val": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.width(${2:integer})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "width": true
        },
        "options": {}
      },
      {
        "content": "${1:obj}.wrap('${2:&ltdiv class=\"extra-wrapper\"&gt&lt/div&gt}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wrap": true
        },
        "options": {}
      }
    ],
    "json": [
      {
        "content": "\"${1:key}\": \"${0:value}\",",
        "doc": "",
        "grammar": "snu",
        "label": "String",
        "matches": {
          "s": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "\"${1:key}\": ${0:value},",
        "doc": "",
        "grammar": "snu",
        "label": "Number",
        "matches": {
          "n": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "[\n\t${VISUAL}$0\n],",
        "doc": "",
        "grammar": "snu",
        "label": "Array",
        "matches": {
          "a": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "\"${1:key}\": [\n\t${VISUAL}$0\n],",
        "doc": "",
        "grammar": "snu",
        "label": "Named array",
        "matches": {
          "na": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "{\n\t${VISUAL}$0\n},",
        "doc": "",
        "grammar": "snu",
        "label": "Object",
        "matches": {
          "o": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "\"${1:key}\": {\n\t${VISUAL}$0\n},",
        "doc": "",
        "grammar": "snu",
        "label": "Named object",
        "matches": {
          "no": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "\"${0:key}\": null,",
        "doc": "",
        "grammar": "snu",
        "label": "Null",
        "matches": {
          "null": true
        },
        "options": {
          "b": true
        }
      }
    ],
    "jsonc": [
      {
        "content": "{\n\t\"name\": \"Launch Angular\",\n\t\"type\": \"${1:chrome}\",\n\t\"request\": \"launch\",\n\t\"preLaunchTask\": \"${2:npm: start}\",\n\t\"url\": \"http://localhost:${3:4200}/\",\n\t\"webRoot\": \"${4:\\${workspaceFolder\\}}\"\n}",
        "doc": "",
        "grammar": "lsp",
        "label": "Create launch config for Chrome",
        "matches": {
          "a-launch-chrome": true
        },
        "options": {}
      },
      {
        "content": "{\n\t\"name\": \"Launch Angular\",\n\t\"type\": \"${1:edge}\",\n\t\"version\": \"${2:dev}\",\n\t\"request\": \"launch\",\n\t\"preLaunchTask\": \"${3:npm: start}\",\n\t\"url\": \"http://localhost:${4:4200}/\",\n\t\"webRoot\": \"${5:\\${workspaceFolder\\}}\"\n}",
        "doc": "",
        "grammar": "lsp",
        "label": "Create launch config for Edge",
        "matches": {
          "a-launch-edge": true
        },
        "options": {}
      },
      {
        "content": "{\n\t\"type\": \"npm\",\n\t\"script\": \"${1:start}\",\n\t\"isBackground\": true,\n\t\"presentation\": {\n\t\t\"focus\": true,\n\t\t\"panel\": \"dedicated\"\n\t},\n\t\"group\": {\n\t\t\"kind\": \"build\",\n\t\t\"isDefault\": true\n\t},\n\t\"problemMatcher\": {\n\t\t\"owner\": \"typescript\",\n\t\t\"source\": \"ts\",\n\t\t\"applyTo\": \"closedDocuments\",\n\t\t\"fileLocation\": [\"relative\", \"\\${cwd\\}\"],\n\t\t\"pattern\": \"\\$tsc\",\n\t\t\"background\": {\n\t\t\t\"activeOnStart\": true,\n\t\t\t\"beginsPattern\": {\n\t\t\t\t\"regexp\": \"(.*?)\"\n\t\t\t},\n\t\t\t\"endsPattern\": {\n\t\t\t\t\"regexp\": \"Compiled |Failed to compile.\"\n\t\t\t}\n\t\t}\n\t}\n}",
        "doc": "",
        "grammar": "lsp",
        "label": "Create task to start Angular",
        "matches": {
          "a-task-start": true
        },
        "options": {}
      }
    ],
    "jsp": [
      {
        "content": "<%@page contentType=\"text/html\" pageEncoding=\"UTF-8\"%>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@page": true
        },
        "options": {}
      },
      {
        "content": "<%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %>\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/functions\" prefix=\"fn\" %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jstl": true
        },
        "options": {}
      },
      {
        "content": "<%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jstl:c": true
        },
        "options": {}
      },
      {
        "content": "<%@ taglib uri=\"http://java.sun.com/jsp/jstl/functions\" prefix=\"fn\" %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jstl:fn": true
        },
        "options": {}
      },
      {
        "content": "${pageContext.request.contextPath}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cpath": true
        },
        "options": {}
      },
      {
        "content": "<c:out value=\"${1}\" default=\"${0}\" />",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cout": true
        },
        "options": {}
      },
      {
        "content": "<c:set var=\"${1}\" value=\"${0}\" />",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cset": true
        },
        "options": {}
      },
      {
        "content": "<c:remove var=\"${1}\" scope=\"${0:page}\" />",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cremove": true
        },
        "options": {}
      },
      {
        "content": "<c:catch var=\"${0}\" />",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ccatch": true
        },
        "options": {}
      },
      {
        "content": "<c:if test=\"${${1}}\">\n\t${0}\n</c:if>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cif": true
        },
        "options": {}
      },
      {
        "content": "<c:choose>\n\t${0}\n</c:choose>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cchoose": true
        },
        "options": {}
      },
      {
        "content": "<c:when test=\"${${1}}\">\n\t${0}\n</c:when>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cwhen": true
        },
        "options": {}
      },
      {
        "content": "<c:otherwise>\n\t${0}\n</c:otherwise>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cother": true
        },
        "options": {}
      },
      {
        "content": "<c:forEach items=\"${${1}}\" var=\"${2}\" varStatus=\"${3}\">\n\t${0:<c:out value=\"$2\" />}\n</c:forEach>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cfore": true
        },
        "options": {}
      },
      {
        "content": "<c:set var=\"${1}\">${2:item1,item2,item3}</c:set>\n<c:forTokens var=\"${3}\" items=\"${$1}\" delims=\"${4:,}\">\n\t${0:<c:out value=\"$3\" />}\n</c:forTokens>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cfort": true
        },
        "options": {}
      },
      {
        "content": "<c:param name=\"${1}\" value=\"${0}\" />",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cparam": true
        },
        "options": {}
      },
      {
        "content": "<c:param name=\"${1}\" value=\"${2}\" />\ncparam+${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cparam+": true
        },
        "options": {}
      },
      {
        "content": "<c:import url=\"${1}\" />",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cimport": true
        },
        "options": {}
      },
      {
        "content": "<c:import url=\"${1}\">\n\t<c:param name=\"${2}\" value=\"${3}\" />\n\tcparam+${0}\n</c:import>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cimport+": true
        },
        "options": {}
      },
      {
        "content": "<c:url value=\"${1}\" var=\"${2}\" />\n<a href=\"${$2}\">${0}</a>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "curl": true
        },
        "options": {}
      },
      {
        "content": "<c:url value=\"${1}\" var=\"${2}\">\n\t<c:param name=\"${4}\" value=\"${5}\" />\n\tcparam+${0}\n</c:url>\n<a href=\"${$2}\">${3}</a>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "curl+": true
        },
        "options": {}
      },
      {
        "content": "<c:redirect url=\"${0}\" />",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "credirect": true
        },
        "options": {}
      },
      {
        "content": "${fn:contains(${1:string}, ${0:substr})}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "contains": true
        },
        "options": {}
      },
      {
        "content": "${fn:containsIgnoreCase(${1:string}, ${0:substr})}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "contains:i": true
        },
        "options": {}
      },
      {
        "content": "${fn:endsWith(${1:string}, ${0:suffix})}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "endswith": true
        },
        "options": {}
      },
      {
        "content": "${fn:escapeXml(${0:string})}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "escape": true
        },
        "options": {}
      },
      {
        "content": "${fn:indexOf(${1:string}, ${0:substr})}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "indexof": true
        },
        "options": {}
      },
      {
        "content": "${fn:join(${1:collection}, ${0:delims})}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "join": true
        },
        "options": {}
      },
      {
        "content": "${fn:length(${0:collection_or_string})}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "length": true
        },
        "options": {}
      },
      {
        "content": "${fn:replace(${1:string}, ${2:substr}, ${0:replace})}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "replace": true
        },
        "options": {}
      },
      {
        "content": "${fn:split(${1:string}, ${0:delims})}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "split": true
        },
        "options": {}
      },
      {
        "content": "${fn:startsWith(${1:string}, ${0:prefix})}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "startswith": true
        },
        "options": {}
      },
      {
        "content": "${fn:substring(${1:string}, ${2:begin}, ${0:end})}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "substr": true
        },
        "options": {}
      },
      {
        "content": "${fn:substringAfter(${1:string}, ${0:substr})}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "substr:a": true
        },
        "options": {}
      },
      {
        "content": "${fn:substringBefore(${1:string}, ${0:substr})}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "substr:b": true
        },
        "options": {}
      },
      {
        "content": "${fn:toLowerCase(${0:string})}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lc": true
        },
        "options": {}
      },
      {
        "content": "${fn:toUpperCase(${0:string})}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "uc": true
        },
        "options": {}
      },
      {
        "content": "${fn:trim(${0:string})}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "trim": true
        },
        "options": {}
      }
    ],
    "julia": [
      {
        "content": "function ${1}(${2})\n    ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "function ... end",
        "matches": {
          "function": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "macro ${1}(${2})\n    ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "macro ... end",
        "matches": {
          "macro": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "struct ${1}\n    ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "struct ... end",
        "matches": {
          "struct": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "module ${1}\n${0}\nend#module",
        "doc": "",
        "grammar": "snu",
        "label": "module ... end",
        "matches": {
          "module": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "let ${1}\n    ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "let ... end",
        "matches": {
          "let": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "quote\n    ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "quote ... end",
        "matches": {
          "quote": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "begin\n    ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "begin ... end",
        "matches": {
          "begin": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "for ${1}\n    ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "for ... end",
        "matches": {
          "for": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "if ${1}\n    ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "if ... end",
        "matches": {
          "if": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "try\n    ${1}\n${2:catch}\n    ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "try ... end",
        "matches": {
          "try": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "while ${1:true}\n    ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "while ... end",
        "matches": {
          "while": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "#!/usr/bin/env julia",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#!": true
        },
        "options": {}
      },
      {
        "content": "function ${1}(${2})\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fun function definition": true
        },
        "options": {}
      },
      {
        "content": "return(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ret return": true
        },
        "options": {}
      },
      {
        "content": "print(\"${1}\")\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pr print": true
        },
        "options": {}
      },
      {
        "content": "println(\"${1}\")\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prl print line": true
        },
        "options": {}
      },
      {
        "content": "using ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "use load a package": true
        },
        "options": {}
      },
      {
        "content": "include(\"${1}\")\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "incl include source code": true
        },
        "options": {}
      },
      {
        "content": "for ${1} in ${2}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forc for loop iterating over iterable container": true
        },
        "options": {}
      },
      {
        "content": "for ${1} = ${2}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for standard for loop": true
        },
        "options": {}
      },
      {
        "content": "for ${1} = ${2}, ${3} = ${4}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fornest nested for loop": true
        },
        "options": {}
      },
      {
        "content": "while ${1} ${2:<=} ${3}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh while loop": true
        },
        "options": {}
      },
      {
        "content": "if ${1}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if if statement": true
        },
        "options": {}
      },
      {
        "content": "else\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "el else part of statement": true
        },
        "options": {}
      },
      {
        "content": "else if ${1}\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eif else if part of if statement": true
        },
        "options": {}
      },
      {
        "content": "if ${1}\n\t${2}\nelse\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife full if-else statement": true
        },
        "options": {}
      },
      {
        "content": "${1} ? ${2} : ${3:nothing}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tern ternary operator": true
        },
        "options": {}
      },
      {
        "content": "try\n\t${1:${VISUAL}}\ncatch ${2}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "try try catch": true
        },
        "options": {}
      },
      {
        "content": "finally\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fin finally statement": true
        },
        "options": {}
      },
      {
        "content": "throw(${1})\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "thr throw": true
        },
        "options": {}
      },
      {
        "content": "@info \"${1}\" ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@i": true
        },
        "options": {}
      },
      {
        "content": "@warn \"${1}\" ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@w": true
        },
        "options": {}
      },
      {
        "content": "@error \"${1}\" ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@e": true
        },
        "options": {}
      },
      {
        "content": "@debug \"${1}\" ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@d": true
        },
        "options": {}
      },
      {
        "content": "@testset \"${1}\" begin\n\t${2}\n\t@test ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@t @testset with @test": true
        },
        "options": {}
      },
      {
        "content": "@testset \"${1}\" begin\n\t${2}\n\t@test_throws ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@tt @testset with @test_throws": true
        },
        "options": {}
      },
      {
        "content": "#' @description\n#'\n#' ${1:function description}\n#'\n#' ${2:@param ${3:name}::${4:Type} ${5:Description}}\n#'\n#' ${6:@returns ${7:name}::${8:Type} ${9:Description}}\n#'\n#' @examples\n#'\n#' ${10: function call examples}",
        "doc": "",
        "grammar": "snu",
        "label": "function documentation",
        "matches": {
          "docf": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "#' @description\n#'\n#' ${1:type description}\n#'\n#' ${2:@field ${3:name}::${4:Type} ${5:Description}}\n#'\n#' @examples\n#'\n#' ${10: constructor examples}",
        "doc": "",
        "grammar": "snu",
        "label": "type definition",
        "matches": {
          "doct": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "#' @param ${1:name}::${2:Type} ${0:Description}",
        "doc": "",
        "grammar": "snu",
        "label": "function parameter documentation",
        "matches": {
          "par": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "#' @field ${1:name}::${2:Type} ${0:Description}",
        "doc": "",
        "grammar": "snu",
        "label": "type field documentation",
        "matches": {
          "fld": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "Main.@bp",
        "doc": "",
        "grammar": "snu",
        "label": "Debugger breakpoint",
        "matches": {
          "deb": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "Main.@infiltrate",
        "doc": "",
        "grammar": "snu",
        "label": "Infiltrator breakpoint",
        "matches": {
          "inf": true
        },
        "options": {
          "b": true
        }
      }
    ],
    "kotlin": [
      {
        "content": "fun ${1:name}(${2}): ${3:String} {\n\t${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fun": true
        },
        "options": {}
      },
      {
        "content": "private fun ${1:name}(${2}): ${3:String} {\n\t${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pfun": true
        },
        "options": {}
      },
      {
        "content": "return ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ret": true
        },
        "options": {}
      },
      {
        "content": "when (${1:${VISUAL}}) {\n\t${2} -> ${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whe": true
        },
        "options": {}
      },
      {
        "content": "class ${1} {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cla": true
        },
        "options": {}
      },
      {
        "content": "companion object {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cobj": true
        },
        "options": {}
      },
      {
        "content": "object ${1} {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "obj": true
        },
        "options": {}
      },
      {
        "content": "if (${1}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "if (${1}) {\n\t${2:${VISUAL}}\n} else {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife": true
        },
        "options": {}
      }
    ],
    "kp19pp": [
      {
        "content": "<token_desc> token{\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "token_desc": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "<left>{\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "left": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "<grammar> grammar{\n\tE<${1}>\n\t\t: [${2}] ${3}\n\t\t;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "grammar": true
        },
        "options": {
          "head": true
        }
      }
    ],
    "laravel": [],
    "ledger": [],
    "lfe": [
      {
        "content": "(defun $1 ($2)\n\t$0)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "def": true
        },
        "options": {}
      },
      {
        "content": "(deftest $1\n\t$0)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "test": true
        },
        "options": {}
      }
    ],
    "lhaskell": [],
    "liquid": [
      {
        "content": "{% comment %}${1:#:comment}{% endcomment %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "comment": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "{% raw %}${1:#:TARGET}{% endraw %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "raw": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "{% if ${1:#:condition} %}\n  ${0:TARGET}\n{% endif %}",
        "doc": "",
        "grammar": "snu",
        "label": "if endif",
        "matches": {
          "if": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "{% elseif ${1:#:condition} %}\n  ${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "elseif": true
        },
        "options": {}
      },
      {
        "content": "{% if ${1:#:condition} %}\n  ${2:TARGET}\n{% else %}\n  ${3}\n{% endif %}",
        "doc": "",
        "grammar": "snu",
        "label": "if else endif",
        "matches": {
          "ifelse": true
        },
        "options": {}
      },
      {
        "content": "{% unless ${1:#:TARGET} %}\n  ${0:TARGET}\n{% endunless %}",
        "doc": "",
        "grammar": "snu",
        "label": "unless endunless",
        "matches": {
          "unless": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "{% case ${1:#:condition} %}\n{% when ${2:#:TARGET} %}\n  ${3}\n{% endcase%}",
        "doc": "",
        "grammar": "snu",
        "label": "case when endcase",
        "matches": {
          "case": true
        },
        "options": {}
      },
      {
        "content": "{% else %}\n  ${1:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "else": true
        },
        "options": {}
      },
      {
        "content": "{% when ${1:#:TARGET} %}\n  ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "when": true
        },
        "options": {}
      },
      {
        "content": "{% cycle ${1:#:TARGET} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cycle": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "{% for ${1:#:var} in ${2:#:list} %}\n  ${0:TARGET}\n{% endfor%}",
        "doc": "",
        "grammar": "snu",
        "label": "for in endfor",
        "matches": {
          "for": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "{% tablerow ${1:#:var} in ${2:#:list} %}\n  ${0:TARGET}\n{% endtablerow %}",
        "doc": "",
        "grammar": "snu",
        "label": "tablerow in endtablerow",
        "matches": {
          "tablerow": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "{% assign ${1:#:var} = ${2:#:value} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "assign": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "{% capture ${1:#:var} %}${2:#:TARGET}{% endcapture %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "capture": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "{% include ${1:#:TARGET} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "include": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "{{ ${1:#:TARGET} }}",
        "doc": "",
        "grammar": "snu",
        "label": "{{ }}",
        "matches": {
          "output": true,
          "{{": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "{{ ${1:#:TARGET} | ${2:#:filter} }}",
        "doc": "",
        "grammar": "snu",
        "label": "{{ | }}",
        "matches": {
          "filter": true,
          "{{": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "{% highlight ${1:#:TARGET} %}\n  ${2:code}\n{% endhighlight %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "highlight": true,
          "hl": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "{% highlight ${1:#:TARGET} linenos %}\n  ${2:code}\n{% endhighlight %}",
        "doc": "",
        "grammar": "snu",
        "label": "Line number",
        "matches": {
          "highlight_line": true,
          "hl_l": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "{% post_url ${1:#:TARGET} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "post_url": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "---\nlayout: ${1}\ntitle: ${2}\ncategory: ${3}\n---\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "layout title category",
        "matches": {
          "---": true,
          "front-matter": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "{% if ${1:condition} %}\n\t${0:${VISUAL}}\n{% endif %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "{% else %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "else": true
        },
        "options": {}
      },
      {
        "content": "{% elsif ${1:condition} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "elsif": true
        },
        "options": {}
      },
      {
        "content": "{% if ${1:condition} %}\n\t${2}\n{% else %}\n\t${0}\n{% endif %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifelse": true
        },
        "options": {}
      },
      {
        "content": "{% unless ${1:condition} %}\n\t${0:${VISUAL}}\n{% endunless %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "unless": true
        },
        "options": {}
      },
      {
        "content": "{% case ${1:variable} %}\n\t{% when ${2:condition} %}\n\t\t${3}\n\t{% else %}\n\t\t${0}\n{% endcase %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case": true
        },
        "options": {}
      },
      {
        "content": "{% when ${1:condition} %}\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "when": true
        },
        "options": {}
      },
      {
        "content": "{% cycle '${1:odd}', '${2:even}' %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cycle": true
        },
        "options": {}
      },
      {
        "content": "{% cycle '${1:group name}': '${2:odd}', '${3:even}' %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cyclegroup": true
        },
        "options": {}
      },
      {
        "content": "{% for ${1:item} in ${2:collection} %}\n\t${0}\n{% endfor %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "limit: ${1:5}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "limit": true
        },
        "options": {}
      },
      {
        "content": "offset: ${1:0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "offset": true
        },
        "options": {}
      },
      {
        "content": "reversed",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "reversed": true
        },
        "options": {}
      },
      {
        "content": "{% break %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "break": true
        },
        "options": {}
      },
      {
        "content": "{% continue %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "continue": true
        },
        "options": {}
      },
      {
        "content": "{% tablerow ${1:item} in ${2:collection} cols: ${3:2} %}\n\t${0}\n{% endtablerow %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tablerow": true
        },
        "options": {}
      },
      {
        "content": "{% assign ${1:variable} = ${0:value} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "assign": true
        },
        "options": {}
      },
      {
        "content": "{% increment ${0:variable} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "increment": true
        },
        "options": {}
      },
      {
        "content": "{% decrement ${0:variable} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "decrement": true
        },
        "options": {}
      },
      {
        "content": "{% capture ${1:variable} %}${0}{% endcapture %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "capture": true
        },
        "options": {}
      },
      {
        "content": "{% include '${0:snippet}' %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "include": true
        },
        "options": {}
      },
      {
        "content": "{% include '${1:snippet}', ${2:variable}: ${0:value} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "includewith": true
        },
        "options": {}
      },
      {
        "content": "{% render '${0:snippet}' %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "render": true
        },
        "options": {}
      },
      {
        "content": "{% render '${1:snippet}', ${2:variable}: ${0:value} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "renderwith": true
        },
        "options": {}
      },
      {
        "content": "{% section '${1:snippet}' %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "section": true
        },
        "options": {}
      },
      {
        "content": "{% raw %}${0}{% endraw %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "raw": true
        },
        "options": {}
      },
      {
        "content": "{% layout '${1:layout}' %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "layout": true
        },
        "options": {}
      },
      {
        "content": "{% layout none %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "layoutnone": true
        },
        "options": {}
      },
      {
        "content": "{% paginate ${1:collection.products} by ${2:12} %}\n\t{% for ${3:product} in $1 %}\n\t\t${0}\n\t{% endfor %}\n{% endpaginate %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "paginate": true
        },
        "options": {}
      },
      {
        "content": "{% schema %}\n\t{\n\t\t${0}\n\t}\n{% endschema %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "schema": true
        },
        "options": {}
      },
      {
        "content": "{% stylesheet %}\n\t${0}\n{% endstylesheet %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "stylesheet": true
        },
        "options": {}
      },
      {
        "content": "{% stylesheet '${1:scss}' %}\n\t${0}\n{% endstylesheet %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "stylesheet_scss": true
        },
        "options": {}
      },
      {
        "content": "{% javascript %}\n\t${0}\n{% endjavascript %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "javascript": true
        },
        "options": {}
      },
      {
        "content": "{%- comment -%}${0:${VISUAL}}{%- endcomment -%}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "comment-": true
        },
        "options": {}
      },
      {
        "content": "{%- if ${1:condition} -%}\n\t${0:${VISUAL}}\n{%- endif -%}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if-": true
        },
        "options": {}
      },
      {
        "content": "{%- else -%}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "else-": true
        },
        "options": {}
      },
      {
        "content": "{%- elsif ${1:condition} -%}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "elsif-": true
        },
        "options": {}
      },
      {
        "content": "{%- if ${1:condition} -%}\n\t${2}\n{%- else -%}\n\t${0}\n{%- endif -%}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifelse-": true
        },
        "options": {}
      },
      {
        "content": "{%- unless ${1:condition} -%}\n\t${0:${VISUAL}}\n{%- endunless -%}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "unless-": true
        },
        "options": {}
      },
      {
        "content": "{%- case ${1:variable} -%}\n\t{%- when ${2:condition} -%}\n\t\t${3}\n\t{%- else -%}\n\t\t${0}\n{%- endcase -%}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case-": true
        },
        "options": {}
      },
      {
        "content": "{%- when ${1:condition} -%}\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "when-": true
        },
        "options": {}
      },
      {
        "content": "{%- cycle '${1:odd}', '${2:even}' -%}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cycle-": true
        },
        "options": {}
      },
      {
        "content": "{%- cycle '${1:group name}': '${2:odd}', '${3:even}' -%}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cyclegroup-": true
        },
        "options": {}
      },
      {
        "content": "{%- for ${1:item} in ${2:collection} -%}\n\t${0}\n{%- endfor -%}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for-": true
        },
        "options": {}
      },
      {
        "content": "{%- continue -%}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "continue-": true
        },
        "options": {}
      },
      {
        "content": "{%- tablerow ${1:item} in ${2:collection} cols: ${3:2} -%}\n\t${0}\n{%- endtablerow -%}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tablerow-": true
        },
        "options": {}
      },
      {
        "content": "{%- assign ${1:variable} = ${0:value} -%}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "assign-": true
        },
        "options": {}
      },
      {
        "content": "{%- capture ${1:variable} -%}${0}{%- endcapture -%}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "capture-": true
        },
        "options": {}
      },
      {
        "content": "{%- include '${0:snippet}' -%}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "include-": true
        },
        "options": {}
      },
      {
        "content": "{%- include '${1:snippet}', ${2:variable}: ${0:value} -%}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "includewith-": true
        },
        "options": {}
      },
      {
        "content": "{%- render '${0:snippet}' -%}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "render-": true
        },
        "options": {}
      },
      {
        "content": "{%- render '${1:snippet}', ${2:variable}: ${0:value} -%}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "renderwith-": true
        },
        "options": {}
      },
      {
        "content": "{%- section '${1:snippet}' -%}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "section-": true
        },
        "options": {}
      },
      {
        "content": "{%- layout '${1:layout}' -%}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "layout-": true
        },
        "options": {}
      },
      {
        "content": "{%- layout none -%}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "layoutnone-": true
        },
        "options": {}
      },
      {
        "content": "{%- paginate ${1:collection.products} by ${2:12} -%}\n\t{%- for ${3:product} in $1 -%}\n\t\t${0}\n\t{%- endfor -%}\n{%- endpaginate -%}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "paginate-": true
        },
        "options": {}
      },
      {
        "content": "| join: '${1:, }'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "join": true
        },
        "options": {}
      },
      {
        "content": "| first",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "first": true
        },
        "options": {}
      },
      {
        "content": "| last",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "last": true
        },
        "options": {}
      },
      {
        "content": "| concat: ${1:array}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "concat": true
        },
        "options": {}
      },
      {
        "content": "| map: '${1:key}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "map": true
        },
        "options": {}
      },
      {
        "content": "| reverse",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "reverse": true
        },
        "options": {}
      },
      {
        "content": "| size",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "size": true
        },
        "options": {}
      },
      {
        "content": "| sort: '${1:key}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sort": true
        },
        "options": {}
      },
      {
        "content": "| uniq",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "uniq": true
        },
        "options": {}
      },
      {
        "content": "| img_tag",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "img_tag": true
        },
        "options": {}
      },
      {
        "content": "| img_tag: '${1:alt}', '${2:class}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "img_tag_param": true
        },
        "options": {}
      },
      {
        "content": "| script_tag",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "script_tag": true
        },
        "options": {}
      },
      {
        "content": "| stylesheet_tag",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "stylesheet_tag": true
        },
        "options": {}
      },
      {
        "content": "| abs",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "abs": true
        },
        "options": {}
      },
      {
        "content": "| ceil",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ceil": true
        },
        "options": {}
      },
      {
        "content": "| divided_by: ${1:2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "divided_by": true
        },
        "options": {}
      },
      {
        "content": "| floor",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "floor": true
        },
        "options": {}
      },
      {
        "content": "| minus: ${1:1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "minus": true
        },
        "options": {}
      },
      {
        "content": "| plus: ${1:1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "plus": true
        },
        "options": {}
      },
      {
        "content": "| round: ${1:0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "round": true
        },
        "options": {}
      },
      {
        "content": "| times: ${1:1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "times": true
        },
        "options": {}
      },
      {
        "content": "| modulo: ${1:2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "modulo": true
        },
        "options": {}
      },
      {
        "content": "| money",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "money": true
        },
        "options": {}
      },
      {
        "content": "| money_with_currency",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "money_with_currency": true
        },
        "options": {}
      },
      {
        "content": "| money_without_trailing_zeros",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "money_without_trailing_zeros": true
        },
        "options": {}
      },
      {
        "content": "| money_without_currency",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "money_without_currency": true
        },
        "options": {}
      },
      {
        "content": "| append: '${1:string}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "append": true
        },
        "options": {}
      },
      {
        "content": "| camelcase",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "camelcase": true
        },
        "options": {}
      },
      {
        "content": "| capitalize",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "capitalize": true
        },
        "options": {}
      },
      {
        "content": "| downcase",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "downcase": true
        },
        "options": {}
      },
      {
        "content": "| escape",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "escape": true
        },
        "options": {}
      },
      {
        "content": "| handleize",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "handleize": true
        },
        "options": {}
      },
      {
        "content": "| md5",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "md5": true
        },
        "options": {}
      },
      {
        "content": "| newline_to_br",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "newline_to_br": true
        },
        "options": {}
      },
      {
        "content": "| pluralize: '${1:item}', '${2:items}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pluralize": true
        },
        "options": {}
      },
      {
        "content": "| prepend: '${1:string}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prepend": true
        },
        "options": {}
      },
      {
        "content": "| remove: '${1:string}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "remove": true
        },
        "options": {}
      },
      {
        "content": "| remove_first: '${1:string}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "remove_first": true
        },
        "options": {}
      },
      {
        "content": "| replace: '${1:target}', '${2:replace}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "replace": true
        },
        "options": {}
      },
      {
        "content": "| replace_first: '${1:target}', '${2:replace}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "replace_first": true
        },
        "options": {}
      },
      {
        "content": "| slice: ${1:0}, ${2:5}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "slice": true
        },
        "options": {}
      },
      {
        "content": "| slice: ${1:at}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "slice_single": true
        },
        "options": {}
      },
      {
        "content": "| split: '${1:,}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "split": true
        },
        "options": {}
      },
      {
        "content": "| strip",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "strip": true
        },
        "options": {}
      },
      {
        "content": "| lstrip",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lstrip": true
        },
        "options": {}
      },
      {
        "content": "| rstrip",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rstrip": true
        },
        "options": {}
      },
      {
        "content": "| strip_html",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "strip_html": true
        },
        "options": {}
      },
      {
        "content": "| strip_newlines",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "strip_newlines": true
        },
        "options": {}
      },
      {
        "content": "| truncate: ${1:20}, '${2:...}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "truncate": true
        },
        "options": {}
      },
      {
        "content": "| truncatewords: ${1:5}, '${2:...}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "truncatewords": true
        },
        "options": {}
      },
      {
        "content": "| upcase",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "upcase": true
        },
        "options": {}
      },
      {
        "content": "| url_encode",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "url_encode": true
        },
        "options": {}
      },
      {
        "content": "| url_escape",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "url_escape": true
        },
        "options": {}
      },
      {
        "content": "| url_param_escape",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "url_param_escape": true
        },
        "options": {}
      },
      {
        "content": "| asset_url",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asset_url": true
        },
        "options": {}
      },
      {
        "content": "| asset_img_url: '${1:medium}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asset_img_url": true
        },
        "options": {}
      },
      {
        "content": "| img_url: '${1:medium}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "img_url": true
        },
        "options": {}
      },
      {
        "content": "{% schema %}\n\t{\n\t\t\"name\": \"${1}\",\n\t\t\"class\": \"${2}\",\n\t\t\"settings\": [\n\t\t\t${0}\n\t\t]\n\t}\n{% endschema %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "_schema": true
        },
        "options": {}
      },
      {
        "content": "\"blocks\": [\n\t{\n\t\t\"type\": \"${1}\",\n\t\t\"name\": \"${2}\",\n\t\t\"settings\": [\n\t\t\t${0}\n\t\t]\n\t}\n]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "_blocks": true
        },
        "options": {}
      },
      {
        "content": "{\n\t\"type\": \"text\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"default\": \"${3}\",\n\t\"info\": \"${4}\",\n\t\"placeholder\": \"${0}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "_text": true
        },
        "options": {}
      },
      {
        "content": "{\n\t\"type\": \"textarea\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"default\": \"${3}\",\n\t\"info\": \"${4}\",\n\t\"placeholder\": \"${0}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "_textarea": true
        },
        "options": {}
      },
      {
        "content": "{\n\t\"type\": \"image_picker\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${0}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "_image_picker": true
        },
        "options": {}
      },
      {
        "content": "{\n\t\"type\": \"radio\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"options\": [\n\t\t{ \"value\": \"${5}\", \"label\": \"${0}\" }\n\t],\n\t\"default\": \"${3}\",\n\t\"info\": \"${4}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "_radio": true
        },
        "options": {}
      },
      {
        "content": "{\n\t\"type\": \"select\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"options\": [\n\t\t{\n\t\t\t\"group\": \"${5}\",\n\t\t\t\"value\": \"${6}\",\n\t\t\t\"label\": \"${0}\"\n\t\t}\n\t],\n\t\"default\": \"${3}\",\n\t\"info\": \"${4}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "_select": true
        },
        "options": {}
      },
      {
        "content": "{\n\t\"type\": \"checkbox\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"default\": ${3:true},\n\t\"info\": \"${0}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "_checkbox": true
        },
        "options": {}
      },
      {
        "content": "{\n\t\"type\": \"range\",\n\t\"id\": \"${1}\",\n\t\"min\": ${2},\n\t\"max\": ${3},\n\t\"step\": ${4},\n\t\"unit\": \"${5}\",\n\t\"label\": \"${6}\",\n\t\"default\": ${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "_range": true
        },
        "options": {}
      },
      {
        "content": "{\n\t\"type\": \"color\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"default\": \"${3}\",\n\t\"info\": \"${0}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "_color": true
        },
        "options": {}
      },
      {
        "content": "{\n\t\"type\": \"font_picker\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"info\": \"${3}\",\n\t\"default\": \"${0:helvetica_n4}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "_font": true
        },
        "options": {}
      },
      {
        "content": "{\n\t\"type\": \"collection\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"info\": \"${0}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "_collection": true
        },
        "options": {}
      },
      {
        "content": "{\n\t\"type\": \"product\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"info\": \"${0}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "_product": true
        },
        "options": {}
      },
      {
        "content": "{\n\t\"type\": \"blog\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"info\": \"${0}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "_blog": true
        },
        "options": {}
      },
      {
        "content": "{\n\t\"type\": \"page\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"info\": \"${0}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "_page": true
        },
        "options": {}
      },
      {
        "content": "{\n\t\"type\": \"link_list\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"info\": \"${0}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "_link_list": true
        },
        "options": {}
      },
      {
        "content": "{\n\t\"type\": \"url\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"info\": \"${0}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "_url": true
        },
        "options": {}
      },
      {
        "content": "{\n\t\"type\": \"video_url\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"accept\": [\"youtube\", \"vimeo\"${0}],\n\t\"default\": \"${3}\",\n\t\"info\": \"${4}\",\n\t\"placeholder\": \"${5}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "_video": true
        },
        "options": {}
      },
      {
        "content": "{\n\t\"type\": \"richtext\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"default\": \"<p>${0}</p>\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "_richtext": true
        },
        "options": {}
      },
      {
        "content": "{\n\t\"type\": \"html\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"default\": \"<div>${0}</div>\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "_html": true
        },
        "options": {}
      },
      {
        "content": "{\n\t\"type\": \"article\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"info\": \"${0}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "_article": true
        },
        "options": {}
      },
      {
        "content": "{\n\t\"type\": \"header\",\n\t\"content\": \"${1}\",\n\t\"info\": \"${0}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "_header": true
        },
        "options": {}
      },
      {
        "content": "{\n\t\"type\": \"paragraph\",\n\t\"content\": \"${0}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "_paragraph": true
        },
        "options": {}
      }
    ],
    "lodash": [
      {
        "content": "_.runInContext(${context})",
        "doc": "_.mixin({ 'foo': _.constant('foo') });\n\nvar lodash = _.runInContext();\nlodash.mixin({ 'bar': lodash.constant('bar') });\n\n_.isFunction(_.foo);\n// => true\n_.isFunction(_.bar);\n// => false\n\nlodash.isFunction(lodash.foo);\n// => false\nlodash.isFunction(lodash.bar);\n// => true\n\n// Create a suped-up `defer` in Node.js.\nvar defer = _.runInContext({ 'setTimeout': setImmediate }).defer;\n\nCreate a new pristine `lodash` function using the `context` object.",
        "grammar": "lsp",
        "label": "lodash-runincontext",
        "matches": {
          "lodash runincontext": true
        },
        "options": {}
      },
      {
        "content": "_.chunk(${array}, ${size})",
        "doc": "_.chunk(['a', 'b', 'c', 'd'], 2);\n// => [['a', 'b'], ['c', 'd']]\n\n_.chunk(['a', 'b', 'c', 'd'], 3);\n// => [['a', 'b', 'c'], ['d']]\n\nCreates an array of elements split into groups the length of `size`.\nIf `array` can't be split evenly, the final chunk will be the remaining\nelements.",
        "grammar": "lsp",
        "label": "lodash-chunk",
        "matches": {
          "lodash chunk": true
        },
        "options": {}
      },
      {
        "content": "_.compact(${array})",
        "doc": "_.compact([0, 1, false, 2, '', 3]);\n// => [1, 2, 3]\n\nCreates an array with all falsey values removed. The values `false`, `null`,\n`0`, `\"\"`, `undefined`, and `NaN` are falsey.",
        "grammar": "lsp",
        "label": "lodash-compact",
        "matches": {
          "lodash compact": true
        },
        "options": {}
      },
      {
        "content": "_.concat(${array}, ${values})",
        "doc": "var array = [1];\nvar other = _.concat(array, 2, [3], [[4]]);\n\nconsole.log(other);\n// => [1, 2, 3, [4]]\n\nconsole.log(array);\n// => [1]\n\nCreates a new array concatenating `array` with any additional arrays\nand/or values.",
        "grammar": "lsp",
        "label": "lodash-concat",
        "matches": {
          "lodash concat": true
        },
        "options": {}
      },
      {
        "content": "_.difference(${array}, ${values})",
        "doc": "_.difference([2, 1], [2, 3]);\n// => [1]\n\nCreates an array of `array` values not included in the other given arrays\nusing [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\nfor equality comparisons. The order and references of result values are\ndetermined by the first array.\n\n**Note:** Unlike `_.pullAll`, this method returns a new array.",
        "grammar": "lsp",
        "label": "lodash-difference",
        "matches": {
          "lodash difference": true
        },
        "options": {}
      },
      {
        "content": "_.differenceBy(${array}, ${values}, ${iteratee})",
        "doc": "_.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n// => [1.2]\n\n// The `_.property` iteratee shorthand.\n_.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');\n// => [{ 'x': 2 }]\n\nThis method is like `_.difference` except that it accepts `iteratee` which\nis invoked for each element of `array` and `values` to generate the criterion\nby which they're compared. The order and references of result values are\ndetermined by the first array. The iteratee is invoked with one argument:\n(value).\n\n**Note:** Unlike `_.pullAllBy`, this method returns a new array.",
        "grammar": "lsp",
        "label": "lodash-differenceby",
        "matches": {
          "lodash differenceby": true
        },
        "options": {}
      },
      {
        "content": "_.differenceWith(${array}, ${values}, ${comparator})",
        "doc": "var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n\n_.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);\n// => [{ 'x': 2, 'y': 1 }]\n\nThis method is like `_.difference` except that it accepts `comparator`\nwhich is invoked to compare elements of `array` to `values`. The order and\nreferences of result values are determined by the first array. The comparator\nis invoked with two arguments: (arrVal, othVal).\n\n**Note:** Unlike `_.pullAllWith`, this method returns a new array.",
        "grammar": "lsp",
        "label": "lodash-differencewith",
        "matches": {
          "lodash differencewith": true
        },
        "options": {}
      },
      {
        "content": "_.drop(${array}, ${n})",
        "doc": "_.drop([1, 2, 3]);\n// => [2, 3]\n\n_.drop([1, 2, 3], 2);\n// => [3]\n\n_.drop([1, 2, 3], 5);\n// => []\n\n_.drop([1, 2, 3], 0);\n// => [1, 2, 3]\n\nCreates a slice of `array` with `n` elements dropped from the beginning.",
        "grammar": "lsp",
        "label": "lodash-drop",
        "matches": {
          "lodash drop": true
        },
        "options": {}
      },
      {
        "content": "_.dropRight(${array}, ${n})",
        "doc": "_.dropRight([1, 2, 3]);\n// => [1, 2]\n\n_.dropRight([1, 2, 3], 2);\n// => [1]\n\n_.dropRight([1, 2, 3], 5);\n// => []\n\n_.dropRight([1, 2, 3], 0);\n// => [1, 2, 3]\n\nCreates a slice of `array` with `n` elements dropped from the end.",
        "grammar": "lsp",
        "label": "lodash-dropright",
        "matches": {
          "lodash dropright": true
        },
        "options": {}
      },
      {
        "content": "_.dropRightWhile(${array}, ${predicate})",
        "doc": "var users = [\n  { 'user': 'barney',  'active': true },\n  { 'user': 'fred',    'active': false },\n  { 'user': 'pebbles', 'active': false }\n];\n\n_.dropRightWhile(users, function(o) { return !o.active; });\n// => objects for ['barney']\n\n// The `_.matches` iteratee shorthand.\n_.dropRightWhile(users, { 'user': 'pebbles', 'active': false });\n// => objects for ['barney', 'fred']\n\n// The `_.matchesProperty` iteratee shorthand.\n_.dropRightWhile(users, ['active', false]);\n// => objects for ['barney']\n\n// The `_.property` iteratee shorthand.\n_.dropRightWhile(users, 'active');\n// => objects for ['barney', 'fred', 'pebbles']\n\nCreates a slice of `array` excluding elements dropped from the end.\nElements are dropped until `predicate` returns falsey. The predicate is\ninvoked with three arguments: (value, index, array).",
        "grammar": "lsp",
        "label": "lodash-droprightwhile",
        "matches": {
          "lodash droprightwhile": true
        },
        "options": {}
      },
      {
        "content": "_.dropWhile(${array}, ${predicate})",
        "doc": "var users = [\n  { 'user': 'barney',  'active': false },\n  { 'user': 'fred',    'active': false },\n  { 'user': 'pebbles', 'active': true }\n];\n\n_.dropWhile(users, function(o) { return !o.active; });\n// => objects for ['pebbles']\n\n// The `_.matches` iteratee shorthand.\n_.dropWhile(users, { 'user': 'barney', 'active': false });\n// => objects for ['fred', 'pebbles']\n\n// The `_.matchesProperty` iteratee shorthand.\n_.dropWhile(users, ['active', false]);\n// => objects for ['pebbles']\n\n// The `_.property` iteratee shorthand.\n_.dropWhile(users, 'active');\n// => objects for ['barney', 'fred', 'pebbles']\n\nCreates a slice of `array` excluding elements dropped from the beginning.\nElements are dropped until `predicate` returns falsey. The predicate is\ninvoked with three arguments: (value, index, array).",
        "grammar": "lsp",
        "label": "lodash-dropwhile",
        "matches": {
          "lodash dropwhile": true
        },
        "options": {}
      },
      {
        "content": "_.fill(${array}, ${value}, ${start}, ${end})",
        "doc": "var array = [1, 2, 3];\n\n_.fill(array, 'a');\nconsole.log(array);\n// => ['a', 'a', 'a']\n\n_.fill(Array(3), 2);\n// => [2, 2, 2]\n\n_.fill([4, 6, 8, 10], '*', 1, 3);\n// => [4, '*', '*', 10]\n\nFills elements of `array` with `value` from `start` up to, but not\nincluding, `end`.\n\n**Note:** This method mutates `array`.",
        "grammar": "lsp",
        "label": "lodash-fill",
        "matches": {
          "lodash fill": true
        },
        "options": {}
      },
      {
        "content": "_.findIndex(${array}, ${predicate}, ${fromIndex})",
        "doc": "var users = [\n  { 'user': 'barney',  'active': false },\n  { 'user': 'fred',    'active': false },\n  { 'user': 'pebbles', 'active': true }\n];\n\n_.findIndex(users, function(o) { return o.user == 'barney'; });\n// => 0\n\n// The `_.matches` iteratee shorthand.\n_.findIndex(users, { 'user': 'fred', 'active': false });\n// => 1\n\n// The `_.matchesProperty` iteratee shorthand.\n_.findIndex(users, ['active', false]);\n// => 0\n\n// The `_.property` iteratee shorthand.\n_.findIndex(users, 'active');\n// => 2\n\nThis method is like `_.find` except that it returns the index of the first\nelement `predicate` returns truthy for instead of the element itself.",
        "grammar": "lsp",
        "label": "lodash-findindex",
        "matches": {
          "lodash findindex": true
        },
        "options": {}
      },
      {
        "content": "_.findLastIndex(${array}, ${predicate}, ${fromIndex})",
        "doc": "var users = [\n  { 'user': 'barney',  'active': true },\n  { 'user': 'fred',    'active': false },\n  { 'user': 'pebbles', 'active': false }\n];\n\n_.findLastIndex(users, function(o) { return o.user == 'pebbles'; });\n// => 2\n\n// The `_.matches` iteratee shorthand.\n_.findLastIndex(users, { 'user': 'barney', 'active': true });\n// => 0\n\n// The `_.matchesProperty` iteratee shorthand.\n_.findLastIndex(users, ['active', false]);\n// => 2\n\n// The `_.property` iteratee shorthand.\n_.findLastIndex(users, 'active');\n// => 0\n\nThis method is like `_.findIndex` except that it iterates over elements\nof `collection` from right to left.",
        "grammar": "lsp",
        "label": "lodash-findlastindex",
        "matches": {
          "lodash findlastindex": true
        },
        "options": {}
      },
      {
        "content": "_.flatten(${array})",
        "doc": "_.flatten([1, [2, [3, [4]], 5]]);\n// => [1, 2, [3, [4]], 5]\n\nFlattens `array` a single level deep.",
        "grammar": "lsp",
        "label": "lodash-flatten",
        "matches": {
          "lodash flatten": true
        },
        "options": {}
      },
      {
        "content": "_.flattenDeep(${array})",
        "doc": "_.flattenDeep([1, [2, [3, [4]], 5]]);\n// => [1, 2, 3, 4, 5]\n\nRecursively flattens `array`.",
        "grammar": "lsp",
        "label": "lodash-flattendeep",
        "matches": {
          "lodash flattendeep": true
        },
        "options": {}
      },
      {
        "content": "_.flattenDepth(${array}, ${depth})",
        "doc": "var array = [1, [2, [3, [4]], 5]];\n\n_.flattenDepth(array, 1);\n// => [1, 2, [3, [4]], 5]\n\n_.flattenDepth(array, 2);\n// => [1, 2, 3, [4], 5]\n\nRecursively flatten `array` up to `depth` times.",
        "grammar": "lsp",
        "label": "lodash-flattendepth",
        "matches": {
          "lodash flattendepth": true
        },
        "options": {}
      },
      {
        "content": "_.fromPairs(${pairs})",
        "doc": "_.fromPairs([['a', 1], ['b', 2]]);\n// => { 'a': 1, 'b': 2 }\n\nThe inverse of `_.toPairs`; this method returns an object composed\nfrom key-value `pairs`.",
        "grammar": "lsp",
        "label": "lodash-frompairs",
        "matches": {
          "lodash frompairs": true
        },
        "options": {}
      },
      {
        "content": "_.first(${array})",
        "doc": "_.head([1, 2, 3]);\n// => 1\n\n_.head([]);\n// => undefined\n\nGets the first element of `array`.",
        "grammar": "lsp",
        "label": "lodash-first",
        "matches": {
          "lodash first": true
        },
        "options": {}
      },
      {
        "content": "_.indexOf(${array}, ${value}, ${fromIndex})",
        "doc": "_.indexOf([1, 2, 1, 2], 2);\n// => 1\n\n// Search from the `fromIndex`.\n_.indexOf([1, 2, 1, 2], 2, 2);\n// => 3\n\nGets the index at which the first occurrence of `value` is found in `array`\nusing [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\nfor equality comparisons. If `fromIndex` is negative, it's used as the\noffset from the end of `array`.",
        "grammar": "lsp",
        "label": "lodash-indexof",
        "matches": {
          "lodash indexof": true
        },
        "options": {}
      },
      {
        "content": "_.initial(${array})",
        "doc": "_.initial([1, 2, 3]);\n// => [1, 2]\n\nGets all but the last element of `array`.",
        "grammar": "lsp",
        "label": "lodash-initial",
        "matches": {
          "lodash initial": true
        },
        "options": {}
      },
      {
        "content": "_.intersection(${arrays})",
        "doc": "_.intersection([2, 1], [2, 3]);\n// => [2]\n\nCreates an array of unique values that are included in all given arrays\nusing [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\nfor equality comparisons. The order and references of result values are\ndetermined by the first array.",
        "grammar": "lsp",
        "label": "lodash-intersection",
        "matches": {
          "lodash intersection": true
        },
        "options": {}
      },
      {
        "content": "_.intersectionBy(${arrays}, ${iteratee})",
        "doc": "_.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n// => [2.1]\n\n// The `_.property` iteratee shorthand.\n_.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n// => [{ 'x': 1 }]\n\nThis method is like `_.intersection` except that it accepts `iteratee`\nwhich is invoked for each element of each `arrays` to generate the criterion\nby which they're compared. The order and references of result values are\ndetermined by the first array. The iteratee is invoked with one argument:\n(value).",
        "grammar": "lsp",
        "label": "lodash-intersectionby",
        "matches": {
          "lodash intersectionby": true
        },
        "options": {}
      },
      {
        "content": "_.intersectionWith(${arrays}, ${comparator})",
        "doc": "var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\nvar others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n\n_.intersectionWith(objects, others, _.isEqual);\n// => [{ 'x': 1, 'y': 2 }]\n\nThis method is like `_.intersection` except that it accepts `comparator`\nwhich is invoked to compare elements of `arrays`. The order and references\nof result values are determined by the first array. The comparator is\ninvoked with two arguments: (arrVal, othVal).",
        "grammar": "lsp",
        "label": "lodash-intersectionwith",
        "matches": {
          "lodash intersectionwith": true
        },
        "options": {}
      },
      {
        "content": "_.join(${array}, ${separator})",
        "doc": "_.join(['a', 'b', 'c'], '~');\n// => 'a~b~c'\n\nConverts all elements in `array` into a string separated by `separator`.",
        "grammar": "lsp",
        "label": "lodash-join",
        "matches": {
          "lodash join": true
        },
        "options": {}
      },
      {
        "content": "_.last(${array})",
        "doc": "_.last([1, 2, 3]);\n// => 3\n\nGets the last element of `array`.",
        "grammar": "lsp",
        "label": "lodash-last",
        "matches": {
          "lodash last": true
        },
        "options": {}
      },
      {
        "content": "_.lastIndexOf(${array}, ${value}, ${fromIndex})",
        "doc": "_.lastIndexOf([1, 2, 1, 2], 2);\n// => 3\n\n// Search from the `fromIndex`.\n_.lastIndexOf([1, 2, 1, 2], 2, 2);\n// => 1\n\nThis method is like `_.indexOf` except that it iterates over elements of\n`array` from right to left.",
        "grammar": "lsp",
        "label": "lodash-lastindexof",
        "matches": {
          "lodash lastindexof": true
        },
        "options": {}
      },
      {
        "content": "_.nth(${array}, ${n})",
        "doc": "var array = ['a', 'b', 'c', 'd'];\n\n_.nth(array, 1);\n// => 'b'\n\n_.nth(array, -2);\n// => 'c';\n\nGets the element at index `n` of `array`. If `n` is negative, the nth\nelement from the end is returned.",
        "grammar": "lsp",
        "label": "lodash-nth",
        "matches": {
          "lodash nth": true
        },
        "options": {}
      },
      {
        "content": "_.pull(${array}, ${values})",
        "doc": "var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n\n_.pull(array, 'a', 'c');\nconsole.log(array);\n// => ['b', 'b']\n\nRemoves all given values from `array` using\n[`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\nfor equality comparisons.\n\n**Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`\nto remove elements from an array by predicate.",
        "grammar": "lsp",
        "label": "lodash-pull",
        "matches": {
          "lodash pull": true
        },
        "options": {}
      },
      {
        "content": "_.pullAll(${array}, ${values})",
        "doc": "var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n\n_.pullAll(array, ['a', 'c']);\nconsole.log(array);\n// => ['b', 'b']\n\nThis method is like `_.pull` except that it accepts an array of values to remove.\n\n**Note:** Unlike `_.difference`, this method mutates `array`.",
        "grammar": "lsp",
        "label": "lodash-pullall",
        "matches": {
          "lodash pullall": true
        },
        "options": {}
      },
      {
        "content": "_.pullAllBy(${array}, ${values}, ${iteratee})",
        "doc": "var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\n\n_.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');\nconsole.log(array);\n// => [{ 'x': 2 }]\n\nThis method is like `_.pullAll` except that it accepts `iteratee` which is\ninvoked for each element of `array` and `values` to generate the criterion\nby which they're compared. The iteratee is invoked with one argument: (value).\n\n**Note:** Unlike `_.differenceBy`, this method mutates `array`.",
        "grammar": "lsp",
        "label": "lodash-pullallby",
        "matches": {
          "lodash pullallby": true
        },
        "options": {}
      },
      {
        "content": "_.pullAllWith(${array}, ${values}, ${comparator})",
        "doc": "var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];\n\n_.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);\nconsole.log(array);\n// => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]\n\nThis method is like `_.pullAll` except that it accepts `comparator` which\nis invoked to compare elements of `array` to `values`. The comparator is\ninvoked with two arguments: (arrVal, othVal).\n\n**Note:** Unlike `_.differenceWith`, this method mutates `array`.",
        "grammar": "lsp",
        "label": "lodash-pullallwith",
        "matches": {
          "lodash pullallwith": true
        },
        "options": {}
      },
      {
        "content": "_.pullAt(${array}, ${indexes})",
        "doc": "var array = ['a', 'b', 'c', 'd'];\nvar pulled = _.pullAt(array, [1, 3]);\n\nconsole.log(array);\n// => ['a', 'c']\n\nconsole.log(pulled);\n// => ['b', 'd']\n\nRemoves elements from `array` corresponding to `indexes` and returns an\narray of removed elements.\n\n**Note:** Unlike `_.at`, this method mutates `array`.",
        "grammar": "lsp",
        "label": "lodash-pullat",
        "matches": {
          "lodash pullat": true
        },
        "options": {}
      },
      {
        "content": "_.remove(${array}, ${predicate})",
        "doc": "var array = [1, 2, 3, 4];\nvar evens = _.remove(array, function(n) {\n  return n % 2 == 0;\n});\n\nconsole.log(array);\n// => [1, 3]\n\nconsole.log(evens);\n// => [2, 4]\n\nRemoves all elements from `array` that `predicate` returns truthy for\nand returns an array of the removed elements. The predicate is invoked\nwith three arguments: (value, index, array).\n\n**Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`\nto pull elements from an array by value.",
        "grammar": "lsp",
        "label": "lodash-remove",
        "matches": {
          "lodash remove": true
        },
        "options": {}
      },
      {
        "content": "_.reverse()",
        "doc": "var array = [1, 2, 3];\n\n_(array).reverse().value()\n// => [3, 2, 1]\n\nconsole.log(array);\n// => [3, 2, 1]\n\nThis method is the wrapper version of `_.reverse`.\n\n**Note:** This method mutates the wrapped array.",
        "grammar": "lsp",
        "label": "lodash-reverse",
        "matches": {
          "lodash reverse": true
        },
        "options": {}
      },
      {
        "content": "_.slice(${array}, ${start}, ${end})",
        "doc": "undefined\n\nCreates a slice of `array` from `start` up to, but not including, `end`.\n\n**Note:** This method is used instead of\n[`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are\nreturned.",
        "grammar": "lsp",
        "label": "lodash-slice",
        "matches": {
          "lodash slice": true
        },
        "options": {}
      },
      {
        "content": "_.sortedIndex(${array}, ${value})",
        "doc": "_.sortedIndex([30, 50], 40);\n// => 1\n\nUses a binary search to determine the lowest index at which `value`\nshould be inserted into `array` in order to maintain its sort order.",
        "grammar": "lsp",
        "label": "lodash-sortedindex",
        "matches": {
          "lodash sortedindex": true
        },
        "options": {}
      },
      {
        "content": "_.sortedIndexBy(${array}, ${value}, ${iteratee})",
        "doc": "var objects = [{ 'x': 4 }, { 'x': 5 }];\n\n_.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n// => 0\n\n// The `_.property` iteratee shorthand.\n_.sortedIndexBy(objects, { 'x': 4 }, 'x');\n// => 0\n\nThis method is like `_.sortedIndex` except that it accepts `iteratee`\nwhich is invoked for `value` and each element of `array` to compute their\nsort ranking. The iteratee is invoked with one argument: (value).",
        "grammar": "lsp",
        "label": "lodash-sortedindexby",
        "matches": {
          "lodash sortedindexby": true
        },
        "options": {}
      },
      {
        "content": "_.sortedIndexOf(${array}, ${value})",
        "doc": "_.sortedIndexOf([4, 5, 5, 5, 6], 5);\n// => 1\n\nThis method is like `_.indexOf` except that it performs a binary\nsearch on a sorted `array`.",
        "grammar": "lsp",
        "label": "lodash-sortedindexof",
        "matches": {
          "lodash sortedindexof": true
        },
        "options": {}
      },
      {
        "content": "_.sortedLastIndex(${array}, ${value})",
        "doc": "_.sortedLastIndex([4, 5, 5, 5, 6], 5);\n// => 4\n\nThis method is like `_.sortedIndex` except that it returns the highest\nindex at which `value` should be inserted into `array` in order to\nmaintain its sort order.",
        "grammar": "lsp",
        "label": "lodash-sortedlastindex",
        "matches": {
          "lodash sortedlastindex": true
        },
        "options": {}
      },
      {
        "content": "_.sortedLastIndexBy(${array}, ${value}, ${iteratee})",
        "doc": "var objects = [{ 'x': 4 }, { 'x': 5 }];\n\n_.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n// => 1\n\n// The `_.property` iteratee shorthand.\n_.sortedLastIndexBy(objects, { 'x': 4 }, 'x');\n// => 1\n\nThis method is like `_.sortedLastIndex` except that it accepts `iteratee`\nwhich is invoked for `value` and each element of `array` to compute their\nsort ranking. The iteratee is invoked with one argument: (value).",
        "grammar": "lsp",
        "label": "lodash-sortedlastindexby",
        "matches": {
          "lodash sortedlastindexby": true
        },
        "options": {}
      },
      {
        "content": "_.sortedLastIndexOf(${array}, ${value})",
        "doc": "_.sortedLastIndexOf([4, 5, 5, 5, 6], 5);\n// => 3\n\nThis method is like `_.lastIndexOf` except that it performs a binary\nsearch on a sorted `array`.",
        "grammar": "lsp",
        "label": "lodash-sortedlastindexof",
        "matches": {
          "lodash sortedlastindexof": true
        },
        "options": {}
      },
      {
        "content": "_.sortedUniq(${array})",
        "doc": "_.sortedUniq([1, 1, 2]);\n// => [1, 2]\n\nThis method is like `_.uniq` except that it's designed and optimized\nfor sorted arrays.",
        "grammar": "lsp",
        "label": "lodash-sorteduniq",
        "matches": {
          "lodash sorteduniq": true
        },
        "options": {}
      },
      {
        "content": "_.sortedUniqBy(${array}, ${iteratee})",
        "doc": "_.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);\n// => [1.1, 2.3]\n\nThis method is like `_.uniqBy` except that it's designed and optimized\nfor sorted arrays.",
        "grammar": "lsp",
        "label": "lodash-sorteduniqby",
        "matches": {
          "lodash sorteduniqby": true
        },
        "options": {}
      },
      {
        "content": "_.tail(${array})",
        "doc": "_.tail([1, 2, 3]);\n// => [2, 3]\n\nGets all but the first element of `array`.",
        "grammar": "lsp",
        "label": "lodash-tail",
        "matches": {
          "lodash tail": true
        },
        "options": {}
      },
      {
        "content": "_.take(${array}, ${n})",
        "doc": "_.take([1, 2, 3]);\n// => [1]\n\n_.take([1, 2, 3], 2);\n// => [1, 2]\n\n_.take([1, 2, 3], 5);\n// => [1, 2, 3]\n\n_.take([1, 2, 3], 0);\n// => []\n\nCreates a slice of `array` with `n` elements taken from the beginning.",
        "grammar": "lsp",
        "label": "lodash-take",
        "matches": {
          "lodash take": true
        },
        "options": {}
      },
      {
        "content": "_.takeRight(${array}, ${n})",
        "doc": "_.takeRight([1, 2, 3]);\n// => [3]\n\n_.takeRight([1, 2, 3], 2);\n// => [2, 3]\n\n_.takeRight([1, 2, 3], 5);\n// => [1, 2, 3]\n\n_.takeRight([1, 2, 3], 0);\n// => []\n\nCreates a slice of `array` with `n` elements taken from the end.",
        "grammar": "lsp",
        "label": "lodash-takeright",
        "matches": {
          "lodash takeright": true
        },
        "options": {}
      },
      {
        "content": "_.takeRightWhile(${array}, ${predicate})",
        "doc": "var users = [\n  { 'user': 'barney',  'active': true },\n  { 'user': 'fred',    'active': false },\n  { 'user': 'pebbles', 'active': false }\n];\n\n_.takeRightWhile(users, function(o) { return !o.active; });\n// => objects for ['fred', 'pebbles']\n\n// The `_.matches` iteratee shorthand.\n_.takeRightWhile(users, { 'user': 'pebbles', 'active': false });\n// => objects for ['pebbles']\n\n// The `_.matchesProperty` iteratee shorthand.\n_.takeRightWhile(users, ['active', false]);\n// => objects for ['fred', 'pebbles']\n\n// The `_.property` iteratee shorthand.\n_.takeRightWhile(users, 'active');\n// => []\n\nCreates a slice of `array` with elements taken from the end. Elements are\ntaken until `predicate` returns falsey. The predicate is invoked with\nthree arguments: (value, index, array).",
        "grammar": "lsp",
        "label": "lodash-takerightwhile",
        "matches": {
          "lodash takerightwhile": true
        },
        "options": {}
      },
      {
        "content": "_.takeWhile(${array}, ${predicate})",
        "doc": "var users = [\n  { 'user': 'barney',  'active': false },\n  { 'user': 'fred',    'active': false },\n  { 'user': 'pebbles', 'active': true }\n];\n\n_.takeWhile(users, function(o) { return !o.active; });\n// => objects for ['barney', 'fred']\n\n// The `_.matches` iteratee shorthand.\n_.takeWhile(users, { 'user': 'barney', 'active': false });\n// => objects for ['barney']\n\n// The `_.matchesProperty` iteratee shorthand.\n_.takeWhile(users, ['active', false]);\n// => objects for ['barney', 'fred']\n\n// The `_.property` iteratee shorthand.\n_.takeWhile(users, 'active');\n// => []\n\nCreates a slice of `array` with elements taken from the beginning. Elements\nare taken until `predicate` returns falsey. The predicate is invoked with\nthree arguments: (value, index, array).",
        "grammar": "lsp",
        "label": "lodash-takewhile",
        "matches": {
          "lodash takewhile": true
        },
        "options": {}
      },
      {
        "content": "_.union(${arrays})",
        "doc": "_.union([2], [1, 2]);\n// => [2, 1]\n\nCreates an array of unique values, in order, from all given arrays using\n[`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\nfor equality comparisons.",
        "grammar": "lsp",
        "label": "lodash-union",
        "matches": {
          "lodash union": true
        },
        "options": {}
      },
      {
        "content": "_.unionBy(${arrays}, ${iteratee})",
        "doc": "_.unionBy([2.1], [1.2, 2.3], Math.floor);\n// => [2.1, 1.2]\n\n// The `_.property` iteratee shorthand.\n_.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n// => [{ 'x': 1 }, { 'x': 2 }]\n\nThis method is like `_.union` except that it accepts `iteratee` which is\ninvoked for each element of each `arrays` to generate the criterion by\nwhich uniqueness is computed. Result values are chosen from the first\narray in which the value occurs. The iteratee is invoked with one argument:\n(value).",
        "grammar": "lsp",
        "label": "lodash-unionby",
        "matches": {
          "lodash unionby": true
        },
        "options": {}
      },
      {
        "content": "_.unionWith(${arrays}, ${comparator})",
        "doc": "var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\nvar others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n\n_.unionWith(objects, others, _.isEqual);\n// => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n\nThis method is like `_.union` except that it accepts `comparator` which\nis invoked to compare elements of `arrays`. Result values are chosen from\nthe first array in which the value occurs. The comparator is invoked\nwith two arguments: (arrVal, othVal).",
        "grammar": "lsp",
        "label": "lodash-unionwith",
        "matches": {
          "lodash unionwith": true
        },
        "options": {}
      },
      {
        "content": "_.uniq(${array})",
        "doc": "_.uniq([2, 1, 2]);\n// => [2, 1]\n\nCreates a duplicate-free version of an array, using\n[`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\nfor equality comparisons, in which only the first occurrence of each element\nis kept. The order of result values is determined by the order they occur\nin the array.",
        "grammar": "lsp",
        "label": "lodash-uniq",
        "matches": {
          "lodash uniq": true
        },
        "options": {}
      },
      {
        "content": "_.uniqBy(${array}, ${iteratee})",
        "doc": "_.uniqBy([2.1, 1.2, 2.3], Math.floor);\n// => [2.1, 1.2]\n\n// The `_.property` iteratee shorthand.\n_.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n// => [{ 'x': 1 }, { 'x': 2 }]\n\nThis method is like `_.uniq` except that it accepts `iteratee` which is\ninvoked for each element in `array` to generate the criterion by which\nuniqueness is computed. The order of result values is determined by the\norder they occur in the array. The iteratee is invoked with one argument:\n(value).",
        "grammar": "lsp",
        "label": "lodash-uniqby",
        "matches": {
          "lodash uniqby": true
        },
        "options": {}
      },
      {
        "content": "_.uniqWith(${array}, ${comparator})",
        "doc": "var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];\n\n_.uniqWith(objects, _.isEqual);\n// => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]\n\nThis method is like `_.uniq` except that it accepts `comparator` which\nis invoked to compare elements of `array`. The order of result values is\ndetermined by the order they occur in the array.The comparator is invoked\nwith two arguments: (arrVal, othVal).",
        "grammar": "lsp",
        "label": "lodash-uniqwith",
        "matches": {
          "lodash uniqwith": true
        },
        "options": {}
      },
      {
        "content": "_.unzip(${array})",
        "doc": "var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);\n// => [['a', 1, true], ['b', 2, false]]\n\n_.unzip(zipped);\n// => [['a', 'b'], [1, 2], [true, false]]\n\nThis method is like `_.zip` except that it accepts an array of grouped\nelements and creates an array regrouping the elements to their pre-zip\nconfiguration.",
        "grammar": "lsp",
        "label": "lodash-unzip",
        "matches": {
          "lodash unzip": true
        },
        "options": {}
      },
      {
        "content": "_.unzipWith(${array}, ${iteratee})",
        "doc": "var zipped = _.zip([1, 2], [10, 20], [100, 200]);\n// => [[1, 10, 100], [2, 20, 200]]\n\n_.unzipWith(zipped, _.add);\n// => [3, 30, 300]\n\nThis method is like `_.unzip` except that it accepts `iteratee` to specify\nhow regrouped values should be combined. The iteratee is invoked with the\nelements of each group: (...group).",
        "grammar": "lsp",
        "label": "lodash-unzipwith",
        "matches": {
          "lodash unzipwith": true
        },
        "options": {}
      },
      {
        "content": "_.without(${array}, ${values})",
        "doc": "_.without([2, 1, 2, 3], 1, 2);\n// => [3]\n\nCreates an array excluding all given values using\n[`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\nfor equality comparisons.\n\n**Note:** Unlike `_.pull`, this method returns a new array.",
        "grammar": "lsp",
        "label": "lodash-without",
        "matches": {
          "lodash without": true
        },
        "options": {}
      },
      {
        "content": "_.xor(${arrays})",
        "doc": "_.xor([2, 1], [2, 3]);\n// => [1, 3]\n\nCreates an array of unique values that is the\n[symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\nof the given arrays. The order of result values is determined by the order\nthey occur in the arrays.",
        "grammar": "lsp",
        "label": "lodash-xor",
        "matches": {
          "lodash xor": true
        },
        "options": {}
      },
      {
        "content": "_.xorBy(${arrays}, ${iteratee})",
        "doc": "_.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n// => [1.2, 3.4]\n\n// The `_.property` iteratee shorthand.\n_.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n// => [{ 'x': 2 }]\n\nThis method is like `_.xor` except that it accepts `iteratee` which is\ninvoked for each element of each `arrays` to generate the criterion by\nwhich by which they're compared. The order of result values is determined\nby the order they occur in the arrays. The iteratee is invoked with one\nargument: (value).",
        "grammar": "lsp",
        "label": "lodash-xorby",
        "matches": {
          "lodash xorby": true
        },
        "options": {}
      },
      {
        "content": "_.xorWith(${arrays}, ${comparator})",
        "doc": "var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\nvar others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n\n_.xorWith(objects, others, _.isEqual);\n// => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n\nThis method is like `_.xor` except that it accepts `comparator` which is\ninvoked to compare elements of `arrays`. The order of result values is\ndetermined by the order they occur in the arrays. The comparator is invoked\nwith two arguments: (arrVal, othVal).",
        "grammar": "lsp",
        "label": "lodash-xorwith",
        "matches": {
          "lodash xorwith": true
        },
        "options": {}
      },
      {
        "content": "_.zip(${arrays})",
        "doc": "_.zip(['a', 'b'], [1, 2], [true, false]);\n// => [['a', 1, true], ['b', 2, false]]\n\nCreates an array of grouped elements, the first of which contains the\nfirst elements of the given arrays, the second of which contains the\nsecond elements of the given arrays, and so on.",
        "grammar": "lsp",
        "label": "lodash-zip",
        "matches": {
          "lodash zip": true
        },
        "options": {}
      },
      {
        "content": "_.zipObject(${props}, ${values})",
        "doc": "_.zipObject(['a', 'b'], [1, 2]);\n// => { 'a': 1, 'b': 2 }\n\nThis method is like `_.fromPairs` except that it accepts two arrays,\none of property identifiers and one of corresponding values.",
        "grammar": "lsp",
        "label": "lodash-zipobject",
        "matches": {
          "lodash zipobject": true
        },
        "options": {}
      },
      {
        "content": "_.zipObjectDeep(${props}, ${values})",
        "doc": "_.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);\n// => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }\n\nThis method is like `_.zipObject` except that it supports property paths.",
        "grammar": "lsp",
        "label": "lodash-zipobjectdeep",
        "matches": {
          "lodash zipobjectdeep": true
        },
        "options": {}
      },
      {
        "content": "_.zipWith(${arrays}, ${iteratee})",
        "doc": "_.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {\n  return a + b + c;\n});\n// => [1, 222]\n\nThis method is like `_.zip` except that it accepts `iteratee` to specify\nhow grouped values should be combined. The iteratee is invoked with the\nelements of each group: (...group).",
        "grammar": "lsp",
        "label": "lodash-zipwith",
        "matches": {
          "lodash zipwith": true
        },
        "options": {}
      },
      {
        "content": "_.chain()",
        "doc": "var users = [\n  { 'user': 'barney', 'age': 36 },\n  { 'user': 'fred',   'age': 40 }\n];\n\n// A sequence without explicit chaining.\n_(users).head();\n// => { 'user': 'barney', 'age': 36 }\n\n// A sequence with explicit chaining.\n_(users)\n  .chain()\n  .head()\n  .pick('user')\n  .value();\n// => { 'user': 'barney' }\n\nCreates a `lodash` wrapper instance with explicit method chain sequences enabled.",
        "grammar": "lsp",
        "label": "lodash-chain",
        "matches": {
          "lodash chain": true
        },
        "options": {}
      },
      {
        "content": "_.tap(${value}, ${interceptor})",
        "doc": "_([1, 2, 3])\n .tap(function(array) {\n   // Mutate input array.\n   array.pop();\n })\n .reverse()\n .value();\n// => [2, 1]\n\nThis method invokes `interceptor` and returns `value`. The interceptor\nis invoked with one argument; (value). The purpose of this method is to\n\"tap into\" a method chain sequence in order to modify intermediate results.",
        "grammar": "lsp",
        "label": "lodash-tap",
        "matches": {
          "lodash tap": true
        },
        "options": {}
      },
      {
        "content": "_.thru(${value}, ${interceptor})",
        "doc": "_('  abc  ')\n .chain()\n .trim()\n .thru(function(value) {\n   return [value];\n })\n .value();\n// => ['abc']\n\nThis method is like `_.tap` except that it returns the result of `interceptor`.\nThe purpose of this method is to \"pass thru\" values replacing intermediate\nresults in a method chain sequence.",
        "grammar": "lsp",
        "label": "lodash-thru",
        "matches": {
          "lodash thru": true
        },
        "options": {}
      },
      {
        "content": "_.at(${object}, ${paths})",
        "doc": "var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n\n_.at(object, ['a[0].b.c', 'a[1]']);\n// => [3, 4]\n\nCreates an array of values corresponding to `paths` of `object`.",
        "grammar": "lsp",
        "label": "lodash-at",
        "matches": {
          "lodash at": true
        },
        "options": {}
      },
      {
        "content": "_.commit()",
        "doc": "var array = [1, 2];\nvar wrapped = _(array).push(3);\n\nconsole.log(array);\n// => [1, 2]\n\nwrapped = wrapped.commit();\nconsole.log(array);\n// => [1, 2, 3]\n\nwrapped.last();\n// => 3\n\nconsole.log(array);\n// => [1, 2, 3]\n\nExecutes the chain sequence and returns the wrapped result.",
        "grammar": "lsp",
        "label": "lodash-commit",
        "matches": {
          "lodash commit": true
        },
        "options": {}
      },
      {
        "content": "_.next()",
        "doc": "var wrapped = _([1, 2]);\n\nwrapped.next();\n// => { 'done': false, 'value': 1 }\n\nwrapped.next();\n// => { 'done': false, 'value': 2 }\n\nwrapped.next();\n// => { 'done': true, 'value': undefined }\n\nGets the next value on a wrapped object following the\n[iterator protocol](https://mdn.io/iteration_protocols#iterator).",
        "grammar": "lsp",
        "label": "lodash-next",
        "matches": {
          "lodash next": true
        },
        "options": {}
      },
      {
        "content": "_.plant(${value})",
        "doc": "function square(n) {\n  return n * n;\n}\n\nvar wrapped = _([1, 2]).map(square);\nvar other = wrapped.plant([3, 4]);\n\nother.value();\n// => [9, 16]\n\nwrapped.value();\n// => [1, 4]\n\nCreates a clone of the chain sequence planting `value` as the wrapped value.",
        "grammar": "lsp",
        "label": "lodash-plant",
        "matches": {
          "lodash plant": true
        },
        "options": {}
      },
      {
        "content": "_.value()",
        "doc": "_([1, 2, 3]).value();\n// => [1, 2, 3]\n\nExecutes the chain sequence to resolve the unwrapped value.",
        "grammar": "lsp",
        "label": "lodash-value",
        "matches": {
          "lodash value": true
        },
        "options": {}
      },
      {
        "content": "_.countBy(${collection}, ${iteratee})",
        "doc": "_.countBy([6.1, 4.2, 6.3], Math.floor);\n// => { '4': 1, '6': 2 }\n\n// The `_.property` iteratee shorthand.\n_.countBy(['one', 'two', 'three'], 'length');\n// => { '3': 2, '5': 1 }\n\nCreates an object composed of keys generated from the results of running\neach element of `collection` thru `iteratee`. The corresponding value of\neach key is the number of times the key was returned by `iteratee`. The\niteratee is invoked with one argument: (value).",
        "grammar": "lsp",
        "label": "lodash-countby",
        "matches": {
          "lodash countby": true
        },
        "options": {}
      },
      {
        "content": "_.every(${collection}, ${predicate})",
        "doc": "_.every([true, 1, null, 'yes'], Boolean);\n// => false\n\nvar users = [\n  { 'user': 'barney', 'age': 36, 'active': false },\n  { 'user': 'fred',   'age': 40, 'active': false }\n];\n\n// The `_.matches` iteratee shorthand.\n_.every(users, { 'user': 'barney', 'active': false });\n// => false\n\n// The `_.matchesProperty` iteratee shorthand.\n_.every(users, ['active', false]);\n// => true\n\n// The `_.property` iteratee shorthand.\n_.every(users, 'active');\n// => false\n\nChecks if `predicate` returns truthy for **all** elements of `collection`.\nIteration is stopped once `predicate` returns falsey. The predicate is\ninvoked with three arguments: (value, index|key, collection).\n\n**Note:** This method returns `true` for\n[empty collections](https://en.wikipedia.org/wiki/Empty_set) because\n[everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\nelements of empty collections.",
        "grammar": "lsp",
        "label": "lodash-every",
        "matches": {
          "lodash every": true
        },
        "options": {}
      },
      {
        "content": "_.filter(${collection}, ${predicate})",
        "doc": "var users = [\n  { 'user': 'barney', 'age': 36, 'active': true },\n  { 'user': 'fred',   'age': 40, 'active': false }\n];\n\n_.filter(users, function(o) { return !o.active; });\n// => objects for ['fred']\n\n// The `_.matches` iteratee shorthand.\n_.filter(users, { 'age': 36, 'active': true });\n// => objects for ['barney']\n\n// The `_.matchesProperty` iteratee shorthand.\n_.filter(users, ['active', false]);\n// => objects for ['fred']\n\n// The `_.property` iteratee shorthand.\n_.filter(users, 'active');\n// => objects for ['barney']\n\nIterates over elements of `collection`, returning an array of all elements\n`predicate` returns truthy for. The predicate is invoked with three\narguments: (value, index|key, collection).\n\n**Note:** Unlike `_.remove`, this method returns a new array.",
        "grammar": "lsp",
        "label": "lodash-filter",
        "matches": {
          "lodash filter": true
        },
        "options": {}
      },
      {
        "content": "_.find(${collection}, ${predicate}, ${fromIndex})",
        "doc": "var users = [\n  { 'user': 'barney',  'age': 36, 'active': true },\n  { 'user': 'fred',    'age': 40, 'active': false },\n  { 'user': 'pebbles', 'age': 1,  'active': true }\n];\n\n_.find(users, function(o) { return o.age < 40; });\n// => object for 'barney'\n\n// The `_.matches` iteratee shorthand.\n_.find(users, { 'age': 1, 'active': true });\n// => object for 'pebbles'\n\n// The `_.matchesProperty` iteratee shorthand.\n_.find(users, ['active', false]);\n// => object for 'fred'\n\n// The `_.property` iteratee shorthand.\n_.find(users, 'active');\n// => object for 'barney'\n\nIterates over elements of `collection`, returning the first element\n`predicate` returns truthy for. The predicate is invoked with three\narguments: (value, index|key, collection).",
        "grammar": "lsp",
        "label": "lodash-find",
        "matches": {
          "lodash find": true
        },
        "options": {}
      },
      {
        "content": "_.findLast(${collection}, ${predicate}, ${fromIndex})",
        "doc": "_.findLast([1, 2, 3, 4], function(n) {\n  return n % 2 == 1;\n});\n// => 3\n\nThis method is like `_.find` except that it iterates over elements of\n`collection` from right to left.",
        "grammar": "lsp",
        "label": "lodash-findlast",
        "matches": {
          "lodash findlast": true
        },
        "options": {}
      },
      {
        "content": "_.flatMap(${collection}, ${iteratee})",
        "doc": "function duplicate(n) {\n  return [n, n];\n}\n\n_.flatMap([1, 2], duplicate);\n// => [1, 1, 2, 2]\n\nCreates a flattened array of values by running each element in `collection`\nthru `iteratee` and flattening the mapped results. The iteratee is invoked\nwith three arguments: (value, index|key, collection).",
        "grammar": "lsp",
        "label": "lodash-flatmap",
        "matches": {
          "lodash flatmap": true
        },
        "options": {}
      },
      {
        "content": "_.flatMapDeep(${collection}, ${iteratee})",
        "doc": "function duplicate(n) {\n  return [[[n, n]]];\n}\n\n_.flatMapDeep([1, 2], duplicate);\n// => [1, 1, 2, 2]\n\nThis method is like `_.flatMap` except that it recursively flattens the\nmapped results.",
        "grammar": "lsp",
        "label": "lodash-flatmapdeep",
        "matches": {
          "lodash flatmapdeep": true
        },
        "options": {}
      },
      {
        "content": "_.flatMapDepth(${collection}, ${iteratee}, ${depth})",
        "doc": "function duplicate(n) {\n  return [[[n, n]]];\n}\n\n_.flatMapDepth([1, 2], duplicate, 2);\n// => [[1, 1], [2, 2]]\n\nThis method is like `_.flatMap` except that it recursively flattens the\nmapped results up to `depth` times.",
        "grammar": "lsp",
        "label": "lodash-flatmapdepth",
        "matches": {
          "lodash flatmapdepth": true
        },
        "options": {}
      },
      {
        "content": "_.each(${collection}, ${iteratee})",
        "doc": "_.forEach([1, 2], function(value) {\n  console.log(value);\n});\n// => Logs `1` then `2`.\n\n_.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n  console.log(key);\n});\n// => Logs 'a' then 'b' (iteration order is not guaranteed).\n\nIterates over elements of `collection` and invokes `iteratee` for each element.\nThe iteratee is invoked with three arguments: (value, index|key, collection).\nIteratee functions may exit iteration early by explicitly returning `false`.\n\n**Note:** As with other \"Collections\" methods, objects with a \"length\"\nproperty are iterated like arrays. To avoid this behavior use `_.forIn`\nor `_.forOwn` for object iteration.",
        "grammar": "lsp",
        "label": "lodash-each",
        "matches": {
          "lodash each": true
        },
        "options": {}
      },
      {
        "content": "_.eachRight(${collection}, ${iteratee})",
        "doc": "_.forEachRight([1, 2], function(value) {\n  console.log(value);\n});\n// => Logs `2` then `1`.\n\nThis method is like `_.forEach` except that it iterates over elements of\n`collection` from right to left.",
        "grammar": "lsp",
        "label": "lodash-eachright",
        "matches": {
          "lodash eachright": true
        },
        "options": {}
      },
      {
        "content": "_.groupBy(${collection}, ${iteratee})",
        "doc": "_.groupBy([6.1, 4.2, 6.3], Math.floor);\n// => { '4': [4.2], '6': [6.1, 6.3] }\n\n// The `_.property` iteratee shorthand.\n_.groupBy(['one', 'two', 'three'], 'length');\n// => { '3': ['one', 'two'], '5': ['three'] }\n\nCreates an object composed of keys generated from the results of running\neach element of `collection` thru `iteratee`. The order of grouped values\nis determined by the order they occur in `collection`. The corresponding\nvalue of each key is an array of elements responsible for generating the\nkey. The iteratee is invoked with one argument: (value).",
        "grammar": "lsp",
        "label": "lodash-groupby",
        "matches": {
          "lodash groupby": true
        },
        "options": {}
      },
      {
        "content": "_.includes(${collection}, ${value}, ${fromIndex})",
        "doc": "_.includes([1, 2, 3], 1);\n// => true\n\n_.includes([1, 2, 3], 1, 2);\n// => false\n\n_.includes({ 'a': 1, 'b': 2 }, 1);\n// => true\n\n_.includes('abcd', 'bc');\n// => true\n\nChecks if `value` is in `collection`. If `collection` is a string, it's\nchecked for a substring of `value`, otherwise\n[`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\nis used for equality comparisons. If `fromIndex` is negative, it's used as\nthe offset from the end of `collection`.",
        "grammar": "lsp",
        "label": "lodash-includes",
        "matches": {
          "lodash includes": true
        },
        "options": {}
      },
      {
        "content": "_.invokeMap(${collection}, ${path}, ${args})",
        "doc": "_.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');\n// => [[1, 5, 7], [1, 2, 3]]\n\n_.invokeMap([123, 456], String.prototype.split, '');\n// => [['1', '2', '3'], ['4', '5', '6']]\n\nInvokes the method at `path` of each element in `collection`, returning\nan array of the results of each invoked method. Any additional arguments\nare provided to each invoked method. If `path` is a function, it's invoked\nfor, and `this` bound to, each element in `collection`.",
        "grammar": "lsp",
        "label": "lodash-invokemap",
        "matches": {
          "lodash invokemap": true
        },
        "options": {}
      },
      {
        "content": "_.keyBy(${collection}, ${iteratee})",
        "doc": "var array = [\n  { 'dir': 'left', 'code': 97 },\n  { 'dir': 'right', 'code': 100 }\n];\n\n_.keyBy(array, function(o) {\n  return String.fromCharCode(o.code);\n});\n// => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n\n_.keyBy(array, 'dir');\n// => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n\nCreates an object composed of keys generated from the results of running\neach element of `collection` thru `iteratee`. The corresponding value of\neach key is the last element responsible for generating the key. The\niteratee is invoked with one argument: (value).",
        "grammar": "lsp",
        "label": "lodash-keyby",
        "matches": {
          "lodash keyby": true
        },
        "options": {}
      },
      {
        "content": "_.map(${collection}, ${iteratee})",
        "doc": "function square(n) {\n  return n * n;\n}\n\n_.map([4, 8], square);\n// => [16, 64]\n\n_.map({ 'a': 4, 'b': 8 }, square);\n// => [16, 64] (iteration order is not guaranteed)\n\nvar users = [\n  { 'user': 'barney' },\n  { 'user': 'fred' }\n];\n\n// The `_.property` iteratee shorthand.\n_.map(users, 'user');\n// => ['barney', 'fred']\n\nCreates an array of values by running each element in `collection` thru\n`iteratee`. The iteratee is invoked with three arguments:\n(value, index|key, collection).\n\nMany lodash methods are guarded to work as iteratees for methods like\n`_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n\nThe guarded methods are:\n`ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n`fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n`sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n`template`, `trim`, `trimEnd`, `trimStart`, and `words`",
        "grammar": "lsp",
        "label": "lodash-map",
        "matches": {
          "lodash map": true
        },
        "options": {}
      },
      {
        "content": "_.orderBy(${collection}, ${iteratees}, ${orders})",
        "doc": "var users = [\n  { 'user': 'fred',   'age': 48 },\n  { 'user': 'barney', 'age': 34 },\n  { 'user': 'fred',   'age': 40 },\n  { 'user': 'barney', 'age': 36 }\n];\n\n// Sort by `user` in ascending order and by `age` in descending order.\n_.orderBy(users, ['user', 'age'], ['asc', 'desc']);\n// => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n\nThis method is like `_.sortBy` except that it allows specifying the sort\norders of the iteratees to sort by. If `orders` is unspecified, all values\nare sorted in ascending order. Otherwise, specify an order of \"desc\" for\ndescending or \"asc\" for ascending sort order of corresponding values.",
        "grammar": "lsp",
        "label": "lodash-orderby",
        "matches": {
          "lodash orderby": true
        },
        "options": {}
      },
      {
        "content": "_.partition(${collection}, ${predicate})",
        "doc": "var users = [\n  { 'user': 'barney',  'age': 36, 'active': false },\n  { 'user': 'fred',    'age': 40, 'active': true },\n  { 'user': 'pebbles', 'age': 1,  'active': false }\n];\n\n_.partition(users, function(o) { return o.active; });\n// => objects for [['fred'], ['barney', 'pebbles']]\n\n// The `_.matches` iteratee shorthand.\n_.partition(users, { 'age': 1, 'active': false });\n// => objects for [['pebbles'], ['barney', 'fred']]\n\n// The `_.matchesProperty` iteratee shorthand.\n_.partition(users, ['active', false]);\n// => objects for [['barney', 'pebbles'], ['fred']]\n\n// The `_.property` iteratee shorthand.\n_.partition(users, 'active');\n// => objects for [['fred'], ['barney', 'pebbles']]\n\nCreates an array of elements split into two groups, the first of which\ncontains elements `predicate` returns truthy for, the second of which\ncontains elements `predicate` returns falsey for. The predicate is\ninvoked with one argument: (value).",
        "grammar": "lsp",
        "label": "lodash-partition",
        "matches": {
          "lodash partition": true
        },
        "options": {}
      },
      {
        "content": "_.reduce(${collection}, ${iteratee}, ${accumulator})",
        "doc": "_.reduce([1, 2], function(sum, n) {\n  return sum + n;\n}, 0);\n// => 3\n\n_.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n  (result[value] || (result[value] = [])).push(key);\n  return result;\n}, {});\n// => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n\nReduces `collection` to a value which is the accumulated result of running\neach element in `collection` thru `iteratee`, where each successive\ninvocation is supplied the return value of the previous. If `accumulator`\nis not given, the first element of `collection` is used as the initial\nvalue. The iteratee is invoked with four arguments:\n(accumulator, value, index|key, collection).\n\nMany lodash methods are guarded to work as iteratees for methods like\n`_.reduce`, `_.reduceRight`, and `_.transform`.\n\nThe guarded methods are:\n`assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\nand `sortBy`",
        "grammar": "lsp",
        "label": "lodash-reduce",
        "matches": {
          "lodash reduce": true
        },
        "options": {}
      },
      {
        "content": "_.reduceRight(${collection}, ${iteratee}, ${accumulator})",
        "doc": "var array = [[0, 1], [2, 3], [4, 5]];\n\n_.reduceRight(array, function(flattened, other) {\n  return flattened.concat(other);\n}, []);\n// => [4, 5, 2, 3, 0, 1]\n\nThis method is like `_.reduce` except that it iterates over elements of\n`collection` from right to left.",
        "grammar": "lsp",
        "label": "lodash-reduceright",
        "matches": {
          "lodash reduceright": true
        },
        "options": {}
      },
      {
        "content": "_.reject(${collection}, ${predicate})",
        "doc": "var users = [\n  { 'user': 'barney', 'age': 36, 'active': false },\n  { 'user': 'fred',   'age': 40, 'active': true }\n];\n\n_.reject(users, function(o) { return !o.active; });\n// => objects for ['fred']\n\n// The `_.matches` iteratee shorthand.\n_.reject(users, { 'age': 40, 'active': true });\n// => objects for ['barney']\n\n// The `_.matchesProperty` iteratee shorthand.\n_.reject(users, ['active', false]);\n// => objects for ['fred']\n\n// The `_.property` iteratee shorthand.\n_.reject(users, 'active');\n// => objects for ['barney']\n\nThe opposite of `_.filter`; this method returns the elements of `collection`\nthat `predicate` does **not** return truthy for.",
        "grammar": "lsp",
        "label": "lodash-reject",
        "matches": {
          "lodash reject": true
        },
        "options": {}
      },
      {
        "content": "_.sample(${collection})",
        "doc": "_.sample([1, 2, 3, 4]);\n// => 2\n\nGets a random element from `collection`.",
        "grammar": "lsp",
        "label": "lodash-sample",
        "matches": {
          "lodash sample": true
        },
        "options": {}
      },
      {
        "content": "_.sampleSize(${collection}, ${n})",
        "doc": "_.sampleSize([1, 2, 3], 2);\n// => [3, 1]\n\n_.sampleSize([1, 2, 3], 4);\n// => [2, 3, 1]\n\nGets `n` random elements at unique keys from `collection` up to the\nsize of `collection`.",
        "grammar": "lsp",
        "label": "lodash-samplesize",
        "matches": {
          "lodash samplesize": true
        },
        "options": {}
      },
      {
        "content": "_.shuffle(${collection})",
        "doc": "_.shuffle([1, 2, 3, 4]);\n// => [4, 1, 3, 2]\n\nCreates an array of shuffled values, using a version of the\n[Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).",
        "grammar": "lsp",
        "label": "lodash-shuffle",
        "matches": {
          "lodash shuffle": true
        },
        "options": {}
      },
      {
        "content": "_.size(${collection})",
        "doc": "_.size([1, 2, 3]);\n// => 3\n\n_.size({ 'a': 1, 'b': 2 });\n// => 2\n\n_.size('pebbles');\n// => 7\n\nGets the size of `collection` by returning its length for array-like\nvalues or the number of own enumerable string keyed properties for objects.",
        "grammar": "lsp",
        "label": "lodash-size",
        "matches": {
          "lodash size": true
        },
        "options": {}
      },
      {
        "content": "_.some(${collection}, ${predicate})",
        "doc": "_.some([null, 0, 'yes', false], Boolean);\n// => true\n\nvar users = [\n  { 'user': 'barney', 'active': true },\n  { 'user': 'fred',   'active': false }\n];\n\n// The `_.matches` iteratee shorthand.\n_.some(users, { 'user': 'barney', 'active': false });\n// => false\n\n// The `_.matchesProperty` iteratee shorthand.\n_.some(users, ['active', false]);\n// => true\n\n// The `_.property` iteratee shorthand.\n_.some(users, 'active');\n// => true\n\nChecks if `predicate` returns truthy for **any** element of `collection`.\nIteration is stopped once `predicate` returns truthy. The predicate is\ninvoked with three arguments: (value, index|key, collection).",
        "grammar": "lsp",
        "label": "lodash-some",
        "matches": {
          "lodash some": true
        },
        "options": {}
      },
      {
        "content": "_.sortBy(${collection}, ${iteratees})",
        "doc": "var users = [\n  { 'user': 'fred',   'age': 48 },\n  { 'user': 'barney', 'age': 36 },\n  { 'user': 'fred',   'age': 40 },\n  { 'user': 'barney', 'age': 34 }\n];\n\n_.sortBy(users, [function(o) { return o.user; }]);\n// => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n\n_.sortBy(users, ['user', 'age']);\n// => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]\n\nCreates an array of elements, sorted in ascending order by the results of\nrunning each element in a collection thru each iteratee. This method\nperforms a stable sort, that is, it preserves the original sort order of\nequal elements. The iteratees are invoked with one argument: (value).",
        "grammar": "lsp",
        "label": "lodash-sortby",
        "matches": {
          "lodash sortby": true
        },
        "options": {}
      },
      {
        "content": "_.now()",
        "doc": "_.defer(function(stamp) {\n  console.log(_.now() - stamp);\n}, _.now());\n// => Logs the number of milliseconds it took for the deferred invocation.\n\nGets the timestamp of the number of milliseconds that have elapsed since\nthe Unix epoch (1 January 1970 00:00:00 UTC).",
        "grammar": "lsp",
        "label": "lodash-now",
        "matches": {
          "lodash now": true
        },
        "options": {}
      },
      {
        "content": "_.after(${n}, ${func})",
        "doc": "var saves = ['profile', 'settings'];\n\nvar done = _.after(saves.length, function() {\n  console.log('done saving!');\n});\n\n_.forEach(saves, function(type) {\n  asyncSave({ 'type': type, 'complete': done });\n});\n// => Logs 'done saving!' after the two async saves have completed.\n\nThe opposite of `_.before`; this method creates a function that invokes\n`func` once it's called `n` or more times.",
        "grammar": "lsp",
        "label": "lodash-after",
        "matches": {
          "lodash after": true
        },
        "options": {}
      },
      {
        "content": "_.ary(${func}, ${n})",
        "doc": "_.map(['6', '8', '10'], _.ary(parseInt, 1));\n// => [6, 8, 10]\n\nCreates a function that invokes `func`, with up to `n` arguments,\nignoring any additional arguments.",
        "grammar": "lsp",
        "label": "lodash-ary",
        "matches": {
          "lodash ary": true
        },
        "options": {}
      },
      {
        "content": "_.before(${n}, ${func})",
        "doc": "jQuery(element).on('click', _.before(5, addContactToList));\n// => Allows adding up to 4 contacts to the list.\n\nCreates a function that invokes `func`, with the `this` binding and arguments\nof the created function, while it's called less than `n` times. Subsequent\ncalls to the created function return the result of the last `func` invocation.",
        "grammar": "lsp",
        "label": "lodash-before",
        "matches": {
          "lodash before": true
        },
        "options": {}
      },
      {
        "content": "_.bind(${func}, ${thisArg}, ${partials})",
        "doc": "function greet(greeting, punctuation) {\n  return greeting + ' ' + this.user + punctuation;\n}\n\nvar object = { 'user': 'fred' };\n\nvar bound = _.bind(greet, object, 'hi');\nbound('!');\n// => 'hi fred!'\n\n// Bound with placeholders.\nvar bound = _.bind(greet, object, _, '!');\nbound('hi');\n// => 'hi fred!'\n\nCreates a function that invokes `func` with the `this` binding of `thisArg`\nand `partials` prepended to the arguments it receives.\n\nThe `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\nmay be used as a placeholder for partially applied arguments.\n\n**Note:** Unlike native `Function#bind`, this method doesn't set the \"length\"\nproperty of bound functions.",
        "grammar": "lsp",
        "label": "lodash-bind",
        "matches": {
          "lodash bind": true
        },
        "options": {}
      },
      {
        "content": "_.bindKey(${object}, ${key}, ${partials})",
        "doc": "var object = {\n  'user': 'fred',\n  'greet': function(greeting, punctuation) {\n    return greeting + ' ' + this.user + punctuation;\n  }\n};\n\nvar bound = _.bindKey(object, 'greet', 'hi');\nbound('!');\n// => 'hi fred!'\n\nobject.greet = function(greeting, punctuation) {\n  return greeting + 'ya ' + this.user + punctuation;\n};\n\nbound('!');\n// => 'hiya fred!'\n\n// Bound with placeholders.\nvar bound = _.bindKey(object, 'greet', _, '!');\nbound('hi');\n// => 'hiya fred!'\n\nCreates a function that invokes the method at `object[key]` with `partials`\nprepended to the arguments it receives.\n\nThis method differs from `_.bind` by allowing bound functions to reference\nmethods that may be redefined or don't yet exist. See\n[Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)\nfor more details.\n\nThe `_.bindKey.placeholder` value, which defaults to `_` in monolithic\nbuilds, may be used as a placeholder for partially applied arguments.",
        "grammar": "lsp",
        "label": "lodash-bindkey",
        "matches": {
          "lodash bindkey": true
        },
        "options": {}
      },
      {
        "content": "_.curry(${func}, ${arity})",
        "doc": "var abc = function(a, b, c) {\n  return [a, b, c];\n};\n\nvar curried = _.curry(abc);\n\ncurried(1)(2)(3);\n// => [1, 2, 3]\n\ncurried(1, 2)(3);\n// => [1, 2, 3]\n\ncurried(1, 2, 3);\n// => [1, 2, 3]\n\n// Curried with placeholders.\ncurried(1)(_, 3)(2);\n// => [1, 2, 3]\n\nCreates a function that accepts arguments of `func` and either invokes\n`func` returning its result, if at least `arity` number of arguments have\nbeen provided, or returns a function that accepts the remaining `func`\narguments, and so on. The arity of `func` may be specified if `func.length`\nis not sufficient.\n\nThe `_.curry.placeholder` value, which defaults to `_` in monolithic builds,\nmay be used as a placeholder for provided arguments.\n\n**Note:** This method doesn't set the \"length\" property of curried functions.",
        "grammar": "lsp",
        "label": "lodash-curry",
        "matches": {
          "lodash curry": true
        },
        "options": {}
      },
      {
        "content": "_.curryRight(${func}, ${arity})",
        "doc": "var abc = function(a, b, c) {\n  return [a, b, c];\n};\n\nvar curried = _.curryRight(abc);\n\ncurried(3)(2)(1);\n// => [1, 2, 3]\n\ncurried(2, 3)(1);\n// => [1, 2, 3]\n\ncurried(1, 2, 3);\n// => [1, 2, 3]\n\n// Curried with placeholders.\ncurried(3)(1, _)(2);\n// => [1, 2, 3]\n\nThis method is like `_.curry` except that arguments are applied to `func`\nin the manner of `_.partialRight` instead of `_.partial`.\n\nThe `_.curryRight.placeholder` value, which defaults to `_` in monolithic\nbuilds, may be used as a placeholder for provided arguments.\n\n**Note:** This method doesn't set the \"length\" property of curried functions.",
        "grammar": "lsp",
        "label": "lodash-curryright",
        "matches": {
          "lodash curryright": true
        },
        "options": {}
      },
      {
        "content": "_.defer(${func}, ${args})",
        "doc": "_.defer(function(text) {\n  console.log(text);\n}, 'deferred');\n// => Logs 'deferred' after one millisecond.\n\nDefers invoking the `func` until the current call stack has cleared. Any\nadditional arguments are provided to `func` when it's invoked.",
        "grammar": "lsp",
        "label": "lodash-defer",
        "matches": {
          "lodash defer": true
        },
        "options": {}
      },
      {
        "content": "_.delay(${func}, ${wait}, ${args})",
        "doc": "_.delay(function(text) {\n  console.log(text);\n}, 1000, 'later');\n// => Logs 'later' after one second.\n\nInvokes `func` after `wait` milliseconds. Any additional arguments are\nprovided to `func` when it's invoked.",
        "grammar": "lsp",
        "label": "lodash-delay",
        "matches": {
          "lodash delay": true
        },
        "options": {}
      },
      {
        "content": "_.flip(${func})",
        "doc": "var flipped = _.flip(function() {\n  return _.toArray(arguments);\n});\n\nflipped('a', 'b', 'c', 'd');\n// => ['d', 'c', 'b', 'a']\n\nCreates a function that invokes `func` with arguments reversed.",
        "grammar": "lsp",
        "label": "lodash-flip",
        "matches": {
          "lodash flip": true
        },
        "options": {}
      },
      {
        "content": "_.memoize(${func}, ${resolver})",
        "doc": "var object = { 'a': 1, 'b': 2 };\nvar other = { 'c': 3, 'd': 4 };\n\nvar values = _.memoize(_.values);\nvalues(object);\n// => [1, 2]\n\nvalues(other);\n// => [3, 4]\n\nobject.a = 2;\nvalues(object);\n// => [1, 2]\n\n// Modify the result cache.\nvalues.cache.set(object, ['a', 'b']);\nvalues(object);\n// => ['a', 'b']\n\n// Replace `_.memoize.Cache`.\n_.memoize.Cache = WeakMap;\n\nCreates a function that memoizes the result of `func`. If `resolver` is\nprovided, it determines the cache key for storing the result based on the\narguments provided to the memoized function. By default, the first argument\nprovided to the memoized function is used as the map cache key. The `func`\nis invoked with the `this` binding of the memoized function.\n\n**Note:** The cache is exposed as the `cache` property on the memoized\nfunction. Its creation may be customized by replacing the `_.memoize.Cache`\nconstructor with one whose instances implement the\n[`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\nmethod interface of `clear`, `delete`, `get`, `has`, and `set`.",
        "grammar": "lsp",
        "label": "lodash-memoize",
        "matches": {
          "lodash memoize": true
        },
        "options": {}
      },
      {
        "content": "_.negate(${predicate})",
        "doc": "function isEven(n) {\n  return n % 2 == 0;\n}\n\n_.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n// => [1, 3, 5]\n\nCreates a function that negates the result of the predicate `func`. The\n`func` predicate is invoked with the `this` binding and arguments of the\ncreated function.",
        "grammar": "lsp",
        "label": "lodash-negate",
        "matches": {
          "lodash negate": true
        },
        "options": {}
      },
      {
        "content": "_.once(${func})",
        "doc": "var initialize = _.once(createApplication);\ninitialize();\ninitialize();\n// => `createApplication` is invoked once\n\nCreates a function that is restricted to invoking `func` once. Repeat calls\nto the function return the value of the first invocation. The `func` is\ninvoked with the `this` binding and arguments of the created function.",
        "grammar": "lsp",
        "label": "lodash-once",
        "matches": {
          "lodash once": true
        },
        "options": {}
      },
      {
        "content": "_.overArgs(${func}, ${transforms})",
        "doc": "function doubled(n) {\n  return n * 2;\n}\n\nfunction square(n) {\n  return n * n;\n}\n\nvar func = _.overArgs(function(x, y) {\n  return [x, y];\n}, [square, doubled]);\n\nfunc(9, 3);\n// => [81, 6]\n\nfunc(10, 5);\n// => [100, 10]\n\nCreates a function that invokes `func` with its arguments transformed.",
        "grammar": "lsp",
        "label": "lodash-overargs",
        "matches": {
          "lodash overargs": true
        },
        "options": {}
      },
      {
        "content": "_.partial(${func}, ${partials})",
        "doc": "function greet(greeting, name) {\n  return greeting + ' ' + name;\n}\n\nvar sayHelloTo = _.partial(greet, 'hello');\nsayHelloTo('fred');\n// => 'hello fred'\n\n// Partially applied with placeholders.\nvar greetFred = _.partial(greet, _, 'fred');\ngreetFred('hi');\n// => 'hi fred'\n\nCreates a function that invokes `func` with `partials` prepended to the\narguments it receives. This method is like `_.bind` except it does **not**\nalter the `this` binding.\n\nThe `_.partial.placeholder` value, which defaults to `_` in monolithic\nbuilds, may be used as a placeholder for partially applied arguments.\n\n**Note:** This method doesn't set the \"length\" property of partially\napplied functions.",
        "grammar": "lsp",
        "label": "lodash-partial",
        "matches": {
          "lodash partial": true
        },
        "options": {}
      },
      {
        "content": "_.partialRight(${func}, ${partials})",
        "doc": "function greet(greeting, name) {\n  return greeting + ' ' + name;\n}\n\nvar greetFred = _.partialRight(greet, 'fred');\ngreetFred('hi');\n// => 'hi fred'\n\n// Partially applied with placeholders.\nvar sayHelloTo = _.partialRight(greet, 'hello', _);\nsayHelloTo('fred');\n// => 'hello fred'\n\nThis method is like `_.partial` except that partially applied arguments\nare appended to the arguments it receives.\n\nThe `_.partialRight.placeholder` value, which defaults to `_` in monolithic\nbuilds, may be used as a placeholder for partially applied arguments.\n\n**Note:** This method doesn't set the \"length\" property of partially\napplied functions.",
        "grammar": "lsp",
        "label": "lodash-partialright",
        "matches": {
          "lodash partialright": true
        },
        "options": {}
      },
      {
        "content": "_.rearg(${func}, ${indexes})",
        "doc": "var rearged = _.rearg(function(a, b, c) {\n  return [a, b, c];\n}, [2, 0, 1]);\n\nrearged('b', 'c', 'a')\n// => ['a', 'b', 'c']\n\nCreates a function that invokes `func` with arguments arranged according\nto the specified `indexes` where the argument value at the first index is\nprovided as the first argument, the argument value at the second index is\nprovided as the second argument, and so on.",
        "grammar": "lsp",
        "label": "lodash-rearg",
        "matches": {
          "lodash rearg": true
        },
        "options": {}
      },
      {
        "content": "_.rest(${func}, ${start})",
        "doc": "var say = _.rest(function(what, names) {\n  return what + ' ' + _.initial(names).join(', ') +\n    (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n});\n\nsay('hello', 'fred', 'barney', 'pebbles');\n// => 'hello fred, barney, & pebbles'\n\nCreates a function that invokes `func` with the `this` binding of the\ncreated function and arguments from `start` and beyond provided as\nan array.\n\n**Note:** This method is based on the\n[rest parameter](https://mdn.io/rest_parameters).",
        "grammar": "lsp",
        "label": "lodash-rest",
        "matches": {
          "lodash rest": true
        },
        "options": {}
      },
      {
        "content": "_.spread(${func}, ${start})",
        "doc": "var say = _.spread(function(who, what) {\n  return who + ' says ' + what;\n});\n\nsay(['fred', 'hello']);\n// => 'fred says hello'\n\nvar numbers = Promise.all([\n  Promise.resolve(40),\n  Promise.resolve(36)\n]);\n\nnumbers.then(_.spread(function(x, y) {\n  return x + y;\n}));\n// => a Promise of 76\n\nCreates a function that invokes `func` with the `this` binding of the\ncreate function and an array of arguments much like\n[`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).\n\n**Note:** This method is based on the\n[spread operator](https://mdn.io/spread_operator).",
        "grammar": "lsp",
        "label": "lodash-spread",
        "matches": {
          "lodash spread": true
        },
        "options": {}
      },
      {
        "content": "_.unary(${func})",
        "doc": "_.map(['6', '8', '10'], _.unary(parseInt));\n// => [6, 8, 10]\n\nCreates a function that accepts up to one argument, ignoring any\nadditional arguments.",
        "grammar": "lsp",
        "label": "lodash-unary",
        "matches": {
          "lodash unary": true
        },
        "options": {}
      },
      {
        "content": "_.wrap(${value}, ${wrapper})",
        "doc": "var p = _.wrap(_.escape, function(func, text) {\n  return '<p>' + func(text) + '</p>';\n});\n\np('fred, barney, & pebbles');\n// => '<p>fred, barney, &amp; pebbles</p>'\n\nCreates a function that provides `value` to `wrapper` as its first\nargument. Any additional arguments provided to the function are appended\nto those provided to the `wrapper`. The wrapper is invoked with the `this`\nbinding of the created function.",
        "grammar": "lsp",
        "label": "lodash-wrap",
        "matches": {
          "lodash wrap": true
        },
        "options": {}
      },
      {
        "content": "_.castArray(${value})",
        "doc": "_.castArray(1);\n// => [1]\n\n_.castArray({ 'a': 1 });\n// => [{ 'a': 1 }]\n\n_.castArray('abc');\n// => ['abc']\n\n_.castArray(null);\n// => [null]\n\n_.castArray(undefined);\n// => [undefined]\n\n_.castArray();\n// => []\n\nvar array = [1, 2, 3];\nconsole.log(_.castArray(array) === array);\n// => true\n\nCasts `value` as an array if it's not one.",
        "grammar": "lsp",
        "label": "lodash-castarray",
        "matches": {
          "lodash castarray": true
        },
        "options": {}
      },
      {
        "content": "_.clone(${value})",
        "doc": "var objects = [{ 'a': 1 }, { 'b': 2 }];\n\nvar shallow = _.clone(objects);\nconsole.log(shallow[0] === objects[0]);\n// => true\n\nCreates a shallow clone of `value`.\n\n**Note:** This method is loosely based on the\n[structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\nand supports cloning arrays, array buffers, booleans, date objects, maps,\nnumbers, `Object` objects, regexes, sets, strings, symbols, and typed\narrays. The own enumerable properties of `arguments` objects are cloned\nas plain objects. An empty object is returned for uncloneable values such\nas error objects, functions, DOM nodes, and WeakMaps.",
        "grammar": "lsp",
        "label": "lodash-clone",
        "matches": {
          "lodash clone": true
        },
        "options": {}
      },
      {
        "content": "_.cloneWith(${value}, ${customizer})",
        "doc": "function customizer(value) {\n  if (_.isElement(value)) {\n    return value.cloneNode(false);\n  }\n}\n\nvar el = _.cloneWith(document.body, customizer);\n\nconsole.log(el === document.body);\n// => false\nconsole.log(el.nodeName);\n// => 'BODY'\nconsole.log(el.childNodes.length);\n// => 0\n\nThis method is like `_.clone` except that it accepts `customizer` which\nis invoked to produce the cloned value. If `customizer` returns `undefined`,\ncloning is handled by the method instead. The `customizer` is invoked with\nup to four arguments; (value [, index|key, object, stack]).",
        "grammar": "lsp",
        "label": "lodash-clonewith",
        "matches": {
          "lodash clonewith": true
        },
        "options": {}
      },
      {
        "content": "_.cloneDeep(${value})",
        "doc": "var objects = [{ 'a': 1 }, { 'b': 2 }];\n\nvar deep = _.cloneDeep(objects);\nconsole.log(deep[0] === objects[0]);\n// => false\n\nThis method is like `_.clone` except that it recursively clones `value`.",
        "grammar": "lsp",
        "label": "lodash-clonedeep",
        "matches": {
          "lodash clonedeep": true
        },
        "options": {}
      },
      {
        "content": "_.cloneDeepWith(${value}, ${customizer})",
        "doc": "function customizer(value) {\n  if (_.isElement(value)) {\n    return value.cloneNode(true);\n  }\n}\n\nvar el = _.cloneDeepWith(document.body, customizer);\n\nconsole.log(el === document.body);\n// => false\nconsole.log(el.nodeName);\n// => 'BODY'\nconsole.log(el.childNodes.length);\n// => 20\n\nThis method is like `_.cloneWith` except that it recursively clones `value`.",
        "grammar": "lsp",
        "label": "lodash-clonedeepwith",
        "matches": {
          "lodash clonedeepwith": true
        },
        "options": {}
      },
      {
        "content": "_.conformsTo(${object}, ${source})",
        "doc": "var object = { 'a': 1, 'b': 2 };\n\n_.conformsTo(object, { 'b': function(n) { return n > 1; } });\n// => true\n\n_.conformsTo(object, { 'b': function(n) { return n > 2; } });\n// => false\n\nChecks if `object` conforms to `source` by invoking the predicate\nproperties of `source` with the corresponding property values of `object`.\n\n**Note:** This method is equivalent to `_.conforms` when `source` is\npartially applied.",
        "grammar": "lsp",
        "label": "lodash-conformsto",
        "matches": {
          "lodash conformsto": true
        },
        "options": {}
      },
      {
        "content": "_.eq(${value}, ${other})",
        "doc": "var object = { 'a': 1 };\nvar other = { 'a': 1 };\n\n_.eq(object, object);\n// => true\n\n_.eq(object, other);\n// => false\n\n_.eq('a', 'a');\n// => true\n\n_.eq('a', Object('a'));\n// => false\n\n_.eq(NaN, NaN);\n// => true\n\nPerforms a\n[`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\ncomparison between two values to determine if they are equivalent.",
        "grammar": "lsp",
        "label": "lodash-eq",
        "matches": {
          "lodash eq": true
        },
        "options": {}
      },
      {
        "content": "_.gt(${value}, ${other})",
        "doc": "_.gt(3, 1);\n// => true\n\n_.gt(3, 3);\n// => false\n\n_.gt(1, 3);\n// => false\n\nChecks if `value` is greater than `other`.",
        "grammar": "lsp",
        "label": "lodash-gt",
        "matches": {
          "lodash gt": true
        },
        "options": {}
      },
      {
        "content": "_.gte(${value}, ${other})",
        "doc": "_.gte(3, 1);\n// => true\n\n_.gte(3, 3);\n// => true\n\n_.gte(1, 3);\n// => false\n\nChecks if `value` is greater than or equal to `other`.",
        "grammar": "lsp",
        "label": "lodash-gte",
        "matches": {
          "lodash gte": true
        },
        "options": {}
      },
      {
        "content": "_.isArguments(${value})",
        "doc": "_.isArguments(function() { return arguments; }());\n// => true\n\n_.isArguments([1, 2, 3]);\n// => false\n\nChecks if `value` is likely an `arguments` object.",
        "grammar": "lsp",
        "label": "lodash-isarguments",
        "matches": {
          "lodash isarguments": true
        },
        "options": {}
      },
      {
        "content": "_.isArray(${value})",
        "doc": "_.isArray([1, 2, 3]);\n// => true\n\n_.isArray(document.body.children);\n// => false\n\n_.isArray('abc');\n// => false\n\n_.isArray(_.noop);\n// => false\n\nChecks if `value` is classified as an `Array` object.",
        "grammar": "lsp",
        "label": "lodash-isarray",
        "matches": {
          "lodash isarray": true
        },
        "options": {}
      },
      {
        "content": "_.isArrayBuffer(${value})",
        "doc": "_.isArrayBuffer(new ArrayBuffer(2));\n// => true\n\n_.isArrayBuffer(new Array(2));\n// => false\n\nChecks if `value` is classified as an `ArrayBuffer` object.",
        "grammar": "lsp",
        "label": "lodash-isarraybuffer",
        "matches": {
          "lodash isarraybuffer": true
        },
        "options": {}
      },
      {
        "content": "_.isArrayLike(${value})",
        "doc": "_.isArrayLike([1, 2, 3]);\n// => true\n\n_.isArrayLike(document.body.children);\n// => true\n\n_.isArrayLike('abc');\n// => true\n\n_.isArrayLike(_.noop);\n// => false\n\nChecks if `value` is array-like. A value is considered array-like if it's\nnot a function and has a `value.length` that's an integer greater than or\nequal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.",
        "grammar": "lsp",
        "label": "lodash-isarraylike",
        "matches": {
          "lodash isarraylike": true
        },
        "options": {}
      },
      {
        "content": "_.isArrayLikeObject(${value})",
        "doc": "_.isArrayLikeObject([1, 2, 3]);\n// => true\n\n_.isArrayLikeObject(document.body.children);\n// => true\n\n_.isArrayLikeObject('abc');\n// => false\n\n_.isArrayLikeObject(_.noop);\n// => false\n\nThis method is like `_.isArrayLike` except that it also checks if `value`\nis an object.",
        "grammar": "lsp",
        "label": "lodash-isarraylikeobject",
        "matches": {
          "lodash isarraylikeobject": true
        },
        "options": {}
      },
      {
        "content": "_.isBoolean(${value})",
        "doc": "_.isBoolean(false);\n// => true\n\n_.isBoolean(null);\n// => false\n\nChecks if `value` is classified as a boolean primitive or object.",
        "grammar": "lsp",
        "label": "lodash-isboolean",
        "matches": {
          "lodash isboolean": true
        },
        "options": {}
      },
      {
        "content": "_.isBuffer(${value})",
        "doc": "_.isBuffer(new Buffer(2));\n// => true\n\n_.isBuffer(new Uint8Array(2));\n// => false\n\nChecks if `value` is a buffer.",
        "grammar": "lsp",
        "label": "lodash-isbuffer",
        "matches": {
          "lodash isbuffer": true
        },
        "options": {}
      },
      {
        "content": "_.isDate(${value})",
        "doc": "_.isDate(new Date);\n// => true\n\n_.isDate('Mon April 23 2012');\n// => false\n\nChecks if `value` is classified as a `Date` object.",
        "grammar": "lsp",
        "label": "lodash-isdate",
        "matches": {
          "lodash isdate": true
        },
        "options": {}
      },
      {
        "content": "_.isElement(${value})",
        "doc": "_.isElement(document.body);\n// => true\n\n_.isElement('<body>');\n// => false\n\nChecks if `value` is likely a DOM element.",
        "grammar": "lsp",
        "label": "lodash-iselement",
        "matches": {
          "lodash iselement": true
        },
        "options": {}
      },
      {
        "content": "_.isEmpty(${value})",
        "doc": "_.isEmpty(null);\n// => true\n\n_.isEmpty(true);\n// => true\n\n_.isEmpty(1);\n// => true\n\n_.isEmpty([1, 2, 3]);\n// => false\n\n_.isEmpty({ 'a': 1 });\n// => false\n\nChecks if `value` is an empty object, collection, map, or set.\n\nObjects are considered empty if they have no own enumerable string keyed\nproperties.\n\nArray-like values such as `arguments` objects, arrays, buffers, strings, or\njQuery-like collections are considered empty if they have a `length` of `0`.\nSimilarly, maps and sets are considered empty if they have a `size` of `0`.",
        "grammar": "lsp",
        "label": "lodash-isempty",
        "matches": {
          "lodash isempty": true
        },
        "options": {}
      },
      {
        "content": "_.isEqual(${value}, ${other})",
        "doc": "var object = { 'a': 1 };\nvar other = { 'a': 1 };\n\n_.isEqual(object, other);\n// => true\n\nobject === other;\n// => false\n\nPerforms a deep comparison between two values to determine if they are\nequivalent.\n\n**Note:** This method supports comparing arrays, array buffers, booleans,\ndate objects, error objects, maps, numbers, `Object` objects, regexes,\nsets, strings, symbols, and typed arrays. `Object` objects are compared\nby their own, not inherited, enumerable properties. Functions and DOM\nnodes are compared by strict equality, i.e. `===`.",
        "grammar": "lsp",
        "label": "lodash-isequal",
        "matches": {
          "lodash isequal": true
        },
        "options": {}
      },
      {
        "content": "_.isEqualWith(${value}, ${other}, ${customizer})",
        "doc": "function isGreeting(value) {\n  return /^h(?:i|ello)$/.test(value);\n}\n\nfunction customizer(objValue, othValue) {\n  if (isGreeting(objValue) && isGreeting(othValue)) {\n    return true;\n  }\n}\n\nvar array = ['hello', 'goodbye'];\nvar other = ['hi', 'goodbye'];\n\n_.isEqualWith(array, other, customizer);\n// => true\n\nThis method is like `_.isEqual` except that it accepts `customizer` which\nis invoked to compare values. If `customizer` returns `undefined`, comparisons\nare handled by the method instead. The `customizer` is invoked with up to\nsix arguments: (objValue, othValue [, index|key, object, other, stack]).",
        "grammar": "lsp",
        "label": "lodash-isequalwith",
        "matches": {
          "lodash isequalwith": true
        },
        "options": {}
      },
      {
        "content": "_.isError(${value})",
        "doc": "_.isError(new Error);\n// => true\n\n_.isError(Error);\n// => false\n\nChecks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\n`SyntaxError`, `TypeError`, or `URIError` object.",
        "grammar": "lsp",
        "label": "lodash-iserror",
        "matches": {
          "lodash iserror": true
        },
        "options": {}
      },
      {
        "content": "_.isFinite(${value})",
        "doc": "_.isFinite(3);\n// => true\n\n_.isFinite(Number.MIN_VALUE);\n// => true\n\n_.isFinite(Infinity);\n// => false\n\n_.isFinite('3');\n// => false\n\nChecks if `value` is a finite primitive number.\n\n**Note:** This method is based on\n[`Number.isFinite`](https://mdn.io/Number/isFinite).",
        "grammar": "lsp",
        "label": "lodash-isfinite",
        "matches": {
          "lodash isfinite": true
        },
        "options": {}
      },
      {
        "content": "_.isFunction(${value})",
        "doc": "_.isFunction(_);\n// => true\n\n_.isFunction(/abc/);\n// => false\n\nChecks if `value` is classified as a `Function` object.",
        "grammar": "lsp",
        "label": "lodash-isfunction",
        "matches": {
          "lodash isfunction": true
        },
        "options": {}
      },
      {
        "content": "_.isInteger(${value})",
        "doc": "_.isInteger(3);\n// => true\n\n_.isInteger(Number.MIN_VALUE);\n// => false\n\n_.isInteger(Infinity);\n// => false\n\n_.isInteger('3');\n// => false\n\nChecks if `value` is an integer.\n\n**Note:** This method is based on\n[`Number.isInteger`](https://mdn.io/Number/isInteger).",
        "grammar": "lsp",
        "label": "lodash-isinteger",
        "matches": {
          "lodash isinteger": true
        },
        "options": {}
      },
      {
        "content": "_.isLength(${value})",
        "doc": "_.isLength(3);\n// => true\n\n_.isLength(Number.MIN_VALUE);\n// => false\n\n_.isLength(Infinity);\n// => false\n\n_.isLength('3');\n// => false\n\nChecks if `value` is a valid array-like length.\n\n**Note:** This method is loosely based on\n[`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).",
        "grammar": "lsp",
        "label": "lodash-islength",
        "matches": {
          "lodash islength": true
        },
        "options": {}
      },
      {
        "content": "_.isObject(${value})",
        "doc": "_.isObject({});\n// => true\n\n_.isObject([1, 2, 3]);\n// => true\n\n_.isObject(_.noop);\n// => true\n\n_.isObject(null);\n// => false\n\nChecks if `value` is the\n[language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\nof `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)",
        "grammar": "lsp",
        "label": "lodash-isobject",
        "matches": {
          "lodash isobject": true
        },
        "options": {}
      },
      {
        "content": "_.isObjectLike(${value})",
        "doc": "_.isObjectLike({});\n// => true\n\n_.isObjectLike([1, 2, 3]);\n// => true\n\n_.isObjectLike(_.noop);\n// => false\n\n_.isObjectLike(null);\n// => false\n\nChecks if `value` is object-like. A value is object-like if it's not `null`\nand has a `typeof` result of \"object\".",
        "grammar": "lsp",
        "label": "lodash-isobjectlike",
        "matches": {
          "lodash isobjectlike": true
        },
        "options": {}
      },
      {
        "content": "_.isMap(${value})",
        "doc": "_.isMap(new Map);\n// => true\n\n_.isMap(new WeakMap);\n// => false\n\nChecks if `value` is classified as a `Map` object.",
        "grammar": "lsp",
        "label": "lodash-ismap",
        "matches": {
          "lodash ismap": true
        },
        "options": {}
      },
      {
        "content": "_.isMatch(${object}, ${source})",
        "doc": "var object = { 'a': 1, 'b': 2 };\n\n_.isMatch(object, { 'b': 2 });\n// => true\n\n_.isMatch(object, { 'b': 1 });\n// => false\n\nPerforms a partial deep comparison between `object` and `source` to\ndetermine if `object` contains equivalent property values.\n\n**Note:** This method is equivalent to `_.matches` when `source` is\npartially applied.\n\nPartial comparisons will match empty array and empty object `source`\nvalues against any array or object value, respectively. See `_.isEqual`\nfor a list of supported value comparisons.",
        "grammar": "lsp",
        "label": "lodash-ismatch",
        "matches": {
          "lodash ismatch": true
        },
        "options": {}
      },
      {
        "content": "_.isMatchWith(${object}, ${source}, ${customizer})",
        "doc": "function isGreeting(value) {\n  return /^h(?:i|ello)$/.test(value);\n}\n\nfunction customizer(objValue, srcValue) {\n  if (isGreeting(objValue) && isGreeting(srcValue)) {\n    return true;\n  }\n}\n\nvar object = { 'greeting': 'hello' };\nvar source = { 'greeting': 'hi' };\n\n_.isMatchWith(object, source, customizer);\n// => true\n\nThis method is like `_.isMatch` except that it accepts `customizer` which\nis invoked to compare values. If `customizer` returns `undefined`, comparisons\nare handled by the method instead. The `customizer` is invoked with five\narguments: (objValue, srcValue, index|key, object, source).",
        "grammar": "lsp",
        "label": "lodash-ismatchwith",
        "matches": {
          "lodash ismatchwith": true
        },
        "options": {}
      },
      {
        "content": "_.isNaN(${value})",
        "doc": "_.isNaN(NaN);\n// => true\n\n_.isNaN(new Number(NaN));\n// => true\n\nisNaN(undefined);\n// => true\n\n_.isNaN(undefined);\n// => false\n\nChecks if `value` is `NaN`.\n\n**Note:** This method is based on\n[`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as\nglobal [`isNaN`](https://mdn.io/isNaN) which returns `true` for\n`undefined` and other non-number values.",
        "grammar": "lsp",
        "label": "lodash-isnan",
        "matches": {
          "lodash isnan": true
        },
        "options": {}
      },
      {
        "content": "_.isNative(${value})",
        "doc": "_.isNative(Array.prototype.push);\n// => true\n\n_.isNative(_);\n// => false\n\nChecks if `value` is a pristine native function.\n\n**Note:** This method can't reliably detect native functions in the presence\nof the core-js package because core-js circumvents this kind of detection.\nDespite multiple requests, the core-js maintainer has made it clear: any\nattempt to fix the detection will be obstructed. As a result, we're left\nwith little choice but to throw an error. Unfortunately, this also affects\npackages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),\nwhich rely on core-js.",
        "grammar": "lsp",
        "label": "lodash-isnative",
        "matches": {
          "lodash isnative": true
        },
        "options": {}
      },
      {
        "content": "_.isNull(${value})",
        "doc": "_.isNull(null);\n// => true\n\n_.isNull(void 0);\n// => false\n\nChecks if `value` is `null`.",
        "grammar": "lsp",
        "label": "lodash-isnull",
        "matches": {
          "lodash isnull": true
        },
        "options": {}
      },
      {
        "content": "_.isNil(${value})",
        "doc": "_.isNil(null);\n// => true\n\n_.isNil(void 0);\n// => true\n\n_.isNil(NaN);\n// => false\n\nChecks if `value` is `null` or `undefined`.",
        "grammar": "lsp",
        "label": "lodash-isnil",
        "matches": {
          "lodash isnil": true
        },
        "options": {}
      },
      {
        "content": "_.isNumber(${value})",
        "doc": "_.isNumber(3);\n// => true\n\n_.isNumber(Number.MIN_VALUE);\n// => true\n\n_.isNumber(Infinity);\n// => true\n\n_.isNumber('3');\n// => false\n\nChecks if `value` is classified as a `Number` primitive or object.\n\n**Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are\nclassified as numbers, use the `_.isFinite` method.",
        "grammar": "lsp",
        "label": "lodash-isnumber",
        "matches": {
          "lodash isnumber": true
        },
        "options": {}
      },
      {
        "content": "_.isPlainObject(${value})",
        "doc": "function Foo() {\n  this.a = 1;\n}\n\n_.isPlainObject(new Foo);\n// => false\n\n_.isPlainObject([1, 2, 3]);\n// => false\n\n_.isPlainObject({ 'x': 0, 'y': 0 });\n// => true\n\n_.isPlainObject(Object.create(null));\n// => true\n\nChecks if `value` is a plain object, that is, an object created by the\n`Object` constructor or one with a `[[Prototype]]` of `null`.",
        "grammar": "lsp",
        "label": "lodash-isplainobject",
        "matches": {
          "lodash isplainobject": true
        },
        "options": {}
      },
      {
        "content": "_.isRegExp(${value})",
        "doc": "_.isRegExp(/abc/);\n// => true\n\n_.isRegExp('/abc/');\n// => false\n\nChecks if `value` is classified as a `RegExp` object.",
        "grammar": "lsp",
        "label": "lodash-isregexp",
        "matches": {
          "lodash isregexp": true
        },
        "options": {}
      },
      {
        "content": "_.isSafeInteger(${value})",
        "doc": "_.isSafeInteger(3);\n// => true\n\n_.isSafeInteger(Number.MIN_VALUE);\n// => false\n\n_.isSafeInteger(Infinity);\n// => false\n\n_.isSafeInteger('3');\n// => false\n\nChecks if `value` is a safe integer. An integer is safe if it's an IEEE-754\ndouble precision number which isn't the result of a rounded unsafe integer.\n\n**Note:** This method is based on\n[`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).",
        "grammar": "lsp",
        "label": "lodash-issafeinteger",
        "matches": {
          "lodash issafeinteger": true
        },
        "options": {}
      },
      {
        "content": "_.isSet(${value})",
        "doc": "_.isSet(new Set);\n// => true\n\n_.isSet(new WeakSet);\n// => false\n\nChecks if `value` is classified as a `Set` object.",
        "grammar": "lsp",
        "label": "lodash-isset",
        "matches": {
          "lodash isset": true
        },
        "options": {}
      },
      {
        "content": "_.isString(${value})",
        "doc": "_.isString('abc');\n// => true\n\n_.isString(1);\n// => false\n\nChecks if `value` is classified as a `String` primitive or object.",
        "grammar": "lsp",
        "label": "lodash-isstring",
        "matches": {
          "lodash isstring": true
        },
        "options": {}
      },
      {
        "content": "_.isSymbol(${value})",
        "doc": "_.isSymbol(Symbol.iterator);\n// => true\n\n_.isSymbol('abc');\n// => false\n\nChecks if `value` is classified as a `Symbol` primitive or object.",
        "grammar": "lsp",
        "label": "lodash-issymbol",
        "matches": {
          "lodash issymbol": true
        },
        "options": {}
      },
      {
        "content": "_.isTypedArray(${value})",
        "doc": "_.isTypedArray(new Uint8Array);\n// => true\n\n_.isTypedArray([]);\n// => false\n\nChecks if `value` is classified as a typed array.",
        "grammar": "lsp",
        "label": "lodash-istypedarray",
        "matches": {
          "lodash istypedarray": true
        },
        "options": {}
      },
      {
        "content": "_.isUndefined(${value})",
        "doc": "_.isUndefined(void 0);\n// => true\n\n_.isUndefined(null);\n// => false\n\nChecks if `value` is `undefined`.",
        "grammar": "lsp",
        "label": "lodash-isundefined",
        "matches": {
          "lodash isundefined": true
        },
        "options": {}
      },
      {
        "content": "_.isWeakMap(${value})",
        "doc": "_.isWeakMap(new WeakMap);\n// => true\n\n_.isWeakMap(new Map);\n// => false\n\nChecks if `value` is classified as a `WeakMap` object.",
        "grammar": "lsp",
        "label": "lodash-isweakmap",
        "matches": {
          "lodash isweakmap": true
        },
        "options": {}
      },
      {
        "content": "_.isWeakSet(${value})",
        "doc": "_.isWeakSet(new WeakSet);\n// => true\n\n_.isWeakSet(new Set);\n// => false\n\nChecks if `value` is classified as a `WeakSet` object.",
        "grammar": "lsp",
        "label": "lodash-isweakset",
        "matches": {
          "lodash isweakset": true
        },
        "options": {}
      },
      {
        "content": "_.lt(${value}, ${other})",
        "doc": "_.lt(1, 3);\n// => true\n\n_.lt(3, 3);\n// => false\n\n_.lt(3, 1);\n// => false\n\nChecks if `value` is less than `other`.",
        "grammar": "lsp",
        "label": "lodash-lt",
        "matches": {
          "lodash lt": true
        },
        "options": {}
      },
      {
        "content": "_.lte(${value}, ${other})",
        "doc": "_.lte(1, 3);\n// => true\n\n_.lte(3, 3);\n// => true\n\n_.lte(3, 1);\n// => false\n\nChecks if `value` is less than or equal to `other`.",
        "grammar": "lsp",
        "label": "lodash-lte",
        "matches": {
          "lodash lte": true
        },
        "options": {}
      },
      {
        "content": "_.toArray(${value})",
        "doc": "_.toArray({ 'a': 1, 'b': 2 });\n// => [1, 2]\n\n_.toArray('abc');\n// => ['a', 'b', 'c']\n\n_.toArray(1);\n// => []\n\n_.toArray(null);\n// => []\n\nConverts `value` to an array.",
        "grammar": "lsp",
        "label": "lodash-toarray",
        "matches": {
          "lodash toarray": true
        },
        "options": {}
      },
      {
        "content": "_.toFinite(${value})",
        "doc": "_.toFinite(3.2);\n// => 3.2\n\n_.toFinite(Number.MIN_VALUE);\n// => 5e-324\n\n_.toFinite(Infinity);\n// => 1.7976931348623157e+308\n\n_.toFinite('3.2');\n// => 3.2\n\nConverts `value` to a finite number.",
        "grammar": "lsp",
        "label": "lodash-tofinite",
        "matches": {
          "lodash tofinite": true
        },
        "options": {}
      },
      {
        "content": "_.toInteger(${value})",
        "doc": "_.toInteger(3.2);\n// => 3\n\n_.toInteger(Number.MIN_VALUE);\n// => 0\n\n_.toInteger(Infinity);\n// => 1.7976931348623157e+308\n\n_.toInteger('3.2');\n// => 3\n\nConverts `value` to an integer.\n\n**Note:** This method is loosely based on\n[`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).",
        "grammar": "lsp",
        "label": "lodash-tointeger",
        "matches": {
          "lodash tointeger": true
        },
        "options": {}
      },
      {
        "content": "_.toLength(${value})",
        "doc": "_.toLength(3.2);\n// => 3\n\n_.toLength(Number.MIN_VALUE);\n// => 0\n\n_.toLength(Infinity);\n// => 4294967295\n\n_.toLength('3.2');\n// => 3\n\nConverts `value` to an integer suitable for use as the length of an\narray-like object.\n\n**Note:** This method is based on\n[`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).",
        "grammar": "lsp",
        "label": "lodash-tolength",
        "matches": {
          "lodash tolength": true
        },
        "options": {}
      },
      {
        "content": "_.toNumber(${value})",
        "doc": "_.toNumber(3.2);\n// => 3.2\n\n_.toNumber(Number.MIN_VALUE);\n// => 5e-324\n\n_.toNumber(Infinity);\n// => Infinity\n\n_.toNumber('3.2');\n// => 3.2\n\nConverts `value` to a number.",
        "grammar": "lsp",
        "label": "lodash-tonumber",
        "matches": {
          "lodash tonumber": true
        },
        "options": {}
      },
      {
        "content": "_.toPlainObject(${value})",
        "doc": "function Foo() {\n  this.b = 2;\n}\n\nFoo.prototype.c = 3;\n\n_.assign({ 'a': 1 }, new Foo);\n// => { 'a': 1, 'b': 2 }\n\n_.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n// => { 'a': 1, 'b': 2, 'c': 3 }\n\nConverts `value` to a plain object flattening inherited enumerable string\nkeyed properties of `value` to own properties of the plain object.",
        "grammar": "lsp",
        "label": "lodash-toplainobject",
        "matches": {
          "lodash toplainobject": true
        },
        "options": {}
      },
      {
        "content": "_.toSafeInteger(${value})",
        "doc": "_.toSafeInteger(3.2);\n// => 3\n\n_.toSafeInteger(Number.MIN_VALUE);\n// => 0\n\n_.toSafeInteger(Infinity);\n// => 9007199254740991\n\n_.toSafeInteger('3.2');\n// => 3\n\nConverts `value` to a safe integer. A safe integer can be compared and\nrepresented correctly.",
        "grammar": "lsp",
        "label": "lodash-tosafeinteger",
        "matches": {
          "lodash tosafeinteger": true
        },
        "options": {}
      },
      {
        "content": "_.toString(${value})",
        "doc": "_.toString(null);\n// => ''\n\n_.toString(-0);\n// => '-0'\n\n_.toString([1, 2, 3]);\n// => '1,2,3'\n\nConverts `value` to a string. An empty string is returned for `null`\nand `undefined` values. The sign of `-0` is preserved.",
        "grammar": "lsp",
        "label": "lodash-tostring",
        "matches": {
          "lodash tostring": true
        },
        "options": {}
      },
      {
        "content": "_.assign(${object}, ${sources})",
        "doc": "function Foo() {\n  this.a = 1;\n}\n\nfunction Bar() {\n  this.c = 3;\n}\n\nFoo.prototype.b = 2;\nBar.prototype.d = 4;\n\n_.assign({ 'a': 0 }, new Foo, new Bar);\n// => { 'a': 1, 'c': 3 }\n\nAssigns own enumerable string keyed properties of source objects to the\ndestination object. Source objects are applied from left to right.\nSubsequent sources overwrite property assignments of previous sources.\n\n**Note:** This method mutates `object` and is loosely based on\n[`Object.assign`](https://mdn.io/Object/assign).",
        "grammar": "lsp",
        "label": "lodash-assign",
        "matches": {
          "lodash assign": true
        },
        "options": {}
      },
      {
        "content": "_.extend(${object}, ${sources})",
        "doc": "function Foo() {\n  this.a = 1;\n}\n\nfunction Bar() {\n  this.c = 3;\n}\n\nFoo.prototype.b = 2;\nBar.prototype.d = 4;\n\n_.assignIn({ 'a': 0 }, new Foo, new Bar);\n// => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }\n\nThis method is like `_.assign` except that it iterates over own and\ninherited source properties.\n\n**Note:** This method mutates `object`.",
        "grammar": "lsp",
        "label": "lodash-extend",
        "matches": {
          "lodash extend": true
        },
        "options": {}
      },
      {
        "content": "_.extendWith(${object}, ${sources}, ${customizer})",
        "doc": "function customizer(objValue, srcValue) {\n  return _.isUndefined(objValue) ? srcValue : objValue;\n}\n\nvar defaults = _.partialRight(_.assignInWith, customizer);\n\ndefaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n// => { 'a': 1, 'b': 2 }\n\nThis method is like `_.assignIn` except that it accepts `customizer`\nwhich is invoked to produce the assigned values. If `customizer` returns\n`undefined`, assignment is handled by the method instead. The `customizer`\nis invoked with five arguments: (objValue, srcValue, key, object, source).\n\n**Note:** This method mutates `object`.",
        "grammar": "lsp",
        "label": "lodash-extendwith",
        "matches": {
          "lodash extendwith": true
        },
        "options": {}
      },
      {
        "content": "_.assignWith(${object}, ${sources}, ${customizer})",
        "doc": "function customizer(objValue, srcValue) {\n  return _.isUndefined(objValue) ? srcValue : objValue;\n}\n\nvar defaults = _.partialRight(_.assignWith, customizer);\n\ndefaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n// => { 'a': 1, 'b': 2 }\n\nThis method is like `_.assign` except that it accepts `customizer`\nwhich is invoked to produce the assigned values. If `customizer` returns\n`undefined`, assignment is handled by the method instead. The `customizer`\nis invoked with five arguments: (objValue, srcValue, key, object, source).\n\n**Note:** This method mutates `object`.",
        "grammar": "lsp",
        "label": "lodash-assignwith",
        "matches": {
          "lodash assignwith": true
        },
        "options": {}
      },
      {
        "content": "_.create(${prototype}, ${properties})",
        "doc": "function Shape() {\n  this.x = 0;\n  this.y = 0;\n}\n\nfunction Circle() {\n  Shape.call(this);\n}\n\nCircle.prototype = _.create(Shape.prototype, {\n  'constructor': Circle\n});\n\nvar circle = new Circle;\ncircle instanceof Circle;\n// => true\n\ncircle instanceof Shape;\n// => true\n\nCreates an object that inherits from the `prototype` object. If a\n`properties` object is given, its own enumerable string keyed properties\nare assigned to the created object.",
        "grammar": "lsp",
        "label": "lodash-create",
        "matches": {
          "lodash create": true
        },
        "options": {}
      },
      {
        "content": "_.defaults(${object}, ${sources})",
        "doc": "_.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n// => { 'a': 1, 'b': 2 }\n\nAssigns own and inherited enumerable string keyed properties of source\nobjects to the destination object for all destination properties that\nresolve to `undefined`. Source objects are applied from left to right.\nOnce a property is set, additional values of the same property are ignored.\n\n**Note:** This method mutates `object`.",
        "grammar": "lsp",
        "label": "lodash-defaults",
        "matches": {
          "lodash defaults": true
        },
        "options": {}
      },
      {
        "content": "_.defaultsDeep(${object}, ${sources})",
        "doc": "_.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });\n// => { 'a': { 'b': 2, 'c': 3 } }\n\nThis method is like `_.defaults` except that it recursively assigns\ndefault properties.\n\n**Note:** This method mutates `object`.",
        "grammar": "lsp",
        "label": "lodash-defaultsdeep",
        "matches": {
          "lodash defaultsdeep": true
        },
        "options": {}
      },
      {
        "content": "_.findKey(${object}, ${predicate})",
        "doc": "var users = {\n  'barney':  { 'age': 36, 'active': true },\n  'fred':    { 'age': 40, 'active': false },\n  'pebbles': { 'age': 1,  'active': true }\n};\n\n_.findKey(users, function(o) { return o.age < 40; });\n// => 'barney' (iteration order is not guaranteed)\n\n// The `_.matches` iteratee shorthand.\n_.findKey(users, { 'age': 1, 'active': true });\n// => 'pebbles'\n\n// The `_.matchesProperty` iteratee shorthand.\n_.findKey(users, ['active', false]);\n// => 'fred'\n\n// The `_.property` iteratee shorthand.\n_.findKey(users, 'active');\n// => 'barney'\n\nThis method is like `_.find` except that it returns the key of the first\nelement `predicate` returns truthy for instead of the element itself.",
        "grammar": "lsp",
        "label": "lodash-findkey",
        "matches": {
          "lodash findkey": true
        },
        "options": {}
      },
      {
        "content": "_.findLastKey(${object}, ${predicate})",
        "doc": "var users = {\n  'barney':  { 'age': 36, 'active': true },\n  'fred':    { 'age': 40, 'active': false },\n  'pebbles': { 'age': 1,  'active': true }\n};\n\n_.findLastKey(users, function(o) { return o.age < 40; });\n// => returns 'pebbles' assuming `_.findKey` returns 'barney'\n\n// The `_.matches` iteratee shorthand.\n_.findLastKey(users, { 'age': 36, 'active': true });\n// => 'barney'\n\n// The `_.matchesProperty` iteratee shorthand.\n_.findLastKey(users, ['active', false]);\n// => 'fred'\n\n// The `_.property` iteratee shorthand.\n_.findLastKey(users, 'active');\n// => 'pebbles'\n\nThis method is like `_.findKey` except that it iterates over elements of\na collection in the opposite order.",
        "grammar": "lsp",
        "label": "lodash-findlastkey",
        "matches": {
          "lodash findlastkey": true
        },
        "options": {}
      },
      {
        "content": "_.forIn(${object}, ${iteratee})",
        "doc": "function Foo() {\n  this.a = 1;\n  this.b = 2;\n}\n\nFoo.prototype.c = 3;\n\n_.forIn(new Foo, function(value, key) {\n  console.log(key);\n});\n// => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).\n\nIterates over own and inherited enumerable string keyed properties of an\nobject and invokes `iteratee` for each property. The iteratee is invoked\nwith three arguments: (value, key, object). Iteratee functions may exit\niteration early by explicitly returning `false`.",
        "grammar": "lsp",
        "label": "lodash-forin",
        "matches": {
          "lodash forin": true
        },
        "options": {}
      },
      {
        "content": "_.forInRight(${object}, ${iteratee})",
        "doc": "function Foo() {\n  this.a = 1;\n  this.b = 2;\n}\n\nFoo.prototype.c = 3;\n\n_.forInRight(new Foo, function(value, key) {\n  console.log(key);\n});\n// => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.\n\nThis method is like `_.forIn` except that it iterates over properties of\n`object` in the opposite order.",
        "grammar": "lsp",
        "label": "lodash-forinright",
        "matches": {
          "lodash forinright": true
        },
        "options": {}
      },
      {
        "content": "_.forOwn(${object}, ${iteratee})",
        "doc": "function Foo() {\n  this.a = 1;\n  this.b = 2;\n}\n\nFoo.prototype.c = 3;\n\n_.forOwn(new Foo, function(value, key) {\n  console.log(key);\n});\n// => Logs 'a' then 'b' (iteration order is not guaranteed).\n\nIterates over own enumerable string keyed properties of an object and\ninvokes `iteratee` for each property. The iteratee is invoked with three\narguments: (value, key, object). Iteratee functions may exit iteration\nearly by explicitly returning `false`.",
        "grammar": "lsp",
        "label": "lodash-forown",
        "matches": {
          "lodash forown": true
        },
        "options": {}
      },
      {
        "content": "_.forOwnRight(${object}, ${iteratee})",
        "doc": "function Foo() {\n  this.a = 1;\n  this.b = 2;\n}\n\nFoo.prototype.c = 3;\n\n_.forOwnRight(new Foo, function(value, key) {\n  console.log(key);\n});\n// => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.\n\nThis method is like `_.forOwn` except that it iterates over properties of\n`object` in the opposite order.",
        "grammar": "lsp",
        "label": "lodash-forownright",
        "matches": {
          "lodash forownright": true
        },
        "options": {}
      },
      {
        "content": "_.functions(${object})",
        "doc": "function Foo() {\n  this.a = _.constant('a');\n  this.b = _.constant('b');\n}\n\nFoo.prototype.c = _.constant('c');\n\n_.functions(new Foo);\n// => ['a', 'b']\n\nCreates an array of function property names from own enumerable properties\nof `object`.",
        "grammar": "lsp",
        "label": "lodash-functions",
        "matches": {
          "lodash functions": true
        },
        "options": {}
      },
      {
        "content": "_.functionsIn(${object})",
        "doc": "function Foo() {\n  this.a = _.constant('a');\n  this.b = _.constant('b');\n}\n\nFoo.prototype.c = _.constant('c');\n\n_.functionsIn(new Foo);\n// => ['a', 'b', 'c']\n\nCreates an array of function property names from own and inherited\nenumerable properties of `object`.",
        "grammar": "lsp",
        "label": "lodash-functionsin",
        "matches": {
          "lodash functionsin": true
        },
        "options": {}
      },
      {
        "content": "_.get(${object}, ${path}, ${defaultValue})",
        "doc": "var object = { 'a': [{ 'b': { 'c': 3 } }] };\n\n_.get(object, 'a[0].b.c');\n// => 3\n\n_.get(object, ['a', '0', 'b', 'c']);\n// => 3\n\n_.get(object, 'a.b.c', 'default');\n// => 'default'\n\nGets the value at `path` of `object`. If the resolved value is\n`undefined`, the `defaultValue` is returned in its place.",
        "grammar": "lsp",
        "label": "lodash-get",
        "matches": {
          "lodash get": true
        },
        "options": {}
      },
      {
        "content": "_.has(${object}, ${path})",
        "doc": "var object = { 'a': { 'b': 2 } };\nvar other = _.create({ 'a': _.create({ 'b': 2 }) });\n\n_.has(object, 'a');\n// => true\n\n_.has(object, 'a.b');\n// => true\n\n_.has(object, ['a', 'b']);\n// => true\n\n_.has(other, 'a');\n// => false\n\nChecks if `path` is a direct property of `object`.",
        "grammar": "lsp",
        "label": "lodash-has",
        "matches": {
          "lodash has": true
        },
        "options": {}
      },
      {
        "content": "_.hasIn(${object}, ${path})",
        "doc": "var object = _.create({ 'a': _.create({ 'b': 2 }) });\n\n_.hasIn(object, 'a');\n// => true\n\n_.hasIn(object, 'a.b');\n// => true\n\n_.hasIn(object, ['a', 'b']);\n// => true\n\n_.hasIn(object, 'b');\n// => false\n\nChecks if `path` is a direct or inherited property of `object`.",
        "grammar": "lsp",
        "label": "lodash-hasin",
        "matches": {
          "lodash hasin": true
        },
        "options": {}
      },
      {
        "content": "_.invert(${object})",
        "doc": "var object = { 'a': 1, 'b': 2, 'c': 1 };\n\n_.invert(object);\n// => { '1': 'c', '2': 'b' }\n\nCreates an object composed of the inverted keys and values of `object`.\nIf `object` contains duplicate values, subsequent values overwrite\nproperty assignments of previous values.",
        "grammar": "lsp",
        "label": "lodash-invert",
        "matches": {
          "lodash invert": true
        },
        "options": {}
      },
      {
        "content": "_.invertBy(${object}, ${iteratee})",
        "doc": "var object = { 'a': 1, 'b': 2, 'c': 1 };\n\n_.invertBy(object);\n// => { '1': ['a', 'c'], '2': ['b'] }\n\n_.invertBy(object, function(value) {\n  return 'group' + value;\n});\n// => { 'group1': ['a', 'c'], 'group2': ['b'] }\n\nThis method is like `_.invert` except that the inverted object is generated\nfrom the results of running each element of `object` thru `iteratee`. The\ncorresponding inverted value of each inverted key is an array of keys\nresponsible for generating the inverted value. The iteratee is invoked\nwith one argument: (value).",
        "grammar": "lsp",
        "label": "lodash-invertby",
        "matches": {
          "lodash invertby": true
        },
        "options": {}
      },
      {
        "content": "_.invoke(${object}, ${path}, ${args})",
        "doc": "var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };\n\n_.invoke(object, 'a[0].b.c.slice', 1, 3);\n// => [2, 3]\n\nInvokes the method at `path` of `object`.",
        "grammar": "lsp",
        "label": "lodash-invoke",
        "matches": {
          "lodash invoke": true
        },
        "options": {}
      },
      {
        "content": "_.keys(${object})",
        "doc": "function Foo() {\n  this.a = 1;\n  this.b = 2;\n}\n\nFoo.prototype.c = 3;\n\n_.keys(new Foo);\n// => ['a', 'b'] (iteration order is not guaranteed)\n\n_.keys('hi');\n// => ['0', '1']\n\nCreates an array of the own enumerable property names of `object`.\n\n**Note:** Non-object values are coerced to objects. See the\n[ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\nfor more details.",
        "grammar": "lsp",
        "label": "lodash-keys",
        "matches": {
          "lodash keys": true
        },
        "options": {}
      },
      {
        "content": "_.keysIn(${object})",
        "doc": "function Foo() {\n  this.a = 1;\n  this.b = 2;\n}\n\nFoo.prototype.c = 3;\n\n_.keysIn(new Foo);\n// => ['a', 'b', 'c'] (iteration order is not guaranteed)\n\nCreates an array of the own and inherited enumerable property names of `object`.\n\n**Note:** Non-object values are coerced to objects.",
        "grammar": "lsp",
        "label": "lodash-keysin",
        "matches": {
          "lodash keysin": true
        },
        "options": {}
      },
      {
        "content": "_.mapKeys(${object}, ${iteratee})",
        "doc": "_.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {\n  return key + value;\n});\n// => { 'a1': 1, 'b2': 2 }\n\nThe opposite of `_.mapValues`; this method creates an object with the\nsame values as `object` and keys generated by running each own enumerable\nstring keyed property of `object` thru `iteratee`. The iteratee is invoked\nwith three arguments: (value, key, object).",
        "grammar": "lsp",
        "label": "lodash-mapkeys",
        "matches": {
          "lodash mapkeys": true
        },
        "options": {}
      },
      {
        "content": "_.mapValues(${object}, ${iteratee})",
        "doc": "var users = {\n  'fred':    { 'user': 'fred',    'age': 40 },\n  'pebbles': { 'user': 'pebbles', 'age': 1 }\n};\n\n_.mapValues(users, function(o) { return o.age; });\n// => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n\n// The `_.property` iteratee shorthand.\n_.mapValues(users, 'age');\n// => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n\nCreates an object with the same keys as `object` and values generated\nby running each own enumerable string keyed property of `object` thru\n`iteratee`. The iteratee is invoked with three arguments:\n(value, key, object).",
        "grammar": "lsp",
        "label": "lodash-mapvalues",
        "matches": {
          "lodash mapvalues": true
        },
        "options": {}
      },
      {
        "content": "_.merge(${object}, ${sources})",
        "doc": "var object = {\n  'a': [{ 'b': 2 }, { 'd': 4 }]\n};\n\nvar other = {\n  'a': [{ 'c': 3 }, { 'e': 5 }]\n};\n\n_.merge(object, other);\n// => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n\nThis method is like `_.assign` except that it recursively merges own and\ninherited enumerable string keyed properties of source objects into the\ndestination object. Source properties that resolve to `undefined` are\nskipped if a destination value exists. Array and plain object properties\nare merged recursively. Other objects and value types are overridden by\nassignment. Source objects are applied from left to right. Subsequent\nsources overwrite property assignments of previous sources.\n\n**Note:** This method mutates `object`.",
        "grammar": "lsp",
        "label": "lodash-merge",
        "matches": {
          "lodash merge": true
        },
        "options": {}
      },
      {
        "content": "_.mergeWith(${object}, ${sources}, ${customizer})",
        "doc": "function customizer(objValue, srcValue) {\n  if (_.isArray(objValue)) {\n    return objValue.concat(srcValue);\n  }\n}\n\nvar object = { 'a': [1], 'b': [2] };\nvar other = { 'a': [3], 'b': [4] };\n\n_.mergeWith(object, other, customizer);\n// => { 'a': [1, 3], 'b': [2, 4] }\n\nThis method is like `_.merge` except that it accepts `customizer` which\nis invoked to produce the merged values of the destination and source\nproperties. If `customizer` returns `undefined`, merging is handled by the\nmethod instead. The `customizer` is invoked with six arguments:\n(objValue, srcValue, key, object, source, stack).\n\n**Note:** This method mutates `object`.",
        "grammar": "lsp",
        "label": "lodash-mergewith",
        "matches": {
          "lodash mergewith": true
        },
        "options": {}
      },
      {
        "content": "_.omit(${object}, ${paths})",
        "doc": "var object = { 'a': 1, 'b': '2', 'c': 3 };\n\n_.omit(object, ['a', 'c']);\n// => { 'b': '2' }\n\nThe opposite of `_.pick`; this method creates an object composed of the\nown and inherited enumerable property paths of `object` that are not omitted.\n\n**Note:** This method is considerably slower than `_.pick`.",
        "grammar": "lsp",
        "label": "lodash-omit",
        "matches": {
          "lodash omit": true
        },
        "options": {}
      },
      {
        "content": "_.omitBy(${object}, ${predicate})",
        "doc": "var object = { 'a': 1, 'b': '2', 'c': 3 };\n\n_.omitBy(object, _.isNumber);\n// => { 'b': '2' }\n\nThe opposite of `_.pickBy`; this method creates an object composed of\nthe own and inherited enumerable string keyed properties of `object` that\n`predicate` doesn't return truthy for. The predicate is invoked with two\narguments: (value, key).",
        "grammar": "lsp",
        "label": "lodash-omitby",
        "matches": {
          "lodash omitby": true
        },
        "options": {}
      },
      {
        "content": "_.pick(${object}, ${paths})",
        "doc": "var object = { 'a': 1, 'b': '2', 'c': 3 };\n\n_.pick(object, ['a', 'c']);\n// => { 'a': 1, 'c': 3 }\n\nCreates an object composed of the picked `object` properties.",
        "grammar": "lsp",
        "label": "lodash-pick",
        "matches": {
          "lodash pick": true
        },
        "options": {}
      },
      {
        "content": "_.pickBy(${object}, ${predicate})",
        "doc": "var object = { 'a': 1, 'b': '2', 'c': 3 };\n\n_.pickBy(object, _.isNumber);\n// => { 'a': 1, 'c': 3 }\n\nCreates an object composed of the `object` properties `predicate` returns\ntruthy for. The predicate is invoked with two arguments: (value, key).",
        "grammar": "lsp",
        "label": "lodash-pickby",
        "matches": {
          "lodash pickby": true
        },
        "options": {}
      },
      {
        "content": "_.result(${object}, ${path}, ${defaultValue})",
        "doc": "var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };\n\n_.result(object, 'a[0].b.c1');\n// => 3\n\n_.result(object, 'a[0].b.c2');\n// => 4\n\n_.result(object, 'a[0].b.c3', 'default');\n// => 'default'\n\n_.result(object, 'a[0].b.c3', _.constant('default'));\n// => 'default'\n\nThis method is like `_.get` except that if the resolved value is a\nfunction it's invoked with the `this` binding of its parent object and\nits result is returned.",
        "grammar": "lsp",
        "label": "lodash-result",
        "matches": {
          "lodash result": true
        },
        "options": {}
      },
      {
        "content": "_.set(${object}, ${path}, ${value})",
        "doc": "var object = { 'a': [{ 'b': { 'c': 3 } }] };\n\n_.set(object, 'a[0].b.c', 4);\nconsole.log(object.a[0].b.c);\n// => 4\n\n_.set(object, ['x', '0', 'y', 'z'], 5);\nconsole.log(object.x[0].y.z);\n// => 5\n\nSets the value at `path` of `object`. If a portion of `path` doesn't exist,\nit's created. Arrays are created for missing index properties while objects\nare created for all other missing properties. Use `_.setWith` to customize\n`path` creation.\n\n**Note:** This method mutates `object`.",
        "grammar": "lsp",
        "label": "lodash-set",
        "matches": {
          "lodash set": true
        },
        "options": {}
      },
      {
        "content": "_.setWith(${object}, ${path}, ${value}, ${customizer})",
        "doc": "var object = {};\n\n_.setWith(object, '[0][1]', 'a', Object);\n// => { '0': { '1': 'a' } }\n\nThis method is like `_.set` except that it accepts `customizer` which is\ninvoked to produce the objects of `path`.  If `customizer` returns `undefined`\npath creation is handled by the method instead. The `customizer` is invoked\nwith three arguments: (nsValue, key, nsObject).\n\n**Note:** This method mutates `object`.",
        "grammar": "lsp",
        "label": "lodash-setwith",
        "matches": {
          "lodash setwith": true
        },
        "options": {}
      },
      {
        "content": "_.entries(${object})",
        "doc": "function Foo() {\n  this.a = 1;\n  this.b = 2;\n}\n\nFoo.prototype.c = 3;\n\n_.toPairs(new Foo);\n// => [['a', 1], ['b', 2]] (iteration order is not guaranteed)\n\nCreates an array of own enumerable string keyed-value pairs for `object`\nwhich can be consumed by `_.fromPairs`. If `object` is a map or set, its\nentries are returned.",
        "grammar": "lsp",
        "label": "lodash-entries",
        "matches": {
          "lodash entries": true
        },
        "options": {}
      },
      {
        "content": "_.entriesIn(${object})",
        "doc": "function Foo() {\n  this.a = 1;\n  this.b = 2;\n}\n\nFoo.prototype.c = 3;\n\n_.toPairsIn(new Foo);\n// => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)\n\nCreates an array of own and inherited enumerable string keyed-value pairs\nfor `object` which can be consumed by `_.fromPairs`. If `object` is a map\nor set, its entries are returned.",
        "grammar": "lsp",
        "label": "lodash-entriesin",
        "matches": {
          "lodash entriesin": true
        },
        "options": {}
      },
      {
        "content": "_.transform(${object}, ${iteratee}, ${accumulator})",
        "doc": "_.transform([2, 3, 4], function(result, n) {\n  result.push(n *= n);\n  return n % 2 == 0;\n}, []);\n// => [4, 9]\n\n_.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n  (result[value] || (result[value] = [])).push(key);\n}, {});\n// => { '1': ['a', 'c'], '2': ['b'] }\n\nAn alternative to `_.reduce`; this method transforms `object` to a new\n`accumulator` object which is the result of running each of its own\nenumerable string keyed properties thru `iteratee`, with each invocation\npotentially mutating the `accumulator` object. If `accumulator` is not\nprovided, a new object with the same `[[Prototype]]` will be used. The\niteratee is invoked with four arguments: (accumulator, value, key, object).\nIteratee functions may exit iteration early by explicitly returning `false`.",
        "grammar": "lsp",
        "label": "lodash-transform",
        "matches": {
          "lodash transform": true
        },
        "options": {}
      },
      {
        "content": "_.unset(${object}, ${path})",
        "doc": "var object = { 'a': [{ 'b': { 'c': 7 } }] };\n_.unset(object, 'a[0].b.c');\n// => true\n\nconsole.log(object);\n// => { 'a': [{ 'b': {} }] };\n\n_.unset(object, ['a', '0', 'b', 'c']);\n// => true\n\nconsole.log(object);\n// => { 'a': [{ 'b': {} }] };\n\nRemoves the property at `path` of `object`.\n\n**Note:** This method mutates `object`.",
        "grammar": "lsp",
        "label": "lodash-unset",
        "matches": {
          "lodash unset": true
        },
        "options": {}
      },
      {
        "content": "_.update(${object}, ${path}, ${updater})",
        "doc": "var object = { 'a': [{ 'b': { 'c': 3 } }] };\n\n_.update(object, 'a[0].b.c', function(n) { return n * n; });\nconsole.log(object.a[0].b.c);\n// => 9\n\n_.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });\nconsole.log(object.x[0].y.z);\n// => 0\n\nThis method is like `_.set` except that accepts `updater` to produce the\nvalue to set. Use `_.updateWith` to customize `path` creation. The `updater`\nis invoked with one argument: (value).\n\n**Note:** This method mutates `object`.",
        "grammar": "lsp",
        "label": "lodash-update",
        "matches": {
          "lodash update": true
        },
        "options": {}
      },
      {
        "content": "_.updateWith(${object}, ${path}, ${updater}, ${customizer})",
        "doc": "var object = {};\n\n_.updateWith(object, '[0][1]', _.constant('a'), Object);\n// => { '0': { '1': 'a' } }\n\nThis method is like `_.update` except that it accepts `customizer` which is\ninvoked to produce the objects of `path`.  If `customizer` returns `undefined`\npath creation is handled by the method instead. The `customizer` is invoked\nwith three arguments: (nsValue, key, nsObject).\n\n**Note:** This method mutates `object`.",
        "grammar": "lsp",
        "label": "lodash-updatewith",
        "matches": {
          "lodash updatewith": true
        },
        "options": {}
      },
      {
        "content": "_.values(${object})",
        "doc": "function Foo() {\n  this.a = 1;\n  this.b = 2;\n}\n\nFoo.prototype.c = 3;\n\n_.values(new Foo);\n// => [1, 2] (iteration order is not guaranteed)\n\n_.values('hi');\n// => ['h', 'i']\n\nCreates an array of the own enumerable string keyed property values of `object`.\n\n**Note:** Non-object values are coerced to objects.",
        "grammar": "lsp",
        "label": "lodash-values",
        "matches": {
          "lodash values": true
        },
        "options": {}
      },
      {
        "content": "_.valuesIn(${object})",
        "doc": "function Foo() {\n  this.a = 1;\n  this.b = 2;\n}\n\nFoo.prototype.c = 3;\n\n_.valuesIn(new Foo);\n// => [1, 2, 3] (iteration order is not guaranteed)\n\nCreates an array of the own and inherited enumerable string keyed property\nvalues of `object`.\n\n**Note:** Non-object values are coerced to objects.",
        "grammar": "lsp",
        "label": "lodash-valuesin",
        "matches": {
          "lodash valuesin": true
        },
        "options": {}
      },
      {
        "content": "_.clamp(${number}, ${lower}, ${upper})",
        "doc": "_.clamp(-10, -5, 5);\n// => -5\n\n_.clamp(10, -5, 5);\n// => 5\n\nClamps `number` within the inclusive `lower` and `upper` bounds.",
        "grammar": "lsp",
        "label": "lodash-clamp",
        "matches": {
          "lodash clamp": true
        },
        "options": {}
      },
      {
        "content": "_.inRange(${number}, ${start}, ${end})",
        "doc": "_.inRange(3, 2, 4);\n// => true\n\n_.inRange(4, 8);\n// => true\n\n_.inRange(4, 2);\n// => false\n\n_.inRange(2, 2);\n// => false\n\n_.inRange(1.2, 2);\n// => true\n\n_.inRange(5.2, 4);\n// => false\n\n_.inRange(-3, -2, -6);\n// => true\n\nChecks if `n` is between `start` and up to, but not including, `end`. If\n`end` is not specified, it's set to `start` with `start` then set to `0`.\nIf `start` is greater than `end` the params are swapped to support\nnegative ranges.",
        "grammar": "lsp",
        "label": "lodash-inrange",
        "matches": {
          "lodash inrange": true
        },
        "options": {}
      },
      {
        "content": "_.random(${lower}, ${upper}, ${floating})",
        "doc": "_.random(0, 5);\n// => an integer between 0 and 5\n\n_.random(5);\n// => also an integer between 0 and 5\n\n_.random(5, true);\n// => a floating-point number between 0 and 5\n\n_.random(1.2, 5.2);\n// => a floating-point number between 1.2 and 5.2\n\nProduces a random number between the inclusive `lower` and `upper` bounds.\nIf only one argument is provided a number between `0` and the given number\nis returned. If `floating` is `true`, or either `lower` or `upper` are\nfloats, a floating-point number is returned instead of an integer.\n\n**Note:** JavaScript follows the IEEE-754 standard for resolving\nfloating-point values which can produce unexpected results.",
        "grammar": "lsp",
        "label": "lodash-random",
        "matches": {
          "lodash random": true
        },
        "options": {}
      },
      {
        "content": "_.camelCase(${string})",
        "doc": "_.camelCase('Foo Bar');\n// => 'fooBar'\n\n_.camelCase('--foo-bar--');\n// => 'fooBar'\n\n_.camelCase('__FOO_BAR__');\n// => 'fooBar'\n\nConverts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).",
        "grammar": "lsp",
        "label": "lodash-camelcase",
        "matches": {
          "lodash camelcase": true
        },
        "options": {}
      },
      {
        "content": "_.capitalize(${string})",
        "doc": "_.capitalize('FRED');\n// => 'Fred'\n\nConverts the first character of `string` to upper case and the remaining\nto lower case.",
        "grammar": "lsp",
        "label": "lodash-capitalize",
        "matches": {
          "lodash capitalize": true
        },
        "options": {}
      },
      {
        "content": "_.deburr(${string})",
        "doc": "_.deburr('dj vu');\n// => 'deja vu'\n\nDeburrs `string` by converting\n[Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\nand [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)\nletters to basic Latin letters and removing\n[combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).",
        "grammar": "lsp",
        "label": "lodash-deburr",
        "matches": {
          "lodash deburr": true
        },
        "options": {}
      },
      {
        "content": "_.endsWith(${string}, ${target}, ${position})",
        "doc": "_.endsWith('abc', 'c');\n// => true\n\n_.endsWith('abc', 'b');\n// => false\n\n_.endsWith('abc', 'b', 2);\n// => true\n\nChecks if `string` ends with the given target string.",
        "grammar": "lsp",
        "label": "lodash-endswith",
        "matches": {
          "lodash endswith": true
        },
        "options": {}
      },
      {
        "content": "_.escape(${string})",
        "doc": "_.escape('fred, barney, & pebbles');\n// => 'fred, barney, &amp; pebbles'\n\nConverts the characters \"&\", \"<\", \">\", '\"', and \"'\" in `string` to their\ncorresponding HTML entities.\n\n**Note:** No other characters are escaped. To escape additional\ncharacters use a third-party library like [_he_](https://mths.be/he).\n\nThough the \">\" character is escaped for symmetry, characters like\n\">\" and \"/\" don't need escaping in HTML and have no special meaning\nunless they're part of a tag or unquoted attribute value. See\n[Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\n(under \"semi-related fun fact\") for more details.\n\nWhen working with HTML you should always\n[quote attribute values](http://wonko.com/post/html-escaping) to reduce\nXSS vectors.",
        "grammar": "lsp",
        "label": "lodash-escape",
        "matches": {
          "lodash escape": true
        },
        "options": {}
      },
      {
        "content": "_.escapeRegExp(${string})",
        "doc": "_.escapeRegExp('[lodash](https://lodash.com/)');\n// => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n\nEscapes the `RegExp` special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\",\n\"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `string`.",
        "grammar": "lsp",
        "label": "lodash-escaperegexp",
        "matches": {
          "lodash escaperegexp": true
        },
        "options": {}
      },
      {
        "content": "_.kebabCase(${string})",
        "doc": "_.kebabCase('Foo Bar');\n// => 'foo-bar'\n\n_.kebabCase('fooBar');\n// => 'foo-bar'\n\n_.kebabCase('__FOO_BAR__');\n// => 'foo-bar'\n\nConverts `string` to\n[kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).",
        "grammar": "lsp",
        "label": "lodash-kebabcase",
        "matches": {
          "lodash kebabcase": true
        },
        "options": {}
      },
      {
        "content": "_.lowerCase(${string})",
        "doc": "_.lowerCase('--Foo-Bar--');\n// => 'foo bar'\n\n_.lowerCase('fooBar');\n// => 'foo bar'\n\n_.lowerCase('__FOO_BAR__');\n// => 'foo bar'\n\nConverts `string`, as space separated words, to lower case.",
        "grammar": "lsp",
        "label": "lodash-lowercase",
        "matches": {
          "lodash lowercase": true
        },
        "options": {}
      },
      {
        "content": "_.lowerFirst(${string})",
        "doc": "_.lowerFirst('Fred');\n// => 'fred'\n\n_.lowerFirst('FRED');\n// => 'fRED'\n\nConverts the first character of `string` to lower case.",
        "grammar": "lsp",
        "label": "lodash-lowerfirst",
        "matches": {
          "lodash lowerfirst": true
        },
        "options": {}
      },
      {
        "content": "_.pad(${string}, ${length}, ${chars})",
        "doc": "_.pad('abc', 8);\n// => '  abc   '\n\n_.pad('abc', 8, '_-');\n// => '_-abc_-_'\n\n_.pad('abc', 3);\n// => 'abc'\n\nPads `string` on the left and right sides if it's shorter than `length`.\nPadding characters are truncated if they can't be evenly divided by `length`.",
        "grammar": "lsp",
        "label": "lodash-pad",
        "matches": {
          "lodash pad": true
        },
        "options": {}
      },
      {
        "content": "_.padEnd(${string}, ${length}, ${chars})",
        "doc": "_.padEnd('abc', 6);\n// => 'abc   '\n\n_.padEnd('abc', 6, '_-');\n// => 'abc_-_'\n\n_.padEnd('abc', 3);\n// => 'abc'\n\nPads `string` on the right side if it's shorter than `length`. Padding\ncharacters are truncated if they exceed `length`.",
        "grammar": "lsp",
        "label": "lodash-padend",
        "matches": {
          "lodash padend": true
        },
        "options": {}
      },
      {
        "content": "_.padStart(${string}, ${length}, ${chars})",
        "doc": "_.padStart('abc', 6);\n// => '   abc'\n\n_.padStart('abc', 6, '_-');\n// => '_-_abc'\n\n_.padStart('abc', 3);\n// => 'abc'\n\nPads `string` on the left side if it's shorter than `length`. Padding\ncharacters are truncated if they exceed `length`.",
        "grammar": "lsp",
        "label": "lodash-padstart",
        "matches": {
          "lodash padstart": true
        },
        "options": {}
      },
      {
        "content": "_.parseInt(${string}, ${radix})",
        "doc": "_.parseInt('08');\n// => 8\n\n_.map(['6', '08', '10'], _.parseInt);\n// => [6, 8, 10]\n\nConverts `string` to an integer of the specified radix. If `radix` is\n`undefined` or `0`, a `radix` of `10` is used unless `value` is a\nhexadecimal, in which case a `radix` of `16` is used.\n\n**Note:** This method aligns with the\n[ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.",
        "grammar": "lsp",
        "label": "lodash-parseint",
        "matches": {
          "lodash parseint": true
        },
        "options": {}
      },
      {
        "content": "_.repeat(${string}, ${n})",
        "doc": "_.repeat('*', 3);\n// => '***'\n\n_.repeat('abc', 2);\n// => 'abcabc'\n\n_.repeat('abc', 0);\n// => ''\n\nRepeats the given string `n` times.",
        "grammar": "lsp",
        "label": "lodash-repeat",
        "matches": {
          "lodash repeat": true
        },
        "options": {}
      },
      {
        "content": "_.replace(${string}, ${pattern}, ${replacement})",
        "doc": "_.replace('Hi Fred', 'Fred', 'Barney');\n// => 'Hi Barney'\n\nReplaces matches for `pattern` in `string` with `replacement`.\n\n**Note:** This method is based on\n[`String#replace`](https://mdn.io/String/replace).",
        "grammar": "lsp",
        "label": "lodash-replace",
        "matches": {
          "lodash replace": true
        },
        "options": {}
      },
      {
        "content": "_.snakeCase(${string})",
        "doc": "_.snakeCase('Foo Bar');\n// => 'foo_bar'\n\n_.snakeCase('fooBar');\n// => 'foo_bar'\n\n_.snakeCase('--FOO-BAR--');\n// => 'foo_bar'\n\nConverts `string` to\n[snake case](https://en.wikipedia.org/wiki/Snake_case).",
        "grammar": "lsp",
        "label": "lodash-snakecase",
        "matches": {
          "lodash snakecase": true
        },
        "options": {}
      },
      {
        "content": "_.split(${string}, ${separator}, ${limit})",
        "doc": "_.split('a-b-c', '-', 2);\n// => ['a', 'b']\n\nSplits `string` by `separator`.\n\n**Note:** This method is based on\n[`String#split`](https://mdn.io/String/split).",
        "grammar": "lsp",
        "label": "lodash-split",
        "matches": {
          "lodash split": true
        },
        "options": {}
      },
      {
        "content": "_.startCase(${string})",
        "doc": "_.startCase('--foo-bar--');\n// => 'Foo Bar'\n\n_.startCase('fooBar');\n// => 'Foo Bar'\n\n_.startCase('__FOO_BAR__');\n// => 'FOO BAR'\n\nConverts `string` to\n[start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).",
        "grammar": "lsp",
        "label": "lodash-startcase",
        "matches": {
          "lodash startcase": true
        },
        "options": {}
      },
      {
        "content": "_.startsWith(${string}, ${target}, ${position})",
        "doc": "_.startsWith('abc', 'a');\n// => true\n\n_.startsWith('abc', 'b');\n// => false\n\n_.startsWith('abc', 'b', 1);\n// => true\n\nChecks if `string` starts with the given target string.",
        "grammar": "lsp",
        "label": "lodash-startswith",
        "matches": {
          "lodash startswith": true
        },
        "options": {}
      },
      {
        "content": "_.toLower(${string})",
        "doc": "_.toLower('--Foo-Bar--');\n// => '--foo-bar--'\n\n_.toLower('fooBar');\n// => 'foobar'\n\n_.toLower('__FOO_BAR__');\n// => '__foo_bar__'\n\nConverts `string`, as a whole, to lower case just like\n[String#toLowerCase](https://mdn.io/toLowerCase).",
        "grammar": "lsp",
        "label": "lodash-tolower",
        "matches": {
          "lodash tolower": true
        },
        "options": {}
      },
      {
        "content": "_.toUpper(${string})",
        "doc": "_.toUpper('--foo-bar--');\n// => '--FOO-BAR--'\n\n_.toUpper('fooBar');\n// => 'FOOBAR'\n\n_.toUpper('__foo_bar__');\n// => '__FOO_BAR__'\n\nConverts `string`, as a whole, to upper case just like\n[String#toUpperCase](https://mdn.io/toUpperCase).",
        "grammar": "lsp",
        "label": "lodash-toupper",
        "matches": {
          "lodash toupper": true
        },
        "options": {}
      },
      {
        "content": "_.trim(${string}, ${chars})",
        "doc": "_.trim('  abc  ');\n// => 'abc'\n\n_.trim('-_-abc-_-', '_-');\n// => 'abc'\n\n_.map(['  foo  ', '  bar  '], _.trim);\n// => ['foo', 'bar']\n\nRemoves leading and trailing whitespace or specified characters from `string`.",
        "grammar": "lsp",
        "label": "lodash-trim",
        "matches": {
          "lodash trim": true
        },
        "options": {}
      },
      {
        "content": "_.trimEnd(${string}, ${chars})",
        "doc": "_.trimEnd('  abc  ');\n// => '  abc'\n\n_.trimEnd('-_-abc-_-', '_-');\n// => '-_-abc'\n\nRemoves trailing whitespace or specified characters from `string`.",
        "grammar": "lsp",
        "label": "lodash-trimend",
        "matches": {
          "lodash trimend": true
        },
        "options": {}
      },
      {
        "content": "_.trimStart(${string}, ${chars})",
        "doc": "_.trimStart('  abc  ');\n// => 'abc  '\n\n_.trimStart('-_-abc-_-', '_-');\n// => 'abc-_-'\n\nRemoves leading whitespace or specified characters from `string`.",
        "grammar": "lsp",
        "label": "lodash-trimstart",
        "matches": {
          "lodash trimstart": true
        },
        "options": {}
      },
      {
        "content": "_.unescape(${string})",
        "doc": "_.unescape('fred, barney, &amp; pebbles');\n// => 'fred, barney, & pebbles'\n\nThe inverse of `_.escape`; this method converts the HTML entities\n`&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to\ntheir corresponding characters.\n\n**Note:** No other HTML entities are unescaped. To unescape additional\nHTML entities use a third-party library like [_he_](https://mths.be/he).",
        "grammar": "lsp",
        "label": "lodash-unescape",
        "matches": {
          "lodash unescape": true
        },
        "options": {}
      },
      {
        "content": "_.upperCase(${string})",
        "doc": "_.upperCase('--foo-bar');\n// => 'FOO BAR'\n\n_.upperCase('fooBar');\n// => 'FOO BAR'\n\n_.upperCase('__foo_bar__');\n// => 'FOO BAR'\n\nConverts `string`, as space separated words, to upper case.",
        "grammar": "lsp",
        "label": "lodash-uppercase",
        "matches": {
          "lodash uppercase": true
        },
        "options": {}
      },
      {
        "content": "_.upperFirst(${string})",
        "doc": "_.upperFirst('fred');\n// => 'Fred'\n\n_.upperFirst('FRED');\n// => 'FRED'\n\nConverts the first character of `string` to upper case.",
        "grammar": "lsp",
        "label": "lodash-upperfirst",
        "matches": {
          "lodash upperfirst": true
        },
        "options": {}
      },
      {
        "content": "_.words(${string}, ${pattern})",
        "doc": "_.words('fred, barney, & pebbles');\n// => ['fred', 'barney', 'pebbles']\n\n_.words('fred, barney, & pebbles', /[^, ]+/g);\n// => ['fred', 'barney', '&', 'pebbles']\n\nSplits `string` into an array of its words.",
        "grammar": "lsp",
        "label": "lodash-words",
        "matches": {
          "lodash words": true
        },
        "options": {}
      },
      {
        "content": "_.attempt(${func}, ${args})",
        "doc": "// Avoid throwing errors for invalid selectors.\nvar elements = _.attempt(function(selector) {\n  return document.querySelectorAll(selector);\n}, '>_>');\n\nif (_.isError(elements)) {\n  elements = [];\n}\n\nAttempts to invoke `func`, returning either the result or the caught error\nobject. Any additional arguments are provided to `func` when it's invoked.",
        "grammar": "lsp",
        "label": "lodash-attempt",
        "matches": {
          "lodash attempt": true
        },
        "options": {}
      },
      {
        "content": "_.bindAll(${object}, ${methodNames})",
        "doc": "var view = {\n  'label': 'docs',\n  'click': function() {\n    console.log('clicked ' + this.label);\n  }\n};\n\n_.bindAll(view, ['click']);\njQuery(element).on('click', view.click);\n// => Logs 'clicked docs' when clicked.\n\nBinds methods of an object to the object itself, overwriting the existing\nmethod.\n\n**Note:** This method doesn't set the \"length\" property of bound functions.",
        "grammar": "lsp",
        "label": "lodash-bindall",
        "matches": {
          "lodash bindall": true
        },
        "options": {}
      },
      {
        "content": "_.cond(${pairs})",
        "doc": "var func = _.cond([\n  [_.matches({ 'a': 1 }),           _.constant('matches A')],\n  [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],\n  [_.stubTrue,                      _.constant('no match')]\n]);\n\nfunc({ 'a': 1, 'b': 2 });\n// => 'matches A'\n\nfunc({ 'a': 0, 'b': 1 });\n// => 'matches B'\n\nfunc({ 'a': '1', 'b': '2' });\n// => 'no match'\n\nCreates a function that iterates over `pairs` and invokes the corresponding\nfunction of the first predicate to return truthy. The predicate-function\npairs are invoked with the `this` binding and arguments of the created\nfunction.",
        "grammar": "lsp",
        "label": "lodash-cond",
        "matches": {
          "lodash cond": true
        },
        "options": {}
      },
      {
        "content": "_.conforms(${source})",
        "doc": "var objects = [\n  { 'a': 2, 'b': 1 },\n  { 'a': 1, 'b': 2 }\n];\n\n_.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));\n// => [{ 'a': 1, 'b': 2 }]\n\nCreates a function that invokes the predicate properties of `source` with\nthe corresponding property values of a given object, returning `true` if\nall predicates return truthy, else `false`.\n\n**Note:** The created function is equivalent to `_.conformsTo` with\n`source` partially applied.",
        "grammar": "lsp",
        "label": "lodash-conforms",
        "matches": {
          "lodash conforms": true
        },
        "options": {}
      },
      {
        "content": "_.constant(${value})",
        "doc": "var objects = _.times(2, _.constant({ 'a': 1 }));\n\nconsole.log(objects);\n// => [{ 'a': 1 }, { 'a': 1 }]\n\nconsole.log(objects[0] === objects[1]);\n// => true\n\nCreates a function that returns `value`.",
        "grammar": "lsp",
        "label": "lodash-constant",
        "matches": {
          "lodash constant": true
        },
        "options": {}
      },
      {
        "content": "_.defaultTo(${value}, ${defaultValue})",
        "doc": "_.defaultTo(1, 10);\n// => 1\n\n_.defaultTo(undefined, 10);\n// => 10\n\nChecks `value` to determine whether a default value should be returned in\nits place. The `defaultValue` is returned if `value` is `NaN`, `null`,\nor `undefined`.",
        "grammar": "lsp",
        "label": "lodash-defaultto",
        "matches": {
          "lodash defaultto": true
        },
        "options": {}
      },
      {
        "content": "_.flow(${funcs})",
        "doc": "function square(n) {\n  return n * n;\n}\n\nvar addSquare = _.flow([_.add, square]);\naddSquare(1, 2);\n// => 9\n\nCreates a function that returns the result of invoking the given functions\nwith the `this` binding of the created function, where each successive\ninvocation is supplied the return value of the previous.",
        "grammar": "lsp",
        "label": "lodash-flow",
        "matches": {
          "lodash flow": true
        },
        "options": {}
      },
      {
        "content": "_.flowRight(${funcs})",
        "doc": "function square(n) {\n  return n * n;\n}\n\nvar addSquare = _.flowRight([square, _.add]);\naddSquare(1, 2);\n// => 9\n\nThis method is like `_.flow` except that it creates a function that\ninvokes the given functions from right to left.",
        "grammar": "lsp",
        "label": "lodash-flowright",
        "matches": {
          "lodash flowright": true
        },
        "options": {}
      },
      {
        "content": "_.identity(${value})",
        "doc": "var object = { 'a': 1 };\n\nconsole.log(_.identity(object) === object);\n// => true\n\nThis method returns the first argument it receives.",
        "grammar": "lsp",
        "label": "lodash-identity",
        "matches": {
          "lodash identity": true
        },
        "options": {}
      },
      {
        "content": "_.iteratee(${func})",
        "doc": "var users = [\n  { 'user': 'barney', 'age': 36, 'active': true },\n  { 'user': 'fred',   'age': 40, 'active': false }\n];\n\n// The `_.matches` iteratee shorthand.\n_.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));\n// => [{ 'user': 'barney', 'age': 36, 'active': true }]\n\n// The `_.matchesProperty` iteratee shorthand.\n_.filter(users, _.iteratee(['user', 'fred']));\n// => [{ 'user': 'fred', 'age': 40 }]\n\n// The `_.property` iteratee shorthand.\n_.map(users, _.iteratee('user'));\n// => ['barney', 'fred']\n\n// Create custom iteratee shorthands.\n_.iteratee = _.wrap(_.iteratee, function(iteratee, func) {\n  return !_.isRegExp(func) ? iteratee(func) : function(string) {\n    return func.test(string);\n  };\n});\n\n_.filter(['abc', 'def'], /ef/);\n// => ['def']\n\nCreates a function that invokes `func` with the arguments of the created\nfunction. If `func` is a property name, the created function returns the\nproperty value for a given element. If `func` is an array or object, the\ncreated function returns `true` for elements that contain the equivalent\nsource properties, otherwise it returns `false`.",
        "grammar": "lsp",
        "label": "lodash-iteratee",
        "matches": {
          "lodash iteratee": true
        },
        "options": {}
      },
      {
        "content": "_.matches(${source})",
        "doc": "var objects = [\n  { 'a': 1, 'b': 2, 'c': 3 },\n  { 'a': 4, 'b': 5, 'c': 6 }\n];\n\n_.filter(objects, _.matches({ 'a': 4, 'c': 6 }));\n// => [{ 'a': 4, 'b': 5, 'c': 6 }]\n\nCreates a function that performs a partial deep comparison between a given\nobject and `source`, returning `true` if the given object has equivalent\nproperty values, else `false`.\n\n**Note:** The created function is equivalent to `_.isMatch` with `source`\npartially applied.\n\nPartial comparisons will match empty array and empty object `source`\nvalues against any array or object value, respectively. See `_.isEqual`\nfor a list of supported value comparisons.",
        "grammar": "lsp",
        "label": "lodash-matches",
        "matches": {
          "lodash matches": true
        },
        "options": {}
      },
      {
        "content": "_.matchesProperty(${path}, ${srcValue})",
        "doc": "var objects = [\n  { 'a': 1, 'b': 2, 'c': 3 },\n  { 'a': 4, 'b': 5, 'c': 6 }\n];\n\n_.find(objects, _.matchesProperty('a', 4));\n// => { 'a': 4, 'b': 5, 'c': 6 }\n\nCreates a function that performs a partial deep comparison between the\nvalue at `path` of a given object to `srcValue`, returning `true` if the\nobject value is equivalent, else `false`.\n\n**Note:** Partial comparisons will match empty array and empty object\n`srcValue` values against any array or object value, respectively. See\n`_.isEqual` for a list of supported value comparisons.",
        "grammar": "lsp",
        "label": "lodash-matchesproperty",
        "matches": {
          "lodash matchesproperty": true
        },
        "options": {}
      },
      {
        "content": "_.method(${path}, ${args})",
        "doc": "var objects = [\n  { 'a': { 'b': _.constant(2) } },\n  { 'a': { 'b': _.constant(1) } }\n];\n\n_.map(objects, _.method('a.b'));\n// => [2, 1]\n\n_.map(objects, _.method(['a', 'b']));\n// => [2, 1]\n\nCreates a function that invokes the method at `path` of a given object.\nAny additional arguments are provided to the invoked method.",
        "grammar": "lsp",
        "label": "lodash-method",
        "matches": {
          "lodash method": true
        },
        "options": {}
      },
      {
        "content": "_.methodOf(${object}, ${args})",
        "doc": "var array = _.times(3, _.constant),\n    object = { 'a': array, 'b': array, 'c': array };\n\n_.map(['a[2]', 'c[0]'], _.methodOf(object));\n// => [2, 0]\n\n_.map([['a', '2'], ['c', '0']], _.methodOf(object));\n// => [2, 0]\n\nThe opposite of `_.method`; this method creates a function that invokes\nthe method at a given path of `object`. Any additional arguments are\nprovided to the invoked method.",
        "grammar": "lsp",
        "label": "lodash-methodof",
        "matches": {
          "lodash methodof": true
        },
        "options": {}
      },
      {
        "content": "_.noConflict()",
        "doc": "var lodash = _.noConflict();\n\nReverts the `_` variable to its previous value and returns a reference to\nthe `lodash` function.",
        "grammar": "lsp",
        "label": "lodash-noconflict",
        "matches": {
          "lodash noconflict": true
        },
        "options": {}
      },
      {
        "content": "_.noop()",
        "doc": "_.times(2, _.noop);\n// => [undefined, undefined]\n\nThis method returns `undefined`.",
        "grammar": "lsp",
        "label": "lodash-noop",
        "matches": {
          "lodash noop": true
        },
        "options": {}
      },
      {
        "content": "_.nthArg(${n})",
        "doc": "var func = _.nthArg(1);\nfunc('a', 'b', 'c', 'd');\n// => 'b'\n\nvar func = _.nthArg(-2);\nfunc('a', 'b', 'c', 'd');\n// => 'c'\n\nCreates a function that gets the argument at index `n`. If `n` is negative,\nthe nth argument from the end is returned.",
        "grammar": "lsp",
        "label": "lodash-ntharg",
        "matches": {
          "lodash ntharg": true
        },
        "options": {}
      },
      {
        "content": "_.over(${iteratees})",
        "doc": "var func = _.over([Math.max, Math.min]);\n\nfunc(1, 2, 3, 4);\n// => [4, 1]\n\nCreates a function that invokes `iteratees` with the arguments it receives\nand returns their results.",
        "grammar": "lsp",
        "label": "lodash-over",
        "matches": {
          "lodash over": true
        },
        "options": {}
      },
      {
        "content": "_.overEvery(${predicates})",
        "doc": "var func = _.overEvery([Boolean, isFinite]);\n\nfunc('1');\n// => true\n\nfunc(null);\n// => false\n\nfunc(NaN);\n// => false\n\nCreates a function that checks if **all** of the `predicates` return\ntruthy when invoked with the arguments it receives.",
        "grammar": "lsp",
        "label": "lodash-overevery",
        "matches": {
          "lodash overevery": true
        },
        "options": {}
      },
      {
        "content": "_.overSome(${predicates})",
        "doc": "var func = _.overSome([Boolean, isFinite]);\n\nfunc('1');\n// => true\n\nfunc(null);\n// => true\n\nfunc(NaN);\n// => false\n\nCreates a function that checks if **any** of the `predicates` return\ntruthy when invoked with the arguments it receives.",
        "grammar": "lsp",
        "label": "lodash-oversome",
        "matches": {
          "lodash oversome": true
        },
        "options": {}
      },
      {
        "content": "_.property(${path})",
        "doc": "var objects = [\n  { 'a': { 'b': 2 } },\n  { 'a': { 'b': 1 } }\n];\n\n_.map(objects, _.property('a.b'));\n// => [2, 1]\n\n_.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n// => [1, 2]\n\nCreates a function that returns the value at `path` of a given object.",
        "grammar": "lsp",
        "label": "lodash-property",
        "matches": {
          "lodash property": true
        },
        "options": {}
      },
      {
        "content": "_.propertyOf(${object})",
        "doc": "var array = [0, 1, 2],\n    object = { 'a': array, 'b': array, 'c': array };\n\n_.map(['a[2]', 'c[0]'], _.propertyOf(object));\n// => [2, 0]\n\n_.map([['a', '2'], ['c', '0']], _.propertyOf(object));\n// => [2, 0]\n\nThe opposite of `_.property`; this method creates a function that returns\nthe value at a given path of `object`.",
        "grammar": "lsp",
        "label": "lodash-propertyof",
        "matches": {
          "lodash propertyof": true
        },
        "options": {}
      },
      {
        "content": "_.range(${start}, ${end}, ${step})",
        "doc": "_.range(4);\n// => [0, 1, 2, 3]\n\n_.range(-4);\n// => [0, -1, -2, -3]\n\n_.range(1, 5);\n// => [1, 2, 3, 4]\n\n_.range(0, 20, 5);\n// => [0, 5, 10, 15]\n\n_.range(0, -4, -1);\n// => [0, -1, -2, -3]\n\n_.range(1, 4, 0);\n// => [1, 1, 1]\n\n_.range(0);\n// => []\n\nCreates an array of numbers (positive and/or negative) progressing from\n`start` up to, but not including, `end`. A step of `-1` is used if a negative\n`start` is specified without an `end` or `step`. If `end` is not specified,\nit's set to `start` with `start` then set to `0`.\n\n**Note:** JavaScript follows the IEEE-754 standard for resolving\nfloating-point values which can produce unexpected results.",
        "grammar": "lsp",
        "label": "lodash-range",
        "matches": {
          "lodash range": true
        },
        "options": {}
      },
      {
        "content": "_.rangeRight(${start}, ${end}, ${step})",
        "doc": "_.rangeRight(4);\n// => [3, 2, 1, 0]\n\n_.rangeRight(-4);\n// => [-3, -2, -1, 0]\n\n_.rangeRight(1, 5);\n// => [4, 3, 2, 1]\n\n_.rangeRight(0, 20, 5);\n// => [15, 10, 5, 0]\n\n_.rangeRight(0, -4, -1);\n// => [-3, -2, -1, 0]\n\n_.rangeRight(1, 4, 0);\n// => [1, 1, 1]\n\n_.rangeRight(0);\n// => []\n\nThis method is like `_.range` except that it populates values in\ndescending order.",
        "grammar": "lsp",
        "label": "lodash-rangeright",
        "matches": {
          "lodash rangeright": true
        },
        "options": {}
      },
      {
        "content": "_.stubArray()",
        "doc": "var arrays = _.times(2, _.stubArray);\n\nconsole.log(arrays);\n// => [[], []]\n\nconsole.log(arrays[0] === arrays[1]);\n// => false\n\nThis method returns a new empty array.",
        "grammar": "lsp",
        "label": "lodash-stubarray",
        "matches": {
          "lodash stubarray": true
        },
        "options": {}
      },
      {
        "content": "_.stubFalse()",
        "doc": "_.times(2, _.stubFalse);\n// => [false, false]\n\nThis method returns `false`.",
        "grammar": "lsp",
        "label": "lodash-stubfalse",
        "matches": {
          "lodash stubfalse": true
        },
        "options": {}
      },
      {
        "content": "_.stubObject()",
        "doc": "var objects = _.times(2, _.stubObject);\n\nconsole.log(objects);\n// => [{}, {}]\n\nconsole.log(objects[0] === objects[1]);\n// => false\n\nThis method returns a new empty object.",
        "grammar": "lsp",
        "label": "lodash-stubobject",
        "matches": {
          "lodash stubobject": true
        },
        "options": {}
      },
      {
        "content": "_.stubString()",
        "doc": "_.times(2, _.stubString);\n// => ['', '']\n\nThis method returns an empty string.",
        "grammar": "lsp",
        "label": "lodash-stubstring",
        "matches": {
          "lodash stubstring": true
        },
        "options": {}
      },
      {
        "content": "_.stubTrue()",
        "doc": "_.times(2, _.stubTrue);\n// => [true, true]\n\nThis method returns `true`.",
        "grammar": "lsp",
        "label": "lodash-stubtrue",
        "matches": {
          "lodash stubtrue": true
        },
        "options": {}
      },
      {
        "content": "_.times(${n}, ${iteratee})",
        "doc": "_.times(3, String);\n// => ['0', '1', '2']\n\n _.times(4, _.constant(0));\n// => [0, 0, 0, 0]\n\nInvokes the iteratee `n` times, returning an array of the results of\neach invocation. The iteratee is invoked with one argument; (index).",
        "grammar": "lsp",
        "label": "lodash-times",
        "matches": {
          "lodash times": true
        },
        "options": {}
      },
      {
        "content": "_.toPath(${value})",
        "doc": "_.toPath('a.b.c');\n// => ['a', 'b', 'c']\n\n_.toPath('a[0].b.c');\n// => ['a', '0', 'b', 'c']\n\nConverts `value` to a property path array.",
        "grammar": "lsp",
        "label": "lodash-topath",
        "matches": {
          "lodash topath": true
        },
        "options": {}
      },
      {
        "content": "_.uniqueId(${prefix})",
        "doc": "_.uniqueId('contact_');\n// => 'contact_104'\n\n_.uniqueId();\n// => '105'\n\nGenerates a unique ID. If `prefix` is given, the ID is appended to it.",
        "grammar": "lsp",
        "label": "lodash-uniqueid",
        "matches": {
          "lodash uniqueid": true
        },
        "options": {}
      },
      {
        "content": "_.add(${augend}, ${addend})",
        "doc": "_.add(6, 4);\n// => 10\n\nAdds two numbers.",
        "grammar": "lsp",
        "label": "lodash-add",
        "matches": {
          "lodash add": true
        },
        "options": {}
      },
      {
        "content": "_.ceil(${number}, ${precision})",
        "doc": "_.ceil(4.006);\n// => 5\n\n_.ceil(6.004, 2);\n// => 6.01\n\n_.ceil(6040, -2);\n// => 6100\n\nComputes `number` rounded up to `precision`.",
        "grammar": "lsp",
        "label": "lodash-ceil",
        "matches": {
          "lodash ceil": true
        },
        "options": {}
      },
      {
        "content": "_.divide(${dividend}, ${divisor})",
        "doc": "_.divide(6, 4);\n// => 1.5\n\nDivide two numbers.",
        "grammar": "lsp",
        "label": "lodash-divide",
        "matches": {
          "lodash divide": true
        },
        "options": {}
      },
      {
        "content": "_.floor(${number}, ${precision})",
        "doc": "_.floor(4.006);\n// => 4\n\n_.floor(0.046, 2);\n// => 0.04\n\n_.floor(4060, -2);\n// => 4000\n\nComputes `number` rounded down to `precision`.",
        "grammar": "lsp",
        "label": "lodash-floor",
        "matches": {
          "lodash floor": true
        },
        "options": {}
      },
      {
        "content": "_.max(${array})",
        "doc": "_.max([4, 2, 8, 6]);\n// => 8\n\n_.max([]);\n// => undefined\n\nComputes the maximum value of `array`. If `array` is empty or falsey,\n`undefined` is returned.",
        "grammar": "lsp",
        "label": "lodash-max",
        "matches": {
          "lodash max": true
        },
        "options": {}
      },
      {
        "content": "_.maxBy(${array}, ${iteratee})",
        "doc": "var objects = [{ 'n': 1 }, { 'n': 2 }];\n\n_.maxBy(objects, function(o) { return o.n; });\n// => { 'n': 2 }\n\n// The `_.property` iteratee shorthand.\n_.maxBy(objects, 'n');\n// => { 'n': 2 }\n\nThis method is like `_.max` except that it accepts `iteratee` which is\ninvoked for each element in `array` to generate the criterion by which\nthe value is ranked. The iteratee is invoked with one argument: (value).",
        "grammar": "lsp",
        "label": "lodash-maxby",
        "matches": {
          "lodash maxby": true
        },
        "options": {}
      },
      {
        "content": "_.mean(${array})",
        "doc": "_.mean([4, 2, 8, 6]);\n// => 5\n\nComputes the mean of the values in `array`.",
        "grammar": "lsp",
        "label": "lodash-mean",
        "matches": {
          "lodash mean": true
        },
        "options": {}
      },
      {
        "content": "_.meanBy(${array}, ${iteratee})",
        "doc": "var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n\n_.meanBy(objects, function(o) { return o.n; });\n// => 5\n\n// The `_.property` iteratee shorthand.\n_.meanBy(objects, 'n');\n// => 5\n\nThis method is like `_.mean` except that it accepts `iteratee` which is\ninvoked for each element in `array` to generate the value to be averaged.\nThe iteratee is invoked with one argument: (value).",
        "grammar": "lsp",
        "label": "lodash-meanby",
        "matches": {
          "lodash meanby": true
        },
        "options": {}
      },
      {
        "content": "_.min(${array})",
        "doc": "_.min([4, 2, 8, 6]);\n// => 2\n\n_.min([]);\n// => undefined\n\nComputes the minimum value of `array`. If `array` is empty or falsey,\n`undefined` is returned.",
        "grammar": "lsp",
        "label": "lodash-min",
        "matches": {
          "lodash min": true
        },
        "options": {}
      },
      {
        "content": "_.minBy(${array}, ${iteratee})",
        "doc": "var objects = [{ 'n': 1 }, { 'n': 2 }];\n\n_.minBy(objects, function(o) { return o.n; });\n// => { 'n': 1 }\n\n// The `_.property` iteratee shorthand.\n_.minBy(objects, 'n');\n// => { 'n': 1 }\n\nThis method is like `_.min` except that it accepts `iteratee` which is\ninvoked for each element in `array` to generate the criterion by which\nthe value is ranked. The iteratee is invoked with one argument: (value).",
        "grammar": "lsp",
        "label": "lodash-minby",
        "matches": {
          "lodash minby": true
        },
        "options": {}
      },
      {
        "content": "_.multiply(${multiplier}, ${multiplicand})",
        "doc": "_.multiply(6, 4);\n// => 24\n\nMultiply two numbers.",
        "grammar": "lsp",
        "label": "lodash-multiply",
        "matches": {
          "lodash multiply": true
        },
        "options": {}
      },
      {
        "content": "_.round(${number}, ${precision})",
        "doc": "_.round(4.006);\n// => 4\n\n_.round(4.006, 2);\n// => 4.01\n\n_.round(4060, -2);\n// => 4100\n\nComputes `number` rounded to `precision`.",
        "grammar": "lsp",
        "label": "lodash-round",
        "matches": {
          "lodash round": true
        },
        "options": {}
      },
      {
        "content": "_.subtract(${minuend}, ${subtrahend})",
        "doc": "_.subtract(6, 4);\n// => 2\n\nSubtract two numbers.",
        "grammar": "lsp",
        "label": "lodash-subtract",
        "matches": {
          "lodash subtract": true
        },
        "options": {}
      },
      {
        "content": "_.sum(${array})",
        "doc": "_.sum([4, 2, 8, 6]);\n// => 20\n\nComputes the sum of the values in `array`.",
        "grammar": "lsp",
        "label": "lodash-sum",
        "matches": {
          "lodash sum": true
        },
        "options": {}
      },
      {
        "content": "_.sumBy(${array}, ${iteratee})",
        "doc": "var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n\n_.sumBy(objects, function(o) { return o.n; });\n// => 20\n\n// The `_.property` iteratee shorthand.\n_.sumBy(objects, 'n');\n// => 20\n\nThis method is like `_.sum` except that it accepts `iteratee` which is\ninvoked for each element in `array` to generate the value to be summed.\nThe iteratee is invoked with one argument: (value).",
        "grammar": "lsp",
        "label": "lodash-sumby",
        "matches": {
          "lodash sumby": true
        },
        "options": {}
      }
    ],
    "lpc": [
      {
        "content": "#include <${1:stdio}.h>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "inc": true
        },
        "options": {}
      },
      {
        "content": "#ifndef $1\n#define ${1:SYMBOL} ${2:value}\n#endif /* ifndef $1 */",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ndef": true
        },
        "options": {}
      },
      {
        "content": "#define",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "def": true
        },
        "options": {}
      },
      {
        "content": "#ifdef ${1:FOO}\n\t${2:#define }\n#endif",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifdef": true
        },
        "options": {}
      },
      {
        "content": "#if ${1:FOO}\n\t${0:${VISUAL}}\n#endif",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#if": true
        },
        "options": {}
      },
      {
        "content": "if(${1:true})\n{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "if(${1:true})\n{\n\t${2:${VISUAL}}\n}\nelse\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "else\n{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "el": true
        },
        "options": {}
      },
      {
        "content": "else if(${1:true})\n{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "elif": true
        },
        "options": {}
      },
      {
        "content": "if(${1:true}) ${0};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifi": true
        },
        "options": {}
      },
      {
        "content": "${1:/* condition */} ? ${2:a} : ${3:b}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "t": true
        },
        "options": {}
      },
      {
        "content": "switch(${1:/* variable */})\n{\n\tcase ${2:/* variable case */}:\n\t\t${3}\n\t\t${4:break;}${5}\n\tdefault:\n\t\t${6}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "switch": true
        },
        "options": {}
      },
      {
        "content": "switch(${1:/* variable */})\n{\n\tcase ${2:/* variable case */}:\n\t\t${3}\n\t\t${4:break;}${5}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "switchndef": true
        },
        "options": {}
      },
      {
        "content": "case ${1:/* variable case */}:\n\t${2}\n\t${3:break;}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case": true
        },
        "options": {}
      },
      {
        "content": "return ${0};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ret": true
        },
        "options": {}
      },
      {
        "content": "foreach(${1:mixed} ${2:ele} in ${3:arr})\n{\n\t${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fore": true
        },
        "options": {}
      },
      {
        "content": "for(int ${2:i} = 0; $2 < ${1:count}; $2${3:++})\n{\n\t${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "for(int ${1:i} = ${2:0}; ${3:$1 < 10}; $1${4:++})\n{\n\t${5}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forr": true
        },
        "options": {}
      },
      {
        "content": "while(${1:/* condition */})\n{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh": true
        },
        "options": {}
      },
      {
        "content": "do{\n\t${0:${VISUAL}}\n}while (${1:/* condition */});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "do": true
        },
        "options": {}
      },
      {
        "content": "${1:void} ${2:function_name}(${3})\n{\n\t${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fnc": true
        },
        "options": {}
      },
      {
        "content": "${1:void} ${2:function_name}()\n{\n\t${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defun0": true
        },
        "options": {}
      },
      {
        "content": "${1:void} ${2:function_name}(${3:Type} ${4:Parameter})\n{\n\t${5}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defun1": true
        },
        "options": {}
      },
      {
        "content": "${1:void} ${2:function_name}(${3:Type} ${4:Parameter}, ${5:Type} ${6:Parameter})\n{\n\t${7}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defun2": true
        },
        "options": {}
      },
      {
        "content": "${1:void} ${2:function_name}(${3:Type} ${4:Parameter}, ${5:Type} ${6:Parameter}, ${7:Type} ${8:Parameter})\n{\n\t${9}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defun3": true
        },
        "options": {}
      },
      {
        "content": "${1:void} ${2:function_name}(${3});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fund": true
        },
        "options": {}
      },
      {
        "content": "printf(\"${1:%s}\\n\"${2});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pr": true
        },
        "options": {}
      },
      {
        "content": "fprintf(${1:stderr}, \"${2:%s}\\n\"${3});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fpr": true
        },
        "options": {}
      },
      {
        "content": "printf(\"${1:} = %d\\n\", $1);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prd": true
        },
        "options": {}
      },
      {
        "content": "printf(\"${1:} = %f\\n\", $1);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prf": true
        },
        "options": {}
      },
      {
        "content": "printf(\"${1:} = %${2}\\n\", $1);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prx": true
        },
        "options": {}
      },
      {
        "content": "/*! TODO: ${1:Todo description here} */",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "todo": true
        },
        "options": {}
      },
      {
        "content": "[${1}]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ".": true
        },
        "options": {}
      }
    ],
    "ls": [
      {
        "content": "for ${1:name} in ${2:array}\n\tlet $1\n\t\t${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forinlet": true
        },
        "options": {}
      },
      {
        "content": "for ${1:name} in ${2:array}\n\t${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fora": true
        },
        "options": {}
      },
      {
        "content": "for ${1:key}, ${2:value} of ${3:object}\n\t${4}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "foro": true
        },
        "options": {}
      },
      {
        "content": "for ${1:name} from ${2:start} to ${3:finish}\n\t${4}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forr": true
        },
        "options": {}
      },
      {
        "content": "for ${1:name} from ${2:start} to ${3:finish} by ${4:step}\n\t${5}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forrb": true
        },
        "options": {}
      },
      {
        "content": "for ${1:name} from ${2:start} til ${3:finish}\n\t${4}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forrex": true
        },
        "options": {}
      },
      {
        "content": "for ${1:name} from ${2:start} til ${3:finish} by ${4:step}\n\t${5}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forrexb": true
        },
        "options": {}
      },
      {
        "content": "(${1:args}) ->\n\t${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fun": true
        },
        "options": {}
      },
      {
        "content": "(${1:args}) ~>\n\t${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bfun": true
        },
        "options": {}
      },
      {
        "content": "if ${1:condition}\n\t${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "if ${1:condition}\n\t${2}\nelse\n\t${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "else if ${1:condition}\n\t${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "elif": true
        },
        "options": {}
      },
      {
        "content": "if ${1:condition} then ${2:value} else ${3:other}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifte": true
        },
        "options": {}
      },
      {
        "content": "${1:action} unless ${2:condition}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "unl": true
        },
        "options": {}
      },
      {
        "content": "switch ${1:object}\ncase ${2:value}\n\t${3}\ndefault void",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "swi": true
        },
        "options": {}
      },
      {
        "content": "match ${1:object}\n| ${2:value} => ${3}\n| otherwise => void",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mat": true
        },
        "options": {}
      },
      {
        "content": "console.log ${1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "log": true
        },
        "options": {}
      },
      {
        "content": "JSON.stringify ${1}, void, 2",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "str": true
        },
        "options": {}
      },
      {
        "content": "try\n\t${1:${VISUAL}}\ncatch ${2:error}\n\t${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "try": true
        },
        "options": {}
      },
      {
        "content": "${2:$1} = require '${1}'${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "req": true
        },
        "options": {}
      },
      {
        "content": "require! ${1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "req!": true
        },
        "options": {}
      },
      {
        "content": "${1:root} = exports ? this",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "exp": true
        },
        "options": {}
      }
    ],
    "lua": [
      {
        "content": "function ${1:#:function_name}(${2:#:argument})\n\t${0:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "function name(args)...end",
        "matches": {
          "func": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "if ${1:#:condition} then\n  ${0:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "for ${2:i} = 0, ${1:#:Things} do\n  ${0:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "for ${2:k}, ${3:v} in ${1:ipairs(xs)} do\n  ${0:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forin": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "for k, v in ipairs(${1:table}) do\n  print(k, v)\nend",
        "doc": "",
        "grammar": "snu",
        "label": "for k, v in ipairs(table) do",
        "matches": {
          "print_table": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "print(${0:TARGET})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p": true,
          "print": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "[[${0:TARGET}]]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "comment": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "describe(${1:#:message}, function()\n  ${0:TARGET}\nend)",
        "doc": "",
        "grammar": "snu",
        "label": "describe(message, func)",
        "matches": {
          "describe": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "it(${1:#:message}, function()\n  ${0:TARGET}\nend)",
        "doc": "",
        "grammar": "snu",
        "label": "it(message, func)",
        "matches": {
          "it": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "before_each(function()\n  ${0:TARGET}\nend)",
        "doc": "",
        "grammar": "snu",
        "label": "before_each(func)",
        "matches": {
          "before_each": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "after_each(function()\n  ${0:TARGET}\nend)",
        "doc": "",
        "grammar": "snu",
        "label": "after_each(func)",
        "matches": {
          "after_each": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "setup(function()\n  ${0:TARGET}\nend)",
        "doc": "",
        "grammar": "snu",
        "label": "setup(func)",
        "matches": {
          "setup": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "tear_down(function()\n  ${0:TARGET}\nend)",
        "doc": "",
        "grammar": "snu",
        "label": "tear_down(func)",
        "matches": {
          "tear_down": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "finally(function()\n  ${0:TARGET}\nend)",
        "doc": "",
        "grammar": "snu",
        "label": "finally(func)",
        "matches": {
          "finally": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "#!/usr/bin/env lua\n$1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#!": true
        },
        "options": {}
      },
      {
        "content": "local ${1:x} = ${0:1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "local": true
        },
        "options": {}
      },
      {
        "content": "function ${1:fname}(${2:...})\n\t${0:-- body}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fun": true
        },
        "options": {}
      },
      {
        "content": "for ${1:i}=${2:1},${3:10} do\n\t${0:print(i)}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "for ${1:i},${2:v} in pairs(${3:table_name}) do\n\t${0:-- body}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forp": true
        },
        "options": {}
      },
      {
        "content": "for ${1:i},${2:v} in ipairs(${3:table_name}) do\n\t${0:-- body}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fori": true
        },
        "options": {}
      },
      {
        "content": "if ${1:condition} then\n\t${2:-- body}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "if ${1:condition} then\n\t${2:-- if condition}\nelse\n\t${0:-- else}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "elseif ${1:condition} then\n\t${0:--body}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "elif": true
        },
        "options": {}
      },
      {
        "content": "repeat\n\t${1:--body}\nuntil ${0:condition}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "repeat": true
        },
        "options": {}
      },
      {
        "content": "while ${1:condition} do\n\t${0:--body}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "while": true
        },
        "options": {}
      },
      {
        "content": "print(\"${1:string}\")",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "print": true
        },
        "options": {}
      },
      {
        "content": "import \"${1:import file}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "im": true
        },
        "options": {}
      },
      {
        "content": "#!/usr/bin/env lua\n$0",
        "doc": "",
        "grammar": "snu",
        "label": "#!/usr/bin/env lua",
        "matches": {
          "#!": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "function ${1:new_function}(${2:args})\n\t$0\nend",
        "doc": "",
        "grammar": "snu",
        "label": "New function",
        "matches": {
          "!fun(ction)?!": true
        },
        "options": {
          "b": true,
          "r": true
        }
      },
      {
        "content": "for ${1:name},${2:val} in pairs(${3:table_name}) do\n\t$0\nend",
        "doc": "",
        "grammar": "snu",
        "label": "pair for loop",
        "matches": {
          "forp": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "for ${1:idx},${2:val} in ipairs(${3:table_name}) do\n\t$0\nend",
        "doc": "",
        "grammar": "snu",
        "label": "ipair for foop",
        "matches": {
          "fori": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "do\n\t$0\nend",
        "doc": "",
        "grammar": "snu",
        "label": "do block",
        "matches": {
          "do": true
        },
        "options": {}
      },
      {
        "content": "repeat\n\t$1\nuntil $0",
        "doc": "",
        "grammar": "snu",
        "label": "repeat loop",
        "matches": {
          "repeat": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "while $1 do\n\t$0\nend",
        "doc": "",
        "grammar": "snu",
        "label": "while loop",
        "matches": {
          "while": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "if $1 then\n\t$0\nend",
        "doc": "",
        "grammar": "snu",
        "label": "if statement",
        "matches": {
          "if": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "if $1 then\n\t$2\nelse\n\t$0\nend",
        "doc": "",
        "grammar": "snu",
        "label": "if/else statement",
        "matches": {
          "ife": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "if $1 then\n\t$2\nelseif $3 then\n\t$0\nend",
        "doc": "",
        "grammar": "snu",
        "label": "if/elseif statement",
        "matches": {
          "eif": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "if $1 then\n\t$2\nelseif $3 then\n\t$4\nelse\n\t$0\nend",
        "doc": "",
        "grammar": "snu",
        "label": "if/elseif/else statement",
        "matches": {
          "eife": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "local ok, err = pcall(${1:your_function})\nif not ok then\n\thandler(${2:ok, err})\n${3:else\n\tsuccess(${4:ok, err})\n}end",
        "doc": "",
        "grammar": "snu",
        "label": "pcall statement",
        "matches": {
          "pcall": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "local ${1:x} = ${0:1}",
        "doc": "",
        "grammar": "snu",
        "label": "local x = 1",
        "matches": {
          "local": true
        },
        "options": {}
      }
    ],
    "make": [
      {
        "content": "CFLAGS=-Wall -g ${0: -llua -lzeromq}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "CFLAGS": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "clean:\n  rm -f ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "clean:": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": ".PHONY: clean, mrproper\nCC = gcc\nCFLAGS = -g -Wall\nall: $1\n%.o: %.c\n\t$(CC) $(CFLAGS) -c -o $@ $<\n${1:out}: $1.o\n\t$(CC) $(CFLAGS) -o $@ $+\nclean:\n\trm -f *.o core.*\nmrproper: clean\n\trm -f $1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "base": true
        },
        "options": {}
      },
      {
        "content": "${1:out}: $1.o\n\t$(CC) $(CFLAGS) -o $@ $+",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "add": true
        },
        "options": {}
      },
      {
        "content": "print-%: ; @echo $*=$($*)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "print": true
        },
        "options": {}
      },
      {
        "content": "ifeq (${1:cond0}, ${2:cond1})\n\t${0:${VISUAL}}\nendif",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "ifeq (${1:cond0}, ${2:cond1})\n\t${3:${VISUAL}}\nelse\n\t${0}\nendif",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "else\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "el": true
        },
        "options": {}
      },
      {
        "content": ".DEFAULT_GOAL := ${1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "default": true
        },
        "options": {}
      },
      {
        "content": "help: ## Prints help for targets with comments\n\t@cat $(MAKEFILE_LIST) | grep -E '^[a-zA-Z_-]+:.*?## .*$$' | awk 'BEGIN {FS = \":.*?## \"}; {printf \"\\033[36m%-30s\\033[0m %s\\n\", $\\$1, $\\$2}'\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "help": true
        },
        "options": {}
      }
    ],
    "mako": [
      {
        "content": "<%def name=\"${1:name}\">\n\t${0:}\n</%def>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "def": true
        },
        "options": {}
      },
      {
        "content": "<%call expr=\"${1:name}\">\n\t${0:}\n</%call>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "call": true
        },
        "options": {}
      },
      {
        "content": "<%doc>\n\t${0:}\n</%doc>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "doc": true
        },
        "options": {}
      },
      {
        "content": "<%text>\n\t${0:}\n</%text>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "text": true
        },
        "options": {}
      },
      {
        "content": "% for ${1:i} in ${2:iter}:\n\t${0:}\n% endfor",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "% if ${1:condition}:\n\t${0:}\n% endif",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if if": true
        },
        "options": {}
      },
      {
        "content": "% if ${1:condition}:\n\t${2:}\n% else:\n\t${0:}\n% endif",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife if/else": true
        },
        "options": {}
      },
      {
        "content": "% try:\n\t${1:${VISUAL}}\n% except${2:}:\n\t${0:pass}\n% endtry",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "try": true
        },
        "options": {}
      },
      {
        "content": "% while ${1:}:\n\t${0:}\n% endwhile",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh": true
        },
        "options": {}
      },
      {
        "content": "<% ${0:} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "<%": true
        },
        "options": {}
      },
      {
        "content": "<!% ${0:} %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "<!%": true
        },
        "options": {}
      },
      {
        "content": "<%inherit file=\"${0:filename}\" />",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "inherit": true
        },
        "options": {}
      },
      {
        "content": "<%include file=\"${0:filename}\" />",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "include": true
        },
        "options": {}
      },
      {
        "content": "<%namespace file=\"${0:name}\" />",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "namespace": true
        },
        "options": {}
      },
      {
        "content": "<%page args=\"${0:}\" />",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "page": true
        },
        "options": {}
      },
      {
        "content": "<%def name=\"${1:name}\">\n\t${2:}\n</%def>",
        "doc": "",
        "grammar": "snu",
        "label": "definition",
        "matches": {
          "def": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "<%call expr=\"${1:name}\">\n\t${2:}\n</%call>",
        "doc": "",
        "grammar": "snu",
        "label": "call",
        "matches": {
          "call": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "<%doc>\n\t${1:}\n</%doc>",
        "doc": "",
        "grammar": "snu",
        "label": "doc",
        "matches": {
          "doc": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "<%text>\n\t${1:}\n</%text>",
        "doc": "",
        "grammar": "snu",
        "label": "text",
        "matches": {
          "text": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "% for ${1:i} in ${2:iter}:\n\t${3:}\n% endfor",
        "doc": "",
        "grammar": "snu",
        "label": "for",
        "matches": {
          "for": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "% if ${1:condition}:\n\t${2:}\n% endif",
        "doc": "",
        "grammar": "snu",
        "label": "if ",
        "matches": {
          "if": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "% if ${1:condition}:\n\t${2:}\n% else:\n\t${3:}\n% endif",
        "doc": "",
        "grammar": "snu",
        "label": "if/else",
        "matches": {
          "if": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "% try:\n\t${1:}\n% except${2:}:\n\t${3:pass}\n% endtry",
        "doc": "",
        "grammar": "snu",
        "label": "try",
        "matches": {
          "try": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "% while ${1:}:\n\t${2:}\n% endwhile",
        "doc": "",
        "grammar": "snu",
        "label": "wh",
        "matches": {
          "wh": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "${${1:}}",
        "doc": "",
        "grammar": "snu",
        "label": "$",
        "matches": {
          "$": true
        },
        "options": {
          "i": true
        }
      },
      {
        "content": "<% ${1:} %>",
        "doc": "",
        "grammar": "snu",
        "label": "<%",
        "matches": {
          "<%": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "<!% ${1:} %>",
        "doc": "",
        "grammar": "snu",
        "label": "<!%",
        "matches": {
          "<!%": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "<%inherit file=\"${1:filename}\" />",
        "doc": "",
        "grammar": "snu",
        "label": "inherit",
        "matches": {
          "inherit": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "<%include file=\"${1:filename}\" />",
        "doc": "",
        "grammar": "snu",
        "label": "include",
        "matches": {
          "include": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "<%namespace file=\"${1:name}\" />",
        "doc": "",
        "grammar": "snu",
        "label": "namespace",
        "matches": {
          "namespace": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "<%page args=\"${1:}\" />",
        "doc": "",
        "grammar": "snu",
        "label": "page",
        "matches": {
          "page": true
        },
        "options": {
          "b": true
        }
      }
    ],
    "markdown": [
      {
        "content": "# ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "# section heading",
        "matches": {
          "heading": true,
          "section": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "[${1:#:link_id}][]${2}",
        "doc": "",
        "grammar": "snu",
        "label": "[link][]",
        "matches": {
          "link": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "[${1:#:link}][${2:id}]${3}",
        "doc": "",
        "grammar": "snu",
        "label": "[link][id]",
        "matches": {
          "linkid": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "[${1:#:link}](https://${2:#:url})${3}",
        "doc": "",
        "grammar": "snu",
        "label": "[link](url)",
        "matches": {
          "linkurl": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "[${1:#:link}](mailto:${2:#:email})${3}",
        "doc": "",
        "grammar": "snu",
        "label": "[link](email)",
        "matches": {
          "linkemail": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "[${1:#:link}](${2:#:url} \"${3:#:title}\")${4}",
        "doc": "",
        "grammar": "snu",
        "label": "[link](url \"title\")",
        "matches": {
          "linkurltitle": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "[${1:#:id}]: https://${2:#:url} \"${3:#:title}\"",
        "doc": "",
        "grammar": "snu",
        "label": "[id]: url \"title\"",
        "matches": {
          "idurl": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "[${1:#:id}]: mailto:${2:#:url} \"${3:#:title}\"",
        "doc": "",
        "grammar": "snu",
        "label": "[id]: email \"title\"",
        "matches": {
          "idemail": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "![${1:#:alt}][${2:#:id}]${3}",
        "doc": "",
        "grammar": "snu",
        "label": "![alt][id]",
        "matches": {
          "altid": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "![${1:#:alt}](${2:#:url})${3}",
        "doc": "",
        "grammar": "snu",
        "label": "![alt](url)",
        "matches": {
          "alturl": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "![${1:#:alt}](${2:#:url} \"${3:#:title}\")${4}",
        "doc": "",
        "grammar": "snu",
        "label": "![alt](url \"title\")",
        "matches": {
          "alturltitle": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "*${1}*${2}",
        "doc": "",
        "grammar": "snu",
        "label": "*emphasis*",
        "matches": {
          "emphasis1": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "_${1}_${2}",
        "doc": "",
        "grammar": "snu",
        "label": "_emphasis_",
        "matches": {
          "emphasis2": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "**${1}**${2}",
        "doc": "",
        "grammar": "snu",
        "label": "**strong**",
        "matches": {
          "strong1": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "__${1}__${2}",
        "doc": "",
        "grammar": "snu",
        "label": "__strong__",
        "matches": {
          "strong2": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "quote block",
        "matches": {
          "blockquote": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "[${1:text}](https://${2:address})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "[": true
        },
        "options": {}
      },
      {
        "content": "[${1:text}](https://${2:address} \"${3:title}\")",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "[\"": true
        },
        "options": {}
      },
      {
        "content": "[${1:id}]: https://${2:url}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "[:": true
        },
        "options": {}
      },
      {
        "content": "[${1:id}]: https://${2:url} \"${3:title}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "[:\"": true
        },
        "options": {}
      },
      {
        "content": "![${1:alttext}](${2:/images/image.jpg})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "![": true
        },
        "options": {}
      },
      {
        "content": "![${1:alttext}](${2:/images/image.jpg} \"${3:title}\")",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "![\"": true
        },
        "options": {}
      },
      {
        "content": "![${1:id}]: ${2:url}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "![:": true
        },
        "options": {}
      },
      {
        "content": "![${1:id}]: ${2:url} \"${3:title}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "![:\"": true
        },
        "options": {}
      },
      {
        "content": "<http://${1:url}>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "<": true
        },
        "options": {}
      },
      {
        "content": "**${1:bold}**",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "**": true
        },
        "options": {}
      },
      {
        "content": "__${1:bold}__",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "__": true
        },
        "options": {}
      },
      {
        "content": "-   ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "-": true
        },
        "options": {}
      },
      {
        "content": "{% blockquote %}\n${0:quote}\n{% endblockquote %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "blockquote": true
        },
        "options": {}
      },
      {
        "content": "{% blockquote ${1:author}, ${2:title} %}\n${0:quote}\n{% endblockquote %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "blockquote-author": true
        },
        "options": {}
      },
      {
        "content": "{% blockquote ${1:author} ${2:URL} ${3:link_text} %}\n${0:quote}\n{% endblockquote %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "blockquote-link": true
        },
        "options": {}
      },
      {
        "content": "{% codeblock %}\n${0:code_snippet}\n{% endcodeblock %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "codeblock-short": true
        },
        "options": {}
      },
      {
        "content": "{% codeblock ${1:title} lang:${2:language} ${3:URL} ${4:link_text} %}\n${0:code_snippet}\n{% endcodeblock %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "codeblock-full": true
        },
        "options": {}
      },
      {
        "content": "{% gist ${1:gist_id} ${0:filename} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gist-full": true
        },
        "options": {}
      },
      {
        "content": "{% gist ${0:gist_id} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gist-short": true
        },
        "options": {}
      },
      {
        "content": "{% img ${1:class} ${2:URL} ${3:width} ${4:height} ${5:title_text} ${0:alt_text} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "img": true
        },
        "options": {}
      },
      {
        "content": "{% youtube ${0:video_id} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "youtube": true
        },
        "options": {}
      },
      {
        "content": "|  ${0:factors}      |    ${1:a}       |  ${2:b}   \t|\n| ------------- |-------------  | ------- |\n|    ${3:f1}    |    Y          | N       |\n|    ${4:f2}    |    Y          | N       |",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tb": true
        },
        "options": {}
      },
      {
        "content": "{% pullquote %}\n${1:text} {\" ${2:quote} \"} ${0:text}\n{% endpullquote %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pullquote": true
        },
        "options": {}
      }
    ],
    "matlab": [
      {
        "content": "if ${1}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if if": true
        },
        "options": {}
      },
      {
        "content": "if ${1}\n\t${2}\nelse\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife if ... else": true
        },
        "options": {}
      },
      {
        "content": "else\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "el else": true
        },
        "options": {}
      },
      {
        "content": "elseif ${1}\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eif elsif": true
        },
        "options": {}
      },
      {
        "content": "while ${1}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh while": true
        },
        "options": {}
      },
      {
        "content": "for ${1:i} = ${2:1:n}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for for": true
        },
        "options": {}
      },
      {
        "content": "parfor ${1:i} = ${2:1:n}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "parfor parfor": true
        },
        "options": {}
      },
      {
        "content": "try\n\t${1}\ncatch ${2:err}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "try try ... catch": true
        },
        "options": {}
      },
      {
        "content": "switch ${1:n}\n\tcase ${2:0}\n\t\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "switch switch": true
        },
        "options": {}
      },
      {
        "content": "@(${1:x}) ${0:x*x}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@ anonymous function": true
        },
        "options": {}
      },
      {
        "content": "switch ${1:n}\n\tcase ${2:0}\n\t\t${3}${4:\n\totherwise\n\t\t${5}}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "switch ... otherwise",
        "matches": {
          "switch": true
        },
        "options": {}
      }
    ],
    "mediawiki": [
      {
        "content": "== ${1} ==\n${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "==": true
        },
        "options": {}
      },
      {
        "content": "=== ${1} ===\n${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "===": true
        },
        "options": {}
      },
      {
        "content": "==== ${1} ====\n${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "====": true
        },
        "options": {}
      },
      {
        "content": "===== ${1} =====\n${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "=====": true
        },
        "options": {}
      },
      {
        "content": "====== ${1} ======\n${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "======": true
        },
        "options": {}
      },
      {
        "content": "[[${1}]] ${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "[[": true
        },
        "options": {}
      },
      {
        "content": "''${1}''",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "''": true
        },
        "options": {}
      },
      {
        "content": "'''${1}'''",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "'''": true
        },
        "options": {}
      },
      {
        "content": "'''''${1}'''''",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "'''''": true
        },
        "options": {}
      },
      {
        "content": "<syntaxhighlight lang=\"${1}\">\n${2}\n</syntaxhighlight>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sy": true
        },
        "options": {}
      },
      {
        "content": "<pre>\n${1}\n</pre>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pre": true
        },
        "options": {}
      },
      {
        "content": "<html>\n${1}\n</html>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "html": true
        },
        "options": {}
      },
      {
        "content": "<nowiki>${1}</nowiki>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nowiki": true
        },
        "options": {}
      },
      {
        "content": "<tt>${1}</tt>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tt": true
        },
        "options": {}
      },
      {
        "content": "<blockquote>${1}</blockquote>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "blockquote": true
        },
        "options": {}
      },
      {
        "content": "<!--\nvim: filetype=mediawiki\n-->",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ft": true
        },
        "options": {}
      },
      {
        "content": "{|class=\"wikitable\"\n|+ ${1}\n! ${2}\n! ${3}\n|-\n| ${4}\n| ${5}\n|-\n| ${6}\n| ${7}\n|-\n|\n|\n|}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "{|": true
        },
        "options": {}
      }
    ],
    "mkd": [],
    "moon": [
      {
        "content": "print 'Hello world!'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "helloworld": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "[${0:TARGET} for ${1:x} in ${2:xs}]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "map": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "moon.p ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "${1:f} = (${2:args}) ->\n  ${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defn": true
        },
        "options": {}
      },
      {
        "content": "${1:f}: (${2:args}) =>\n  ${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defm": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "${1:moon} = require '$1'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "require": true
        },
        "options": {
          "head": true
        }
      }
    ],
    "mustache": [
      {
        "content": "{{#${1:value}}}\n${0:${VISUAL}}\n{{/$1}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if # {{#value}} ... {{/value}}": true
        },
        "options": {}
      },
      {
        "content": "{{^${1:value}}}\n${0:${VISUAL}}\n{{/$1}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifn # {{^value}} ... {{/value}}": true
        },
        "options": {}
      },
      {
        "content": "{{#${1:value}}}\n${2:${VISUAL}}\n{{/$1}}\n{{^$1}}\n${3}\n{{/$1}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife # {{#value}} ... {{/value}} {{^value}} ... {{/value}}": true
        },
        "options": {}
      }
    ],
    "neosnippet": [
      {
        "content": "snippet     ${1:#:trigger}\nabbr        ${2:#:abbr}\noptions     head\n    ${3:#:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "snippet abbr options <snippet code>",
        "matches": {
          "snip": true,
          "snippet": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "include ${0:filetype}.snip",
        "doc": "",
        "grammar": "snu",
        "label": "include *.snip",
        "matches": {
          "inc": true,
          "include": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "${${0:0}}",
        "doc": "",
        "grammar": "snu",
        "label": "${..}",
        "matches": {
          "$": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "\\${0}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "${0}",
        "matches": {
          "0": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "\\${1}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "${1}",
        "matches": {
          "1": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "\\${2}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "${2}",
        "matches": {
          "2": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "\\${3}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "${3}",
        "matches": {
          "3": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "\\${4}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "${4}",
        "matches": {
          "4": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "\\${5}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "${5}",
        "matches": {
          "5": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "${${1:0}:${0:default}}",
        "doc": "",
        "grammar": "snu",
        "label": "${X:default}",
        "matches": {
          "$:": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "\\${0:${0:default}}",
        "doc": "",
        "grammar": "snu",
        "label": "${0:default}",
        "matches": {
          "0:": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "\\${1:${0:default}}",
        "doc": "",
        "grammar": "snu",
        "label": "${1:default}",
        "matches": {
          "1:": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "\\${2:${0:default}}",
        "doc": "",
        "grammar": "snu",
        "label": "${2:default}",
        "matches": {
          "2:": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "\\${3:${0:default}}",
        "doc": "",
        "grammar": "snu",
        "label": "${3:default}",
        "matches": {
          "3:": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "\\${4:${0:default}}",
        "doc": "",
        "grammar": "snu",
        "label": "${4:default}",
        "matches": {
          "4:": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "\\${5:${0:default}}",
        "doc": "",
        "grammar": "snu",
        "label": "${5:default}",
        "matches": {
          "5:": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "${${1:0}#${0:optional}}",
        "doc": "",
        "grammar": "snu",
        "label": "${X#optional}",
        "matches": {
          "$#": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "\\${0:#${0:optional}}",
        "doc": "",
        "grammar": "snu",
        "label": "${0:#optional}",
        "matches": {
          "0#": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "\\${1:#${0:optional}}",
        "doc": "",
        "grammar": "snu",
        "label": "${1:#optional}",
        "matches": {
          "1#": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "\\${2:#${0:optional}}",
        "doc": "",
        "grammar": "snu",
        "label": "${2:#optional}",
        "matches": {
          "2#": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "\\${3:#${0:optional}}",
        "doc": "",
        "grammar": "snu",
        "label": "${3:#optional}",
        "matches": {
          "3#": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "\\${4:#${0:optional}}",
        "doc": "",
        "grammar": "snu",
        "label": "${4:#optional}",
        "matches": {
          "4#": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "\\${5:#${0:optional}}",
        "doc": "",
        "grammar": "snu",
        "label": "${5:#optional}",
        "matches": {
          "5#": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "${${0:0}:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "${*:TARGET}",
        "matches": {
          "T": true,
          "TARGET": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "\\${0:TARGET}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "${0:TARGET}",
        "matches": {
          "0T": true,
          "0t": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "\\${1:TARGET}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "${1:TARGET}",
        "matches": {
          "1T": true,
          "1t": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "\\${2:TARGET}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "${2:TARGET}",
        "matches": {
          "2T": true,
          "2t": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "\\${3:TARGET}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "${3:TARGET}",
        "matches": {
          "3T": true,
          "3t": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "\\${4:TARGET}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "${4:TARGET}",
        "matches": {
          "4T": true,
          "4t": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "\\${5:TARGET}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "${5:TARGET}",
        "matches": {
          "5T": true,
          "5t": true
        },
        "options": {
          "word": true
        }
      }
    ],
    "next": [
      {
        "content": "export async function getServerSideProps(${1:context}) {\n  return {\n    props: {}, \n  }\n}",
        "doc": "If you export an async function called getServerSideProps from a page, Next.js will pre-render this page on each request using the data returned by getServerSideProps. The context parameter is an object containing the following keys: params, req, res, query, preview, previewData.",
        "grammar": "lsp",
        "label": "next-get-server-side-props",
        "matches": {
          "next getserversideprops": true
        },
        "options": {}
      },
      {
        "content": "export async function getStaticProps(${1:context}) {\n  return {\n    props: {}, \n  }\n}",
        "doc": "If you export an async function called getStaticProps from a page, Next.js will pre-render this page at build time using the props returned by getStaticProps. The context parameter is an object containing the following keys: params, preview, previewData.",
        "grammar": "lsp",
        "label": "next-get-static-props",
        "matches": {
          "next getstaticprops": true
        },
        "options": {}
      },
      {
        "content": "export async function getStaticPaths() {\n  return {\n    paths: [\n      { params: { ... } } \n    ],\n    fallback: ${1|true,false|}\n  };\n}",
        "doc": "If a page has dynamic routes (documentation) and uses getStaticProps it needs to define a list of paths that have to be rendered to HTML at build time. If you export an async function called getStaticPaths from a page that uses dynamic routes, Next.js will statically pre-render all the paths specified by getStaticPaths.",
        "grammar": "lsp",
        "label": "next-get-static-paths",
        "matches": {
          "next getstaticpaths": true
        },
        "options": {}
      },
      {
        "content": "import { useRouter } from 'next/router'",
        "doc": "",
        "grammar": "lsp",
        "label": "next-import-use-router",
        "matches": {
          "next import userouter": true
        },
        "options": {}
      },
      {
        "content": "import Link from 'next/link'",
        "doc": "",
        "grammar": "lsp",
        "label": "next-import-link",
        "matches": {
          "next import link": true
        },
        "options": {}
      },
      {
        "content": "<Link href=\"${1:#}\">\n  <a>${2:content}</a>\n</Link>",
        "doc": "Link accepts the following props: href, as, passHref, prefetch, replace, scroll, shallow",
        "grammar": "lsp",
        "label": "next-link",
        "matches": {
          "next link": true
        },
        "options": {}
      },
      {
        "content": "<Link href={{ pathname: '${1:/path}', query: { ${2:paramName}: '${3:paramValue}' } }}>\n  <a>${4:content}</a>\n</Link>",
        "doc": "",
        "grammar": "lsp",
        "label": "next-link-url-object",
        "matches": {
          "next link url object": true
        },
        "options": {}
      },
      {
        "content": "<Link href=\"${1:/path/[id]}\" as=\"${2:/path/${id}}\">\n  <a>${3:content}</a>\n</Link>",
        "doc": "",
        "grammar": "lsp",
        "label": "next-link-dynamic-route",
        "matches": {
          "next link dynamic route": true
        },
        "options": {}
      },
      {
        "content": "import Head from 'next/head'",
        "doc": "",
        "grammar": "lsp",
        "label": "next-import-head",
        "matches": {
          "next import head": true
        },
        "options": {}
      },
      {
        "content": "<Head>\n${1:content}\n</Head>",
        "doc": "",
        "grammar": "lsp",
        "label": "next-head",
        "matches": {
          "next head": true
        },
        "options": {}
      },
      {
        "content": "export default (req, res) => {\n  res.json(${1:object});\n};",
        "doc": "API routes provide built in middlewares which parse the incoming request. Those middlewares are: req.cookies, req.body, req.query.",
        "grammar": "lsp",
        "label": "next-api",
        "matches": {
          "next api": true
        },
        "options": {}
      },
      {
        "content": "export default (req, res) => {\n  if (req.method === 'POST') {\n    $1\n  } else {\n    $2\n  }\n};",
        "doc": "",
        "grammar": "lsp",
        "label": "next-api-method",
        "matches": {
          "next api method": true
        },
        "options": {}
      }
    ],
    "nim": [
      {
        "content": "proc ${1:#:name}(${2}) =\n  ${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "proc": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "proc ${1:#:name}(${2}):\ndiscard \"\"\"${3:#:function documentation}\"\"\"\n  ${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "procd": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "proc ${1:#:name}(${2}):${3:#:type} =\n  ${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "proct": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "proc ${1:#:name}(${2}) =\n  ${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "procg": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "proc ${1:#:name}(${2}):${3:#:type} =\n  ${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "procgt": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "template ${1:#:name}(${2}):${3:type} =\n  ${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "template": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "macro ${1:#:name}(${2}):${3:type} =\n  ${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "macro": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "elif ${1:#:condition}:\n  ${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "elif ...: ...",
        "matches": {
          "elif": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "else:\n  ${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "else: ...",
        "matches": {
          "else": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "for ${1:#:value} in ${2:#:list}:\n  ${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "for ... in ...: ...",
        "matches": {
          "for": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "if ${1:#:condition}:\n  ${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "if ...: ...",
        "matches": {
          "if": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "when ${1:#:condition}:\n  ${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "when ...: ...",
        "matches": {
          "when": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "if isMainModule:\n  ${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "if isMainModule: ...",
        "matches": {
          "ifmain": true,
          "main": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "try:\n  ${1:pass}\nexcept ${2:#:ExceptionClass}:\n  ${3:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "try: ... except ...: ...",
        "matches": {
          "tryexcept": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "try:\n  ${1:pass}\nfinally:\n  ${2:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "try: ... finally: ...",
        "matches": {
          "tryfinally": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "try: ${1:pass}\ndefer: ${2:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "trydefer": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "while ${1:#:condition}:\n  ${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "while": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "echo(${0:#:TARGET})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "echo": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "fmt\"${0:#:TARGET}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fmt": true
        },
        "options": {
          "word": true
        }
      }
    ],
    "nuxt": [
      {
        "content": "<nuxt-link to=\"$1\">$2</nuxt-link>$0",
        "doc": "",
        "grammar": "lsp",
        "label": "nuxt-linkto",
        "matches": {
          "nuxt linkto": true
        },
        "options": {}
      },
      {
        "content": "<nuxt-link :to=\"{\t${1|name,path|}: '${2:value}', ${3|params,query|}: {\t${4:key}: '${5:value}'\t}\t}\">$6</nuxt-link>$0",
        "doc": "",
        "grammar": "lsp",
        "label": "nuxt-namedlinkto",
        "matches": {
          "nuxt namedlinkto": true
        },
        "options": {}
      },
      {
        "content": "<nuxt>$1</nuxt>$0",
        "doc": "",
        "grammar": "lsp",
        "label": "nuxt-view",
        "matches": {
          "nuxt view": true
        },
        "options": {}
      },
      {
        "content": "<nuxt name=\"$1\">$2</nuxt>$0",
        "doc": "",
        "grammar": "lsp",
        "label": "nuxt-namedview",
        "matches": {
          "nuxt namedview": true
        },
        "options": {}
      },
      {
        "content": "<nuxt-child $1/>$0",
        "doc": "",
        "grammar": "lsp",
        "label": "nuxt-child",
        "matches": {
          "nuxt child": true
        },
        "options": {}
      },
      {
        "content": "asyncData ({isDev, route, store, env, params, query, req, res, redirect, error}) {\n\treturn { ${1:data} }\n\n},",
        "doc": "Fetch and pre-render data on the server without using a store. The result from asyncData will be merged with data",
        "grammar": "lsp",
        "label": "nuxt-async-data",
        "matches": {
          "nuxt asyncdata": true
        },
        "options": {}
      },
      {
        "content": "head () {\n\treturn {\n\t\ttitle: '${1:title}',\n\t\tmeta: [\n\t\t\t{ hid: '${2:description}', name: '${3:description}', content: '${4:custom description}' }\n\t\t]\n\t}\n},",
        "doc": "Use the head method to set the HTML Head tags for the current page",
        "grammar": "lsp",
        "label": "nuxt-head",
        "matches": {
          "nuxt head": true
        },
        "options": {}
      },
      {
        "content": "middleware ({ store, redirect }) {\n\t${1:data}\n},",
        "doc": "Set the middleware for a specific page of the application.",
        "grammar": "lsp",
        "label": "nuxt-middleware",
        "matches": {
          "nuxt middleware": true
        },
        "options": {}
      },
      {
        "content": "validate({ params, query, store }) {\n\t${1:data}\n},",
        "doc": "Validate is called every time before navigating to a new route.",
        "grammar": "lsp",
        "label": "nuxt-validate",
        "matches": {
          "nuxt validate": true
        },
        "options": {}
      },
      {
        "content": "watchQuery (newQuery, oldQuery) {\n\t${1:data}\n},",
        "doc": "Use the watchQuery key to set up a watcher for query strings.",
        "grammar": "lsp",
        "label": "nuxt-watch-query",
        "matches": {
          "nuxt watchquery": true
        },
        "options": {}
      },
      {
        "content": "nuxtServerInit ({ commit }, { req }) {\n\t${1:data}\n}",
        "doc": "In universal mode, useful to fetch data on the server and give directly to the client-side.",
        "grammar": "lsp",
        "label": "nuxt-serverinit",
        "matches": {
          "nuxt serverinit": true
        },
        "options": {}
      }
    ],
    "nuxt-config": [
      {
        "content": "{ rel: 'stylesheet', href: '${1:https://fonts.googleapis.com/css?family=Montserrat:600|Rufina:700}' }",
        "doc": "link to include fonts in a nuxt project, in nuxt-config",
        "grammar": "lsp",
        "label": "Nuxt Font",
        "matches": {
          "nfont": true
        },
        "options": {}
      },
      {
        "content": "css: ['assets/${1:normalize.css}'],",
        "doc": "link to css assets such as normalize",
        "grammar": "lsp",
        "label": "Nuxt Use CSS File",
        "matches": {
          "ncss": true
        },
        "options": {}
      }
    ],
    "nuxt-script": [
      {
        "content": "async fetch ({ store, ${1:params} }) {\n\tlet { data } = await fetch('${2:endpoint}').then(res => res.json())\n\tstore.commit('${3:MUTATION_TYPE}', data)\n},",
        "doc": "Nuxt Fetch",
        "grammar": "lsp",
        "label": "Nuxt Fetch",
        "matches": {
          "nfetch": true
        },
        "options": {}
      },
      {
        "content": "this.$route.params.${1:id}",
        "doc": "Nuxt Route Params",
        "grammar": "lsp",
        "label": "Nuxt Route Params",
        "matches": {
          "nparam": true
        },
        "options": {}
      },
      {
        "content": "head () {\n\treturn {\n\t\ttitle: ${1:'Page Title'},\n\t\tmeta: [\n\t\t\t// hid is used as unique identifier. Do not use `vmid` for it as it will not work\n\t\t\t{ hid: 'description', name: 'description', content: ${2:'My custom description'} }\n\t\t]\n\t}\n},",
        "doc": "Nuxt Head",
        "grammar": "lsp",
        "label": "Nuxt Head",
        "matches": {
          "nhead": true
        },
        "options": {}
      }
    ],
    "objc": [
      {
        "content": "@selector(${1:#:method}:)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sel": true
        },
        "options": {}
      },
      {
        "content": "#import <${1:Cocoa/Cocoa.h}>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "imp": true
        },
        "options": {}
      },
      {
        "content": "#import \"${1}}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Imp": true
        },
        "options": {}
      },
      {
        "content": "NSLog(@\"${1}\")",
        "doc": "",
        "grammar": "snu",
        "label": "NSLog(...)",
        "matches": {
          "log": true
        },
        "options": {}
      },
      {
        "content": "@interface ${1} : ${2:NSObject}\n{\n}\n@end\n@implementation ${1}\n- (id)init\n{\n\tif((self = [super init]))\n\t{${0}\n\t}\n\treturn self;\n}\n@end",
        "doc": "",
        "grammar": "snu",
        "label": "Class",
        "matches": {
          "cl": true
        },
        "options": {}
      },
      {
        "content": "@interface ${1} : ${2:NSObject}\n{${3}\n}\n${0}\n@end",
        "doc": "",
        "grammar": "snu",
        "label": "ClassInterface",
        "matches": {
          "cli": true
        },
        "options": {}
      },
      {
        "content": "@implementation ${1:object}\n- (id)init\n{\n\tif((self = [super init]))\n\t{${0}\n\t}\n\treturn self;\n}\n@end",
        "doc": "",
        "grammar": "snu",
        "label": "ClassImplementation",
        "matches": {
          "clm": true
        },
        "options": {}
      },
      {
        "content": "@interface ${1:NSObject} (${2:Category})\n@end\n@implementation ${1} (${2})\n${0}\n@end",
        "doc": "",
        "grammar": "snu",
        "label": "Category",
        "matches": {
          "cat": true
        },
        "options": {}
      },
      {
        "content": "@interface ${1:NSObject)} (${2:Category)})\n${0}\n@end",
        "doc": "",
        "grammar": "snu",
        "label": "CategoryInterface",
        "matches": {
          "cati": true
        },
        "options": {}
      },
      {
        "content": "NSMutableArray *${1:#:array} = [NSMutableArray array];",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "array": true
        },
        "options": {}
      },
      {
        "content": "NSMutableDictionary *${1:#:dict} = [NSMutableDictionary dictionary];",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dict": true
        },
        "options": {}
      },
      {
        "content": "NSBezierPath *${1:#:path} = [NSBezierPath bezierPath];",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bez": true
        },
        "options": {}
      },
      {
        "content": "- (${1:#:id})${2:#:method}${3:(#:id)}${4:#:anArgument}\n{\n${0}\n\treturn nil;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "Method",
        "matches": {
          "m": true
        },
        "options": {}
      },
      {
        "content": "- (${1:#:id})${2:#:method}${3:(#:id)}${4:#:anArgument};",
        "doc": "",
        "grammar": "snu",
        "label": "Method",
        "matches": {
          "M": true
        },
        "options": {}
      },
      {
        "content": "+ (${1:#:id})${2:#:method}${3:(#:id)}${4:#:anArgument}\n{\n${0}\n\treturn nil;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "ClassMethod",
        "matches": {
          "cm": true
        },
        "options": {}
      },
      {
        "content": "+ (${1:#:id})${0:#:method};",
        "doc": "",
        "grammar": "snu",
        "label": "InterfaceClassMethod",
        "matches": {
          "icm": true
        },
        "options": {}
      },
      {
        "content": "- (${1:#:id})${2:#:method}${3:(#:id)}${4:#:anArgument}\n{\n\t${1} res = [super ${2:#:method}]\n\treturn res;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "SubMethod",
        "matches": {
          "sm": true
        },
        "options": {}
      },
      {
        "content": "+ (void)initialize\n{\n\t[[NSUserDefaults standardUserDefaults] registerDefaults:[NSDictionary dictionaryWithObjectsAndKeys:\n\t\t${0}@\"value\", @\"key\",\n\t\tnil]];\n}",
        "doc": "",
        "grammar": "snu",
        "label": "MethodInitialize",
        "matches": {
          "mi": true
        },
        "options": {}
      },
      {
        "content": "- (${1:#:id})${2:#:thing}\n{\n\treturn ${2};\n}\n- (void)set${2}:(${1})aValue\n{\n\t${0}${1}old${2} = ${2};\n\t${2} = [aValue retain];\n\t[old${2} release];\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "obj": true
        },
        "options": {}
      },
      {
        "content": "- (${1:#:id})${2:#:thing};\n- (void)set${2}:(${1})aValue;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "iobj": true
        },
        "options": {}
      },
      {
        "content": "- (NSString${$1: *)})${1:#:thing}\n{\n\treturn ${2};\n}\n- (void)set${1}:(NSString${2: *})${3}\n{\n\t${3} = [${3} copy];\n\t[${2} release];\n\t${2} = ${3};\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "str": true
        },
        "options": {}
      },
      {
        "content": "- (NSString${1: *)}${1:#:thing};\n- (void)set${1}:(NSString${2: *})${2};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "istr": true
        },
        "options": {}
      },
      {
        "content": "- (${1:#:id})${2:#:attribute}\n{\n\t[self willAccessValueForKey:@\"$2\"];\n\t$1 value = [self primitiveValueForKey:@\"$2\"];\n\t[self didAccessValueForKey:@\"$2\"];\n\treturn value;\n}\n- (void)set$2:($1)aValue\n{\n\t[self willChangeValueForKey:@\"$2\"];\n\t[self setPrimitiveValue:aValue forKey:@\"$2\"];\n\t[self didChangeValueForKey:@\"$2\"];\n}",
        "doc": "",
        "grammar": "snu",
        "label": "CoreData",
        "matches": {
          "cd": true
        },
        "options": {}
      },
      {
        "content": "- (void)addObjectTo${1:#:Things}:(${2:#:id})anObject\n{\n\t[${3}} addObject:anObject];\n}\n- (void)insertObject:($2)anObject in$1AtIndex:(unsigned int)i\n{\n\t[${3} insertObject:anObject atIndex:i];\n}\n- (${2})objectIn${1}AtIndex:(unsigned int)i\n{\n\treturn [${3} objectAtIndex:i];\n}\n- (unsigned int)indexOfObjectIn${1}:(${2})anObject\n{\n\treturn [${3} indexOfObject:anObject];\n}\n- (void)removeObjectFrom${1}AtIndex:(unsigned int)i\n{\n\t [${3} removeObjectAtIndex:i];\n}\n- (unsigned int)countOf${1}\n{\n\treturn [${3} count];\n}\n- (NSArray${4: *}${1}\n{\n\treturn ${3}\n}\n- (void)set${1}:(NSArray${4: *})new${1}\n{\n\t[${3} setArray:new${1}];\n}",
        "doc": "",
        "grammar": "snu",
        "label": "KVCArry",
        "matches": {
          "karray": true
        },
        "options": {}
      },
      {
        "content": "- (void)addObjectTo${1:#:Things}:(${2:#:id})anObject;\n- (void)insertObject:(${2})anObject in${1}AtIndex:(unsigned int)i;\n- (${2})objectIn${1}AtIndex:(unsigned int)i;\n- (unsigned int)indexOfObjectIn${1}:(${2})anObject;\n- (void)removeObjectFrom${1}AtIndex:(unsigned int)i;\n- (unsigned int)countOf${1};\n- (NSArray${3: *})${1};\n- (void)set${1}:(NSArray${3: *})new${1};",
        "doc": "",
        "grammar": "snu",
        "label": "InterfaceAccessorsForKVCArray",
        "matches": {
          "iarray": true
        },
        "options": {}
      },
      {
        "content": "- (${1:unsigned int})${2:#:thing}\n{\n\treturn ${3};\n}\n- (void)set${2}:(${1:unsigned int})new${2}\n{\n\t${3} = new${2};\n}",
        "doc": "",
        "grammar": "snu",
        "label": "PrimitiveType",
        "matches": {
          "acc": true
        },
        "options": {}
      },
      {
        "content": "- (${1:unsigned int})${2:thing};\n- (void)set${2}:($1)new${2};",
        "doc": "",
        "grammar": "snu",
        "label": "Interface:AccessorsForPrimitiveType",
        "matches": {
          "iacc": true
        },
        "options": {}
      },
      {
        "content": "[[NSUserDefaults standardUserDefaults] objectForKey:${1:key}];",
        "doc": "",
        "grammar": "snu",
        "label": "ReadDefaultsValue",
        "matches": {
          "rdef": true
        },
        "options": {}
      },
      {
        "content": "[[NSUserDefaults standardUserDefaults] setObject:${1:object} forKey:${2:key}];",
        "doc": "",
        "grammar": "snu",
        "label": "WriteDefaultsValue",
        "matches": {
          "wdef": true
        },
        "options": {}
      },
      {
        "content": "IBOutlet ${1}${2: *}${3};",
        "doc": "",
        "grammar": "snu",
        "label": "IBOutlet",
        "matches": {
          "ibo": true
        },
        "options": {}
      },
      {
        "content": "@synthesize ${1:#:property};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "syn": true
        },
        "options": {}
      },
      {
        "content": "bind:@\"${2:#:binding}\" toObject:${3:observableController} withKeyPath:@\"${4:keyPath}\" options:${5:nil}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bind": true
        },
        "options": {}
      },
      {
        "content": "[[NSNotificationCenter defaultCenter] addObserver:${1:self} selector:@selector(${3}) name:${2:NSWindowDidBecomeMainNotification} object:${4:nil}];",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "reg": true
        },
        "options": {}
      },
      {
        "content": "[self lockFocus];\n${0}\n[self unlockFocus];",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "focus": true
        },
        "options": {}
      },
      {
        "content": "unsigned int\t${1:object}Count = [${2:array} count];\nfor(unsigned int index = 0; index < ${1}Count; index += 1)\n{\n\t${3:id}\t${1} = [${2} objectAtIndex:index];\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forarray": true
        },
        "options": {}
      },
      {
        "content": "int choice = NSRunAlertPanel(@\"${1:Something important!}\", @\"${2:Something important just happend, and now I need to ask you, do you want to continue?}\", @\"${3:Continue}\", @\"${4:Cancel}\", nil);\nif(choice == NSAlertDefaultReturn) // \"${3:Continue}\"\n{\n\t${0};\n}\nelse if(choice == NSAlertAlternateReturn) // \"${4:Cancel}\"\n{\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "alert": true
        },
        "options": {}
      },
      {
        "content": "${1} Send ${2} to ${1}, if ${1} supports it}${3}\nif ([${1:self} respondsToSelector:@selector(${2:someSelector:})])\n{\n    [${1} ${3}];\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "res": true
        },
        "options": {}
      },
      {
        "content": "if([${1:[self delegate]} respondsToSelector:@selector(${2:selfDidSomething:})])\n\t[${1} ${3}];",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "del": true
        },
        "options": {}
      },
      {
        "content": "[NSString stringWithFormat:@\"${1}\", ${2}]${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "format": true
        },
        "options": {}
      },
      {
        "content": "[NSGraphicsContext saveGraphicsState];\n${0}\n[NSGraphicsContext restoreGraphicsState];",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "save": true
        },
        "options": {}
      },
      {
        "content": "[NSThread detachNewThreadSelector:@selector(${1:#:method}:) toTarget:${2:#:aTarget} withObject:${3:#:anArgument}]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "thread": true
        },
        "options": {}
      },
      {
        "content": "NSAutoreleasePool${TM_C_POINTER: *}pool = [NSAutoreleasePool new];\n${0}\n[pool drain];",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pool": true
        },
        "options": {}
      },
      {
        "content": "#import <${1:Cocoa/Cocoa.h}>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Imp": true
        },
        "options": {}
      },
      {
        "content": "@selector(${1:method}:)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sel": true
        },
        "options": {}
      },
      {
        "content": "@\"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "s": true
        },
        "options": {}
      },
      {
        "content": "${1:NSObject} *${2:foo} = [${3:$1 alloc}]${4};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "o": true
        },
        "options": {}
      },
      {
        "content": "NSLog(@\"${1:%@}\"${2});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "log": true
        },
        "options": {}
      },
      {
        "content": "- (id)init\n{\n\tif (self = [super init]) {\n\t\t${0}\n\t}\n\treturn self;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "init": true
        },
        "options": {}
      },
      {
        "content": "- (void) dealloc\n{\n\t${0:deallocations}\n\t[super dealloc];\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dealloc": true
        },
        "options": {}
      },
      {
        "content": "[super ${1:init}]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "su": true
        },
        "options": {}
      },
      {
        "content": "IBOutlet ${1:NSSomeClass} *${2:$1};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ibo": true
        },
        "options": {}
      },
      {
        "content": "@interface ${1:NSObject} (${2:MyCategory})\n@end\n@implementation $1 ($2)\n${0}\n@end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cat": true
        },
        "options": {}
      },
      {
        "content": "- (${1:id})${2:method}\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "m": true
        },
        "options": {}
      },
      {
        "content": "- (${1:id})${2:method};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "md": true
        },
        "options": {}
      },
      {
        "content": "- (IBAction)${1:method}:(${2:id})sender;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ibad": true
        },
        "options": {}
      },
      {
        "content": "- (IBAction)${1:method}:(${2:id})sender\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "iba": true
        },
        "options": {}
      },
      {
        "content": "- (void)awakeFromNib\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wake": true
        },
        "options": {}
      },
      {
        "content": "+ (${1:id})${2:method}\n{\n\t${0:return nil;}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "M": true
        },
        "options": {}
      },
      {
        "content": "- (${1:id})${2:method}\n{\n\t[super $2];${0}\n\treturn self;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sm": true
        },
        "options": {}
      },
      {
        "content": "- (${1:id})${2:thing}\n{\n\treturn $2;\n}\n- (void)set$2:($1)${3:new$2}\n{\n\t[$3 retain];\n\t[$2 release];\n\t$2 = $3;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "objacc": true
        },
        "options": {}
      },
      {
        "content": "for (${1:Class} *${2:some$1} in ${3:array}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forin": true
        },
        "options": {}
      },
      {
        "content": "for (${1:object} in ${2:array}) {\n\t${0:statements}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fore": true
        },
        "options": {}
      },
      {
        "content": "unsigned int ${1:object}Count = [${2:array} count];\nfor (unsigned int index = 0; index < $1Count; index++) {\n\t${3:id} $1 = [$2 $1AtIndex:index];\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forarray": true
        },
        "options": {}
      },
      {
        "content": "unsigned int ${1:object}Count = [${2:array} count];\nfor (unsigned int index = 0; index < $1Count; index++) {\n\t${3:id} $1 = [$2 $1AtIndex:index];\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fora": true
        },
        "options": {}
      },
      {
        "content": "@try {\n\t${1:statements}\n}\n@catch (NSException * e) {\n\t${2:handler}\n}\n@finally {\n\t${0:statements}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@try": true
        },
        "options": {}
      },
      {
        "content": "@catch (${1:exception}) {\n\t${0:handler}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@catch": true
        },
        "options": {}
      },
      {
        "content": "@finally {\n\t${0:statements}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@finally": true
        },
        "options": {}
      },
      {
        "content": "@property (${1:retain}) ${2:NSSomeClass} ${3:*$2};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prop": true
        },
        "options": {}
      },
      {
        "content": "@synthesize ${1:property};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "syn": true
        },
        "options": {}
      },
      {
        "content": "[[${1:foo} alloc] init${2}];",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "alloc": true
        },
        "options": {}
      },
      {
        "content": "[[${1:foo} alloc] init${2}];",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "a": true
        },
        "options": {}
      },
      {
        "content": "[${1:foo} retain];",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ret": true
        },
        "options": {}
      },
      {
        "content": "[${0:foo} release];",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rel": true
        },
        "options": {}
      },
      {
        "content": "[${0:foo} autorelease];",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "arel": true
        },
        "options": {}
      },
      {
        "content": "NSAutoreleasePool *${1:pool} = [[NSAutoreleasePool alloc] init];\n${0}\n[$1 drain];",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pool": true
        },
        "options": {}
      },
      {
        "content": "NSException *${1:badness};\n$1 = [NSException exceptionWithName:@\"${2:$1Name}\"\n                             reason:@\"${0}\"\n                           userInfo:nil];\n[$1 raise];",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "except": true
        },
        "options": {}
      },
      {
        "content": "#pragma mark ${0:-}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prag": true
        },
        "options": {}
      },
      {
        "content": "@class ${1:Foo};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cl": true
        },
        "options": {}
      },
      {
        "content": "[[NSColor ${0:blackColor}] set];",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "color": true
        },
        "options": {}
      },
      {
        "content": "NSMutableArray *${1:array} = [NSMutable array];",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "array": true
        },
        "options": {}
      },
      {
        "content": "NSArray ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nsa": true
        },
        "options": {}
      },
      {
        "content": "NSMutableArray ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nsma": true
        },
        "options": {}
      },
      {
        "content": "NSArray * array;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "aa": true
        },
        "options": {}
      },
      {
        "content": "NSMutableArray * array;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ma": true
        },
        "options": {}
      },
      {
        "content": "NSMutableDictionary *${1:dict} = [NSMutableDictionary dictionary];",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dict": true
        },
        "options": {}
      },
      {
        "content": "NSDictionary ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nsd": true
        },
        "options": {}
      },
      {
        "content": "NSMutableDictionary ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nsmd": true
        },
        "options": {}
      },
      {
        "content": "NSString ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nss": true
        },
        "options": {}
      },
      {
        "content": "NSMutableString ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nsms": true
        },
        "options": {}
      },
      {
        "content": "#import <${1:Cocoa/Cocoa.h}>",
        "doc": "",
        "grammar": "snu",
        "label": "#import <> (Imp)",
        "matches": {
          "Imp": true
        },
        "options": {}
      },
      {
        "content": "NSMutableArray *${1:array} = [NSMutableArray array];",
        "doc": "",
        "grammar": "snu",
        "label": "NSArray (array)",
        "matches": {
          "array": true
        },
        "options": {}
      },
      {
        "content": "NSMutableDictionary *${1:dict} = [NSMutableDictionary dictionary];",
        "doc": "",
        "grammar": "snu",
        "label": "NSDictionary (dict)",
        "matches": {
          "dict": true
        },
        "options": {}
      },
      {
        "content": "unsigned int\t${1:object}Count = [${2:array} count];\n\nfor(unsigned int index = 0; index < $1Count; index += 1)\n{\n\t${3:id}\t$1 = [$2 objectAtIndex:index];\n\t$0\n}",
        "doc": "",
        "grammar": "snu",
        "label": "for NSArray loop (forarray)",
        "matches": {
          "forarray": true
        },
        "options": {}
      },
      {
        "content": "@selector(${1:method}:)",
        "doc": "",
        "grammar": "snu",
        "label": "@selector",
        "matches": {
          "sel": true
        },
        "options": {}
      },
      {
        "content": "[NSThread detachNewThreadSelector:@selector(${1:method}:) toTarget:${2:aTarget} withObject:${3:anArgument}]",
        "doc": "",
        "grammar": "snu",
        "label": "Detach New NSThread",
        "matches": {
          "thread": true
        },
        "options": {}
      },
      {
        "content": "+ (void)initialize\n{\n\t[[NSUserDefaults standardUserDefaults] registerDefaults:[NSDictionary dictionaryWithObjectsAndKeys:\n\t\t$0@\"value\", @\"key\",\n\t\tnil]];\n}",
        "doc": "",
        "grammar": "snu",
        "label": "Initialize Implementation (I)",
        "matches": {
          "I": true
        },
        "options": {}
      },
      {
        "content": "bind:@\"${1:binding}\" toObject:${2:observableController} withKeyPath:@\"${3:keyPath}\" options:${4:nil}",
        "doc": "",
        "grammar": "snu",
        "label": "Key:value binding (bind)",
        "matches": {
          "bind": true
        },
        "options": {}
      },
      {
        "content": "[self lockFocus];\n$0\n[self unlockFocus];",
        "doc": "",
        "grammar": "snu",
        "label": "Lock Focus",
        "matches": {
          "focus": true
        },
        "options": {}
      },
      {
        "content": "NSAutoreleasePool *pool = [NSAutoreleasePool new];\n$0\n[pool drain];",
        "doc": "",
        "grammar": "snu",
        "label": "NSAutoreleasePool (pool)",
        "matches": {
          "pool": true
        },
        "options": {}
      },
      {
        "content": "int choice = NSRunAlertPanel(@\"${1:Something important!}\", @\"${2:Something important just happend, and now I need to ask you, do you want to continue?}\", @\"${3:Continue}\", @\"${4:Cancel}\", nil);\nif(choice == NSAlertDefaultReturn) // \"$3\"\n{\n\t$0;\n}\nelse if(choice == NSAlertAlternateReturn) // \"$4\"\n{\n\t\t$0\n}",
        "doc": "",
        "grammar": "snu",
        "label": "NSRunAlertPanel (alert)",
        "matches": {
          "alert": true
        },
        "options": {}
      },
      {
        "content": "[NSString stringWithFormat:@\"$1\", $2]$0",
        "doc": "",
        "grammar": "snu",
        "label": "NSString stringWithFormat (format)",
        "matches": {
          "format": true
        },
        "options": {}
      },
      {
        "content": "[[NSUserDefaults standardUserDefaults] objectForKey:${1:key}];",
        "doc": "",
        "grammar": "snu",
        "label": "Read from defaults (getprefs)",
        "matches": {
          "getprefs": true
        },
        "options": {}
      },
      {
        "content": "[NSGraphicsContext saveGraphicsState];\n$0\n[NSGraphicsContext restoreGraphicsState];\n",
        "doc": "",
        "grammar": "snu",
        "label": "Save and Restore Graphics Context (gsave)",
        "matches": {
          "gsave": true
        },
        "options": {}
      },
      {
        "content": "@synthesize ${1:property};",
        "doc": "",
        "grammar": "snu",
        "label": "Synthesize",
        "matches": {
          "syn": true
        },
        "options": {}
      },
      {
        "content": "[[NSUserDefaults standardUserDefaults] setObject:${1:object} forKey:${2:key}];",
        "doc": "",
        "grammar": "snu",
        "label": "Write to defaults (setprefs)",
        "matches": {
          "setprefs": true
        },
        "options": {}
      }
    ],
    "ocaml": [
      {
        "content": "module type ${1} = sig\n  ${2:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "module signature",
        "matches": {
          "mot": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "module ${1} = struct\n  ${2:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "module struct",
        "matches": {
          "mod": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "module ${1} : sig\n  ${2:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "module signature",
        "matches": {
          "mos": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "(* ${0:TARGET} *)",
        "doc": "",
        "grammar": "snu",
        "label": "comment",
        "matches": {
          "cc": true
        },
        "options": {}
      },
      {
        "content": "(*\n   ${0:TARGET}\n*)",
        "doc": "",
        "grammar": "snu",
        "label": "multi line comment",
        "matches": {
          "Cc": true
        },
        "options": {}
      },
      {
        "content": "(** ${0:TARGET} *)",
        "doc": "",
        "grammar": "snu",
        "label": "ocamldoc comment (** .. *)",
        "matches": {
          "oo": true
        },
        "options": {}
      },
      {
        "content": "if ${1:TARGET}\nthen ${2}\nelse ${3}",
        "doc": "",
        "grammar": "snu",
        "label": "if..then..else",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "let ${1:TARGET} in ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "let..in",
        "matches": {
          "let": true
        },
        "options": {}
      },
      {
        "content": "let rec ${1:TARGET}\nin ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "let rec .. in",
        "matches": {
          "letr": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "match ${1:TARGET} with\n| ${2} -> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "match",
        "matches": {
          "match": true
        },
        "options": {}
      },
      {
        "content": "object\n  ${0:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "object",
        "matches": {
          "obj": true
        },
        "options": {}
      },
      {
        "content": "try ${1:TARGET}\nwith ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "try..with",
        "matches": {
          "try": true
        },
        "options": {}
      },
      {
        "content": "let open ${1} in\n${2:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "let open .. in",
        "matches": {
          "lopen": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "for ${1:i} = ${2:0} to ${3:10} do\n  ${0:TARGET}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": "for i=x..y do; ... done",
        "matches": {
          "for": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "while ${1:true} do\n  ${2:TARGET}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": "while ... do; ... done",
        "matches": {
          "while": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "(fun ${1:x} -> ${2:TARGET})",
        "doc": "",
        "grammar": "snu",
        "label": "(fun x -> ...)",
        "matches": {
          "fun": true
        },
        "options": {}
      },
      {
        "content": "[| ${0:TARGET} |]",
        "doc": "",
        "grammar": "snu",
        "label": "array literal [| |]",
        "matches": {
          "arl": true
        },
        "options": {}
      },
      {
        "content": "failwith \"${0:TARGET}\"",
        "doc": "",
        "grammar": "snu",
        "label": "failwith \"...\"",
        "matches": {
          "fail": true
        },
        "options": {}
      },
      {
        "content": "begin ${0:TARGET} end",
        "doc": "",
        "grammar": "snu",
        "label": "begin ... end",
        "matches": {
          "beg": true
        },
        "options": {}
      },
      {
        "content": "exception ${0:TARGET} of ${1:string}",
        "doc": "",
        "grammar": "snu",
        "label": "exception",
        "matches": {
          "exn": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "{${0:}|${1:TARGET}|$0}",
        "doc": "",
        "grammar": "snu",
        "label": "string literals {xxx| ... |xxx}",
        "matches": {
          "lit": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "[@@deriving ${0:TARGET}]",
        "doc": "",
        "grammar": "snu",
        "label": "[@@deriving ...]",
        "matches": {
          "@@": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "(** ${0} *)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "doc": true
        },
        "options": {}
      },
      {
        "content": "(* ${0} *)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "comment": true
        },
        "options": {}
      },
      {
        "content": "let ${1} = ${2} in\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "let": true
        },
        "options": {}
      },
      {
        "content": "let ${1} =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fn": true
        },
        "options": {}
      },
      {
        "content": "type ${1} = ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fun": true
        },
        "options": {}
      },
      {
        "content": "module ${1} = struct\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mod": true
        },
        "options": {}
      },
      {
        "content": "module type ${1} = sig\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "modty": true
        },
        "options": {}
      },
      {
        "content": "match ${1} with\n| ${2} -> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sw": true
        },
        "options": {}
      },
      {
        "content": "| ${1} -> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "|": true
        },
        "options": {}
      },
      {
        "content": "|> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p": true
        },
        "options": {}
      },
      {
        "content": "if ${1} then\n\t${2}\nelse\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "let rec ${1} =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fnr": true
        },
        "options": {}
      },
      {
        "content": "try\n\t${1}\nwith ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "try": true
        },
        "options": {}
      },
      {
        "content": "raise (${1:Not_found})",
        "doc": "",
        "grammar": "snu",
        "label": "raise",
        "matches": {
          "rs": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "let open ${1:module} in\n${2:e}",
        "doc": "",
        "grammar": "snu",
        "label": "open",
        "matches": {
          "open": true
        },
        "options": {}
      },
      {
        "content": "try ${1:e}\nwith ${2:Not_found} -> ${3:()}",
        "doc": "",
        "grammar": "snu",
        "label": "try",
        "matches": {
          "try": true
        },
        "options": {}
      },
      {
        "content": "let ${1:name} = ref ${2:val} in\n${3:e}",
        "doc": "",
        "grammar": "snu",
        "label": "ref",
        "matches": {
          "ref": true
        },
        "options": {}
      },
      {
        "content": "match ${1:list} with\n| [] -> ${2:()}\n| x::xs -> ${3:()}",
        "doc": "",
        "grammar": "snu",
        "label": "pattern match on a list",
        "matches": {
          "matchl": true
        },
        "options": {}
      },
      {
        "content": "match ${1:x} with\n| Some(${2:y}) -> ${3:()}\n| None -> ${4:()}",
        "doc": "",
        "grammar": "snu",
        "label": "pattern match on an option type",
        "matches": {
          "matcho": true
        },
        "options": {}
      },
      {
        "content": "(fun ${1:x} -> ${2:x})",
        "doc": "",
        "grammar": "snu",
        "label": "anonymous function",
        "matches": {
          "fun": true
        },
        "options": {}
      },
      {
        "content": "(* ${1:comment} *)",
        "doc": "",
        "grammar": "snu",
        "label": "commment",
        "matches": {
          "cc": true
        },
        "options": {}
      },
      {
        "content": "let ${1:x} = ${2:v} in\n${3:e}",
        "doc": "",
        "grammar": "snu",
        "label": "let .. in binding",
        "matches": {
          "let": true
        },
        "options": {}
      },
      {
        "content": "let rec ${1:f} =\n\t${2:expr}",
        "doc": "",
        "grammar": "snu",
        "label": "let rec",
        "matches": {
          "lr": true
        },
        "options": {}
      },
      {
        "content": "if ${1:(* condition *)} then\n\t${2:(* A *)}\nelse\n\t${3:(* B *)}",
        "doc": "",
        "grammar": "snu",
        "label": "if",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "if ${1:(* condition *)} then\n\t${2:(* A *)}",
        "doc": "",
        "grammar": "snu",
        "label": "If",
        "matches": {
          "If": true
        },
        "options": {}
      },
      {
        "content": "while ${1:(* condition *)} do\n\t${2:(* A *)}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": "while",
        "matches": {
          "while": true
        },
        "options": {}
      },
      {
        "content": "for ${1:i} = ${2:1} to ${3:10} do\n\t${4:(* BODY *)}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": "for",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "match ${1:(* e1 *)} with\n| ${2:p} -> ${3:e2}",
        "doc": "",
        "grammar": "snu",
        "label": "match",
        "matches": {
          "match": true
        },
        "options": {}
      },
      {
        "content": "match ${1:(* e1 *)} with\n| ${2:p} -> ${3:e2}",
        "doc": "",
        "grammar": "snu",
        "label": "match",
        "matches": {
          "Match": true
        },
        "options": {}
      },
      {
        "content": "class ${1:name} = object\n\t${2:methods}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "class",
        "matches": {
          "class": true
        },
        "options": {}
      },
      {
        "content": "object\n\t${2:methods}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "obj",
        "matches": {
          "obj": true
        },
        "options": {}
      },
      {
        "content": "object (self)\n\t${2:methods}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "object",
        "matches": {
          "Obj": true
        },
        "options": {}
      },
      {
        "content": "{< ${1:x} = ${2:y} >}",
        "doc": "",
        "grammar": "snu",
        "label": "object functional update",
        "matches": {
          "{{": true
        },
        "options": {}
      },
      {
        "content": "begin\n\t${1:block}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "beg",
        "matches": {
          "beg": true
        },
        "options": {}
      },
      {
        "content": "module ${1:Mod} = ${2:Functor}(${3:Arg})",
        "doc": "",
        "grammar": "snu",
        "label": "module instantiantion with functor",
        "matches": {
          "ml": true
        },
        "options": {}
      },
      {
        "content": "module ${1:(* Name *)} = struct\n\t${2:(* BODY *)}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "module - no signature",
        "matches": {
          "mod": true
        },
        "options": {}
      },
      {
        "content": "module ${1:(* Name *)} : ${2:(* SIG *)} = struct\n\t${3:(* BODY *)}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "module with signature",
        "matches": {
          "Mod": true
        },
        "options": {}
      },
      {
        "content": "sig\n\t${2:(* BODY *)}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "anonymous signature",
        "matches": {
          "sig": true
        },
        "options": {}
      },
      {
        "content": "functor (${1:Arg} : ${2:ARG}) -> ${3:(* BODY *)}",
        "doc": "",
        "grammar": "snu",
        "label": "functor signature or anonymous functor",
        "matches": {
          "sigf": true
        },
        "options": {}
      },
      {
        "content": "module ${1:M} (${2:Arg} : ${3:ARG}) = struct\n\t${4:(* BODY *)}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "define functor - no signature",
        "matches": {
          "func": true
        },
        "options": {}
      },
      {
        "content": "module ${1:M} (${2:Arg} : ${3:ARG}) : ${4:SIG} = struct\n\t${5:(* BODY *)}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "define functor - with signature",
        "matches": {
          "Func": true
        },
        "options": {}
      },
      {
        "content": "module type ${1:(* Name *)} = sig\n\t${2:(* BODY *)}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "Declare module signature",
        "matches": {
          "mot": true
        },
        "options": {}
      },
      {
        "content": "module ${1:(* Name *)} : sig\n\t${2:(* SIGNATURE *)}\nend = struct\n\t${3:(* BODY *)}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "Module with anonymous signature",
        "matches": {
          "module": true
        },
        "options": {}
      },
      {
        "content": "(** ${1:odoc} *)",
        "doc": "",
        "grammar": "snu",
        "label": "odoc",
        "matches": {
          "oo": true
        },
        "options": {}
      },
      {
        "content": "(*$T ${1:name}\n\t${2:test}\n*)",
        "doc": "",
        "grammar": "snu",
        "label": "inline qtest",
        "matches": {
          "qt": true
        },
        "options": {}
      }
    ],
    "octave": [],
    "openfoam": [
      {
        "content": "type\t\tfixedValue;\nvalue\t\tuniform ${0};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fv": true
        },
        "options": {}
      },
      {
        "content": "type\t\tzeroGradient;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "zg": true
        },
        "options": {}
      },
      {
        "content": "type\t\tsymmetryPlane;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sym": true
        },
        "options": {}
      },
      {
        "content": "forces\n{\n\ttype\t\t\t\tforces;\n\tfunctionObjectLibs\t(\"libforces.so\");\n\tenabled\t\t\t\ttrue;\n\toutputControl\t\t${1:timeStep};\n\toutputInterval\t\t${2:1};\n\tpatches\t\t\t\t(${3});\n\tlog\t\t\t\t\t${4:true};\n\tCofR\t\t\t\t(${0:0 0 0});\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forces": true
        },
        "options": {}
      },
      {
        "content": "${1:p}\n{\n\tsolver          GAMG;\n\ttolerance       1e-${2:6};\n\trelTol          ${0:0.0};\n\tsmoother        GaussSeidel;\n\tcacheAgglomeration true;\n\tnCellsInCoarsestLevel 10;\n\tagglomerator    faceAreaPair;\n\tmergeLevels     1;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gamg": true
        },
        "options": {}
      },
      {
        "content": "${1:U}\n{\n\tsolver          PBiCG;\n\tpreconditioner  DILU;\n\ttolerance       1e-${2:6};\n\trelTol          ${0:0.0};\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pbicg": true
        },
        "options": {}
      },
      {
        "content": "PIMPLE\n{\n\tnOuterCorrectors \t${1:outer};\n\tnCorrectors     \t${2:inner};\n\tnNonOrthogonalCorrectors ${3:nonOrtho};\n\tpRefCell        \t${4:cell};\n\tpRefValue       \t${0:value for $4};\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pimple": true
        },
        "options": {}
      }
    ],
    "pandoc": [],
    "perl": [
      {
        "content": "#!/opt/local/bin/perl\nuse strict;\nuse warnings;\n${1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "perl": true
        },
        "options": {}
      },
      {
        "content": "sub ${1:#:function_name} {\n\t${2:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sub": true
        },
        "options": {}
      },
      {
        "content": "if (${1:#:condition}) {\n\t${2:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "if (${1:#:condition}) {\n\t${2:TARGET}\n} else {\n\t${3:#:else...}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "if (${1:#:condition}) {\n\t${2:TARGET}\n} elsif (${3}) {\n\t${4:#:elsif...}\n} else {\n\t${5:#:else...}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifee": true
        },
        "options": {}
      },
      {
        "content": "${1:#:expression} if ${2:#:condition};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "xif": true
        },
        "options": {}
      },
      {
        "content": "while (${1:#:condition}) {\n\t${2:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "wh",
        "matches": {
          "while": true
        },
        "options": {}
      },
      {
        "content": "${1:#:expression} while ${2:#:condition};",
        "doc": "",
        "grammar": "snu",
        "label": "xwh",
        "matches": {
          "xwhile": true
        },
        "options": {}
      },
      {
        "content": "for (my $${1:#:var} = 0; $$1 < ${2:#:expression}; $$1++) {\n\t${3:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "for ${1} (${2:#:expression}){\n\t${3:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fore": true
        },
        "options": {}
      },
      {
        "content": "${1:#:expression} for @${2:#:array};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "xfor": true
        },
        "options": {}
      },
      {
        "content": "unless (${1:condition}) {\n\t${2:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "un",
        "matches": {
          "unless": true
        },
        "options": {}
      },
      {
        "content": "${1:#:expression} unless ${2:#:condition};",
        "doc": "",
        "grammar": "snu",
        "label": "xun",
        "matches": {
          "xunless": true
        },
        "options": {}
      },
      {
        "content": "eval {\n\t${1:TARGET}\n};\nif ($@) {\n\t${2:#:handle failure...}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eval": true
        },
        "options": {}
      },
      {
        "content": "#!/usr/bin/env perl",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#!": true
        },
        "options": {}
      },
      {
        "content": "=>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ".": true
        },
        "options": {}
      },
      {
        "content": "sub ${1:function_name} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sub": true
        },
        "options": {}
      },
      {
        "content": "if (${1}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "if (${1}) {\n\t${2}\n}\nelse {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "if (${1}) {\n\t${2}\n}\nelsif (${3}) {\n\t${4:# elsif...}\n}\nelse {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifee": true
        },
        "options": {}
      },
      {
        "content": "elsif (${1}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eif": true
        },
        "options": {}
      },
      {
        "content": "${1:expression} if ${2:condition};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "xif": true
        },
        "options": {}
      },
      {
        "content": "unless (${1}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "unless": true
        },
        "options": {}
      },
      {
        "content": "${1:expression} unless ${2:condition};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "xunless": true
        },
        "options": {}
      },
      {
        "content": "local $@;\neval {\n\t${1:# do something risky...}\n};\nif (my $e = $@) {\n\t${0:# handle failure...}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eval": true
        },
        "options": {}
      },
      {
        "content": "while (${1}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh": true
        },
        "options": {}
      },
      {
        "content": "${1:expression} while ${2:condition};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "xwh": true
        },
        "options": {}
      },
      {
        "content": "for (my $${2:var} = 0; $$2 < ${1:count}; $$2${3:++}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cfor": true
        },
        "options": {}
      },
      {
        "content": "${1:expression} for @${2:array};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "xfor": true
        },
        "options": {}
      },
      {
        "content": "foreach my $${1:x} (@${2:array}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "${1:expression} foreach @${2:array};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fore": true
        },
        "options": {}
      },
      {
        "content": "use Moose;\nuse namespace::autoclean;\n${1:#}BEGIN {extends '${2:ParentClass}'};\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "moose": true
        },
        "options": {}
      },
      {
        "content": "use parent qw(${0:Parent Class});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "parent": true
        },
        "options": {}
      },
      {
        "content": "my $${1:var} = do { local $/; open my $file, '<', \"${2:file}\"; <$file> };\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "slurp": true
        },
        "options": {}
      },
      {
        "content": "use strict;\nuse warnings;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "strwar": true
        },
        "options": {}
      },
      {
        "content": "## no critic\nour $VERSION = '${0:version}';\neval $VERSION;\n## use critic",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vers": true
        },
        "options": {}
      },
      {
        "content": "use feature 'switch';",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "switch": true
        },
        "options": {}
      },
      {
        "content": "sub {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asub": true
        },
        "options": {}
      },
      {
        "content": "BEGIN {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "begin": true
        },
        "options": {}
      },
      {
        "content": "__PACKAGE__->${1:package_method}(${0:var})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pkgmv": true
        },
        "options": {}
      },
      {
        "content": "__PACKAGE__->${0:package_method}()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pkgm": true
        },
        "options": {}
      },
      {
        "content": "__PACKAGE__->get_${0:package_method}()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pkget": true
        },
        "options": {}
      },
      {
        "content": "__PACKAGE__->get_${1:package_method}(${0:var})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pkgetv": true
        },
        "options": {}
      },
      {
        "content": "qr/\n     ${0:regex}\n/xms",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "qrx": true
        },
        "options": {}
      },
      {
        "content": "qr/${0:regex}/x",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "qr/": true
        },
        "options": {}
      },
      {
        "content": "given ($${1:var}) {\n\t${2:# cases}\n\t${0:# default}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "given": true
        },
        "options": {}
      },
      {
        "content": "when (${1:case}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "when": true
        },
        "options": {}
      },
      {
        "content": "@{ ${1:hash}  }{ ${0:array} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "hslice": true
        },
        "options": {}
      },
      {
        "content": "map {  ${0: body }    }  ${1: @array } ;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "map": true
        },
        "options": {}
      },
      {
        "content": "=head1 NAME\n${1:ClassName} - ${2:ShortDesc}\n=head1 SYNOPSIS\n  use $1;\n  ${3:# synopsis...}\n=head1 DESCRIPTION\n${0:# longer description...}\n=head1 INTERFACE\n=head1 DEPENDENCIES\n=head1 SEE ALSO",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ppod": true
        },
        "options": {}
      },
      {
        "content": "=head2 ${1:MethodName}\n${0:Summary....}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "psub": true
        },
        "options": {}
      },
      {
        "content": "=head2 ${1:MethodName}\n${0:Summary...}\n=cut",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "psubi": true
        },
        "options": {}
      },
      {
        "content": "=head2 $1\nSummary of $1\n=cut\nsub ${1:subroutine_name} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "subpod": true
        },
        "options": {}
      },
      {
        "content": "=over 2\n=item\nArguments\n=over 3\n=item\nC<${1:DataStructure}>\n  ${2:Sample}\n=back\n=item\nReturn\n=over 3\n=item\nC<${0:...return data}>\n=back\n=back",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "parg": true
        },
        "options": {}
      },
      {
        "content": "has ${1:attribute} => (\n\tis\t    => '${2:ro|rw}',\n\tisa \t=> '${3:Str|Int|HashRef|ArrayRef|etc}',\n\tdefault => sub {\n\t\t${4:defaultvalue}\n\t},\n\t${0:# other attributes}\n);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "has": true
        },
        "options": {}
      },
      {
        "content": "override ${1:attribute} => sub {\n\t${2:# my $self = shift;};\n\t${0:# my ($self, $args) = @_;};\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "override": true
        },
        "options": {}
      },
      {
        "content": "use Test::More;\nuse Test::Deep; # (); # uncomment to stop prototype errors\nuse Test::Exception;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tuse": true
        },
        "options": {}
      },
      {
        "content": "use lib qw{ ./t/lib };",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tlib": true
        },
        "options": {}
      },
      {
        "content": "$ENV{TEST_METHOD} = '${0:regex}';",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tmeths": true
        },
        "options": {}
      },
      {
        "content": "use ${0:test_class};\n$1->runtests();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "trunner": true
        },
        "options": {}
      },
      {
        "content": "sub t${1:number}_${2:test_case} :Test(${3:num_of_tests}) {\n\tmy $self = shift;\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tsub": true
        },
        "options": {}
      },
      {
        "content": "test ${1:test_name} => { description => '${2:Description of test.}'} => sub {\n\tmy ($self) = @_;\n\t${0}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "trsub": true
        },
        "options": {}
      },
      {
        "content": "sub prep${1:number}_${2:test_case} :Test(startup) {\n\tmy $self = shift;\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tprep": true
        },
        "options": {}
      },
      {
        "content": "use Carp; # 'verbose';\n# cloak \"die\"\n# warn \"warning\"\n$SIG{'__DIE__'} = sub {\n\trequire Carp; Carp::confess\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "debug_trace": true
        },
        "options": {}
      },
      {
        "content": "use Data::Dump qw(dump);\nwarn dump ${1:variable}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dump": true
        },
        "options": {}
      },
      {
        "content": "use DDP;\np ${1:variable}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ddp": true
        },
        "options": {}
      },
      {
        "content": "subtest '${1: test_name}' => sub {\n\t${2}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "subtest": true
        },
        "options": {}
      },
      {
        "content": "if ($1) {\n\t${2:# body...}\n}\nelse {\n\t${3:# else...}\n}\n",
        "doc": "",
        "grammar": "snu",
        "label": "Conditional if..else (ife)",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "if ($1) {\n\t${2:# body...}\n}\nelsif ($3) {\n\t${4:# elsif...}\n}\nelse {\n\t${5:# else...}\n}\n",
        "doc": "",
        "grammar": "snu",
        "label": "Conditional if..elsif..else (ifee)",
        "matches": {
          "ifee": true
        },
        "options": {}
      },
      {
        "content": "${1:expression} unless ${2:condition};\n",
        "doc": "",
        "grammar": "snu",
        "label": "Conditional one-line (unless)",
        "matches": {
          "xunless": true
        },
        "options": {}
      },
      {
        "content": "${1:expression} if ${2:condition};\n",
        "doc": "",
        "grammar": "snu",
        "label": "Conditional one-line (xif)",
        "matches": {
          "xif": true
        },
        "options": {}
      },
      {
        "content": "sub ${1:function_name} {\n\t${2:# body...}\n}\n",
        "doc": "",
        "grammar": "snu",
        "label": "Function (sub)",
        "matches": {
          "sub": true
        },
        "options": {}
      },
      {
        "content": "${1:expression} foreach @${2:array};\n",
        "doc": "",
        "grammar": "snu",
        "label": "Loop one-line (xforeach)",
        "matches": {
          "xfore": true
        },
        "options": {}
      },
      {
        "content": "${1:expression} while ${2:condition};\n",
        "doc": "",
        "grammar": "snu",
        "label": "Loop one-line (xwhile)",
        "matches": {
          "xwhile": true
        },
        "options": {}
      },
      {
        "content": "#!/usr/bin/env perl -w\n\nuse strict;\nuse Test::More tests => ${1:1};\nuse ${2:ModuleName};\n\nok(${3:assertion});\n",
        "doc": "",
        "grammar": "snu",
        "label": "Test",
        "matches": {
          "test": true
        },
        "options": {}
      },
      {
        "content": "local $@;\neval {\n\t${1:# do something risky...}\n};\nif (my $${2:exception} = $@) {\n\t${3:# handle failure...}\n}\n",
        "doc": "",
        "grammar": "snu",
        "label": "eval",
        "matches": {
          "eval": true
        },
        "options": {}
      },
      {
        "content": "for (my $${1:var} = 0; $$1 < ${2:expression}; $$1++) {\n\t${3:# body...}\n}\n",
        "doc": "",
        "grammar": "snu",
        "label": "for",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "foreach ${1:my $${2:x}} (@${3:array}) {\n\t${4:# body...}\n}\n",
        "doc": "",
        "grammar": "snu",
        "label": "foreach",
        "matches": {
          "fore": true
        },
        "options": {}
      },
      {
        "content": "if ($1) {\n\t${2:# body...}\n}\n",
        "doc": "",
        "grammar": "snu",
        "label": "if",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "my $${1:var} = do { local $/ = undef; open my $fh, '<', ${2:$file}; <$fh> };\n",
        "doc": "",
        "grammar": "snu",
        "label": "slurp",
        "matches": {
          "slurp": true
        },
        "options": {}
      },
      {
        "content": "unless ($1) {\n\t${2:# body...}\n}\n",
        "doc": "",
        "grammar": "snu",
        "label": "unless",
        "matches": {
          "unless": true
        },
        "options": {}
      },
      {
        "content": "while ($1) {\n\t${2:# body...}\n}\n",
        "doc": "",
        "grammar": "snu",
        "label": "while",
        "matches": {
          "while": true
        },
        "options": {}
      },
      {
        "content": "until ($1) {\n\t${2:# body...}\n}\n",
        "doc": "",
        "grammar": "snu",
        "label": "until",
        "matches": {
          "until": true
        },
        "options": {}
      }
    ],
    "perl6": [
      {
        "content": "#!/usr/bin/env perl6",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#!": true
        },
        "options": {}
      },
      {
        "content": "=>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ".": true
        },
        "options": {}
      },
      {
        "content": "sub ${1:function_name}(${2:Str $var}) {\n\t${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sub": true
        },
        "options": {}
      },
      {
        "content": "multi ${1:function_name}(${2:Str $var}) {\n\t${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mul": true
        },
        "options": {}
      },
      {
        "content": "if ${1} {\n\t${2}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "if ${1} {\n\t${2}\n}\nelse {\n\t${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "${1:expression} if ${2:condition};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "xif": true
        },
        "options": {}
      },
      {
        "content": "unless ${1} {\n\t${2}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "unless": true
        },
        "options": {}
      },
      {
        "content": "${1:expression} unless ${2:condition};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "xunless": true
        },
        "options": {}
      },
      {
        "content": "${1:condition} ?? ${2:value-if-true} !! ${3:value-if-false};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tc": true
        },
        "options": {}
      },
      {
        "content": "given ${1:$var} {\n  when ${2:condition} {\n\t  ${3:# code block ...}\n  }\n  ${4}\n  default {\n\t  ${5}\n  }\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "switch": true
        },
        "options": {}
      },
      {
        "content": "loop (my ${1:$i} = 0; $$1 < ${2:count}; $$1++) {\n\t${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "loop": true
        },
        "options": {}
      },
      {
        "content": "for ${1:@array} -> ${2:$variable} {\n\t${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "while ${1} {\n\t${2}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh": true
        },
        "options": {}
      },
      {
        "content": "repeat {\n\t${1}\n} ${2:while|until} ${3};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rp": true
        },
        "options": {}
      },
      {
        "content": "${1:my} class ${2:ClassName} ${3:is|does Parent|Role}{\n\t${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cl": true
        },
        "options": {}
      },
      {
        "content": "has ${1:Type} ${2:$!identifier};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "has": true
        },
        "options": {}
      },
      {
        "content": "method ${1:method_name}(${2:$attr}) {\n\t${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mth": true
        },
        "options": {}
      },
      {
        "content": "method ${1:!}${2:method_name}(${3:$attr}) {\n\t${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pmth": true
        },
        "options": {}
      },
      {
        "content": "submethod ${1:submethod_name}(${2:$attr}) {\n\t${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "smth": true
        },
        "options": {}
      },
      {
        "content": "use v6;\nuse Test;\n${1:use lib 'lib';}\nplan ${2:$num-tests};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "test": true
        },
        "options": {}
      },
      {
        "content": "my ${1:$var} = \"${2:filename}\".IO.slurp;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "slurp": true
        },
        "options": {}
      },
      {
        "content": "for \"${1:filename}\".IO.lines -> $line {\n\t${2}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rfile": true
        },
        "options": {}
      },
      {
        "content": "my $fh = open \"${1:filename}\", ${2::r|:w|:a};\n${3:# actions};\n$fh.close;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "open": true
        },
        "options": {}
      }
    ],
    "phoenix": [
      {
        "content": "defmodule ${1:AppName}Web.${2:ControllerName}Controller do\n\tuse $1Web, :controller\n\t${3}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cont": true
        },
        "options": {}
      },
      {
        "content": "defmodule ${1:AppName}Web.${2:ViewName}View do\n\tuse $1Web, :view\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "view": true
        },
        "options": {}
      },
      {
        "content": "defmodule ${1:AppName}Web.${2:ChannelName}Channel do\n\tuse $1Web, :channel\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "chan": true
        },
        "options": {}
      }
    ],
    "php": [
      {
        "content": "${1:public }function ${2:#:FunctionName}(${3})\n{\n\t${4:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "public function () {}",
        "matches": {
          "function": true
        },
        "options": {}
      },
      {
        "content": "function (${1})${2: use } {\n\t${3:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "function () {}",
        "matches": {
          "function_literal": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "<?php\n${1:TARGET}\n/* End of file ${2:filename}.php */",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "php": true
        },
        "options": {}
      },
      {
        "content": "<?php echo ${1} ?>${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pecho": true
        },
        "options": {}
      },
      {
        "content": "<?php echo htmlentities(${1}, ENT_QUOTES, 'utf-8') ?>${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "echoh": true
        },
        "options": {}
      },
      {
        "content": "<?$php foreach ($${1:#:variable} as $${2:#:key}${3: =>}): ?>\n${0:TARGET}\n<?php endforeach; ?>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pforeach": true
        },
        "options": {}
      },
      {
        "content": "<?php if (${1:#:condition}): ?>\n${2:TARGET}\n<?php else: ?>\n${0}\n<?php endif; ?>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pifelse": true
        },
        "options": {}
      },
      {
        "content": "<?php if (${1:#:condition}): ?>\n${0:TARGET}\n<?php endif; ?>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pif": true
        },
        "options": {}
      },
      {
        "content": "<?php else: ?>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pelse": true
        },
        "options": {}
      },
      {
        "content": "<?php $this->${0} ?>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pthis": true
        },
        "options": {}
      },
      {
        "content": "<?php echo $this->${0} ?>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pethis": true
        },
        "options": {}
      },
      {
        "content": "/**\n * ${3:#:undocumented class variable}\n *\n * @var ${4:#:string}\n **/\n${1:#:var} $${2};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "doc_class_var": true
        },
        "options": {}
      },
      {
        "content": "/**\n * ${3:#:undocumented constant}\n **/\ndefine(${1} ${2});${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "doc_constant": true
        },
        "options": {}
      },
      {
        "content": "/**\n * ${4:#:undocumented function}\n *\n * @return ${5:void}\n * @author ${6}\n **/\n${1}function ${2}(${3});${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "doc_interface_function": true
        },
        "options": {}
      },
      {
        "content": "/**\n * ${4:#:undocumented function}\n *\n * @return ${5:void}\n * @author ${6}\n **/\n${1}function ${2}(${3})\n{\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "doc_function": true
        },
        "options": {}
      },
      {
        "content": "/**\n * ${1}\n *\n * @author ${2}\n * @version ${3}\n * @copyright ${4}\n * @package ${5:default}\n **/\n/**\n * Define DocBlock\n **/",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "doch": true
        },
        "options": {}
      },
      {
        "content": "/**\n * ${2:#:undocumented class}\n *\n * @package ${3:default}\n * @author ${4}\n **/\ninterface ${1}\n{\n\t${0:TARGET}\n} // END interface $1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "doci": true
        },
        "options": {}
      },
      {
        "content": "/**\n * ${0}\n */",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "doc": true
        },
        "options": {}
      },
      {
        "content": "/**\n * ${1}\n */\nclass ${2:#:ClassName}${3:#:extends}\n{\n\t$5\n\tfunction ${4:__construct}(${5:#:argument})\n\t{\n\t\t${0:# code...}\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "class_with_constructor": true
        },
        "options": {}
      },
      {
        "content": "class ${2:#:ClassName} {\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "class": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "${1}defined('${2}')${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "def": true
        },
        "options": {}
      },
      {
        "content": "do {\n\t${0:TARGET}\n} while (${1:#:condition});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dowhile": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "$${1:#:retVal} = (${2:#:condition}) ? ${3:#:a} : ${4:#:b};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if?": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "if (${1:#:condition}) {\n\t${2:TARGET}\n} else {\n\t${3:#:code...}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifelse": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "if (${1:#:condition}) {\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "var_dump(${0:TARGET});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "var_dump": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "print_r(${1});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "echo \"${1:#:string}\";",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "echo": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "printf(\"${1:#:string}\\n\"${2:, });",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "println": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "else {\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "else": true
        },
        "options": {}
      },
      {
        "content": "elseif (${1:#:condition}) {\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "elseif": true
        },
        "options": {}
      },
      {
        "content": "for ($${1:i}=${2:0}; $$1 < ${3}; $$1++) {\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "foreach ($${1:#:variable} as $${2:#:key}${3: =>} $${4:#:value}) {\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "foreach-hashmap": true
        },
        "options": {}
      },
      {
        "content": "foreach ($${1:#:variable} as $${2:#:x}) {\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "foreach": true,
          "foreach-list": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "function __construct(${1})\n{\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "construct": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "<<<${1:HTML}\n${2:TARGET:#:content here}\n$1;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "here": true
        },
        "options": {}
      },
      {
        "content": "include '${1:#:file}';${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "inc": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "include_once '${1:#:file}';${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "inco": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "$${1:#:arrayName} = array('${2}' => ${3} ${0});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "array": true
        },
        "options": {}
      },
      {
        "content": "require '${1:#:file}';${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "req": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "require_once '${1:#:file}';${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "reqo": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "return${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ret": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "return false;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "retf": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "return true;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rett": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "case '${1:#:variable}':\n\t${0:#:code...}\n\tbreak;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "switch (${1:#:variable}) {\ncase '${2:#:value}':\n\t${3:#:code...}\n\tbreak;\n${0}\ndefault:\n\t${4:#:code...}\n\tbreak;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "sw",
        "matches": {
          "switch": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "try {\n\t${1:TARGET}\n} catch (${2:#:Exception} $e) {\n\t${3:#:code}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "try": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "try {\n\t${1:TARGET}\n} catch (${2:#:Exception} $e) {\n\t${3:#:code}\n} finally {\n\t${4:#:code}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tryf": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "throw new ${1}Exception(${2:\"${3:#:Error Processing Request}\"}${4:});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "throw": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "while (${1}) {\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "wh",
        "matches": {
          "while": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "\\$GLOBALS['${1:#:variable}']${2: = }${3:#:something}${4:;}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gloabals": true
        },
        "options": {}
      },
      {
        "content": "\\$_COOKIE['${1:#:variable}']",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cookie": true
        },
        "options": {}
      },
      {
        "content": "\\$_ENV['${1:#:variable}']",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "env": true
        },
        "options": {}
      },
      {
        "content": "\\$_FILES['${1:#:variable}']",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "files": true
        },
        "options": {}
      },
      {
        "content": "\\$_GET['${1:#:variable}']",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "get": true
        },
        "options": {}
      },
      {
        "content": "\\$_POST['${1:#:variable}']",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "post": true
        },
        "options": {}
      },
      {
        "content": "\\$_REQUEST['${1:#:variable}']",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "request": true
        },
        "options": {}
      },
      {
        "content": "\\$_SERVER['${1:#:variable}']",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "server": true
        },
        "options": {}
      },
      {
        "content": "\\$_SESSION['${1:#:variable}']",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "session": true
        },
        "options": {}
      },
      {
        "content": "var_export(${1}, true)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "inspect": true,
          "var_export": true
        },
        "options": {}
      },
      {
        "content": "<?php\n${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "<?": true
        },
        "options": {}
      },
      {
        "content": "declare(strict_types=${1:1});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dst \"declare(strict_types=1)\"": true
        },
        "options": {}
      },
      {
        "content": "echo ${0};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ec": true
        },
        "options": {}
      },
      {
        "content": "<?php echo ${0} ?>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "<?e": true
        },
        "options": {}
      },
      {
        "content": "<?=${0}?>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "<?=": true
        },
        "options": {}
      },
      {
        "content": "<?= ${0} ?>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "?=": true
        },
        "options": {}
      },
      {
        "content": "<?php ${0} ?>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "?": true
        },
        "options": {}
      },
      {
        "content": "<?php foreach ($${1:vars} as $${2:$var}): ?>\n\t${0:${VISUAL}}\n<?php endforeach ?>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "?f": true
        },
        "options": {}
      },
      {
        "content": "<?php if ($${1:var}): ?>\n\t${0:${VISUAL}}\n<?php endif ?>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "?i": true
        },
        "options": {}
      },
      {
        "content": "namespace ${1:Foo\\Bar\\Baz};\n${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ns": true
        },
        "options": {}
      },
      {
        "content": "$this->",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "t.": true
        },
        "options": {}
      },
      {
        "content": "function ${1}(${3})\n{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "f": true
        },
        "options": {}
      },
      {
        "content": "${1:protected} function ${2:foo}()\n{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "m": true
        },
        "options": {}
      },
      {
        "content": "/**\n * Gets the value of ${1:foo}\n *\n * @return ${2:string}\n */\n${3:public} function get${4:$1}()\n{\n\treturn $this->${5:$1};\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gm \"PHP Class Getter Setter\"": true
        },
        "options": {}
      },
      {
        "content": "${1:$foo}->set${2:Bar}(${0});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "$s": true
        },
        "options": {}
      },
      {
        "content": "${1:$foo}->get${0:Bar}();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "$g": true
        },
        "options": {}
      },
      {
        "content": "$${1:foo} = ${2:true} ? ${3:a} : ${0};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "=?:": true
        },
        "options": {}
      },
      {
        "content": "${1:true} ? ${2:a} : ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "?:": true
        },
        "options": {}
      },
      {
        "content": "$${1:retVal} = (${2:condition}) ? ${3:a} : ${4:b};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "t \"$retVal = (condition) ? a : b\"": true
        },
        "options": {}
      },
      {
        "content": "$_COOKIE['${1:variable}']",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "C": true
        },
        "options": {}
      },
      {
        "content": "$_ENV['${1:variable}']",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "E": true
        },
        "options": {}
      },
      {
        "content": "$_FILES['${1:variable}']",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "F": true
        },
        "options": {}
      },
      {
        "content": "$_GET['${1:variable}']",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "G \"_GET array\"": true
        },
        "options": {}
      },
      {
        "content": "$_POST['${1:variable}']",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "P \"_POST array\"": true
        },
        "options": {}
      },
      {
        "content": "$_REQUEST['${1:variable}']",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "R": true
        },
        "options": {}
      },
      {
        "content": "$_SERVER['${1:variable}']",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "S": true
        },
        "options": {}
      },
      {
        "content": "$_SESSION['${1:variable}']",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "SS": true
        },
        "options": {}
      },
      {
        "content": "$_GET['${1}']",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "get \"get\"": true
        },
        "options": {}
      },
      {
        "content": "$_POST['${1}']",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "post \"post\"": true
        },
        "options": {}
      },
      {
        "content": "$_SESSION['${1}']",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "session \"session\"": true
        },
        "options": {}
      },
      {
        "content": "include '${1:file}';",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "inc": true
        },
        "options": {}
      },
      {
        "content": "include_once '${1:file}';",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "inc1": true
        },
        "options": {}
      },
      {
        "content": "require '${1:file}';",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "req": true
        },
        "options": {}
      },
      {
        "content": "require_once '${1:file}';",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "req1": true
        },
        "options": {}
      },
      {
        "content": "/**\n * ${0}\n */",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "/*": true
        },
        "options": {}
      },
      {
        "content": "/**\n * ${1:undocumented class variable}\n *\n * @var ${2:string}\n */",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "doc_vp": true
        },
        "options": {}
      },
      {
        "content": "/**\n * ${3:undocumented class variable}\n *\n * @var ${4:string}\n */\n${1:var} $${2};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "doc_v": true
        },
        "options": {}
      },
      {
        "content": "/** @var ${3:string} */\n${1:public} $${2};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "att": true
        },
        "options": {}
      },
      {
        "content": "/**\n * ${1:undocumented constant}\n */",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "doc_dp": true
        },
        "options": {}
      },
      {
        "content": "/**\n * ${3:undocumented constant}\n */\ndefine(${1}, ${2});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "doc_d": true
        },
        "options": {}
      },
      {
        "content": "/**\n * {@inheritdoc}\n */",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "inheritdoc \"@inheritdoc docblock\"": true
        },
        "options": {}
      },
      {
        "content": "define('${1:VARIABLE_NAME}', ${2:'definition'});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "def \"define('VARIABLE_NAME', 'definition')\"": true
        },
        "options": {}
      },
      {
        "content": "${1}defined('${2}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "def?": true
        },
        "options": {}
      },
      {
        "content": "while (${1:/* condition */}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh \"while (condition) { ... }\"": true
        },
        "options": {}
      },
      {
        "content": "do {\n\t${0:${VISUAL}}\n} while (${1});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "do \"do { ... } while (condition)\"": true
        },
        "options": {}
      },
      {
        "content": "if (${1}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if \"if (condition) { ... }\"": true
        },
        "options": {}
      },
      {
        "content": "if (!${1}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifn \"if (!condition) { ... }\"": true
        },
        "options": {}
      },
      {
        "content": "<?php if (${1}): ?>\n\t${0:${VISUAL}}\n<?php endif; ?>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifil \"<?php if (condition): ?> ... <?php endif; ?>\"": true
        },
        "options": {}
      },
      {
        "content": "if (${1}) {\n\t${0:${VISUAL}}\n} else {\n\t${2}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife \"if (cond) { ... } else { ... }\"": true
        },
        "options": {}
      },
      {
        "content": "<?php if (${1}): ?>\n\t${0:${VISUAL}}\n<?php else: ?>\n\t${2}\n<?php endif; ?>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifeil \"<?php if (condition): ?> ... <?php else: ?> ... <?php endif; ?>\"": true
        },
        "options": {}
      },
      {
        "content": "else {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "el \"else { ... }\"": true
        },
        "options": {}
      },
      {
        "content": "elseif (${1}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eif \"elseif(condition) { ... }\"": true
        },
        "options": {}
      },
      {
        "content": "switch ($${1:variable}) {\n\tcase '${2:value}':\n\t\t${3}\n\t\tbreak;\n\t${0}\n\tdefault:\n\t\t${4}\n\t\tbreak;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "switch \"switch($var) { case 'xyz': ... default: .... }\"": true
        },
        "options": {}
      },
      {
        "content": "case '${1:value}':\n\t${0:${VISUAL}}\n\tbreak;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case \"case 'value': ... break\"": true
        },
        "options": {}
      },
      {
        "content": "for ($${2:i} = 0; $$2 < ${1:count}; $$2${3:++}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for \"for ($i = 0; $i < $count; $i++) { ... }\"": true
        },
        "options": {}
      },
      {
        "content": "foreach ($${1:variable} as $${2:value}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "foreach \"foreach ($var as $value) { .. }\"": true
        },
        "options": {}
      },
      {
        "content": "<?php foreach ($${1:variable} as $${2:value}): ?>\n\t${0:${VISUAL}}\n<?php endforeach; ?>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "foreachil \"<?php foreach ($var as $value): ?>  ... <?php endforeach; ?>\"": true
        },
        "options": {}
      },
      {
        "content": "foreach ($${1:variable} as $${2:key} => $${3:value}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "foreachk \"foreach ($var as $key => $value) { .. }\"": true
        },
        "options": {}
      },
      {
        "content": "<?php foreach ($${1:variable} as $${2:key} => $${3:value}): ?>\n\t${0:<!-- html... -->}\n<?php endforeach; ?>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "foreachkil \"<?php foreach ($var as $key => $value): ?>  ... <?php endforeach; ?>\"": true
        },
        "options": {}
      },
      {
        "content": "$${1:arrayName} = ['${2}' => ${3}];",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "array \"$... = ['' => ]\"": true
        },
        "options": {}
      },
      {
        "content": "try {\n\t${0:${VISUAL}}\n} catch (${1:Exception} $e) {\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "try \"try { ... } catch (Exception $e) { ... }\"": true
        },
        "options": {}
      },
      {
        "content": "${1:static }function (${2:args}) use (${3:&$x, $y /*put vars in scope (closure) */}) {\n\t${0}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lambda": true
        },
        "options": {}
      },
      {
        "content": "echo '<pre>'; var_dump(${0}); echo '</pre>';",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pd": true
        },
        "options": {}
      },
      {
        "content": "echo '<pre>'; var_dump(${1}); echo '</pre>'; die(${0:});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pdd": true
        },
        "options": {}
      },
      {
        "content": "var_dump(${0});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vd": true
        },
        "options": {}
      },
      {
        "content": "var_dump(${1}); die(${0:});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vdd": true
        },
        "options": {}
      },
      {
        "content": "print_r(${0});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pr": true
        },
        "options": {}
      },
      {
        "content": "print_r(${0}, 1);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prs": true
        },
        "options": {}
      },
      {
        "content": "error_log(print_r($${1:foo}, true), 3, '${2:/tmp/debug.log}');",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vdf": true
        },
        "options": {}
      },
      {
        "content": "header (\"HTTP/1.1 301 Moved Permanently\");\nheader (\"Location: \".URL);\nexit();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "http_redirect": true
        },
        "options": {}
      },
      {
        "content": "error_log(var_export(${1}, true));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "log \"error_log(var_export($var, true));\"": true
        },
        "options": {}
      },
      {
        "content": "var_export(${1});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "var \"var_export($var)\"": true
        },
        "options": {}
      },
      {
        "content": "echo '<pre>' . var_export(${1}, 1) . '</pre>';",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ve \"Dumb debug helper in HTML\"": true
        },
        "options": {}
      },
      {
        "content": "var_export($1);$0",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc \"Dumb debug helper in cli\"": true
        },
        "options": {}
      },
      {
        "content": "/**\n * ${1:description}\n *\n * @${0}\n */\n${2:protected} $${3:foo};\npublic function get${4:$3}()\n{\n\treturn $this->$3;\n}\npublic function set$4(${5:$4 }$${6:$3})\n{\n\t$this->$3 = $$6;\n\treturn $this;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ags": true
        },
        "options": {}
      },
      {
        "content": "return true;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rett": true
        },
        "options": {}
      },
      {
        "content": "return false;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "retf": true
        },
        "options": {}
      },
      {
        "content": "$${1:foo} = array_map(function($${2:v}) {\n\t${0}\n\treturn $$2;\n}, $$1);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "am": true
        },
        "options": {}
      },
      {
        "content": "array_walk($${1:foo}, function(&$${2:v}, $${3:k}) {\n\t$$2 = ${0};\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "aw": true
        },
        "options": {}
      },
      {
        "content": "static $${1} = null;\nif (is_null($$1)){\n\t$$1 = ${2};\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "static_var": true
        },
        "options": {}
      },
      {
        "content": "<?php\nclass CSVWriter {\n\tpublic function __construct($file_or_handle, $sep = \"\\t\", $quot = '\"'){\n\t\t$args = func_get_args();\n\t\t$mode = isset($opts['mode']) ? $opts['mode'] : 'w';\n\t\t$this->f =\n\t\t\tis_string($file_or_handle)\n\t\t\t? fopen($file_or_handle, $mode)\n\t\t\t: $file_or_handle;\n\t\t$this->fputcsv_args = [$this->f, null, $sep, $quot];\n\t\tif (!$this->f) throw new Exception('bad file descriptor');\n\t}\n\tpublic function write($row){\n\t\t$this->fputcsv_args[1] =& $row;\n\t\tcall_user_func_array('fputcsv', $this->fputcsv_args);\n\t}\n\tpublic function close(){\n\t\tif (!is_null($this->f))\n\t\t\tfclose($this->f);\n\t\t$this->f = null;\n\t}\n\tpublic function __destruct(){\n\t\t$this->close();\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "CSVWriter": true
        },
        "options": {}
      },
      {
        "content": "// http://snipplr.com/view.php?codeview&id=1986 // modified\nclass CSVIterator implements Iterator\n{\t\n\tprivate $f;\n\tprivate $curr;\n\tprivate $rowCounter;\n\t /* opts keys:\n\t\t* row_size\n\t\t* escape\n\t\t* enclosure\n\t\t* delimiter\n\t\t*/\n\tpublic function __construct( $file_or_handle, $opts = [4096, ','] )\n\t{\n\t\t$d = function($n) use(&$opts){ return isset($opts[$n]) ? $opts[$n] : false; };\n\t\t$this->combine = $d('combine');\n\t\t$this->headers = $d('headers');\n\t\t$this->headerCheckFunction = $d('header_check_function');\n\t\t$this->f =\n\t\t\tis_string($file_or_handle)\n\t\t\t? fopen( $file_or_handle, 'r' )\n\t\t\t: $file_or_handle;\n\t\tif (!$this->f) throw new Exception('bad file descriptor');\n\t\t$this->fgetcsv_args = [\n\t\t\t\t$this->f,\n\t\t\t\tisset($opts['row_size']) ? $opts['row_size'] : 4096,\n\t\t\t\tisset($opts['delimiter']) ? $opts['delimiter'] : ',',\n\t\t\t\tisset($opts['enclosure']) ? $opts['enclosure'] : '\"',\n\t\t\t\tisset($opts['escape']) ? $opts['escape'] : '\\\\',\n\t\t];\n\t\t$this->start();\n\t}\n\tprotected function readRow(){\n\t\t$this->curr = call_user_func_array('fgetcsv', $this->fgetcsv_args );\n\t\t$this->rowCounter++;\n\t\tif ($this->rowCounter == 1){\n\t\t\t$this->processHeader();\n\t\t} elseif ($this->curr) {\n\t\t\t$this->processRow();\n\t\t}\n\t}\n\tpublic function processHeader(){\n\t\tif ($this->headers || $this->combine){\n\t\t\t$this->header = $this->curr;\n\t\t\tif ($this->headerCheckFunction){\n\t\t\t\t$f = $this->headerCheckFunction;\n\t\t\t\t$f($this->header);\n\t\t\t}\n\t\t\t$this->readRow();\n\t\t}\n\t}\n\tpublic function processRow(){\n\t\tif ($this->combine)\n\t\t\t$this->curr = array_combine($this->header, $this->curr);\n\t}\n\tpublic function start(){\n\t\t$this->rowCounter = 0;\n\t\trewind( $this->f );\n\t\t$this->readRow();\n\t}\n\tpublic function rewind()\n\t{\n\t\t$this->start();\n\t}\n\tpublic function current()\n\t{\n\t\t$curr = $this->curr;\n\t\t$this->readRow();\n\t\treturn $curr;\n\t}\n\tpublic function key()\n\t{\n\t\treturn $this->rowCounter;\n\t}\n\tpublic function next()\n\t{\n\t\treturn $this->curr;\n\t}\n\tpublic function valid(){\n\t\tif( !$this->next() )\n\t\t{\n\t\t\tfclose( $this->f );\n\t\t\treturn FALSE;\n\t\t}\n\t\treturn TRUE;\n\t}\n} // end class",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "CSVIterator": true
        },
        "options": {}
      },
      {
        "content": "$this->assertEquals(${1:$expected}, ${2:$actual});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ase \"$this->assertEquals($a, $b)\"": true
        },
        "options": {}
      },
      {
        "content": "$this->assertNotEquals(${1:$expected}, ${2:$actual});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asne \"$this->assertNotEquals($a, $b)\"": true
        },
        "options": {}
      },
      {
        "content": "$this->assertFalse(${1});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asf \"$this->assertFalse($a)\"": true
        },
        "options": {}
      },
      {
        "content": "$this->assertTrue(${1});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ast \"$this->assertTrue($a)\"": true
        },
        "options": {}
      },
      {
        "content": "$this->assertFileExists(${1:'path/to/file'});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asfex \"$this->assertFileExists('path/to/file')\"": true
        },
        "options": {}
      },
      {
        "content": "$this->assertFileNotExists(${1:'path/to/file'});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asfnex \"$this->assertFileNotExists('path/to/file')\"": true
        },
        "options": {}
      },
      {
        "content": "$this->assertContains(${1:$needle}, ${2:$haystack});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ascon \"$this->assertContains($needle, $haystack)\"": true
        },
        "options": {}
      },
      {
        "content": "$this->assertNotContains(${1:$needle}, ${2:$haystack});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asncon \"$this->assertNotContains($needle, $haystack)\"": true
        },
        "options": {}
      },
      {
        "content": "$this->assertContainsOnly(${1:$needle}, ${2:$haystack});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ascono \"$this->assertContainsOnly($needle, $haystack)\"": true
        },
        "options": {}
      },
      {
        "content": "$this->assertContainsOnlyInstancesOf(${1:Example}::class, ${2:$haystack});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asconoi \"$this->assertContainsOnlyInstancesOf(Example::class, $haystack)\"": true
        },
        "options": {}
      },
      {
        "content": "$this->assertArrayHasKey(${1:$key}, ${2:$array});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ashk \"$this->assertArrayHasKey($key, $array)\"": true
        },
        "options": {}
      },
      {
        "content": "this->assertArrayNotHasKey(${1:$key}, ${2:$array});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asnhk \"$this->assertArrayNotHasKey($key, $array)\"": true
        },
        "options": {}
      },
      {
        "content": "$this->assertClassHasAttribute(${1:$attributeName}, ${2:Example}::class);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ascha \"$this->assertClassHasAttribute($name, Example::class)\"": true
        },
        "options": {}
      },
      {
        "content": "$this->assertInstanceOf(${1:Example}::class, ${2:$actual});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asi \"$this->assertInstanceOf(Example::class, $actual)\"": true
        },
        "options": {}
      },
      {
        "content": "$this->assertInternalType(${1:'string'}, ${2:actual});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asit \"$this->assertInternalType('string', $actual)\"": true
        },
        "options": {}
      },
      {
        "content": "$this->assertCount(${1:$expectedCount}, ${2:$haystack});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asco \"$this->assertCount($count, $haystack)\"": true
        },
        "options": {}
      },
      {
        "content": "$this->assertNotCount(${1:$count}, ${2:$haystack});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asnco \"$this->assertNotCount($count, $haystack)\"": true
        },
        "options": {}
      },
      {
        "content": "$this->assertArraySubset(${1:$subset}, ${2:$array});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "assub \"$this->assertArraySubset($subset, $array)\"": true
        },
        "options": {}
      },
      {
        "content": "$this->assertNull(${1});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asnu \"$this->assertNull($a)\"": true
        },
        "options": {}
      },
      {
        "content": "$this->assertNotNull(${1});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asnnu \"$this->assertNotNull($a)\"": true
        },
        "options": {}
      },
      {
        "content": "public function test${1}()\n{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "test \"public function testXYZ() { ... }\"": true
        },
        "options": {}
      },
      {
        "content": "protected function setUp()\n{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "setup \"protected function setUp() { ... }\"": true
        },
        "options": {}
      },
      {
        "content": "protected function tearDown()\n{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "teardown \"protected function tearDown() { ... }\"": true
        },
        "options": {}
      },
      {
        "content": "$${1:observer} = $this->prophesize(${2:SomeClass}::class);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "proph \"$observer = $this->prophesize(SomeClass::class);\"": true
        },
        "options": {}
      },
      {
        "content": "$${1:mock} = $this->createMock(${2:SomeClass}::class);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mock \"$mock = $this->createMock(SomeClass::class);\"": true
        },
        "options": {}
      },
      {
        "content": "expects($this->${1:once}())\n\t->method('${2}')\n\t->with(${3})\n\t->willReturn(${4});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "exp \"phpunit expects\"": true
        },
        "options": {}
      },
      {
        "content": "/**\n* @group ${1}\n*/",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "testcmt \"phpunit comment with group\"": true
        },
        "options": {}
      },
      {
        "content": "$this->fail(${1});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fail \"$this->fail()\"": true
        },
        "options": {}
      },
      {
        "content": "$this->markTestIncomplete(${1});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "marki \"$this->markTestIncomplete()\"": true
        },
        "options": {}
      },
      {
        "content": "$this->markTestSkipped(${1});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "marks \"$this->markTestSkipped()\"": true
        },
        "options": {}
      },
      {
        "content": "throw new ${1:Exception}(\"${2:Error Processing Request}\");",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "te \"throw new Exception()\"": true
        },
        "options": {}
      },
      {
        "content": "file_put_contents(${1:file}, ${2:content}${3:, FILE_APPEND});$0",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fpc \"file_put_contents\" b": true
        },
        "options": {}
      },
      {
        "content": "str_replace(${1:search}, ${2:replace}, ${3:subject})$0",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sr \"str_replace\"": true
        },
        "options": {}
      },
      {
        "content": "in_array(${1:needle}, ${2:haystack})$0",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ia \"in_array\"": true
        },
        "options": {}
      },
      {
        "content": "isset(${1:var})$0",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "is \"isset\"": true
        },
        "options": {}
      },
      {
        "content": "isset($${1:array}[${2:key}])$0",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isa \"isset array\"": true
        },
        "options": {}
      },
      {
        "content": "is_null($${1:var})$0",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "in \"is_null\"": true
        },
        "options": {}
      },
      {
        "content": "file_exists(${1:file})$0",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fe \"file_exists\"": true
        },
        "options": {}
      },
      {
        "content": "is_dir(${1:path})$0",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "id \"is_dir\"": true
        },
        "options": {}
      }
    ],
    "php-laravel": [],
    "php-phpspec": [
      {
        "content": "function it_$1()\n{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "function it_does_something() { ... }",
        "matches": {
          "it": true
        },
        "options": {}
      },
      {
        "content": "function let()\n{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "function let() { ... }",
        "matches": {
          "let": true
        },
        "options": {}
      },
      {
        "content": "function letgo()\n{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "function letgo() { ... }",
        "matches": {
          "letgo": true
        },
        "options": {}
      },
      {
        "content": "$this->beConstructedWith($1);",
        "doc": "",
        "grammar": "snu",
        "label": "$this->beConstructedWith($arg)",
        "matches": {
          "cw": true
        },
        "options": {}
      },
      {
        "content": "$this->beConstructedThrough(${1:'methodName'}, [${2:'$arg'}]);",
        "doc": "",
        "grammar": "snu",
        "label": "$this->beConstructedThrough($methodName, [$arg])",
        "matches": {
          "ct": true
        },
        "options": {}
      },
      {
        "content": "$this->${1:method}()->shouldReturn(${2:'value'});",
        "doc": "",
        "grammar": "snu",
        "label": "$this->XYZ()->shouldReturn('value')",
        "matches": {
          "sreturn": true
        },
        "options": {}
      },
      {
        "content": "$this->${1:method}()->shouldNotReturn(${2:'value'});",
        "doc": "",
        "grammar": "snu",
        "label": "$this->XYZ()->shouldNotReturn('value')",
        "matches": {
          "snreturn": true
        },
        "options": {}
      },
      {
        "content": "$this->${1:method}()->shouldBe(${2:'value'});",
        "doc": "",
        "grammar": "snu",
        "label": "$this->XYZ()->shouldBe('value')",
        "matches": {
          "sbe": true
        },
        "options": {}
      },
      {
        "content": "$this->${1:method}()->shouldNotBe(${2:'value'});",
        "doc": "",
        "grammar": "snu",
        "label": "$this->XYZ()->shouldNotBe('value')",
        "matches": {
          "snbe": true
        },
        "options": {}
      },
      {
        "content": "$this->${1:method}()->shouldEqual(${2:'value'});",
        "doc": "",
        "grammar": "snu",
        "label": "$this->XYZ()->shouldEqual('value')",
        "matches": {
          "sequal": true
        },
        "options": {}
      },
      {
        "content": "$this->${1:method}()->shouldNotEqual(${2:'value'});",
        "doc": "",
        "grammar": "snu",
        "label": "$this->XYZ()->shouldNotEqual('value')",
        "matches": {
          "snequal": true
        },
        "options": {}
      },
      {
        "content": "$this->${1:method}()->shouldBeEqualTo(${2:'value'});",
        "doc": "",
        "grammar": "snu",
        "label": "$this->XYZ()->shouldBeEqualTo('value')",
        "matches": {
          "sbequalto": true
        },
        "options": {}
      },
      {
        "content": "$this->${1:method}()->shouldNotBeEqualTo(${2:'value'});",
        "doc": "",
        "grammar": "snu",
        "label": "$this->XYZ()->shouldNotBeEqualTo('value')",
        "matches": {
          "snbequalto": true
        },
        "options": {}
      },
      {
        "content": "$this->${1:method}()->shouldBeLike(${2:'value'});",
        "doc": "",
        "grammar": "snu",
        "label": "$this->XYZ()->shouldBeLike('value')",
        "matches": {
          "sblike": true
        },
        "options": {}
      },
      {
        "content": "$this->${1:method}()->shouldNotBeLike(${2:'value'});",
        "doc": "",
        "grammar": "snu",
        "label": "$this->XYZ()->shouldNotBeLike('value')",
        "matches": {
          "snblike": true
        },
        "options": {}
      },
      {
        "content": "$this->shouldThrow(${1:'\\Exception'})->during${2:Method}(${3:'$arg'});",
        "doc": "",
        "grammar": "snu",
        "label": "$this->shouldThrow('\\Exception')->duringXYZ($arg)",
        "matches": {
          "sthrowm": true
        },
        "options": {}
      },
      {
        "content": "$this->shouldThrow(${1:'\\Exception'})->duringInstantiation();",
        "doc": "",
        "grammar": "snu",
        "label": "$this->shouldThrow('\\Exception')->duringInstantiation()",
        "matches": {
          "sthrowi": true
        },
        "options": {}
      },
      {
        "content": "$this->shouldHaveType($1);",
        "doc": "",
        "grammar": "snu",
        "label": "$this->shouldHaveType('Type')",
        "matches": {
          "stype": true
        },
        "options": {}
      },
      {
        "content": "$this->shouldNotHaveType($1);",
        "doc": "",
        "grammar": "snu",
        "label": "$this->shouldNotHaveType('Type')",
        "matches": {
          "sntype": true
        },
        "options": {}
      },
      {
        "content": "$this->shouldReturnAnInstanceOf($1);",
        "doc": "",
        "grammar": "snu",
        "label": "$this->shouldReturnAnInstanceOf('Type')",
        "matches": {
          "srinstance": true
        },
        "options": {}
      },
      {
        "content": "$this->shouldNotReturnAnInstanceOf($1);",
        "doc": "",
        "grammar": "snu",
        "label": "$this->shouldNotReturnAnInstanceOf('Type')",
        "matches": {
          "snrinstance": true
        },
        "options": {}
      },
      {
        "content": "$this->shouldBeAnInstanceOf($1);",
        "doc": "",
        "grammar": "snu",
        "label": "$this->shouldBeAnInstanceOf('Type')",
        "matches": {
          "sbinstance": true
        },
        "options": {}
      },
      {
        "content": "$this->shouldNotBeAnInstanceOf($1);",
        "doc": "",
        "grammar": "snu",
        "label": "$this->shouldNotBeAnInstanceOf('Type')",
        "matches": {
          "snbinstance": true
        },
        "options": {}
      },
      {
        "content": "$this->shouldImplement($1);",
        "doc": "",
        "grammar": "snu",
        "label": "$this->shouldImplement('Type')",
        "matches": {
          "simplement": true
        },
        "options": {}
      },
      {
        "content": "$this->shouldNotImplement($1);",
        "doc": "",
        "grammar": "snu",
        "label": "$this->shouldNotImplement('Type')",
        "matches": {
          "snimplement": true
        },
        "options": {}
      },
      {
        "content": "$this->shouldBe$1();",
        "doc": "",
        "grammar": "snu",
        "label": "$this->shouldBeXYZ()",
        "matches": {
          "sbstate": true
        },
        "options": {}
      },
      {
        "content": "$this->shouldNotBe$1();",
        "doc": "",
        "grammar": "snu",
        "label": "$this->shouldNotBeXYZ()",
        "matches": {
          "snbstate": true
        },
        "options": {}
      },
      {
        "content": "$this->${1:method}()->shouldHaveCount(${2:7});",
        "doc": "",
        "grammar": "snu",
        "label": "$this->XYZ()->shouldHaveCount(7)",
        "matches": {
          "scount": true
        },
        "options": {}
      },
      {
        "content": "$this->${1:method}()->shouldNotHaveCount(${2:7});",
        "doc": "",
        "grammar": "snu",
        "label": "$this->XYZ()->shouldNotHaveCount(7)",
        "matches": {
          "sncount": true
        },
        "options": {}
      },
      {
        "content": "$this->${1:method}()->shouldBe${2:String|Array|Bool}();",
        "doc": "",
        "grammar": "snu",
        "label": "$this->XYZ()->shouldBeString|Array|Bool()",
        "matches": {
          "sbscalar": true
        },
        "options": {}
      },
      {
        "content": "$this->${1:method}()->shouldNotBe${2:String|Array|Bool}();",
        "doc": "",
        "grammar": "snu",
        "label": "$this->XYZ()->shouldNotBeString|Array|Bool()",
        "matches": {
          "snbscalar": true
        },
        "options": {}
      },
      {
        "content": "$this->${1:method}()->shouldContain(${2:'value'});",
        "doc": "",
        "grammar": "snu",
        "label": "$this->XYZ()->shouldContain('value')",
        "matches": {
          "scontain": true
        },
        "options": {}
      },
      {
        "content": "$this->${1:method}()->shouldNotContain(${2:'value'});",
        "doc": "",
        "grammar": "snu",
        "label": "$this->XYZ()->shouldNotContain('value')",
        "matches": {
          "sncontain": true
        },
        "options": {}
      },
      {
        "content": "$this->${1:method}()->shouldHaveKey(${2:'key'});",
        "doc": "",
        "grammar": "snu",
        "label": "$this->XYZ()->shouldHaveKey('key')",
        "matches": {
          "skey": true
        },
        "options": {}
      },
      {
        "content": "$this->${1:method}()->shouldNotHaveKey(${2:'key'});",
        "doc": "",
        "grammar": "snu",
        "label": "$this->XYZ()->shouldNotHaveKey('key')",
        "matches": {
          "snkey": true
        },
        "options": {}
      },
      {
        "content": "$this->${1:method}()->shouldHaveKeyWithValue(${2:'key'}, ${3:'value'});",
        "doc": "",
        "grammar": "snu",
        "label": "$this->XYZ()->shouldHaveKeyWithValue('key', 'value')",
        "matches": {
          "skeyvalue": true
        },
        "options": {}
      },
      {
        "content": "$this->${1:method}()->shouldNotHaveKeyWithValue(${2:'key'}, ${3:'value'});",
        "doc": "",
        "grammar": "snu",
        "label": "$this->XYZ()->shouldNotHaveKeyWithValue('key', 'value')",
        "matches": {
          "snkeyvalue": true
        },
        "options": {}
      },
      {
        "content": "$this->${1:method}()->shouldStartWith(${2:'string'});",
        "doc": "",
        "grammar": "snu",
        "label": "$this->XYZ()->shouldStartWith('string')",
        "matches": {
          "sstart": true
        },
        "options": {}
      },
      {
        "content": "$this->${1:method}()->shouldNotStartWith(${2:'string'});",
        "doc": "",
        "grammar": "snu",
        "label": "$this->XYZ()->shouldNotStartWith('string')",
        "matches": {
          "snstart": true
        },
        "options": {}
      },
      {
        "content": "$this->${1:method}()->shouldEndWith(${2:'string'});",
        "doc": "",
        "grammar": "snu",
        "label": "$this->XYZ()->shouldEndWith('string')",
        "matches": {
          "send": true
        },
        "options": {}
      },
      {
        "content": "$this->${1:method}()->shouldNotEndWith(${2:'string'});",
        "doc": "",
        "grammar": "snu",
        "label": "$this->XYZ()->shouldNotEndWith('string')",
        "matches": {
          "snend": true
        },
        "options": {}
      },
      {
        "content": "$this->${1:method}()->shouldMatch(${2:'/wizard/i'});",
        "doc": "",
        "grammar": "snu",
        "label": "$this->XYZ()->shouldMatch('/wizard/i')",
        "matches": {
          "smatch": true
        },
        "options": {}
      },
      {
        "content": "$this->${1:method}()->shouldNotMatch(${2:'/wizard/i'});",
        "doc": "",
        "grammar": "snu",
        "label": "$this->XYZ()->shouldNotMatch('/wizard/i')",
        "matches": {
          "snmatch": true
        },
        "options": {}
      }
    ],
    "php-symfony2": [
      {
        "content": "/**\n* @Route(\"/${1:route_name}\", name=\"$1\")\n* @Template()\n*/\npublic function $1Action($2)\n{\n\t$3\n\treturn ${4:[];}$0\n}",
        "doc": "",
        "grammar": "snu",
        "label": "Symfony 2 Controller action",
        "matches": {
          "sfa": true
        },
        "options": {}
      },
      {
        "content": "/**\n * @Route(\"$3\", name=\"$4\")\n * @Method({${5:\"POST\"}})\n * @Template()\n */\npublic function $1Action($2)\n{\n\t$6\n}",
        "doc": "",
        "grammar": "snu",
        "label": "Symfony2 action",
        "matches": {
          "act": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "$this->redirect($this->generateUrl('$1', $2));",
        "doc": "",
        "grammar": "snu",
        "label": "Symfony2 redirect",
        "matches": {
          "redir": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "use Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller;$1",
        "doc": "",
        "grammar": "snu",
        "label": "Symfony2 use Symfony\\..\\Controller",
        "matches": {
          "usecontroller": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "use Symfony\\Component\\HttpFoundation\\Request;$1",
        "doc": "",
        "grammar": "snu",
        "label": "Symfony2 use Symfony\\..\\Request",
        "matches": {
          "usereauest": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "use Sensio\\Bundle\\FrameworkExtraBundle\\Configuration\\Route;$1",
        "doc": "",
        "grammar": "snu",
        "label": "Symfony2 use Sensio\\..\\Route",
        "matches": {
          "useroute": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "use Symfony\\Component\\HttpFoundation\\Response;$1",
        "doc": "",
        "grammar": "snu",
        "label": "Symfony2 use Symfony\\..\\Response",
        "matches": {
          "useresponse": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "use Symfony\\Component\\HttpFoundation\\File\\UploadedFile;$1",
        "doc": "",
        "grammar": "snu",
        "label": "Symfony2 use Symfony\\..\\File",
        "matches": {
          "usefile": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "use Symfony\\Component\\Validator\\Constraints as Assert;$1",
        "doc": "",
        "grammar": "snu",
        "label": "Symfony2 use Symfony\\..\\Constraints as Assert",
        "matches": {
          "useassert": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "use Sensio\\Bundle\\FrameworkExtraBundle\\Configuration\\Template;$1",
        "doc": "",
        "grammar": "snu",
        "label": "Symfony2 use Sensio\\..\\Template",
        "matches": {
          "usetemplate": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "use Sensio\\Bundle\\FrameworkExtraBundle\\Configuration\\Cache;$1",
        "doc": "",
        "grammar": "snu",
        "label": "Symfony2 use Sensio\\..\\Cache",
        "matches": {
          "usecache": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "use Sensio\\Bundle\\FrameworkExtraBundle\\Configuration\\Method;$1",
        "doc": "",
        "grammar": "snu",
        "label": "Symfony2 use Sensio\\..\\Method",
        "matches": {
          "usemethod": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "use Doctrine\\Common\\Collections\\ArrayCollection;$1",
        "doc": "",
        "grammar": "snu",
        "label": "Symfony2 use Doctrine\\..\\ArrayCollection",
        "matches": {
          "usearray": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "use Doctrine\\ORM\\Mapping as ORM;$1",
        "doc": "",
        "grammar": "snu",
        "label": "Symfony2 use Doctrine\\..\\Mapping as ORM",
        "matches": {
          "useorm": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "use JMS\\SecurityExtraBundle\\Annotation\\Secure;$1",
        "doc": "",
        "grammar": "snu",
        "label": "Symfony2 use JMS\\..\\Secure",
        "matches": {
          "usesecure": true
        },
        "options": {
          "b": true
        }
      }
    ],
    "plsql": [
      {
        "content": "create or replace package ${1:name}\nas\n\t${0:-- spec}\nend; -- end of package spec $1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ps": true
        },
        "options": {}
      },
      {
        "content": "create or replace package body ${1:name}\nas\n\t${0:-- body}\nend; -- end of package body $1;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pb": true
        },
        "options": {}
      },
      {
        "content": "procedure ${1:name}(${0:args});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pps": true
        },
        "options": {}
      },
      {
        "content": "procedure ${1:name}(${2:args})\nas\nbegin\n\t${0:-- body}\nend $2;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ppb": true
        },
        "options": {}
      },
      {
        "content": "function ${1:name}(${2:args})\n  return ${0:type};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pfs": true
        },
        "options": {}
      },
      {
        "content": "function ${1:name}(${2:args})\n  return ${3:type}\nas\n\tl_res\t$3;\nbegin\n\t${0:-- body};\n\treturn l_res;\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pfb": true
        },
        "options": {}
      },
      {
        "content": "show errors;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "err": true
        },
        "options": {}
      },
      {
        "content": "${1:name} ${2:in} ${3:type} ${0: := null}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p": true
        },
        "options": {}
      },
      {
        "content": "type tr_${1:name} is record (${0:/* columns */});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tr": true
        },
        "options": {}
      },
      {
        "content": "type tt_${1:name} is table of tr_${0:name};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tt": true
        },
        "options": {}
      },
      {
        "content": "type tt_${1:name} is table of tr_${0:name} index by binary_integer;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tti": true
        },
        "options": {}
      },
      {
        "content": "/*\n *\t${0: comment ...}\n */",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "doc": true
        },
        "options": {}
      },
      {
        "content": "begin\n\t${0}\nend;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "beg": true
        },
        "options": {}
      },
      {
        "content": "declare\n\t${1}\nbegin\n\t${0}\nend;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dec": true
        },
        "options": {}
      },
      {
        "content": "for ${1:i} in 1 .. ${0:l_res}.count loop\n\tpipe row( $2($1) );\nend loop;\nreturn;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rpipe": true
        },
        "options": {}
      },
      {
        "content": "bulk collect into ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bc": true
        },
        "options": {}
      },
      {
        "content": "l_${1}\t\t${0:number};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "l": true
        },
        "options": {}
      },
      {
        "content": "dbms_output.put_line('${0}');",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "log": true
        },
        "options": {}
      },
      {
        "content": "for ${1:i} in ${2:1}..${3:42} loop\n\t${0}\nend loop;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "for ${1:rec} in (${2: select}) loop\n\t${0}\nend loop;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fors": true
        },
        "options": {}
      },
      {
        "content": "for ${1:i} in ${2:l_var}.first .. $2.last loop\n\t${0: -- dbms_output.put_line($2($1)); }\nend loop;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forc": true
        },
        "options": {}
      },
      {
        "content": "if ${1} then\n\t${0}\nend if;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "if ${1} then\n\t${2}\nelse\n\t${0}\nend if;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife": true
        },
        "options": {}
      }
    ],
    "po": [
      {
        "content": "msgid \"${1}\"\nmsgstr \"${2}\"\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "msg": true
        },
        "options": {}
      }
    ],
    "processing": [
      {
        "content": "/**\n *\t${1:@private}$0\n */\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "docc": true
        },
        "options": {}
      },
      {
        "content": "${1:void/private/protected/public}${2: static} ${3:name}(${4}) {\n\t${5://if not void return null;}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fun": true
        },
        "options": {}
      },
      {
        "content": "${1:void }${2:name}(${3}) {\n\t${4://if not void return null;}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fn": true
        },
        "options": {}
      },
      {
        "content": "static final ${1:Object} ${2:VAR_NAM} = ${0};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "const": true
        },
        "options": {}
      },
      {
        "content": "${1:private/public }${2:static }${3:String} ${4:str}${5: =}${0:value};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "var": true
        },
        "options": {}
      },
      {
        "content": "${1:private/public }${2:Object} ${3:o}${4: = new }$2(${0});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "obj": true
        },
        "options": {}
      },
      {
        "content": "for (int ${2:i} = 0; $2 < ${1:Things}.length; $2${3:++}) {\n\t${0:$1[$2]}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "while (${1:/* condition */}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh": true
        },
        "options": {}
      },
      {
        "content": "break ${1:label};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "break": true
        },
        "options": {}
      },
      {
        "content": "case ${1:expression} :\n\t${0}\nbreak;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case": true
        },
        "options": {}
      },
      {
        "content": "default :\n\t${1}\nbreak;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "default": true
        },
        "options": {}
      },
      {
        "content": "switch(${1:expression}) {\n\tcase '${3:case}':\n\t\t${4}\n\t\tbreak;\n\t${0}\n\tdefault:\n\t\t${2}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "switch": true
        },
        "options": {}
      },
      {
        "content": "try {\n\t${0:${VISUAL}}\n} catch(${1:Exception} ${2:e}) {\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "try": true
        },
        "options": {}
      },
      {
        "content": "try {\n\t${0:${VISUAL}}\n} catch(${1:Exception} ${2:e}) {\n} finally {\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tryf": true
        },
        "options": {}
      },
      {
        "content": "throw new (\"${1:Exception()}\");",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "throw": true
        },
        "options": {}
      },
      {
        "content": "? ${1:trueExpression} : ${2:falseExpression}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "?": true
        },
        "options": {}
      },
      {
        "content": "if (${1:true}) {${0}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "if (${1:true}) {${2}}\nelse{${0}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "public ${1:String} get${2}() {\n\treturn ${0:fieldName};\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "get": true
        },
        "options": {}
      },
      {
        "content": "public void set${1}(${0:String} new${1}) {\n\t${1:fieldName} = new${1};\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "set": true
        },
        "options": {}
      },
      {
        "content": "println(\"${0}\");",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pr": true
        },
        "options": {}
      },
      {
        "content": "void setup(){\n\t${1}\n}\nvoid draw(){\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "setup": true
        },
        "options": {}
      },
      {
        "content": "import processing.opengl.*;\nimport javax.media.opengl.*;\nPGraphicsOpenGL pgl;\nGL gl;\nvoid setup(){\n\tsize( ${1:300}, ${2:300}, OPENGL );\n\tcolorMode( RGB, 1.0 );\n\thint( ENABLE_OPENGL_4X_SMOOTH );\n\tpgl = (PGraphicsOpenGL) g;\n\tgl = pgl.gl;\n\tgl.setSwapInterval(1);\n\tinitGL();\n\t${3}\n}\nvoid draw(){\n\tpgl.beginGL();\n\t\t${4}\n\tpgl.endGL();\n\tgetOpenGLErrors();\n}\nvoid initGL(){\n\t${0}\n}\nvoid getOpenGLErrors(){\n\tint error = gl.glGetError();\n\tswitch (error){\n\t\tcase 1280 :\n\t\t\tprintln(\"GL_INVALID_ENUM - An invalid enumerant was passed to an OpenGL command.\");\n\t\tbreak;\n\t\tcase 1282 :\n\t\t\tprintln(\"GL_INVALID_OPERATION - An OpenGL command was issued that was invalid or inappropriate for the current state.\");\n\t\tbreak;\n\t\tcase 1281 :\n\t\t\tprintln(\"GL_INVALID_VALUE - A value was passed to OpenGL that was outside the allowed range.\");\n\t\tbreak;\n\t\tcase 1285 :\n\t\t\tprintln(\"GL_OUT_OF_MEMORY - OpenGL was unable to allocate enough memory to process a command.\");\n\t\tbreak;\n\t\tcase 1283 :\n\t\t\tprintln(\"GL_STACK_OVERFLOW - A command caused an OpenGL stack to overflow.\");\n\t\tbreak;\n\t\tcase 1284 :\n\t\t\tprintln(\"GL_STACK_UNDERFLOW - A command caused an OpenGL stack to underflow.\");\n\t\tbreak;\n\t\tcase 32817 :\n\t\t\tprintln(\"GL_TABLE_TOO_LARGE\");\n\t\tbreak;\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "opengl": true
        },
        "options": {}
      },
      {
        "content": "pgl.beginGL();\n\t${0}\npgl.endGL();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gl begin gl": true
        },
        "options": {}
      },
      {
        "content": "// specify the minimum swap interval for buffer swaps.\ngl.setSwapInterval(${0:interval});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gl gl swap interval": true
        },
        "options": {}
      },
      {
        "content": "// execute a display list\ngl.glCallList(${0:list});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gl gl call list": true
        },
        "options": {}
      },
      {
        "content": "// import java.nio.IntBuffer;\n// import java.nio.FloatBuffer;\n// import com.sun.opengl.util.BufferUtil;\n// You might need to create four buffers to store vertext data, normal data, texture coordinate data, and indices in vertex arrays\nIntBuffer bufferObjects = IntBuffer.allocate(${1:4});\ngl.glGenBuffers($1, bufferObjects);\nint vertexCount = ${2:3};\nint numCoordinates = ${0:3};\n// vertexCount * numCoordinates\nFloatBuffer vertices = BufferUtil.newFloatBuffer(vertexCount * numCoordinates);\nfloat[] v = {0.0f, 0.0f, 0.0f,\n\t\t\t\t\t\t 1.0f, 0.0f, 0.0f,\n\t\t\t\t\t\t 0.0f, 1.0f, 1.0f};\nvertices.put(v);\n// Bind the first buffer object ID for use with vertext array data\ngl.glBindBuffer(GL.GL_ARRAY_BUFFER, bufferObjects.get(0));\ngl.glBufferData(GL.GL_ARRAY_BUFFER, vertexCount * numCoordinates * BufferUtil.SIZEOF_FLOAT, vertices, GL.GL_STATIC_DRAW);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gl gl gen buffers": true
        },
        "options": {}
      },
      {
        "content": "${0:// A buffer ID of zero unbinds a buffer object}\ngl.glBindBuffer(GL.GL_ARRAY_BUFFER, ${1:0});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gl gl bind buffer": true
        },
        "options": {}
      },
      {
        "content": "${0:// Parameters are the same for glGenBuffers}\ngl.glDeleteBuffers(${1:4}, ${2:bufferObjects});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gl gl delete buffers": true
        },
        "options": {}
      },
      {
        "content": "// enable or disable writing into the depth buffer\ngl.glDepthMask(${0:flag});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gl gl depth mask": true
        },
        "options": {}
      },
      {
        "content": "// replaces the top of the active matrix stack with the identity matrix\ngl.glLoadIdentity();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gl gl load identity": true
        },
        "options": {}
      },
      {
        "content": "// set the current texture coordinates - 2 floats\ngl.glTexCoord2f(${1:0.0f}, ${0:0.0f});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gl gl tex coord 2f": true
        },
        "options": {}
      },
      {
        "content": "gl.glVertex2f(${1:0.0f}, ${0:0.0f});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gl gl vertex 2f": true
        },
        "options": {}
      },
      {
        "content": "gl.glVertex3f(${1:0.0f}, ${2:0.0f}, ${0:0.0f});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gl gl vertex 3f": true
        },
        "options": {}
      },
      {
        "content": "// multiply the current matrix by a translation matrix\ngl.glTranslatef(${1:x}, ${2:y}, ${0:z});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gl gl translate f": true
        },
        "options": {}
      },
      {
        "content": "// rotate, x-axis, y-axis, z-axiz\ngl.glRotatef(${1:angle}, ${2:x}, ${3:y}, ${0:z});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gl gl rotate f": true
        },
        "options": {}
      },
      {
        "content": "// multiply the current matrix by a general scaling matrix\ngl.glScalef(${1:x}, ${2:y}, ${0:z});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gl gl scale f": true
        },
        "options": {}
      },
      {
        "content": "gl.glColor4f(${1:red}, ${2:green}, ${3:blue}, ${0:alpha});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gl gl color 4f": true
        },
        "options": {}
      },
      {
        "content": "gl.glClearColor(${1:red}, ${2:green}, ${3:blue}, ${0:alpha});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gl gl clear color": true
        },
        "options": {}
      },
      {
        "content": "gl.glColor3f(${1:red}, ${2:green}, ${0:blue});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gl gl color 3f": true
        },
        "options": {}
      },
      {
        "content": "// spush and pop the current matrix stack\ngl.glPushMatrix();\n${0}\ngl.glPopMatrix();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gl gl push matrix": true
        },
        "options": {}
      },
      {
        "content": "gl.glGenLists(${0:1})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gl gl gen lists": true
        },
        "options": {}
      },
      {
        "content": "// Empties buffers. Call this when all previous issues commands completed\ngl.glFlush();\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gl gl flush": true
        },
        "options": {}
      },
      {
        "content": "println(gl.glGetError());",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gl gl get error": true
        },
        "options": {}
      },
      {
        "content": "gl.glClear(${1:GL.GL_COLOR_BUFFER_BIT}${2: | }${0:GL.GL_DEPTH_BUFFER_BIT});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gl gl clear": true
        },
        "options": {}
      },
      {
        "content": "frameRate(${1:30});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "frameRate": true
        },
        "options": {}
      },
      {
        "content": "saveFrame(\"${1:filename-####}${0:.ext}\");",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "saveFrame": true
        },
        "options": {}
      },
      {
        "content": "size(${1:200}, ${2:200}${0:, P3D});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "size normal": true
        },
        "options": {}
      },
      {
        "content": "size(${1:200}, ${2:200}${0:, OPENGL});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "size opengl": true
        },
        "options": {}
      },
      {
        "content": "color ${1:c}${2: = color(}${3:value1, }${4:value2, }${0:value3)};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "color": true
        },
        "options": {}
      },
      {
        "content": "char ${1:m}${2: = \"}${0:char\"};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "char": true
        },
        "options": {}
      },
      {
        "content": "float ${1:f}${2: = }${0:0.0f};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "float": true
        },
        "options": {}
      },
      {
        "content": "int ${1:f}${2: = }${0:0};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "int": true
        },
        "options": {}
      },
      {
        "content": "boolean ${1:b}${2: = }${0:true};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "boolean": true
        },
        "options": {}
      },
      {
        "content": "byte ${1:b}${2: = }${0:127};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "byte": true
        },
        "options": {}
      },
      {
        "content": "String ${1:str}${2: = \"}${0:CCCP\"};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "string": true
        },
        "options": {}
      },
      {
        "content": "${1:int}[] ${2:numbers}${3: = new $1}[${0:length}];",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "array": true
        },
        "options": {}
      },
      {
        "content": "${1:Object} ${2:o}${3: = new $1}(${0});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "object": true
        },
        "options": {}
      },
      {
        "content": "curve(${1:x1}, ${2:y1}, ${3:x2}, ${4:y2}, ${5:x3}, ${6:y3}, ${7:x4}, ${0:y4});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "curve": true
        },
        "options": {}
      },
      {
        "content": "curve(${1:x1}, ${2:y1}, ${3:z1}, ${4:x2}, ${5:y2}, ${6:z2}, ${7:x3}, ${8:y3}, ${9:z3}, ${10:x4}, ${11:y4}, ${0:z4});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "curve 3D": true
        },
        "options": {}
      },
      {
        "content": "curveDetail(${0:detail});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "curveDetail": true
        },
        "options": {}
      },
      {
        "content": "curvePoint(${1:a}, ${2:b}, ${3:c}, ${4:d}, ${0:t});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "curvePoint": true
        },
        "options": {}
      },
      {
        "content": "curveTightness(${0:squishy});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "curveTightness": true
        },
        "options": {}
      },
      {
        "content": "bezier(${1:x1}, ${2:y1}, ${3:cx1}, ${4:cy1}, ${5:cx2}, ${6:cy2}, ${7:x2}, ${0:y2});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bezier": true
        },
        "options": {}
      },
      {
        "content": "bezier(${1:x1}, ${2:y1}, ${3:z1}, ${4:cx1}, ${5:cy1}, ${6:cz1}, ${7:cx2}, ${8:cy2}, ${9:cz2}, ${10:x2}, ${11:y2}, ${0:z2});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bezier 3D": true
        },
        "options": {}
      },
      {
        "content": "bezierDetail(${0:detail});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bezierDetail": true
        },
        "options": {}
      },
      {
        "content": "bezierTangent(${1:a}, ${2:b}, ${3:c}, ${4:d}, ${0:t});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bezierTangent": true
        },
        "options": {}
      },
      {
        "content": "bezierPoint(${1:a}, ${2:b}, ${3:c}, ${4:d}, ${0:t});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bezierPoint": true
        },
        "options": {}
      },
      {
        "content": "vertex(${1:x}, ${2:y}${3:, }${4:u}${5:, }${0:v});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vertex": true
        },
        "options": {}
      },
      {
        "content": "vertex(${1:x}, ${2:y}, ${3:z}${4:, }${5:u}${6:, }${0:v});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vertex 3D": true
        },
        "options": {}
      },
      {
        "content": "bezierVertex(${1:cx1}, ${2:cy1}, ${3:cx2}, ${4:cy2}, ${5:x}, ${0:y});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bezierVertex": true
        },
        "options": {}
      },
      {
        "content": "bezierVertex(${1:cx1}, ${2:cy1}, ${3:cz1}, ${4:cx2}, ${5:cy2}, ${6:cz2}, ${7:x}, ${8:y}, ${0:z});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bezierVertex 3D": true
        },
        "options": {}
      },
      {
        "content": "curveVertex(${1:x}, ${0:y});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "curveVertex": true
        },
        "options": {}
      },
      {
        "content": "curveVertex(${1:x}, ${2:y}, ${0:z});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "curveVertex 3D": true
        },
        "options": {}
      },
      {
        "content": "stroke(${1:value1}, ${2:value2}, ${3:value3}${4:, }${0:alpha});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "stroke": true
        },
        "options": {}
      },
      {
        "content": "strokeWeight(${0:1});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "strokeWeight": true
        },
        "options": {}
      },
      {
        "content": "void mouseDragged(){\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mouseDragged": true
        },
        "options": {}
      },
      {
        "content": "void mouseMoved(){\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mouseMoved": true
        },
        "options": {}
      },
      {
        "content": "void mouseReleased(){\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mouseReleased": true
        },
        "options": {}
      },
      {
        "content": "void mousePressed(){\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mousePressed": true
        },
        "options": {}
      },
      {
        "content": "void keyReleased(){\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "keyReleased": true
        },
        "options": {}
      },
      {
        "content": "void keyTyped(){\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "keyTyped": true
        },
        "options": {}
      },
      {
        "content": "void keyPressed(){\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "keyPressed": true
        },
        "options": {}
      },
      {
        "content": "loadStrings(\"${0:filename}\");",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "loadStrings": true
        },
        "options": {}
      },
      {
        "content": "saveStrings(${1:filename}, ${0:strings});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "saveStrings": true
        },
        "options": {}
      },
      {
        "content": "loadBytes(\"${0:filename}\");",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "loadBytes": true
        },
        "options": {}
      },
      {
        "content": "beginRecord(${1:renderer}, ${0:filename});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "beginRecord": true
        },
        "options": {}
      },
      {
        "content": "saveBytes(${1:filename}, ${0:bytes});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "saveBytes": true
        },
        "options": {}
      },
      {
        "content": "createWriter(${0:filename});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "createWriter": true
        },
        "options": {}
      },
      {
        "content": "createReader(${0:filename});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "createReader": true
        },
        "options": {}
      },
      {
        "content": "pushMatrix();\n${0:};\npopMatrix();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pushMatrix": true
        },
        "options": {}
      },
      {
        "content": "text(${1:data}, ${2:x}, ${3:y}${4:, }${0:z});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "text data": true
        },
        "options": {}
      },
      {
        "content": "text(${1:stringdata}, ${2:x}, ${3:y}, ${4:width}, ${5:height}${6:, }${0:z});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "text stringdata": true
        },
        "options": {}
      },
      {
        "content": "textSize(${0:size});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "textSize": true
        },
        "options": {}
      },
      {
        "content": "textLeading(${0:size});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "textLeading": true
        },
        "options": {}
      },
      {
        "content": "textWidth(${0:data});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "textWidth": true
        },
        "options": {}
      },
      {
        "content": "PFont ${1:font};\n$1 = loadFont(\"${0:FFScala-32.vlw}\");",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "font": true
        },
        "options": {}
      },
      {
        "content": "${1:font} = loadFont(\"${0:FFScala-32.vlw}\");",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "loadFont": true
        },
        "options": {}
      },
      {
        "content": "textFont(${1:font}${2:, }${0:size});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "textFont": true
        },
        "options": {}
      },
      {
        "content": "tan(${0:rad});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tan": true
        },
        "options": {}
      },
      {
        "content": "atan(${0:rad});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "atan": true
        },
        "options": {}
      },
      {
        "content": "atan2(${0:rad});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "atan2": true
        },
        "options": {}
      },
      {
        "content": "sin(${0:rad});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sin": true
        },
        "options": {}
      },
      {
        "content": "asin(${0:rad});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asin": true
        },
        "options": {}
      },
      {
        "content": "cos(${0:rad});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cos": true
        },
        "options": {}
      },
      {
        "content": "acos(${0:rad});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "acos": true
        },
        "options": {}
      },
      {
        "content": "degrees(${0:rad});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "degrees": true
        },
        "options": {}
      },
      {
        "content": "radians(${0:deg});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "radians": true
        },
        "options": {}
      },
      {
        "content": "randomSeed(${0:value});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "randomSseed": true
        },
        "options": {}
      },
      {
        "content": "random(${1:value1}${2:, }${0:value2});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "random": true
        },
        "options": {}
      },
      {
        "content": "pow(${1:num}, ${0:exponent});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pow": true
        },
        "options": {}
      },
      {
        "content": "floor(${0:value});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "floor": true
        },
        "options": {}
      },
      {
        "content": "sqrt(${0:value});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sqrt": true
        },
        "options": {}
      },
      {
        "content": "abs(${0:value});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "abs": true
        },
        "options": {}
      },
      {
        "content": "sq(${0:value});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sq": true
        },
        "options": {}
      },
      {
        "content": "ceil(${0:value});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ceil": true
        },
        "options": {}
      },
      {
        "content": "exp(${0:value});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "exp": true
        },
        "options": {}
      },
      {
        "content": "round(${0:value}};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "round": true
        },
        "options": {}
      },
      {
        "content": "min(${1:value1}, ${2:value2}${3:, }${0:value3});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "min": true
        },
        "options": {}
      },
      {
        "content": "max(${1:value1}, ${2:value2}${3:, }${0:value3});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "max": true
        },
        "options": {}
      },
      {
        "content": "max(${0:array});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "max array": true
        },
        "options": {}
      },
      {
        "content": "min(${0:array});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "min array": true
        },
        "options": {}
      },
      {
        "content": "log(${0:value});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "log": true
        },
        "options": {}
      },
      {
        "content": "map(${1:value}, ${2:low1}, ${4:high1}, ${5:low2}, ${0:high2});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "map": true
        },
        "options": {}
      },
      {
        "content": "norm(${1:value}, ${2:low}, ${0:high});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "norm": true
        },
        "options": {}
      },
      {
        "content": "constrain(${1:value}, ${2:min}, ${0:max});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "constrain": true
        },
        "options": {}
      },
      {
        "content": "mag(${1:a}, ${2:b}${3:, }${0:c});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mag": true
        },
        "options": {}
      },
      {
        "content": "dist(${1:x1}, ${2:y1}, ${4:x2}, ${0:y2});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dist": true
        },
        "options": {}
      },
      {
        "content": "dist(${1:x1}, ${2:y1}, ${3:z1}, ${4:x2}, ${5:y2}, ${0:z2});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dist 3D": true
        },
        "options": {}
      },
      {
        "content": "noise(${1:x}${2:, }${3:y}${4:, }${0:z});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "noise": true
        },
        "options": {}
      },
      {
        "content": "noiseDetail(${1:octaves}${2:, }${0:falloff});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "noiseDetail": true
        },
        "options": {}
      },
      {
        "content": "noiseSeed(${0:x});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "noiseSeed": true
        },
        "options": {}
      },
      {
        "content": "shininess(${0:shine});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "shininess": true
        },
        "options": {}
      },
      {
        "content": "specular(${1:value1}, ${2:value2}, ${3:value3}${4:, }${0:alpha});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "specular": true
        },
        "options": {}
      },
      {
        "content": "ambient(${1:value1}, ${2:value2}, ${0:value3});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ambient": true
        },
        "options": {}
      },
      {
        "content": "emissive(${1:value1}, ${2:value2}, ${0:value3});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "emissive": true
        },
        "options": {}
      },
      {
        "content": "directionalLight(${1:v1}, ${2:v2}, ${3:v3}, ${4:nx}, ${5:ny}, ${0:nz});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "diretionalLight": true
        },
        "options": {}
      },
      {
        "content": "pointLight(${1:v1}, ${2:v2}, ${3:v3}, ${4:nx}, ${5:ny}, ${0:nz});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pointLight": true
        },
        "options": {}
      },
      {
        "content": "lightFalloff(${1:constant}, ${2:linear}, ${0:quadratic});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lightFalloff": true
        },
        "options": {}
      },
      {
        "content": "normal(${1:nx}, ${2:ny}, ${0:nz});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "normal": true
        },
        "options": {}
      },
      {
        "content": "lightSpecular(${1:v1}, ${2:v2}, ${0:v3});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lightSpecular": true
        },
        "options": {}
      },
      {
        "content": "ambientLight(${1:v1}, ${2:v2}, ${3:v3}${7:, ${4:x}, ${5:y}, ${0:z}});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ambientLight": true
        },
        "options": {}
      },
      {
        "content": "spotLight(${1:v1}, ${2:v2}, ${3:v3}, ${4:x}, ${5:y}, ${6:z}, ${7:nx}, ${8:ny}, ${9:nz}, ${10:angle}, ${0:concentration});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "spotLight": true
        },
        "options": {}
      },
      {
        "content": "camera(${1:eyeX}, ${2:eyeY}, ${3:eyeZ}, ${4:centerX}, ${5:centerY}, ${6:centerZ}, ${7:upX}, ${8:upY}, ${0:upZ});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "camera": true
        },
        "options": {}
      },
      {
        "content": "ortho(${1:left}, ${2:right}, ${3:bottom}, ${4:top}, ${5:near}, ${0:far});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ortho": true
        },
        "options": {}
      },
      {
        "content": "perspective(${1:fov}, ${2:aspect}, ${3:zNear}, ${0:zFar});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "perspective": true
        },
        "options": {}
      },
      {
        "content": "frustrum(${1:left}, ${2:right}, ${3:bottom}, ${4:top}, ${5:near}, ${0:far});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "frustrum": true
        },
        "options": {}
      },
      {
        "content": "rotate${1:X}(${0:angle});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rotate": true
        },
        "options": {}
      },
      {
        "content": "translate(${1:x}, ${2:y}${3:, }${0:z});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "translate": true
        },
        "options": {}
      },
      {
        "content": "scale(${0:size});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "scale size": true
        },
        "options": {}
      },
      {
        "content": "scale(${1:x}, ${2:y}${3:, }${0:z});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "scale": true
        },
        "options": {}
      },
      {
        "content": "${1:model/screen}${2:X}(${3:x}, ${4:y}, ${0:z});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "coord": true
        },
        "options": {}
      },
      {
        "content": "brightness(${0:color});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "brightness": true
        },
        "options": {}
      },
      {
        "content": "lerpColor(${1:c1}, ${2:c2}, ${0:amt});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lerpColor": true
        },
        "options": {}
      },
      {
        "content": "saturation(${0:color});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "saturation": true
        },
        "options": {}
      },
      {
        "content": "hue(${0:color});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "hue": true
        },
        "options": {}
      },
      {
        "content": "alpha(${0:color});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "alpha": true
        },
        "options": {}
      },
      {
        "content": "tint(${1:value1}, ${2:value2}, ${3:value3}${4:, }${0:alpha});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tint": true
        },
        "options": {}
      },
      {
        "content": "set(${1:x}, ${2:y}, ${0:color/image});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "set pixel": true
        },
        "options": {}
      },
      {
        "content": "pixels[${0:index}]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pixels": true
        },
        "options": {}
      },
      {
        "content": "get(${1:x}, ${2:y}${3:, }${4:width}${5:, }${0:height});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "get pixel": true
        },
        "options": {}
      },
      {
        "content": "triangle(${1:x1}, ${2:y1}, ${3:x2}, ${4:y2}, ${5:x3}, ${0:y3});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "triangle": true
        },
        "options": {}
      },
      {
        "content": "line(${1:x1}, ${2:y1}, ${3:x2}, ${0:y2});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "line": true
        },
        "options": {}
      },
      {
        "content": "line(${1:x1}, ${2:y1}, ${3:z1}, ${4:x2}, ${5:y2}, ${0:z2});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "line 3D": true
        },
        "options": {}
      },
      {
        "content": "arc(${1:x}, ${2:y}, ${3:width}, ${4:height}, ${5:start}, ${0:stop});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "arc": true
        },
        "options": {}
      },
      {
        "content": "point(${1:x}, ${2:y}${3:, }${0:z});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "point": true
        },
        "options": {}
      },
      {
        "content": "quad(${1:x1}, ${2:y1}, ${3:x2}, ${4:y2}, ${5:x3}, ${6:y3}, ${7:x4}, ${0:y4});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "quad": true
        },
        "options": {}
      },
      {
        "content": "ellipse(${1:x}, ${2:y}, ${3:width}, ${0:height});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ellipse": true
        },
        "options": {}
      },
      {
        "content": "rect(${1:x}, ${2:y}, ${3:width}, ${0:height});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rect": true
        },
        "options": {}
      },
      {
        "content": "box(${1:width}, ${2:height}, ${0:depth});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "box": true
        },
        "options": {}
      },
      {
        "content": "sphere(${0:radius});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sphere": true
        },
        "options": {}
      },
      {
        "content": "sphereDetail(${0:n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sphereDetails": true
        },
        "options": {}
      },
      {
        "content": "split(\"${1:str}\"${2: , }${0:delimiter});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "split": true
        },
        "options": {}
      },
      {
        "content": "splitTokens(${1:str}${2:, }${0:tokens});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "splitTokens": true
        },
        "options": {}
      },
      {
        "content": "join(${1:strgArray}${2: , }${0:seperator});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "join": true
        },
        "options": {}
      },
      {
        "content": "shorten(${0:array});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "shorten": true
        },
        "options": {}
      },
      {
        "content": "concat(${1:array1}, ${0:array2});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "concat": true
        },
        "options": {}
      },
      {
        "content": "subset(${1:array}, ${0:offset});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "subset": true
        },
        "options": {}
      },
      {
        "content": "append(${1:array}, ${0:element});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "append": true
        },
        "options": {}
      },
      {
        "content": "reverse(${0:array});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "reverse": true
        },
        "options": {}
      },
      {
        "content": "splice(${1:array}, ${2:value/array2}, ${0:index});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "splice": true
        },
        "options": {}
      },
      {
        "content": "sort(${1:dataArray}${2:, }${0:count});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sort": true
        },
        "options": {}
      },
      {
        "content": "expand(${1:array}${2:, }${0:newSize});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "expand": true
        },
        "options": {}
      },
      {
        "content": "arrayCopy(${1:src}, ${2:dest}, ${3:, }${0:length});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "arrayCopy": true
        },
        "options": {}
      },
      {
        "content": "str(\"${0:str}\");",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "str": true
        },
        "options": {}
      },
      {
        "content": "match(${1:str}, ${0:regexp});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "match": true
        },
        "options": {}
      },
      {
        "content": "trim(${0:str});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "trim": true
        },
        "options": {}
      },
      {
        "content": "nf(${2:value}, ${3:left}${4:, }${0:right});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nf": true
        },
        "options": {}
      },
      {
        "content": "nfs(${2:value}, ${3:left}${4:, }${0:right});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nfs": true
        },
        "options": {}
      },
      {
        "content": "nfp(${2:value}, ${3:left}${4:, }${0:right});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nfp": true
        },
        "options": {}
      },
      {
        "content": "nfc(${1:value}${2:, }${0:right});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nfc": true
        },
        "options": {}
      },
      {
        "content": "unbinary(\"${0:str}\"});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "unbinary": true
        },
        "options": {}
      },
      {
        "content": "hex(${0:c});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "hexadecimal": true
        },
        "options": {}
      },
      {
        "content": "unhex(${0:c});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "unhex": true
        },
        "options": {}
      },
      {
        "content": "binary(${1:value}${2:, }${0:digits});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "binary": true
        },
        "options": {}
      },
      {
        "content": "loadImage(${0:filename});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "loadImage": true
        },
        "options": {}
      },
      {
        "content": "image(${1:img}, ${2:x}, ${3:y}${4:, }${5:width}${6:, }${0:height});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "image": true
        },
        "options": {}
      },
      {
        "content": "copy(${1:srcImg}${2:, }${3:x}, ${4:y}, ${5:width}, ${6:height}, ${7:dx}, ${8:dy}, ${9:dwidth}, ${0:dheight});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "copy": true
        },
        "options": {}
      },
      {
        "content": "background(${1:value1}, ${2:value2}, ${3:value3}${4:, }${0:alpha});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bg": true
        },
        "options": {}
      },
      {
        "content": "PGraphics pg;\npg = createGraphics(${1:width}, ${2:height}${3:, }${0:applet});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pg": true
        },
        "options": {}
      },
      {
        "content": "PImage(${1:width}, ${0:height});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pimage": true
        },
        "options": {}
      },
      {
        "content": "fill(${1:value1}, ${2:value2}, ${3:value3}${4:, }${0:alpha});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fill": true
        },
        "options": {}
      },
      {
        "content": "red(${0:color});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "red": true
        },
        "options": {}
      },
      {
        "content": "green(${0:color});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "green": true
        },
        "options": {}
      },
      {
        "content": "blue(${0:color});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "blue": true
        },
        "options": {}
      },
      {
        "content": "status(${0:text});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "status": true
        },
        "options": {}
      },
      {
        "content": "param(${0:s});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "param": true
        },
        "options": {}
      },
      {
        "content": "link(${1:url}${2:, }${0:target});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "link": true
        },
        "options": {}
      },
      {
        "content": "@${1:param/return/private/public}  ${1:parameter}  ${0:description}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@": true
        },
        "options": {}
      }
    ],
    "progress": [
      {
        "content": "DEFINE BUFFER b_${1:TableName} FOR $1 ${0}.",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defbuf": true
        },
        "options": {}
      },
      {
        "content": "DEFINE VARIABLE ${1:VariableName} AS ${0}.",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defvar": true
        },
        "options": {}
      },
      {
        "content": "NO-LOCK",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nl": true
        },
        "options": {}
      },
      {
        "content": "NO-ERROR",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ne": true
        },
        "options": {}
      },
      {
        "content": "NO-LOCK NO-ERROR",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nle": true
        },
        "options": {}
      },
      {
        "content": "INITIAL ${0:?}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ini": true
        },
        "options": {}
      },
      {
        "content": "NO-UNDO",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nu": true
        },
        "options": {}
      },
      {
        "content": "ERROR",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "err": true
        },
        "options": {}
      },
      {
        "content": "FIND FIRST ${1:BufferName}\n${2:WHERE $1.${3}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ff": true
        },
        "options": {}
      },
      {
        "content": "DEFINE INPUT PARAMETER ${1:ParamName} AS ${0}.",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "input": true
        },
        "options": {}
      },
      {
        "content": "DEFINE OUTPUT PARAMETER ${1:ParamName} AS ${0:ParamType}.",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "output": true
        },
        "options": {}
      },
      {
        "content": "/******************************************************************************/\nPROCEDURE ${1:ProcName}:\n\t${0}\nEND PROCEDURE. /* $1 */\n/******************************************************************************/",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "proc": true
        },
        "options": {}
      },
      {
        "content": "MESSAGE \"${1:MessageContent}\" ${2:Data} VIEW-AS ALERT-BOX.",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "alert": true
        },
        "options": {}
      },
      {
        "content": "IF ${1:Condition}\nTHEN ${2:Action}\n${3:ELSE ${4:OtherWise}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "DO${1: Clauses}:\n\t${0}\nEND.",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "do": true
        },
        "options": {}
      },
      {
        "content": "INTEGER",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "int": true
        },
        "options": {}
      },
      {
        "content": "CHARACTER",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "char": true
        },
        "options": {}
      },
      {
        "content": "LOGICAL",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "log": true
        },
        "options": {}
      },
      {
        "content": "DECIMAL",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dec": true
        },
        "options": {}
      },
      {
        "content": "/* ------------------------------------------------------------------------- */",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sep": true
        },
        "options": {}
      }
    ],
    "prolog": [
      {
        "content": ":- initialization main.\nmain :-\n  current_prolog_flag(argv, Args),\n  writeln(Args),\n  halt.",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "main": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": ":- module(${1:name}, [${0:export}]).",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "module": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": ":- begin_tests(${1:name}).\n  ${0}\n:- end_tests($1).",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "begintest": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": ":- run_tests.\n:- halt.",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "runtest": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "test(${1:case}, [true(${2:var} = ${3:value})]) :-\n  ${0:goal}.",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "test": true
        },
        "options": {
          "head": true
        }
      }
    ],
    "prop-types": [
      {
        "content": "import PropTypes from 'prop-types'\n",
        "doc": "",
        "grammar": "lsp",
        "label": "prop-types-import",
        "matches": {
          "impt": true,
          "prop-types import": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.array,",
        "doc": "Array prop type",
        "grammar": "lsp",
        "label": "prop-type-array",
        "matches": {
          "prop-types array": true,
          "pta": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.array.isRequired,",
        "doc": "Array prop type required",
        "grammar": "lsp",
        "label": "prop-type-array-required",
        "matches": {
          "prop-types array required": true,
          "ptar": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.bool,",
        "doc": "Bool prop type",
        "grammar": "lsp",
        "label": "prop-type-bool",
        "matches": {
          "prop-types bool": true,
          "ptb": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.bool.isRequired,",
        "doc": "Bool prop type required",
        "grammar": "lsp",
        "label": "prop-type-bool-required",
        "matches": {
          "prop-types bool required": true,
          "ptbr": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.func,",
        "doc": "Func prop type",
        "grammar": "lsp",
        "label": "prop-type-func",
        "matches": {
          "prop-types func": true,
          "ptf": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.func.isRequired,",
        "doc": "Func prop type required",
        "grammar": "lsp",
        "label": "prop-type-func-required",
        "matches": {
          "prop-types func required": true,
          "ptfr": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.number,",
        "doc": "Number prop type",
        "grammar": "lsp",
        "label": "prop-type-number",
        "matches": {
          "prop-types number": true,
          "ptn": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.number.isRequired,",
        "doc": "Number prop type required",
        "grammar": "lsp",
        "label": "prop-type-number-required",
        "matches": {
          "prop-types number required": true,
          "ptnr": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.object,",
        "doc": "Object prop type",
        "grammar": "lsp",
        "label": "prop-type-object",
        "matches": {
          "prop-types object": true,
          "pto": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.object.isRequired,",
        "doc": "Object prop type required",
        "grammar": "lsp",
        "label": "prop-type-object-required",
        "matches": {
          "prop-types object required": true,
          "ptor": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.string,",
        "doc": "String prop type",
        "grammar": "lsp",
        "label": "prop-type-string",
        "matches": {
          "prop-types string": true,
          "pts": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.string.isRequired,",
        "doc": "String prop type required",
        "grammar": "lsp",
        "label": "prop-type-string-required",
        "matches": {
          "prop-types string required": true,
          "ptsr": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.node,",
        "doc": "Anything that can be rendered: numbers, strings, elements or an array",
        "grammar": "lsp",
        "label": "prop-type-node",
        "matches": {
          "prop-types node": true,
          "ptnd": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.node.isRequired,",
        "doc": "Anything that can be rendered: numbers, strings, elements or an array required",
        "grammar": "lsp",
        "label": "prop-type-node-required",
        "matches": {
          "prop-types node required": true,
          "ptndr": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.element,",
        "doc": "React element prop type",
        "grammar": "lsp",
        "label": "prop-type-element",
        "matches": {
          "prop-types element": true,
          "ptel": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.element.isRequired,",
        "doc": "React element prop type required",
        "grammar": "lsp",
        "label": "prop-type-element-required",
        "matches": {
          "prop-types element required": true,
          "ptelr": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.instanceOf($0),",
        "doc": "Is an instance of a class prop type",
        "grammar": "lsp",
        "label": "prop-type-instance-of",
        "matches": {
          "prop-types instanceof": true,
          "pti": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.instanceOf($0).isRequired,",
        "doc": "Is an instance of a class prop type required",
        "grammar": "lsp",
        "label": "prop-type-instance-of-required",
        "matches": {
          "prop-types instanceof required": true,
          "ptir": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.oneOf(['$0']),",
        "doc": "Prop type limited to specific values by treating it as an enum",
        "grammar": "lsp",
        "label": "prop-type-enum",
        "matches": {
          "prop-types enum": true,
          "pte": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.oneOf(['$0']).isRequired,",
        "doc": "Prop type limited to specific values by treating it as an enum required",
        "grammar": "lsp",
        "label": "prop-type-enum-required",
        "matches": {
          "prop-types enum required": true,
          "pter": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.oneOfType([\n\t$0\n]),",
        "doc": "An object that could be one of many types",
        "grammar": "lsp",
        "label": "prop-type-one-of-type",
        "matches": {
          "prop-types oneoftype": true,
          "ptet": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.oneOfType([\n\t$0\n]).isRequired,",
        "doc": "An object that could be one of many types required",
        "grammar": "lsp",
        "label": "prop-type-one-of-type-required",
        "matches": {
          "prop-types oneoftype required": true,
          "ptetr": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.arrayOf($0),",
        "doc": "An array of a certain type",
        "grammar": "lsp",
        "label": "prop-type-array-of",
        "matches": {
          "prop-types arrayof": true,
          "ptao": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.arrayOf($0).isRequired,",
        "doc": "An array of a certain type required",
        "grammar": "lsp",
        "label": "prop-type-array-of-required",
        "matches": {
          "prop-types arrayof required": true,
          "ptaor": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.objectOf($0),",
        "doc": "An object with property values of a certain type",
        "grammar": "lsp",
        "label": "prop-type-object-of",
        "matches": {
          "prop-types objectof": true,
          "ptoo": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.objectOf($0).isRequired,",
        "doc": "An object with property values of a certain type required",
        "grammar": "lsp",
        "label": "prop-type-object-of-required",
        "matches": {
          "prop-types objectof required": true,
          "ptoor": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.shape({\n\t$0\n}),",
        "doc": "An object taking on a particular shape",
        "grammar": "lsp",
        "label": "prop-type-shape",
        "matches": {
          "prop-types shape": true,
          "ptsh": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.shape({\n\t$0\n}).isRequired,",
        "doc": "An object taking on a particular shape required",
        "grammar": "lsp",
        "label": "prop-type-shape-required",
        "matches": {
          "prop-types shape required": true,
          "ptshr": true
        },
        "options": {}
      },
      {
        "content": "static propTypes = {\n$0\n}\n",
        "doc": "",
        "grammar": "lsp",
        "label": "prop-type-static",
        "matches": {
          "prop-types static": true,
          "ptypes": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.any,",
        "doc": "Any prop type",
        "grammar": "lsp",
        "label": "prop-type-any",
        "matches": {
          "prop-types any": true,
          "ptany": true
        },
        "options": {}
      }
    ],
    "proto": [],
    "ps1": [
      {
        "content": "class {\n\t[string] ${1:FirstName}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "class": true
        },
        "options": {}
      },
      {
        "content": "function ${1:name} {\n\t[CmdletBinding()]\n\tparam (\n\t\t[Parameter(Mandatory = $true)]\n\t\t[string] ${2:Param}\n\t)\n\tbegin {\n\t}\n\tprocess {\n\t}\n\tend {\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "function": true
        },
        "options": {}
      },
      {
        "content": "$Params = @{\n\t${1:Param1} = '${2:Value1}'\n\t${3:Param2} = '${4:Value2}'\n}\n${5:CommandName} @Params",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "splatting": true
        },
        "options": {}
      },
      {
        "content": "enum ${1:name} {\n\t${2:item1}\n\t${3:item2}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "enum": true
        },
        "options": {}
      },
      {
        "content": "if (${1:condition}) {\n\t${2:statement}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "if ( ${1:condition} ) {\n\t${2}\n}\nelse {\n\t${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "while (${1:condition}) {\n\t${2:statement}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "while": true
        },
        "options": {}
      },
      {
        "content": "${1:command} | Where-Object -FilterScript { $PSItem.${2:property} -${3:operator} '${4:expression}' } | Sort-Object -Property ${5:sortproperty}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "filtersort": true
        },
        "options": {}
      },
      {
        "content": "foreach ( $${1:iterator} in $${2:collection} ) {\n\t${3:statement}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "foreach": true
        },
        "options": {}
      },
      {
        "content": "Export-CSV -NoTypeInformation -Path ${1:path}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "epcsv": true
        },
        "options": {}
      },
      {
        "content": "<#\n.SYNOPSIS\n\t${1:Short Description}\n.DESCRIPTION\n\t${2:Full Description}\n.PARAMETER ${3:Param1}\n\t${4: $3 usage}\n.EXAMPLE\n\t${5:Example}\n.NOTES\n\t${6:notes}\n.LINK\n\t${7:online help}\n#>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "help": true
        },
        "options": {}
      },
      {
        "content": "switch ( ${1:test} ){\n\t${2:condition1} { ${3:action} }\n\t${4:condition2} { ${5:action} }\n\tdefault { ${6:action} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "switch": true
        },
        "options": {}
      }
    ],
    "puppet": [
      {
        "content": "case $${1:variable} {\n\tdefault: { ${0} }\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case": true
        },
        "options": {}
      },
      {
        "content": "if $${1:variable} {\n\t${2}\n} else {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "if $${1:variable} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "if defined(${1:Resource}[\"${2:name}\"]) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifd": true
        },
        "options": {}
      },
      {
        "content": "if !defined(${1:Resource}[\"${2:name}\"]) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifnd": true
        },
        "options": {}
      },
      {
        "content": "else {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "el": true
        },
        "options": {}
      },
      {
        "content": "? {\n\t\"${1}\"\t=> ${0}\n  }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "?": true
        },
        "options": {}
      },
      {
        "content": "[ ${1} ]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "[": true
        },
        "options": {}
      },
      {
        "content": "${1}\t=> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ">": true
        },
        "options": {}
      },
      {
        "content": "\"puppet://puppet/${1:module name}/${0:file name}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p:": true
        },
        "options": {}
      },
      {
        "content": "alert(\"${1:message}\")",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "alert": true
        },
        "options": {}
      },
      {
        "content": "crit(\"${1:message}\")",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "crit": true
        },
        "options": {}
      },
      {
        "content": "debug(\"${1:message}\")",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "debug": true
        },
        "options": {}
      },
      {
        "content": "defined(${1:Resource}[\"${2:name}\"])",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defined": true
        },
        "options": {}
      },
      {
        "content": "emerg(\"${1:message}\")",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "emerg": true
        },
        "options": {}
      },
      {
        "content": "extlookup(\"${1:variable}\")",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "extlookup Simple extlookup": true
        },
        "options": {}
      },
      {
        "content": "extlookup(\"${1:variable}\", \"${2:default}\")",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "extlookup Extlookup with defaults": true
        },
        "options": {}
      },
      {
        "content": "extlookup(\"${1:variable}\", \"${2:default}\", \"${3:data source}\")",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "extlookup Extlookup with defaults and custom data file": true
        },
        "options": {}
      },
      {
        "content": "fail(\"${1:message}\")",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fail": true
        },
        "options": {}
      },
      {
        "content": "info(\"${1:message}\")",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "info": true
        },
        "options": {}
      },
      {
        "content": "inline_template(\"<%= ${1} %>\")",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "inline_template": true
        },
        "options": {}
      },
      {
        "content": "notice(\"${1:message}\")",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "notice": true
        },
        "options": {}
      },
      {
        "content": "realize(${1:Resource}[${2:name}])",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "realize": true
        },
        "options": {}
      },
      {
        "content": "regsubst(${1:hay stack}, ${2:needle}, \"${3:replacement}\")",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "regsubst": true
        },
        "options": {}
      },
      {
        "content": "include ${1:classname}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "inc": true
        },
        "options": {}
      },
      {
        "content": "split(${1:hay stack}, \"${2:patten}\")",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "split": true
        },
        "options": {}
      },
      {
        "content": "versioncmp(\"${1:version}\", \"${2:version}\")",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "versioncmp": true
        },
        "options": {}
      },
      {
        "content": "warning(\"${1:message}\")",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "warning": true
        },
        "options": {}
      },
      {
        "content": "cron { \"${1:name}\":\n\tcommand => \"${2}\",\n\tuser    => \"${3:root}\",\n\t${4}    => ${0},\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cron": true
        },
        "options": {}
      },
      {
        "content": "exec { \"${1:name}\":\n\tcommand => \"${2:$1}\",\n\tuser    => \"${3:root}\",\n\t${4}    => ${0},\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "exec": true
        },
        "options": {}
      },
      {
        "content": "user { \"${1:user}\":\n\tensure      => present,\n\tcomment     => \"${2:$1}\",\n\tmanagehome  => true,\n\thome        => \"${0:/home/$1}\",\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "user": true
        },
        "options": {}
      },
      {
        "content": "group { \"${1:group}\":\n\tensure => ${0:present},\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "group": true
        },
        "options": {}
      },
      {
        "content": "host { \"${1:hostname}\":\n\tip => ${0:127.0.0.1},\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "host": true
        },
        "options": {}
      },
      {
        "content": "mailalias { \"${1:localpart}\":\n\trecipient => \"${0:recipient}\",\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mailalias": true
        },
        "options": {}
      },
      {
        "content": "mount { \"${1:destination path}\":\n\tensure\t=> ${2:mounted},\n\tdevice\t=> \"${0:device name or path}\",\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mount": true
        },
        "options": {}
      },
      {
        "content": "notify { \"${1:message}\": }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "notify": true
        },
        "options": {}
      },
      {
        "content": "package { \"${1:package name}\":\n\tensure\t=> ${0:present},\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "package": true
        },
        "options": {}
      },
      {
        "content": "yumrepo { \"${1:repo name}\":\n\tdescr   => \"${2:$1}\",\n\tenabled => ${0:1},\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yumrepo": true
        },
        "options": {}
      },
      {
        "content": "define ${1} (${2}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "define": true
        },
        "options": {}
      },
      {
        "content": "service { \"${1:service}\":\n\tensure    => running,\n\tenable    => true,\n\trequire   => [ Package[\"${2:package}\"], File[\"${3:file}\"], ],\n\tsubscribe => [ File[\"${4:configfile1}\"], File[\"${5:configfile2}\"], Package[\"${6:package}\"], ],\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "service": true
        },
        "options": {}
      },
      {
        "content": "file { \"${1:filename}\":\n\tensure  => ${2:present},\n\towner   => \"${3:root}\",\n\tgroup   => \"${4:root}\",\n\tmode    => \"${5:0644}\",\n\tsource  => \"puppet:///modules/${6:module}/${7:source}\",\n\tcontent => template(\"${8:module}/${9:template}\"),\n\talias   => \"${10:alias}\",\n\trequire => [ Package[\"${11:package}\"], File[\"${12:file}\"], ],\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "file": true
        },
        "options": {}
      },
      {
        "content": "archive { \"${1:filename}\":\n\tensure     => ${2:present},\n\turl        => \"http://${3:url}\",\n\textension  => \"${4:tgz}\",\n\ttarget     => \"${5:target}\",\n\tchecksum   => ${6:false},\n\tsrc_target => \"${7:/tmp}\",\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "archive": true
        },
        "options": {}
      },
      {
        "content": "firewall { \"${1:comment}\":\n\tproto\t=> ${2:tcp},\n\taction\t=> ${3:accept},\n\tport\t=> ${4},\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "firewall": true
        },
        "options": {}
      }
    ],
    "purescript": [
      {
        "content": "import ${0:Data.List}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "imp": true
        },
        "options": {}
      },
      {
        "content": "import ${1:Data.List} as ${0:List}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "impq": true
        },
        "options": {}
      },
      {
        "content": "${1:name} :: ${2:a}\n$1 = ${0:undefined}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fn0": true
        },
        "options": {}
      },
      {
        "content": "${1:fn} :: ${2:a} -> ${3:a}\n$1 ${4}= ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fn": true
        },
        "options": {}
      },
      {
        "content": "${1:fn} :: ${2:a} -> ${3:a}\n$1 ${4}= ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fn1": true
        },
        "options": {}
      },
      {
        "content": "${1:fn} :: ${2:a} -> ${3:a} -> ${4:a}\n$1 ${5}= ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fn2": true
        },
        "options": {}
      },
      {
        "content": "${1:fn} :: ${2:a} -> ${3:a} -> ${4:a} -> ${5:a}\n$1 ${6}= ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fn3": true
        },
        "options": {}
      },
      {
        "content": "case ${1} of\n\t${2} -> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case": true
        },
        "options": {}
      },
      {
        "content": "let\n\t${1} = ${2}\nin\n\t${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "let": true
        },
        "options": {}
      },
      {
        "content": "where\n\t${1} = ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "where": true
        },
        "options": {}
      },
      {
        "content": "module Test.Main where\nimport Prelude\nimport Test.Unit (suite, test)\nimport Test.Unit.Main (runTest)\nimport Test.Unit.Assert as Assert\nmain = runTest do\n\tsuite \"${1}\" do\n\t\ttest \"${2:the tests run}\" do\n\t\t\tAssert.equal\n\t\t\t\t\"Hello, world!\"\n\t\t\t\t\"Hello, sailor!\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "testunit": true
        },
        "options": {}
      },
      {
        "content": "if ${1} then\n\t${2:${VISUAL}}\nelse\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "{-| ${0}\n-}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "doc": true
        },
        "options": {}
      },
      {
        "content": "type ${1:Type} =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ty": true
        },
        "options": {}
      },
      {
        "content": "data ${1:Type} =\n\t${0:$1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "da": true
        },
        "options": {}
      },
      {
        "content": "newtype ${1:Type} =\n\t${2:$1} ${0:Int}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nty": true
        },
        "options": {}
      },
      {
        "content": "foreign import ${1} :: ${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fi": true
        },
        "options": {}
      }
    ],
    "python": [
      {
        "content": "#!/usr/bin/env python3\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "#!/usr/bin/env python3",
        "matches": {
          "#!": true,
          "shebang": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "class ${1:#:name}(${2:object}):\n\tdef __init__(self, ${3}):\n\t\t${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "class Class(...): ...",
        "matches": {
          "class": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "class ${1:#:name}(${2:object}):\n\t\"\"\"${3:#:class documentation}\"\"\"\n\tdef __init__(self, ${4}):\n\t\t\"\"\"${5:#:__init__ documentation}\"\"\"\n\t\t${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "class Class(...): \"...\"",
        "matches": {
          "classd": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "def ${1:#:name}(${2}):\n\t${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "def function(...): ...",
        "matches": {
          "def": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "def ${1:#:name}(${2}):\n\t\"\"\"${3:#:function documentation}\"\"\"\n\t${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "def function(...): \"\"\"...\"\"\"",
        "matches": {
          "defd": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "def ${1:#:name}(self, ${2}):\n\t${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "def method(self, ...): ...",
        "matches": {
          "defm": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "def ${1:#:name}(self, ${2}):\n\t\"\"\"${3:#:method documentation}\"\"\"\n\t${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "def method(self, ...): \"...\"",
        "matches": {
          "defmd": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "elif ${1:#:condition}:\n\t${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "elif ...: ...",
        "matches": {
          "elif": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "else:\n\t${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "else: ...",
        "matches": {
          "else": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "with open(${1:#:file}, '${2:r}') as ${3:f}:\n\t${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fileidiom": true,
          "with_open": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "for ${1:#:value} in ${2:#:list}:\n\t${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "for ... in ...: ...",
        "matches": {
          "for": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "if ${1:#:condition}:\n\t${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "if ...: ...",
        "matches": {
          "if": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "if __name__ == '__main__':\n\t${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "if __name__ == '__main__': ...",
        "matches": {
          "ifmain": true,
          "main": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "try:\n\t${1:pass}\nexcept ${2:#:ExceptionClass}:\n\t${3:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "try: ... except ...: ...",
        "matches": {
          "tryexcept": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "try:\n\t${1:pass}\nfinally:\n\t${2:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "try: ... finally: ...",
        "matches": {
          "tryfinally": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "while ${1:#:condition}:\n\t${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "while ...: ...",
        "matches": {
          "while": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "with ${1:open}(${2:#:filename, mode}) as ${3:f}:\n\t${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "with {func}({file}) as :",
        "matches": {
          "with": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "[$1 for ${1:x} in ${2:#:list} if ${3:#:condition}]",
        "doc": "",
        "grammar": "snu",
        "label": "[x for x in {list} if {condition}]",
        "matches": {
          "filter": true
        },
        "options": {}
      },
      {
        "content": "print(${0:#:TARGET})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "print": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "# -*- coding: utf-8 -*-",
        "doc": "",
        "grammar": "snu",
        "label": "# -*- coding ...",
        "matches": {
          "coding": true
        },
        "options": {}
      },
      {
        "content": "getattr(${1:#:obj}, ${2:#:attr})",
        "doc": "",
        "grammar": "snu",
        "label": "getattr(..., ...)",
        "matches": {
          "getattr": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "setattr(${1:#:obj}, ${2:#:attr}, ${3:#:value})",
        "doc": "",
        "grammar": "snu",
        "label": "setattr(..., ...)",
        "matches": {
          "setattr": true
        },
        "options": {}
      },
      {
        "content": "hasattr(${1:#:obj}, ${2:#:attr})",
        "doc": "",
        "grammar": "snu",
        "label": "hasattr(..., ...)",
        "matches": {
          "hasattr": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "import pdb; pdb.set_trace()",
        "doc": "",
        "grammar": "snu",
        "label": "import pdb..",
        "matches": {
          "pdb": true
        },
        "options": {}
      },
      {
        "content": "import ipdb; ipdb.set_trace()",
        "doc": "",
        "grammar": "snu",
        "label": "import ipdb..",
        "matches": {
          "ipdb": true
        },
        "options": {}
      },
      {
        "content": "import pudb; pudb.set_trace()",
        "doc": "",
        "grammar": "snu",
        "label": "import pudb..",
        "matches": {
          "pudb": true
        },
        "options": {}
      },
      {
        "content": "from PyQt5.QtCore import pyqtRemoveInputHook\npyqtRemoveInputHook()\nimport pdb; pdb.set_trace()",
        "doc": "",
        "grammar": "snu",
        "label": "removeInputHook...pdb",
        "matches": {
          "qtpdb": true
        },
        "options": {}
      },
      {
        "content": "from IPython import embed; embed()",
        "doc": "",
        "grammar": "snu",
        "label": "import ipython..",
        "matches": {
          "ipy": true
        },
        "options": {}
      },
      {
        "content": "#!/usr/bin/env python3",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#!": true
        },
        "options": {}
      },
      {
        "content": "#!/usr/bin/env python2\n# -*- coding: utf-8 -*-",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#!2": true
        },
        "options": {}
      },
      {
        "content": "#!/usr/bin/env python3",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#!3": true
        },
        "options": {}
      },
      {
        "content": "import ${0:module}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "imp": true
        },
        "options": {}
      },
      {
        "content": "def __unicode__(self):\n\t${0:representation}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "uni": true
        },
        "options": {}
      },
      {
        "content": "from ${1:package} import ${0:module}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "from": true
        },
        "options": {}
      },
      {
        "content": "@unittest.skip(${1:skip_reason})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sk \"skip unittests\" b": true
        },
        "options": {}
      },
      {
        "content": "while ${1:condition}:\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh": true
        },
        "options": {}
      },
      {
        "content": "while True:\n\t${1}\n\tif ${0:condition}:\n\t\tbreak",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dowh": true
        },
        "options": {}
      },
      {
        "content": "with ${1:expr} as ${2:var}:\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "with": true
        },
        "options": {}
      },
      {
        "content": "async with ${1:expr} as ${2:var}:\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "awith": true
        },
        "options": {}
      },
      {
        "content": "class ${1:ClassName}(${2:object}):\n\t\"\"\"${3:docstring for $1}\"\"\"\n\tdef __init__(self, ${4:arg}):\n\t\t${5:super($1, self).__init__()}\n\t\tself.$4 = $4\n\t\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cl": true
        },
        "options": {}
      },
      {
        "content": "class ${1:class_name}:\n\t\"\"\"${0:description}\"\"\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cla": true
        },
        "options": {}
      },
      {
        "content": "class ${1:class_name}:\n\t\"\"\"${2:description}\"\"\"\n\tdef __init__(self, ${3:args}):\n\t\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "clai": true
        },
        "options": {}
      },
      {
        "content": "def __init__(self, ${1:args}):\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defi": true
        },
        "options": {}
      },
      {
        "content": "def ${1:mname}(self, ${2:arg}):\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defm": true
        },
        "options": {}
      },
      {
        "content": "async def ${1:mname}(self, ${2:arg}):\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "adefm": true
        },
        "options": {}
      },
      {
        "content": "def ${1:foo}():\n\tdoc = \"${2:The $1 property.}\"\n\tdef fget(self):\n\t\t${3:return self._$1}\n\tdef fset(self, value):\n\t\t${4:self._$1 = value}\n\tdef fdel(self):\n\t\t${0:del self._$1}\n\treturn locals()\n$1 = property(**$1())",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "property": true
        },
        "options": {}
      },
      {
        "content": "if ${1:condition}:\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "else:\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "el": true
        },
        "options": {}
      },
      {
        "content": "elif ${1:condition}:\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ei": true
        },
        "options": {}
      },
      {
        "content": "for ${1:item} in ${2:items}:\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "# -*- coding: utf-8 -*-",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cutf8": true
        },
        "options": {}
      },
      {
        "content": "# -*- coding: latin-1 -*-",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "clatin1": true
        },
        "options": {}
      },
      {
        "content": "# -*- coding: ascii -*-",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cascii": true
        },
        "options": {}
      },
      {
        "content": "${1:var} = lambda ${2:vars} : ${0:action}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ld": true
        },
        "options": {}
      },
      {
        "content": "return ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ret": true
        },
        "options": {}
      },
      {
        "content": "self.",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ".": true
        },
        "options": {}
      },
      {
        "content": "self.${1:attribute} = $1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sa self.attribute = attribute": true
        },
        "options": {}
      },
      {
        "content": "try:\n\t${1:${VISUAL}}\nexcept ${2:Exception} as ${3:e}:\n\t${0:raise $3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "try Try/Except": true
        },
        "options": {}
      },
      {
        "content": "try:\n\t${1:${VISUAL}}\nexcept ${2:Exception} as ${3:e}:\n\t${4:raise $3}\nelse:\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "trye Try/Except/Else": true
        },
        "options": {}
      },
      {
        "content": "try:\n\t${1:${VISUAL}}\nexcept ${2:Exception} as ${3:e}:\n\t${4:raise $3}\nfinally:\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tryf Try/Except/Finally": true
        },
        "options": {}
      },
      {
        "content": "try:\n\t${1:${VISUAL}}\nexcept ${2:Exception} as ${3:e}:\n\t${4:raise $3}\nelse:\n\t${5}\nfinally:\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tryef Try/Except/Else/Finally": true
        },
        "options": {}
      },
      {
        "content": "if __name__ == '__main__':\n\t${0:main()}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifmain": true
        },
        "options": {}
      },
      {
        "content": "__${1:init}__",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "_": true
        },
        "options": {}
      },
      {
        "content": "__import__('pdb').set_trace()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pdb": true
        },
        "options": {}
      },
      {
        "content": "__import__('bpdb').set_trace()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bpdb": true
        },
        "options": {}
      },
      {
        "content": "__import__('ipdb').set_trace()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ipdb": true
        },
        "options": {}
      },
      {
        "content": "__import__('IPython').embed()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "iem": true
        },
        "options": {}
      },
      {
        "content": "__import__('rpdb').set_trace()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rpdb": true
        },
        "options": {}
      },
      {
        "content": "__import__('wdb').set_trace()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wdb": true
        },
        "options": {}
      },
      {
        "content": "__import__('ptpython.repl', fromlist=('repl')).embed(globals(), locals(), vi_mode=${1:False}, history_filename=${2:None})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ptpython": true
        },
        "options": {}
      },
      {
        "content": "__import__('pudb').set_trace()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pudb": true
        },
        "options": {}
      },
      {
        "content": "from pudb.remote import set_trace\nset_trace()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pudbr": true
        },
        "options": {}
      },
      {
        "content": "__import__('nose').tools.set_trace()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nosetrace": true
        },
        "options": {}
      },
      {
        "content": "__import__('pprint').pprint(${1})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pprint": true
        },
        "options": {}
      },
      {
        "content": "\"\"\"${0:doc}\n\"\"\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\"": true
        },
        "options": {}
      },
      {
        "content": "self.assertEqual(${0}, ${1})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "a=": true
        },
        "options": {}
      },
      {
        "content": "class ${1:ExampleCase}(unittest.TestCase):\n\tdef test_${2:description}(self):\n\t\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "testcase": true
        },
        "options": {}
      },
      {
        "content": "# given: ${1}\n# when: ${2}\n# then: ${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tgwt": true
        },
        "options": {}
      },
      {
        "content": "from __future__ import ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fut": true
        },
        "options": {}
      },
      {
        "content": "try:\n\t# Short option syntax: \"hv:\"\n\t# Long option syntax: \"help\" or \"verbose=\"\n\topts, args = getopt.getopt(sys.argv[1:], \"${1:short_options}\", [${2:long_options}])\nexcept getopt.GetoptError, err:\n\t# Print debug info\n\tprint str(err)\n\t${3:error_action}\nfor option, argument in opts:\n\tif option in (\"-h\", \"--help\"):\n\t\t${0}\n\telif option in (\"-v\", \"--verbose\"):\n\t\tverbose = argument",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "getopt": true
        },
        "options": {}
      },
      {
        "content": "${0:sub_parser} = parser.add_subparsers().add_parser(\"${1:name}\")",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "addsp": true
        },
        "options": {}
      },
      {
        "content": "parser.add_argument(\"${0:short_arg}\", \"${1:long_arg}\", default=${2:None}, help=\"${3:Help text}\")",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "addarg": true
        },
        "options": {}
      },
      {
        "content": "parser.add_argument(\"${0:arg}\", nargs=\"${1:*}\", default=${2:None}, help=\"${3:Help text}\")",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "addnarg": true
        },
        "options": {}
      },
      {
        "content": "parser.add_argument(\"${0:arg}\", \"${1:long_arg}\", action=\"${2:store_true}\", default=${3:False}, help=\"${4:Help text}\")",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "addaarg": true
        },
        "options": {}
      },
      {
        "content": "import logging\nLOGGER = logging.getLogger(${0:__name__})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "glog": true
        },
        "options": {}
      },
      {
        "content": "LOGGER.error(${0:msg})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "le": true
        },
        "options": {}
      },
      {
        "content": "LOGGER.debug(${0:msg})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lg": true
        },
        "options": {}
      },
      {
        "content": "LOGGER.warning(${0:msg})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lw": true
        },
        "options": {}
      },
      {
        "content": "LOGGER.critical(${0:msg})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lc": true
        },
        "options": {}
      },
      {
        "content": "LOGGER.info(${0:msg})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "li": true
        },
        "options": {}
      },
      {
        "content": "\"\"\"${1:Description}\n@param ${2:param}: ${3: Description}\n@type  $2: ${4: Type}\n@return: ${5: Description}\n@rtype : ${6: Type}\n@raise e: ${0: Description}\n\"\"\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "epydoc": true
        },
        "options": {}
      },
      {
        "content": "def ${1:__init__}(self, *args, **kwargs):\n    super(${0:ClassName}, self).$1(*args, **kwargs)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dol": true
        },
        "options": {}
      },
      {
        "content": "self.${1:var_name} = kwargs.get('$1', ${2:None})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "kwg": true
        },
        "options": {}
      },
      {
        "content": "${1:var_name} = kwargs.get('$1', ${2:None})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lkwg": true
        },
        "options": {}
      },
      {
        "content": "*args${1:,}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "args": true
        },
        "options": {}
      },
      {
        "content": "**kwargs${1:,}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "kwargs": true
        },
        "options": {}
      },
      {
        "content": "*args, **kwargs${1:,}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "akw": true
        },
        "options": {}
      },
      {
        "content": "[${1} for ${2} in ${3:${VISUAL}}]${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lcp list comprehension": true
        },
        "options": {}
      },
      {
        "content": "{${1}: ${2} for ${3} in ${4:${VISUAL}}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dcp dict comprehension": true
        },
        "options": {}
      },
      {
        "content": "{${1} for ${2} in ${3:${VISUAL}}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "scp set comprehension": true
        },
        "options": {}
      },
      {
        "content": "def __len__(self):\n\t${1:pass}\ndef __getitem__(self, key):\n\t${2:pass}\ndef __setitem__(self, key, value):\n\t${3:pass}\ndef __delitem__(self, key):\n\t${4:pass}\ndef __iter__(self):\n\t${5:pass}\ndef __reversed__(self):\n\t${6:pass}\ndef __contains__(self, item):\n\t${7:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "contain \"methods for emulating a container type\" b": true
        },
        "options": {}
      },
      {
        "content": "def __enter__(self):\n\t${1:pass}\ndef __exit__(self, exc_type, exc_value, traceback):\n\t${2:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "context \"context manager methods\" b": true
        },
        "options": {}
      },
      {
        "content": "def __getattr__(self, name):\n\t${1:pass}\ndef __setattr__(self, name, value):\n\t${2:pass}\ndef __delattr__(self, name):\n\t${3:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "attr \"methods for customizing attribute access\" b": true
        },
        "options": {}
      },
      {
        "content": "def __get__(self, instance, owner):\n\t${1:pass}\ndef __set__(self, instance, value):\n\t${2:pass}\ndef __delete__(self, instance):\n\t${3:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "desc \"methods implementing descriptors\" b": true
        },
        "options": {}
      },
      {
        "content": "def __eq__(self, other):\n\t${1:pass}\ndef __ne__(self, other):\n\t${2:pass}\ndef __lt__(self, other):\n\t${3:pass}\ndef __le__(self, other):\n\t${4:pass}\ndef __gt__(self, other):\n\t${5:pass}\ndef __ge__(self, other):\n\t${6:pass}\ndef __cmp__(self, other):\n\t${7:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cmp \"methods implementing rich comparison\"": true
        },
        "options": {}
      },
      {
        "content": "def __repr__(self):\n\t${1:pass}\ndef __str__(self):\n\t${2:pass}\ndef __unicode__(self):\n\t${3:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "repr \"methods implementing string representation\"": true
        },
        "options": {}
      },
      {
        "content": "def __add__(self, other):\n\t${1:pass}\ndef __sub__(self, other):\n\t${2:pass}\ndef __mul__(self, other):\n\t${3:pass}\ndef __div__(self, other):\n\t${4:pass}\ndef __truediv__(self, other):\n\t${5:pass}\ndef __floordiv__(self, other):\n\t${6:pass}\ndef __mod__(self, other):\n\t${7:pass}\ndef __divmod__(self, other):\n\t${8:pass}\ndef __pow__(self, other):\n\t${9:pass}\ndef __lshift__(self, other):\n\t${10:pass}\ndef __rshift__(self, other):\n\t${11:pass}\ndef __and__(self, other):\n\t${12:pass}\ndef __xor__(self, other):\n\t${13:pass}\ndef __or__(self, other):\n\t${14:pass}\ndef __neg__(self):\n\t${15:pass}\ndef __pos__(self):\n\t${16:pass}\ndef __abs__(self):\n\t${17:pass}\ndef __invert__(self):\n\t${18:pass}\ndef __complex__(self):\n\t${19:pass}\ndef __int__(self):\n\t${20:pass}\ndef __long__(self):\n\t${21:pass}\ndef __float__(self):\n\t${22:pass}\ndef __oct__(self):\n\t${22:pass}\ndef __hex__(self):\n\t${23:pass}\ndef __index__(self):\n\t${24:pass}\ndef __coerce__(self, other):\n\t${25:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "numeric \"methods for emulating a numeric type\" b": true
        },
        "options": {}
      },
      {
        "content": "#!/usr/bin/env python\n$0",
        "doc": "",
        "grammar": "snu",
        "label": "#!/usr/bin/env python",
        "matches": {
          "#!": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "# -*- coding: utf-8 -*-\n$0",
        "doc": "",
        "grammar": "snu",
        "label": "# encoding: UTF-8",
        "matches": {
          "\"^# ?[uU][tT][fF]-?8": true
        },
        "options": {
          "r": true
        }
      }
    ],
    "r": [
      {
        "content": "#!/usr/bin/env Rscript",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#!": true
        },
        "options": {}
      },
      {
        "content": "library(${0:package})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lib": true
        },
        "options": {}
      },
      {
        "content": "require(${0:package})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "req": true
        },
        "options": {}
      },
      {
        "content": "source('${0:file}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "source": true
        },
        "options": {}
      },
      {
        "content": "if (${1:condition}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "else {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "el": true
        },
        "options": {}
      },
      {
        "content": "else if (${1:condition}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ei": true
        },
        "options": {}
      },
      {
        "content": "while(${1}) {\n\t${2}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh": true
        },
        "options": {}
      },
      {
        "content": "for (${1:item} in ${2:list}) {\n\t${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "foreach (${1:item} = ${2:list}) {\n\t${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "foreach": true
        },
        "options": {}
      },
      {
        "content": "${1:name} <- function (${2:variables}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fun": true
        },
        "options": {}
      },
      {
        "content": "return(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ret": true
        },
        "options": {}
      },
      {
        "content": "${1:name}[${2:rows}, ${0:cols}]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "df": true
        },
        "options": {}
      },
      {
        "content": "c(${0:items})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "c": true
        },
        "options": {}
      },
      {
        "content": "list(${0:items})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "li": true
        },
        "options": {}
      },
      {
        "content": "matrix(${1:data}, nrow = ${2:rows}, ncol = ${0:cols})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mat": true
        },
        "options": {}
      },
      {
        "content": "apply(${1:array}, ${2:margin}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "apply": true
        },
        "options": {}
      },
      {
        "content": "lapply(${1:list}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lapply": true
        },
        "options": {}
      },
      {
        "content": "lapply(${1:list}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sapply": true
        },
        "options": {}
      },
      {
        "content": "vapply(${1:list}, ${2:function}, ${0:type})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vapply": true
        },
        "options": {}
      },
      {
        "content": "mapply(${1:function}, ${0:...})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mapply": true
        },
        "options": {}
      },
      {
        "content": "tapply(${1:vector}, ${2:index}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tapply": true
        },
        "options": {}
      },
      {
        "content": "rapply(${1:list}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rapply": true
        },
        "options": {}
      },
      {
        "content": "ddply(${1:frame}, ${2:variables}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dd": true
        },
        "options": {}
      },
      {
        "content": "dlply(${1:frame}, ${2:variables}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dl": true
        },
        "options": {}
      },
      {
        "content": "daply(${1:frame}, ${2:variables}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "da": true
        },
        "options": {}
      },
      {
        "content": "d_ply(${1:frame}, ${2:variables}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d_": true
        },
        "options": {}
      },
      {
        "content": "adply(${1:array}, ${2:margin}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ad": true
        },
        "options": {}
      },
      {
        "content": "alply(${1:array}, ${2:margin}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "al": true
        },
        "options": {}
      },
      {
        "content": "aaply(${1:array}, ${2:margin}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "aa": true
        },
        "options": {}
      },
      {
        "content": "a_ply(${1:array}, ${2:margin}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "a_": true
        },
        "options": {}
      },
      {
        "content": "ldply(${1:list}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ld": true
        },
        "options": {}
      },
      {
        "content": "llply(${1:list}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ll": true
        },
        "options": {}
      },
      {
        "content": "laply(${1:list}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "la": true
        },
        "options": {}
      },
      {
        "content": "l_ply(${1:list}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "l_": true
        },
        "options": {}
      },
      {
        "content": "mdply(${1:matrix}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "md": true
        },
        "options": {}
      },
      {
        "content": "mlply(${1:matrix}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ml": true
        },
        "options": {}
      },
      {
        "content": "maply(${1:matrix}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ma": true
        },
        "options": {}
      },
      {
        "content": "m_ply(${1:matrix}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "m_": true
        },
        "options": {}
      },
      {
        "content": "plot(${1:x}, ${0:y})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pl": true
        },
        "options": {}
      },
      {
        "content": "ggplot(${1:data}, aes(${0:aesthetics}))",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ggp": true
        },
        "options": {}
      },
      {
        "content": "${1:(jpeg,bmp,png,tiff)}(filename = '${2:filename}', width = ${3}, height = ${4}, unit = '${5}')\n${0:plot}\ndev.off()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "img": true
        },
        "options": {}
      },
      {
        "content": "fisher.test(${1:x}, ${0:y})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fis": true
        },
        "options": {}
      },
      {
        "content": "chisq.test(${1:x}, ${0:y})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "chi": true
        },
        "options": {}
      },
      {
        "content": "t.test(${1:x}, ${0:y})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tt": true
        },
        "options": {}
      },
      {
        "content": "wilcox.test(${1:x}, ${0:y})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wil": true
        },
        "options": {}
      },
      {
        "content": "cor.test(${1:x}, ${0:y})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cor": true
        },
        "options": {}
      },
      {
        "content": "var.test(${1:x}, ${0:y})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fte": true
        },
        "options": {}
      },
      {
        "content": "kv.test(${1:x}, ${0:y})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "kvt": true
        },
        "options": {}
      }
    ],
    "r-snippets": [
      {
        "content": "rug(${1:jitter(${2:x})})",
        "doc": "",
        "grammar": "lsp",
        "label": "rug",
        "matches": {
          "rug": true
        },
        "options": {}
      },
      {
        "content": "apply(${1:X}, ${2:MARGIN}, ${3:FUN}, ${4:...})",
        "doc": "Apply",
        "grammar": "lsp",
        "label": "app",
        "matches": {
          "apply": true
        },
        "options": {}
      },
      {
        "content": "attach(${1:frame})",
        "doc": "Attach",
        "grammar": "lsp",
        "label": "att",
        "matches": {
          "attach": true
        },
        "options": {}
      },
      {
        "content": "cat(${1:file}, ${2:sep = ${3:\"\"}}, ${4:fill = ${5:FALSE}}, ${6:labels = ${7:NULL}}, ${8:append = ${9:FALSE}})",
        "doc": "Cat",
        "grammar": "lsp",
        "label": "cat",
        "matches": {
          "cat": true
        },
        "options": {}
      },
      {
        "content": "cum${1:max}(${2:x})",
        "doc": "Cummulative",
        "grammar": "lsp",
        "label": "cum",
        "matches": {
          "cum": true
        },
        "options": {}
      },
      {
        "content": "cummax(${1:x}",
        "doc": "Cummulative max",
        "grammar": "lsp",
        "label": "cuma",
        "matches": {
          "cumaax": true
        },
        "options": {}
      },
      {
        "content": "cummin(${1:x}",
        "doc": "Cummulative min",
        "grammar": "lsp",
        "label": "cumi",
        "matches": {
          "cumin": true
        },
        "options": {}
      },
      {
        "content": "data.frame(${1:...}, ${2:row.names = ${3:NULL}}, ${4:check.rows = ${5:FALSE}}, ${6:check.names = ${7:TRUE}}, ${8:stringsAsFactors = ${9:default.stringsAsFactors()}})",
        "doc": "Data Frame",
        "grammar": "lsp",
        "label": "daf",
        "matches": {
          "data.frame": true
        },
        "options": {}
      },
      {
        "content": "density(${1:x}${2:, bw = ${3:bandwidth}})",
        "doc": "Density",
        "grammar": "lsp",
        "label": "den",
        "matches": {
          "density": true
        },
        "options": {}
      },
      {
        "content": "detach(${0:})",
        "doc": "Detach",
        "grammar": "lsp",
        "label": "det",
        "matches": {
          "detach": true
        },
        "options": {}
      },
      {
        "content": "cut(${1:x}, breaks = c(${2:${3:}, ${4:max(${1:x})}}))",
        "doc": "Divide Into Intervals",
        "grammar": "lsp",
        "label": "cut",
        "matches": {
          "cut": true
        },
        "options": {}
      },
      {
        "content": "expand.grid(${1:...}, ${2:KEEP.OUT.ATTRS = ${3:TRUE}}, ${4:stringsAsFactors = ${5:TRUE}})",
        "doc": "Expand grid",
        "grammar": "lsp",
        "label": "exp",
        "matches": {
          "exppand": true
        },
        "options": {}
      },
      {
        "content": "factor(${1:x})",
        "doc": "Factor",
        "grammar": "lsp",
        "label": "fac",
        "matches": {
          "factor": true
        },
        "options": {}
      },
      {
        "content": "function(${1:x}) ${3:{$0\\}}",
        "doc": "Function",
        "grammar": "lsp",
        "label": "fun",
        "matches": {
          "function": true
        },
        "options": {}
      },
      {
        "content": "glm(${1:formula}, ${2:family = {3:gaussian}}, ${4:data})",
        "doc": "Generalized Linear Models",
        "grammar": "lsp",
        "label": "glm",
        "matches": {
          "glm": true
        },
        "options": {}
      },
      {
        "content": "grep(${1:pattern}, ${2:x}, ${3:ignore.case = ${4:FALSE}}, ${5:perl = ${6:FALSE}})",
        "doc": "Grep",
        "grammar": "lsp",
        "label": "grep",
        "matches": {
          "grep": true
        },
        "options": {}
      },
      {
        "content": "grep(${1:pattern}, ${2:x}, ${3:ignore.case = ${4:FALSE}}, ${5:perl = ${6:FALSE}}, ${7:value = ${8:FALSE}}, ${9:fixed = ${10:TRUE}})",
        "doc": "Grep",
        "grammar": "lsp",
        "label": "grep2",
        "matches": {
          "grep": true
        },
        "options": {}
      },
      {
        "content": "grep(${1:pattern}, ${2:x}, ${3:ignore.case = ${4:FALSE}}, ${5:perl = ${6:FALSE}}, ${7:fixed = ${8:TRUE}})",
        "doc": "Grep logical",
        "grammar": "lsp",
        "label": "grepl",
        "matches": {
          "grepl": true
        },
        "options": {}
      },
      {
        "content": "install.packages(${1:pkgs}, ${2:lib}, ${3:repos = ${4:getOption(\"repos\")}}, ${5:contriburl = ${6:contrib.url(repos, type)}})",
        "doc": "Install package",
        "grammar": "lsp",
        "label": "ins",
        "matches": {
          "insall": true
        },
        "options": {}
      },
      {
        "content": "kmeans(${1:x}, ${2:centers}, ${3:iter.max = ${4:10}}, ${5:nstart = ${6:1}}, ${7:algorithm = ${8:c(\"Hartigan-Wong\", \"Lloyd\", \"Forgy\",\"MacQueen\")}}, ${9:trace = ${10:FALSE}})",
        "doc": "Kmeans",
        "grammar": "lsp",
        "label": "km",
        "matches": {
          "kmeans": true
        },
        "options": {}
      },
      {
        "content": "kruskal.test(${1:formula}, ${2:data}, ${3:subset}, ${4:na.action}, ${5:...})",
        "doc": "Kruskal-Wallis Rank Sum test",
        "grammar": "lsp",
        "label": "kr",
        "matches": {
          "kruskal": true
        },
        "options": {}
      },
      {
        "content": "lapply(${1:X}, ${2:FUN}, ${3:...})",
        "doc": "Lapply",
        "grammar": "lsp",
        "label": "lap",
        "matches": {
          "lapply": true
        },
        "options": {}
      },
      {
        "content": "length(${1:x})",
        "doc": "Length",
        "grammar": "lsp",
        "label": "len",
        "matches": {
          "length": true
        },
        "options": {}
      },
      {
        "content": "library(${1:package}, ${2:help}, ${3:pos = ${4:2}}, ${5:lib.loc = ${6:NULL}})",
        "doc": "Library",
        "grammar": "lsp",
        "label": "lib",
        "matches": {
          "library": true
        },
        "options": {}
      },
      {
        "content": "lines(${1:x}${2:, color=${3:red}})",
        "doc": "Polygonal Line",
        "grammar": "lsp",
        "label": "lin",
        "matches": {
          "lines": true
        },
        "options": {}
      },
      {
        "content": "data(${1:name})",
        "doc": "Load Dataset",
        "grammar": "lsp",
        "label": "dat",
        "matches": {
          "data": true
        },
        "options": {}
      },
      {
        "content": "load(${1:file}, ${2:envir = ${3:parent.frame()}}, ${4:verbose = ${5:FALSE}})",
        "doc": "Load RData",
        "grammar": "lsp",
        "label": "loa",
        "matches": {
          "load": true
        },
        "options": {}
      },
      {
        "content": "mean(${1:x}${2:, na.rm=${3:FALSE}})",
        "doc": "Mean",
        "grammar": "lsp",
        "label": "mea",
        "matches": {
          "mean": true
        },
        "options": {}
      },
      {
        "content": "merge(${1:x}, ${2:y}, ${3:by = ${4:intersect(names(x), names(y))}}, ${5:all = ${6:FALSE}})",
        "doc": "Merge",
        "grammar": "lsp",
        "label": "mer",
        "matches": {
          "merge": true
        },
        "options": {}
      },
      {
        "content": "names(${1:x})",
        "doc": "Names",
        "grammar": "lsp",
        "label": "nam",
        "matches": {
          "names": true
        },
        "options": {}
      },
      {
        "content": "options(${1:...})",
        "doc": "Options",
        "grammar": "lsp",
        "label": "opt",
        "matches": {
          "option": true
        },
        "options": {}
      },
      {
        "content": "order(${1:...}, ${2:na.last = ${3:TRUE}}, ${4:decreasing = ${5:FALSE}})",
        "doc": "Order",
        "grammar": "lsp",
        "label": "ord",
        "matches": {
          "order": true
        },
        "options": {}
      },
      {
        "content": "outer(${1:X}, ${2:Y}, ${3:FUN = ${4:\"*\"}}, ${5:...})",
        "doc": "Outer",
        "grammar": "lsp",
        "label": "out",
        "matches": {
          "outer": true
        },
        "options": {}
      },
      {
        "content": "paste(${1:...}, ${2:sep = ${3:\" \"}}, ${3:collapse = ${4:NULL}})",
        "doc": "Paste",
        "grammar": "lsp",
        "label": "pas",
        "matches": {
          "paste": true
        },
        "options": {}
      },
      {
        "content": "paste(${1:...}, ${2:collapse = ${3:NULL}})",
        "doc": "Paste0",
        "grammar": "lsp",
        "label": "pas0",
        "matches": {
          "pas0": true
        },
        "options": {}
      },
      {
        "content": "plot(${1:x}, ${2:y}, ${3:...})",
        "doc": "Plot",
        "grammar": "lsp",
        "label": "plot",
        "matches": {
          "plot": true
        },
        "options": {}
      },
      {
        "content": "points(${1:x}, ${2:y = ${3:NULL}}, ${4:type = ${5:\"p\"}}, ${6:...})",
        "doc": "Points",
        "grammar": "lsp",
        "label": "poi",
        "matches": {
          "point": true
        },
        "options": {}
      },
      {
        "content": "print(${1:x}, ${2:...})",
        "doc": "Print",
        "grammar": "lsp",
        "label": "pri",
        "matches": {
          "print": true
        },
        "options": {}
      },
      {
        "content": "quantile(${1:x}, ${2:probs = ${3:seq(0, 1, 0.25)}}, ${4:na.rm = ${5:FALSE}}, ${6:names = ${7:TRUE}}, ${8:type = ${9:7}}, ${10:...})",
        "doc": "Quantile",
        "grammar": "lsp",
        "label": "qua",
        "matches": {
          "quantile": true
        },
        "options": {}
      },
      {
        "content": "read.table('${1:filename}'${2:, header = ${3:TRUE},  sep = '${4:\t}',  stringsAsFactors = ${5:FALSE}})",
        "doc": "Read From File",
        "grammar": "lsp",
        "label": "reat",
        "matches": {
          "read": true
        },
        "options": {}
      },
      {
        "content": "rep(${1:x}, ${2:...})",
        "doc": "Rep",
        "grammar": "lsp",
        "label": "rep",
        "matches": {
          "rep": true
        },
        "options": {}
      },
      {
        "content": "sample(${1:x}, ${2:size}, ${3:replace = ${4:FALSE}}, ${5:prob = ${6:NULL}})",
        "doc": "Sample",
        "grammar": "lsp",
        "label": "sam",
        "matches": {
          "sample": true
        },
        "options": {}
      },
      {
        "content": "seq(${1:from}, ${2:to}, ${3:by})",
        "doc": "Sequence (from,to,by)",
        "grammar": "lsp",
        "label": "seq",
        "matches": {
          "seq": true
        },
        "options": {}
      },
      {
        "content": "sort(${1:x})",
        "doc": "Sort",
        "grammar": "lsp",
        "label": "sor",
        "matches": {
          "sort": true
        },
        "options": {}
      },
      {
        "content": "source(${1:'${2:}'}${3:, chdir = ${4:TRUE}})",
        "doc": "Source",
        "grammar": "lsp",
        "label": "sou",
        "matches": {
          "source": true
        },
        "options": {}
      },
      {
        "content": "sd(${1:x}${2:, na.rm=${3:FALSE}})",
        "doc": "Standard deviation",
        "grammar": "lsp",
        "label": "sd",
        "matches": {
          "sd": true
        },
        "options": {}
      },
      {
        "content": "table(${1:...})",
        "doc": "Table",
        "grammar": "lsp",
        "label": "tab",
        "matches": {
          "table": true
        },
        "options": {}
      },
      {
        "content": "tapply(${1:X}, ${2:INDEX}, ${3:FUN = ${4:NULL}}, ${5:...}, ${6:simplify = ${7:TRUE}})",
        "doc": "Tapply",
        "grammar": "lsp",
        "label": "tap",
        "matches": {
          "tapply": true
        },
        "options": {}
      },
      {
        "content": "unique(${1:x}, ${2:incomparables = ${3:FALSE}}, ${4:...})",
        "doc": "Unique",
        "grammar": "lsp",
        "label": "uni",
        "matches": {
          "unique": true
        },
        "options": {}
      },
      {
        "content": "which(${1:x}, ${2:arr.ind = ${3:FALSE}}, ${4:useNames = ${5:TRUE}})",
        "doc": "Which",
        "grammar": "lsp",
        "label": "whi",
        "matches": {
          "which": true
        },
        "options": {}
      },
      {
        "content": "write.csv(${1:x}, ${2:file = ${3:\"\"}}, ${4:append = ${5:FALSE}}, ${6:quote = ${7:TRUE}}, ${8:sep = ${9:\" \"}}",
        "doc": "Write csv",
        "grammar": "lsp",
        "label": "wric",
        "matches": {
          "write": true
        },
        "options": {}
      },
      {
        "content": "${1:file = }file.choose()${0:}",
        "doc": "file.choose",
        "grammar": "lsp",
        "label": "fch",
        "matches": {
          "fch": true
        },
        "options": {}
      },
      {
        "content": "library(cluster)\nclara(${1:xData}, k = ${2:k}, metric = ${3:metric}, stand = ${4:stand}, samples = ${5:samples})",
        "doc": "Cluster data into k clusters (library: cluster)",
        "grammar": "lsp",
        "label": "Clustering",
        "matches": {
          "clara": true
        },
        "options": {}
      },
      {
        "content": "lmObj <- lm(${1:yCol} ~ {2:xCol}, data = ${3:data}, subset = ${4:subset}, weights = ${5:weights}, na.action = ${6:na.action})\nsummary(lmObj)",
        "doc": "Fit a linear model",
        "grammar": "lsp",
        "label": "Linear model",
        "matches": {
          "lm": true
        },
        "options": {}
      },
      {
        "content": "lmObj <- lm(${1:yCol} ~ {2:xCol}, data = ${3:data}, subset = ${4:subset}, weights = ${5:weights}, na.action = ${6:na.action})\nsummary(lmObj)\nplot(lmObj, which=c(1)) # Plot residuals versus fitted",
        "doc": "Fit a linear model and create a plot",
        "grammar": "lsp",
        "label": "Linear model with plot",
        "matches": {
          "lmplot": true
        },
        "options": {}
      },
      {
        "content": "loess(${1:yCol} ~ {2:xCol}, data = ${3:data}, subset = ${4:subset}, weights = ${5:weights}, span = ${6:span},\ndegree = ${7:degree}, na.action = {8:na.action})",
        "doc": "Local polynomial regression",
        "grammar": "lsp",
        "label": "loess",
        "matches": {
          "loess": true
        },
        "options": {}
      },
      {
        "content": "summary(${1:dataName}, digits = ${2:digits}, maxsum = ${3:maxsum})",
        "doc": "Mean, median, 25th and 75th quartiles, min, and max of variables",
        "grammar": "lsp",
        "label": "Descriptive statistics summary",
        "matches": {
          "summary": true
        },
        "options": {}
      },
      {
        "content": "crossTable <- xtabs(~${1:varNames}, data= ${2:dataName}, exclude = c(${3:exclude}), subset = ${4:subset})\nftable(crossTable)  # print crosstabs\nsummary(crossTable) # chi-square tests",
        "doc": "Crosstabulations for variables in a data frame",
        "grammar": "lsp",
        "label": "Crosstabs",
        "matches": {
          "xtabs": true
        },
        "options": {}
      },
      {
        "content": "${1:dfname} <- data.frame(${2:a} = character(), ${3:b} = character())",
        "doc": "Code snippet for an empty character data frame",
        "grammar": "lsp",
        "label": "Empty data frame (character)",
        "matches": {
          "df2c": true
        },
        "options": {}
      },
      {
        "content": "${1:dfname} <- data.frame(${2:x} = numeric(), ${3:y} = numeric())",
        "doc": "Code snippet for an empty numerical data frame",
        "grammar": "lsp",
        "label": "Empty data frame (numeric)",
        "matches": {
          "df2n": true
        },
        "options": {}
      },
      {
        "content": "${1:dfname} <- data.frame(${2:varlist})",
        "doc": "Create a data frame from vectors",
        "grammar": "lsp",
        "label": "Data frame",
        "matches": {
          "dfv": true
        },
        "options": {}
      },
      {
        "content": "${1:outFactor} <- factor(x = ${2:dataVec}, levels = ${3:levels}, exclude = ${4:exclude})",
        "doc": "Create a factor (categorical variable) from a vector",
        "grammar": "lsp",
        "label": "Categorical variable",
        "matches": {
          "factor": true
        },
        "options": {}
      },
      {
        "content": "${1:outMatrix} <- matrix(data = ${2:dataVec}, nrow = ${3:nrow}, ncol = ${4:ncol}, byrow = ${5:byrow})",
        "doc": "Create a matrix from a vector",
        "grammar": "lsp",
        "label": "Matrix",
        "matches": {
          "matrix": true
        },
        "options": {}
      },
      {
        "content": "${1:newdataframe} <- na.omit(${2:dataframe})",
        "doc": "Remove all rows with missing values from data frame",
        "grammar": "lsp",
        "label": "remove missings",
        "matches": {
          "naomit": true
        },
        "options": {}
      },
      {
        "content": "${1:dfname} <- read.csv(file = \"${2:file}\", header = ${3|TRUE,FALSE|},  sep = \"${4|\\,,;|}\", row.names = ${5:NULL},  stringsAsFactors = ${6|FALSE,TRUE|})",
        "doc": "Read a data table from a comma-separated file (CSV) and create a data frame",
        "grammar": "lsp",
        "label": "Read CSV",
        "matches": {
          "readc": true
        },
        "options": {}
      },
      {
        "content": "else {\n   ${1:selected}\n}",
        "doc": "Code snippet for 'else' conditional",
        "grammar": "lsp",
        "label": "else",
        "matches": {
          "else": true
        },
        "options": {}
      },
      {
        "content": "else if (${1:condition}) {\n   ${2:selected}\n}",
        "doc": "Code snippet for 'else' conditional",
        "grammar": "lsp",
        "label": "elseif",
        "matches": {
          "elseif": true
        },
        "options": {}
      },
      {
        "content": "for (${1:identifier} in ${2:collection}) {\n   ${3:selected}\n}",
        "doc": "Code snippet for 'for' loop",
        "grammar": "lsp",
        "label": "for",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "${1:name} <- function(${2:parameters}) {\n   ${3:selected}\n}",
        "doc": "Named function",
        "grammar": "lsp",
        "label": "function",
        "matches": {
          "function": true
        },
        "options": {}
      },
      {
        "content": "if (${1:condition}) {\n   ${2:selected}\n}",
        "doc": "Code snippet for 'if' conditional",
        "grammar": "lsp",
        "label": "if",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "if (${1:condition}) {\n   ${2:selected}\n} else {\n   \n}",
        "doc": "Code snippet for 'if-else' conditional block",
        "grammar": "lsp",
        "label": "if-else block",
        "matches": {
          "ifelse": true
        },
        "options": {}
      },
      {
        "content": "#region $0",
        "doc": "Folding Region Start",
        "grammar": "lsp",
        "label": "Region Start",
        "matches": {
          "#region": true
        },
        "options": {}
      },
      {
        "content": "#endregion",
        "doc": "Folding Region End",
        "grammar": "lsp",
        "label": "Region End",
        "matches": {
          "#endregion": true
        },
        "options": {}
      }
    ],
    "racket": [
      {
        "content": "#lang racket",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#r": true
        },
        "options": {}
      },
      {
        "content": "#lang typed/racket",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#tr": true
        },
        "options": {}
      },
      {
        "content": "#lang racket/gui",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#rg": true
        },
        "options": {}
      },
      {
        "content": "#lang scribble/base",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#sb": true
        },
        "options": {}
      },
      {
        "content": "#lang datalog",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#d": true
        },
        "options": {}
      },
      {
        "content": "#lang web-server/insta",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#wi": true
        },
        "options": {}
      },
      {
        "content": "(define ${1} ${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "def": true
        },
        "options": {}
      },
      {
        "content": "(define (${1})\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defun": true
        },
        "options": {}
      },
      {
        "content": "(define-values (${1}) (${0}))",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defv \"define-values\"": true
        },
        "options": {}
      },
      {
        "content": "(define/match (${1})\n  [(${2}) ${3}]\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defm \"define/match\"": true
        },
        "options": {}
      },
      {
        "content": "(define-syntax (${1})\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defs \"define-syntax\"": true
        },
        "options": {}
      },
      {
        "content": "(if ${1} ${2} ${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "(if (not ${1}) ${2} ${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifn": true
        },
        "options": {}
      },
      {
        "content": "(if ${1}\n\t(let (${2})\n\t\t${3})\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifl": true
        },
        "options": {}
      },
      {
        "content": "(if (not ${1})\n\t(let (${2})\n\t\t${3})\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifnl": true
        },
        "options": {}
      },
      {
        "content": "(if ${1}\n\t(begin\n\t\t${2})\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifb": true
        },
        "options": {}
      },
      {
        "content": "(if (not ${1})\n\t(begin\n\t\t${2})\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifnb": true
        },
        "options": {}
      },
      {
        "content": "(when ${1}\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "when": true
        },
        "options": {}
      },
      {
        "content": "(unless ${1} ${2} ${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "unless": true
        },
        "options": {}
      },
      {
        "content": "(cond\n\t[(${1}) ${0}])",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cond": true
        },
        "options": {}
      },
      {
        "content": "(cond\n\t[(${1}) ${2}]\n\t[else ${0}])",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "conde": true
        },
        "options": {}
      },
      {
        "content": "(case ${1}\n\t[(${2}) ${0}])",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case": true
        },
        "options": {}
      },
      {
        "content": "(match ${1}\n\t[(${2}) ${0}])",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "match": true
        },
        "options": {}
      },
      {
        "content": "(for ([${1}])\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "(for/list ([${1}])\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forl \"for/list\"": true
        },
        "options": {}
      },
      {
        "content": "(for/fold\n\t([${1}])\n\t([${2}])\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forf \"for/fold\"": true
        },
        "options": {}
      },
      {
        "content": "(for/foldr\n\t([${1}])\n\t([${2}])\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forfr \"for/foldr\"": true
        },
        "options": {}
      },
      {
        "content": "(for/and ([${1}])\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fora \"for/and\"": true
        },
        "options": {}
      },
      {
        "content": "(for/or ([${1}])\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "foro \"for/or\"": true
        },
        "options": {}
      },
      {
        "content": "(for/sum ([${1}])\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fors \"for/sum\"": true
        },
        "options": {}
      },
      {
        "content": "(for/product ([${1}])\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forp \"for/product\"": true
        },
        "options": {}
      },
      {
        "content": "(for/first ([${1}])\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forfi \"for/first\"": true
        },
        "options": {}
      },
      {
        "content": "(for/last ([${1}])\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forla \"for/last\"": true
        },
        "options": {}
      },
      {
        "content": "(lambda (${1}) ${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lambda": true
        },
        "options": {}
      },
      {
        "content": "(apply ${1} ${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "apply": true
        },
        "options": {}
      },
      {
        "content": "(map ${1} ${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "map": true
        },
        "options": {}
      },
      {
        "content": "(filter ${1} ${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "filter": true
        },
        "options": {}
      },
      {
        "content": "(require ${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "req": true
        },
        "options": {}
      },
      {
        "content": "(provide ${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prov": true
        },
        "options": {}
      },
      {
        "content": "(let ([${1}]) ${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "let": true
        },
        "options": {}
      },
      {
        "content": "(let/cc here (set! ${1} here) ${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "letcc": true
        },
        "options": {}
      },
      {
        "content": "(begin\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "begin": true
        },
        "options": {}
      }
    ],
    "rails": [
      {
        "content": "render",
        "doc": "",
        "grammar": "snu",
        "label": "render",
        "matches": {
          "rr": true
        },
        "options": {}
      },
      {
        "content": "render action: ",
        "doc": "",
        "grammar": "snu",
        "label": "render :action",
        "matches": {
          "ra": true
        },
        "options": {}
      },
      {
        "content": "render controller: ",
        "doc": "",
        "grammar": "snu",
        "label": "render :controller",
        "matches": {
          "rc": true
        },
        "options": {}
      },
      {
        "content": "render file: ",
        "doc": "",
        "grammar": "snu",
        "label": "render :file",
        "matches": {
          "rf": true
        },
        "options": {}
      },
      {
        "content": "render inline: ",
        "doc": "",
        "grammar": "snu",
        "label": "render :inline",
        "matches": {
          "ri": true
        },
        "options": {}
      },
      {
        "content": "render json: ",
        "doc": "",
        "grammar": "snu",
        "label": "render :json",
        "matches": {
          "rj": true
        },
        "options": {}
      },
      {
        "content": "render layout: ",
        "doc": "",
        "grammar": "snu",
        "label": "render :layout",
        "matches": {
          "rl": true
        },
        "options": {}
      },
      {
        "content": "render partial: ",
        "doc": "",
        "grammar": "snu",
        "label": "render :partial",
        "matches": {
          "rp": true
        },
        "options": {}
      },
      {
        "content": "render text: ",
        "doc": "",
        "grammar": "snu",
        "label": "render :text",
        "matches": {
          "rt": true
        },
        "options": {}
      },
      {
        "content": "render xml: ",
        "doc": "",
        "grammar": "snu",
        "label": "render :xml",
        "matches": {
          "rx": true
        },
        "options": {}
      },
      {
        "content": "distance_of_time_in_words",
        "doc": "",
        "grammar": "snu",
        "label": "distance_of_time_in_words",
        "matches": {
          "dotiw": true
        },
        "options": {}
      },
      {
        "content": "time_ago_in_words",
        "doc": "",
        "grammar": "snu",
        "label": "time_ago_in_words",
        "matches": {
          "taiw": true
        },
        "options": {}
      },
      {
        "content": "redirect_to",
        "doc": "",
        "grammar": "snu",
        "label": "redirect_to",
        "matches": {
          "re": true
        },
        "options": {}
      },
      {
        "content": "redirect_to action: ",
        "doc": "",
        "grammar": "snu",
        "label": "redirect_to :action",
        "matches": {
          "rea": true
        },
        "options": {}
      },
      {
        "content": "redirect_to controller: ",
        "doc": "",
        "grammar": "snu",
        "label": "redirect_to :controller",
        "matches": {
          "rec": true
        },
        "options": {}
      },
      {
        "content": "respond_to",
        "doc": "",
        "grammar": "snu",
        "label": "respond_to",
        "matches": {
          "rst": true
        },
        "options": {}
      },
      {
        "content": "belongs_to",
        "doc": "",
        "grammar": "snu",
        "label": "belongs_to",
        "matches": {
          "bt": true
        },
        "options": {}
      },
      {
        "content": "has_one",
        "doc": "",
        "grammar": "snu",
        "label": "has_one",
        "matches": {
          "ho": true
        },
        "options": {}
      },
      {
        "content": "has_many",
        "doc": "",
        "grammar": "snu",
        "label": "has_many",
        "matches": {
          "hm": true
        },
        "options": {}
      },
      {
        "content": "has_and_belongs_to_many",
        "doc": "",
        "grammar": "snu",
        "label": "has_and_belongs_to_many",
        "matches": {
          "habtm": true
        },
        "options": {}
      },
      {
        "content": "composed_of",
        "doc": "",
        "grammar": "snu",
        "label": "composed_of",
        "matches": {
          "co": true
        },
        "options": {}
      },
      {
        "content": "validates_associated",
        "doc": "",
        "grammar": "snu",
        "label": "validates_associated",
        "matches": {
          "va": true
        },
        "options": {}
      },
      {
        "content": "validates_acceptance_of",
        "doc": "",
        "grammar": "snu",
        "label": "validates_acceptance_of",
        "matches": {
          "vb": true
        },
        "options": {}
      },
      {
        "content": "validates_confirmation_of",
        "doc": "",
        "grammar": "snu",
        "label": "validates_confirmation_of",
        "matches": {
          "vc": true
        },
        "options": {}
      },
      {
        "content": "validates_exclusion_of",
        "doc": "",
        "grammar": "snu",
        "label": "validates_exclusion_of",
        "matches": {
          "ve": true
        },
        "options": {}
      },
      {
        "content": "validates_format_of",
        "doc": "",
        "grammar": "snu",
        "label": "validates_format_of",
        "matches": {
          "vf": true
        },
        "options": {}
      },
      {
        "content": "validates_inclusion_of",
        "doc": "",
        "grammar": "snu",
        "label": "validates_inclusion_of",
        "matches": {
          "vi": true
        },
        "options": {}
      },
      {
        "content": "validates_length_of",
        "doc": "",
        "grammar": "snu",
        "label": "validates_length_of",
        "matches": {
          "vl": true
        },
        "options": {}
      },
      {
        "content": "validates_numericality_of",
        "doc": "",
        "grammar": "snu",
        "label": "validates_numericality_of",
        "matches": {
          "vn": true
        },
        "options": {}
      },
      {
        "content": "validates_presence_of",
        "doc": "",
        "grammar": "snu",
        "label": "validates_presence_of",
        "matches": {
          "vp": true
        },
        "options": {}
      },
      {
        "content": "validates_uniqueness_of",
        "doc": "",
        "grammar": "snu",
        "label": "validates_uniqueness_of",
        "matches": {
          "vu": true
        },
        "options": {}
      },
      {
        "content": "logger.debug",
        "doc": "",
        "grammar": "snu",
        "label": "logger.debug",
        "matches": {
          "logd": true
        },
        "options": {}
      },
      {
        "content": "logger.info",
        "doc": "",
        "grammar": "snu",
        "label": "logger.info",
        "matches": {
          "logi": true
        },
        "options": {}
      },
      {
        "content": "logger.warn",
        "doc": "",
        "grammar": "snu",
        "label": "logger.warn",
        "matches": {
          "logw": true
        },
        "options": {}
      },
      {
        "content": "logger.error",
        "doc": "",
        "grammar": "snu",
        "label": "logger.error",
        "matches": {
          "loge": true
        },
        "options": {}
      },
      {
        "content": "logger.fatal",
        "doc": "",
        "grammar": "snu",
        "label": "logger.fatal",
        "matches": {
          "logf": true
        },
        "options": {}
      },
      {
        "content": "action: ",
        "doc": "",
        "grammar": "snu",
        "label": "action:",
        "matches": {
          "action": true
        },
        "options": {}
      },
      {
        "content": "co________: ",
        "doc": "",
        "grammar": "snu",
        "label": "co________:",
        "matches": {
          "co_": true
        },
        "options": {}
      },
      {
        "content": "id: ",
        "doc": "",
        "grammar": "snu",
        "label": "id:",
        "matches": {
          "id": true
        },
        "options": {}
      },
      {
        "content": "object: ",
        "doc": "",
        "grammar": "snu",
        "label": "object:",
        "matches": {
          "object": true
        },
        "options": {}
      },
      {
        "content": "partial: ",
        "doc": "",
        "grammar": "snu",
        "label": "partial:",
        "matches": {
          "partial": true
        },
        "options": {}
      },
      {
        "content": "assert_redirected_to ${1:action}: '${2:index}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "art": true
        },
        "options": {}
      },
      {
        "content": "assert_redirected_to ${1:parent}_${2:child}_path(${3:@$1}, ${0:@$2})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "artnp": true
        },
        "options": {}
      },
      {
        "content": "assert_redirected_to ${1:parent}_${2:child}_path(${0:@$1})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "artnpp": true
        },
        "options": {}
      },
      {
        "content": "assert_redirected_to ${1:model}_path(${0:@$1})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "artp": true
        },
        "options": {}
      },
      {
        "content": "assert_redirected_to ${0:model}s_path",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "artpp": true
        },
        "options": {}
      },
      {
        "content": "assert_difference '${1:Model}.${2:count}', ${3:1} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asd": true
        },
        "options": {}
      },
      {
        "content": "assert_no_difference '${1:Model}.${2:count}' do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asnd": true
        },
        "options": {}
      },
      {
        "content": "assert_response :${1:success}, @response.body",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asre": true
        },
        "options": {}
      },
      {
        "content": "assert_rjs :${1:replace}, '${0:dom id}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asrj": true
        },
        "options": {}
      },
      {
        "content": "assert_select '${1:path}', ${2:text}: '${3:inner_html}' ${4:do}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ass assert_select(..)": true
        },
        "options": {}
      },
      {
        "content": "before_action :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ba": true
        },
        "options": {}
      },
      {
        "content": "before_filter :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bf": true
        },
        "options": {}
      },
      {
        "content": "belongs_to :${0:association}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bt": true
        },
        "options": {}
      },
      {
        "content": "belongs_to :${1:association}, polymorphic: true",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "btp": true
        },
        "options": {}
      },
      {
        "content": "cattr_accessor :${0:attr_names}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "crw": true
        },
        "options": {}
      },
      {
        "content": "def create\n\t@${1:model_class_name} = ${2:ModelClassName}.new($1_params)\n\trespond_to do |format|\n\t\tif @$1.save\n\t\t\tflash[:notice] = '$2 was successfully created.'\n\t\t\tformat.html { redirect_to(@$1) }\n\t\t\tformat.json  { render json: @$1, status: :created, location: @$1 }\n\t\telse\n\t\t\tformat.html { render action: 'new' }\n\t\t\tformat.json  { render json: @$1.errors, status: :unprocessable_entity }\n\t\tend\n\tend\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defcreate": true
        },
        "options": {}
      },
      {
        "content": "def destroy\n\t@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])\n\t@$1.destroy\n\trespond_to do |format|\n\t\tformat.html { redirect_to($1s_url) }\n\t\tformat.json  { head :ok }\n\tend\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defdestroy": true
        },
        "options": {}
      },
      {
        "content": "def edit\n\t@${1:model_class_name} = ${0:ModelClassName}.find(params[:id])\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defedit": true
        },
        "options": {}
      },
      {
        "content": "def index\n\t@${1:model_class_name} = ${2:ModelClassName}.all\n\trespond_to do |format|\n\t\tformat.html # index.html.erb\n\t\tformat.json  { render json: @$1s }\n\tend\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defindex": true
        },
        "options": {}
      },
      {
        "content": "def new\n\t@${1:model_class_name} = ${2:ModelClassName}.new\n\trespond_to do |format|\n\t\tformat.html # new.html.erb\n\t\tformat.json  { render json: @$1 }\n\tend\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defnew": true
        },
        "options": {}
      },
      {
        "content": "def show\n\t@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])\n\trespond_to do |format|\n\t\tformat.html # show.html.erb\n\t\tformat.json  { render json: @$1 }\n\tend\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defshow": true
        },
        "options": {}
      },
      {
        "content": "def update\n\t@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])\n\trespond_to do |format|\n\t\tif @$1.update($1_params)\n\t\t\tflash[:notice] = '$2 was successfully updated.'\n\t\t\tformat.html { redirect_to(@$1) }\n\t\t\tformat.json  { head :ok }\n\t\telse\n\t\t\tformat.html { render action: 'edit' }\n\t\t\tformat.json  { render json: @$1.errors, status: :unprocessable_entity }\n\t\tend\n\tend\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defupdate": true
        },
        "options": {}
      },
      {
        "content": "def ${1:model_class_name}_params\n\tparams.require(:$1).permit()\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defparams": true
        },
        "options": {}
      },
      {
        "content": "delegate :${1:methods}, to: :${0:object}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dele delegate .. to": true
        },
        "options": {}
      },
      {
        "content": "delegate :${1:methods}, to: :${2:object}, prefix: :${3:prefix}, allow_nil: ${0:allow_nil}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dele delegate .. to .. prefix .. allow_nil": true
        },
        "options": {}
      },
      {
        "content": "alias_method_chain :${1:method_name}, :${0:feature}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "amc": true
        },
        "options": {}
      },
      {
        "content": "flash[:${1:notice}] = '${0}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "flash": true
        },
        "options": {}
      },
      {
        "content": "has_and_belongs_to_many :${1:object}, join_table: '${2:table_name}', foreign_key: '${3}_id'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "habtm": true
        },
        "options": {}
      },
      {
        "content": "has_many :${0:object}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "hm": true
        },
        "options": {}
      },
      {
        "content": "has_many :${1:other}s, class_name: '${2:$1}', foreign_key: '${3:$1}_id', dependent: :destroy",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "hmd": true
        },
        "options": {}
      },
      {
        "content": "has_many :${1:object}, through: :${0:object}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "hmt": true
        },
        "options": {}
      },
      {
        "content": "has_one :${0:object}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ho": true
        },
        "options": {}
      },
      {
        "content": "has_one :${1:object}, dependent: :${0:destroy}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "hod": true
        },
        "options": {}
      },
      {
        "content": "I18n.t('${1:type.key}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "i18": true
        },
        "options": {}
      },
      {
        "content": "<%= image_submit_tag('${1:agree.png}', id: '${2:id}'${0}) %>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ist": true
        },
        "options": {}
      },
      {
        "content": "Rails.logger.${1:debug} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "log": true
        },
        "options": {}
      },
      {
        "content": "RAILS_DEFAULT_LOGGER.${1:debug} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "log2": true
        },
        "options": {}
      },
      {
        "content": "logger.debug { '${1:message}' }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "logd": true
        },
        "options": {}
      },
      {
        "content": "logger.error { '${1:message}' }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "loge": true
        },
        "options": {}
      },
      {
        "content": "logger.fatal { '${1:message}' }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "logf": true
        },
        "options": {}
      },
      {
        "content": "logger.info { '${1:message}' }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "logi": true
        },
        "options": {}
      },
      {
        "content": "logger.warn { '${1:message}' }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "logw": true
        },
        "options": {}
      },
      {
        "content": "${1:map}.${2:connect} '${0:controller/:action/:id}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mapc": true
        },
        "options": {}
      },
      {
        "content": "${1:map}.catch_all '*${2:anything}', controller: '${3:default}', action: '${4:error}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mapca": true
        },
        "options": {}
      },
      {
        "content": "${1:map}.resource :${0:resource}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mapr": true
        },
        "options": {}
      },
      {
        "content": "${1:map}.resources :${0:resource}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "maprs": true
        },
        "options": {}
      },
      {
        "content": "${1:map}.with_options ${2:controller}: '${3:thing}' do |$3|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mapwo": true
        },
        "options": {}
      },
      {
        "content": "before_validation :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mbv": true
        },
        "options": {}
      },
      {
        "content": "before_create :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mbc": true
        },
        "options": {}
      },
      {
        "content": "before_update :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mbu": true
        },
        "options": {}
      },
      {
        "content": "before_save :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mbs": true
        },
        "options": {}
      },
      {
        "content": "before_destroy :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mbd": true
        },
        "options": {}
      },
      {
        "content": "after_validation :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mav": true
        },
        "options": {}
      },
      {
        "content": "after_find :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "maf": true
        },
        "options": {}
      },
      {
        "content": "after_touch :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mat": true
        },
        "options": {}
      },
      {
        "content": "after_create :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "macr": true
        },
        "options": {}
      },
      {
        "content": "after_update :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mau": true
        },
        "options": {}
      },
      {
        "content": "after_save :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mas": true
        },
        "options": {}
      },
      {
        "content": "after_destroy :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mad": true
        },
        "options": {}
      },
      {
        "content": "around_create :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "marc": true
        },
        "options": {}
      },
      {
        "content": "around_update :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "maru": true
        },
        "options": {}
      },
      {
        "content": "around_save :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mars": true
        },
        "options": {}
      },
      {
        "content": "around_destroy :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mard": true
        },
        "options": {}
      },
      {
        "content": "change_table :${1:table_name} do |t|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mcht": true
        },
        "options": {}
      },
      {
        "content": "map(&:${0:id})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mp": true
        },
        "options": {}
      },
      {
        "content": "mattr_accessor :${0:attr_names}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mrw": true
        },
        "options": {}
      },
      {
        "content": "order('${0:field}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "oa": true
        },
        "options": {}
      },
      {
        "content": "order('${0:field} DESC')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "od": true
        },
        "options": {}
      },
      {
        "content": "params[:${1:id}]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pa": true
        },
        "options": {}
      },
      {
        "content": "render action: '${0:action}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ra": true
        },
        "options": {}
      },
      {
        "content": "render action: '${1:action}', layout: '${0:layoutname}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ral": true
        },
        "options": {}
      },
      {
        "content": "respond_to do |format|\n\tformat.${1:html} { ${0} }\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rest": true
        },
        "options": {}
      },
      {
        "content": "render file: '${0:filepath}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rf": true
        },
        "options": {}
      },
      {
        "content": "render file: '${1:filepath}', use_full_path: ${0:false}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rfu": true
        },
        "options": {}
      },
      {
        "content": "render inline: \"${0:<%= 'hello' %>}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ri": true
        },
        "options": {}
      },
      {
        "content": "render inline: \"${1:<%= 'hello' %>}\", locals: { ${2:name}: '${3:value}'${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ril": true
        },
        "options": {}
      },
      {
        "content": "render inline: \"${1:<%= 'hello' %>}\", type: ${0::rxml}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rit": true
        },
        "options": {}
      },
      {
        "content": "render json: '${0:text to render}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rjson": true
        },
        "options": {}
      },
      {
        "content": "render layout: '${0:layoutname}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rl": true
        },
        "options": {}
      },
      {
        "content": "render nothing: ${0:true}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rn": true
        },
        "options": {}
      },
      {
        "content": "render nothing: ${1:true}, status: ${0:401}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rns": true
        },
        "options": {}
      },
      {
        "content": "render partial: '${0:item}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rp": true
        },
        "options": {}
      },
      {
        "content": "render partial: '${1:item}', collection: ${0:@$1s}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rpc": true
        },
        "options": {}
      },
      {
        "content": "render partial: '${1:item}', locals: { ${2:$1}: ${0:@$1} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rpl": true
        },
        "options": {}
      },
      {
        "content": "render partial: '${1:item}', object: ${0:@$1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rpo": true
        },
        "options": {}
      },
      {
        "content": "render partial: '${1:item}', status: ${0:500}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rps": true
        },
        "options": {}
      },
      {
        "content": "render text: '${0:text to render}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rt": true
        },
        "options": {}
      },
      {
        "content": "render text: '${1:text to render}', layout: '${0:layoutname}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rtl": true
        },
        "options": {}
      },
      {
        "content": "render text: '${1:text to render}', layout: ${0:true}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rtlt": true
        },
        "options": {}
      },
      {
        "content": "render text: '${1:text to render}', status: ${0:401}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rts": true
        },
        "options": {}
      },
      {
        "content": "render :update do |${1:page}|\n\t$1.${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ru": true
        },
        "options": {}
      },
      {
        "content": "render xml: '${0:text to render}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rxml": true
        },
        "options": {}
      },
      {
        "content": "scope :${1:name}, -> { where(${2:field}: ${0:value}) }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sc": true
        },
        "options": {}
      },
      {
        "content": "scope :${1:name}, lambda do |${2:value}|\n\twhere('${3:field = ?}', ${0:value})\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sl": true
        },
        "options": {}
      },
      {
        "content": "Digest::SHA1.hexdigest(${0:string})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sha1": true
        },
        "options": {}
      },
      {
        "content": "class ${1:ModelClassName}Sweeper < ActionController::Caching::Sweeper\n\tobserve $1\n\tdef after_save(${0:model_class_name})\n\t\texpire_cache($2)\n\tend\n\tdef after_destroy($2)\n\t\texpire_cache($2)\n\tend\n\tdef expire_cache($2)\n\t\texpire_page\n\tend\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sweeper": true
        },
        "options": {}
      },
      {
        "content": "validates_associated :${0:attribute}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "va validates_associated": true
        },
        "options": {}
      },
      {
        "content": "validates :${0:terms}, acceptance: true",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "va validates .., acceptance: true": true
        },
        "options": {}
      },
      {
        "content": "validates :${0:attribute}, confirmation: true",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vc": true
        },
        "options": {}
      },
      {
        "content": "validates :${1:attribute}, exclusion: { in: ${0:%w( mov avi )} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ve": true
        },
        "options": {}
      },
      {
        "content": "validates :${1:attribute}, format: { with: /${0:regex}/ }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vf": true
        },
        "options": {}
      },
      {
        "content": "validates :${1:attribute}, inclusion: { in: %w(${0: mov avi }) }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vi": true
        },
        "options": {}
      },
      {
        "content": "validates :${1:attribute}, length: { in: ${2:3}..${0:20} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vl": true
        },
        "options": {}
      },
      {
        "content": "validates :${0:attribute}, numericality: true",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vn": true
        },
        "options": {}
      },
      {
        "content": "validates :${0:attribute}, presence: true",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vp": true
        },
        "options": {}
      },
      {
        "content": "validates :${0:attribute}, uniqueness: true",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vu": true
        },
        "options": {}
      },
      {
        "content": "format.${1:js|xml|html} { ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "format": true
        },
        "options": {}
      },
      {
        "content": "where(${1:'conditions'}${0:, bind_var})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wc": true
        },
        "options": {}
      },
      {
        "content": "where(${1:field}: ${0:value})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wf": true
        },
        "options": {}
      },
      {
        "content": "xhr :delete, :${1:destroy}, id: ${2:1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "xdelete": true
        },
        "options": {}
      },
      {
        "content": "xhr :get, :${1:show}, id: ${2:1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "xget": true
        },
        "options": {}
      },
      {
        "content": "xhr :post, :${1:create}, ${2:object}: ${3:object}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "xpost": true
        },
        "options": {}
      },
      {
        "content": "xhr :put, :${1:update}, id: ${2:1}, ${3:object}: ${4:object}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "xput": true
        },
        "options": {}
      },
      {
        "content": "test '${1:should do something}' do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "test": true
        },
        "options": {}
      },
      {
        "content": "add_column :${1:table_name}, :${2:column_name}, :${0:data_type}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mac": true
        },
        "options": {}
      },
      {
        "content": "add_index :${1:table_name}, :${0:column_name}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mai": true
        },
        "options": {}
      },
      {
        "content": "remove_column :${1:table_name}, :${0:column_name}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mrc": true
        },
        "options": {}
      },
      {
        "content": "rename_column :${1:table_name}, :${2:old_column_name}, :${0:new_column_name}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mrnc": true
        },
        "options": {}
      },
      {
        "content": "change_column :${1:table}, :${2:column}, :${0:type}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mcc": true
        },
        "options": {}
      },
      {
        "content": "t.${1:string} :${2:title}${3:, null: false}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mnc": true
        },
        "options": {}
      },
      {
        "content": "create_table :${1:table_name} do |t|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mct": true
        },
        "options": {}
      },
      {
        "content": "reversible do |dir|\n\tdir.up do\n\t\t${0}\n\tend\n\tdir.down do\n\tend\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mrev reversible do |dir| ... dir.up .. dir.down .. end": true
        },
        "options": {}
      },
      {
        "content": "class Migration${1:class_name} < ApplicationRecord\n\tself.table_name = :${2:model_name}s\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cmm class Migration... < ApplicationModel .. self.table_name .. end": true
        },
        "options": {}
      },
      {
        "content": "t.remove :${0:column}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "trc": true
        },
        "options": {}
      },
      {
        "content": "t.rename :${1:old_column_name}, :${2:new_column_name}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tre": true
        },
        "options": {}
      },
      {
        "content": "t.references :${0:model}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tref": true
        },
        "options": {}
      },
      {
        "content": "t.boolean :${1:title}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tcb": true
        },
        "options": {}
      },
      {
        "content": "t.binary :${1:title}, limit: ${2:2}.megabytes\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tcbi": true
        },
        "options": {}
      },
      {
        "content": "t.decimal :${1:title}, precision: ${2:10}, scale: ${3:2}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tcd": true
        },
        "options": {}
      },
      {
        "content": "t.date :${1:title}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tcda": true
        },
        "options": {}
      },
      {
        "content": "t.datetime :${1:title}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tcdt": true
        },
        "options": {}
      },
      {
        "content": "t.float :${1:title}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tcf": true
        },
        "options": {}
      },
      {
        "content": "t.change :${1:name}, :${2:string}, ${3:limit}: ${4:80}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tch": true
        },
        "options": {}
      },
      {
        "content": "t.integer :${1:title}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tci": true
        },
        "options": {}
      },
      {
        "content": "t.integer :lock_version, null: false, default: 0\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tcl": true
        },
        "options": {}
      },
      {
        "content": "t.references :${1:taggable}, polymorphic: { default: '${2:Photo}' }\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tcr": true
        },
        "options": {}
      },
      {
        "content": "t.string :${1:title}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tcs": true
        },
        "options": {}
      },
      {
        "content": "t.text :${1:title}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tct": true
        },
        "options": {}
      },
      {
        "content": "t.time :${1:title}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tcti": true
        },
        "options": {}
      },
      {
        "content": "t.timestamp :${1:title}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tcts": true
        },
        "options": {}
      },
      {
        "content": "t.timestamps\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tctss": true
        },
        "options": {}
      },
      {
        "content": "it { should filter_param :${0:key} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isfp": true
        },
        "options": {}
      },
      {
        "content": "it { should redirect_to ${0:url} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isrt": true
        },
        "options": {}
      },
      {
        "content": "it { should render_template ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isrtp": true
        },
        "options": {}
      },
      {
        "content": "it { should render_with_layout ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isrwl": true
        },
        "options": {}
      },
      {
        "content": "it { should rescue_from ${0:exception} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isrf": true
        },
        "options": {}
      },
      {
        "content": "it { should respond_with ${0:status} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isrw": true
        },
        "options": {}
      },
      {
        "content": "it { should route(:${1:method}, '${0:path}') }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isr": true
        },
        "options": {}
      },
      {
        "content": "it { should set_session :${0:key} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isss": true
        },
        "options": {}
      },
      {
        "content": "it { should set_the_flash('${0}') }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "issf": true
        },
        "options": {}
      },
      {
        "content": "it { should allow_mass_assignment_of :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isama": true
        },
        "options": {}
      },
      {
        "content": "it { should allow_value(${1}).for :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isav": true
        },
        "options": {}
      },
      {
        "content": "it { should ensure_exclusion_of :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isee": true
        },
        "options": {}
      },
      {
        "content": "it { should ensure_inclusion_of :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isei": true
        },
        "options": {}
      },
      {
        "content": "it { should ensure_length_of :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isel": true
        },
        "options": {}
      },
      {
        "content": "it { should validate_acceptance_of :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isva": true
        },
        "options": {}
      },
      {
        "content": "it { should validate_confirmation_of :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isvc": true
        },
        "options": {}
      },
      {
        "content": "it { should validate_numericality_of :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isvn": true
        },
        "options": {}
      },
      {
        "content": "it { should validate_presence_of :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isvp": true
        },
        "options": {}
      },
      {
        "content": "it { should validate_uniqueness_of :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isvu": true
        },
        "options": {}
      },
      {
        "content": "it { should accept_nested_attributes_for :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isana": true
        },
        "options": {}
      },
      {
        "content": "it { should belong_to :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isbt": true
        },
        "options": {}
      },
      {
        "content": "it { should belong_to(:${1}).counter_cache ${0:true} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isbtcc": true
        },
        "options": {}
      },
      {
        "content": "it { should have_and_belong_to_many :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ishbtm": true
        },
        "options": {}
      },
      {
        "content": "it { should be_valid }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isbv": true
        },
        "options": {}
      },
      {
        "content": "it { should have_db_column :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ishc": true
        },
        "options": {}
      },
      {
        "content": "it { should have_db_index :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ishi": true
        },
        "options": {}
      },
      {
        "content": "it { should have_many :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ishm": true
        },
        "options": {}
      },
      {
        "content": "it { should have_many(:${1}).through :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ishmt": true
        },
        "options": {}
      },
      {
        "content": "it { should have_one :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isho": true
        },
        "options": {}
      },
      {
        "content": "it { should have_readonly_attribute :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ishro": true
        },
        "options": {}
      },
      {
        "content": "it { should serialize :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "iss": true
        },
        "options": {}
      },
      {
        "content": "it { should respond_to :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isres": true
        },
        "options": {}
      },
      {
        "content": "it { should respond_to(:${1}).with(${0}).arguments }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isresw": true
        },
        "options": {}
      },
      {
        "content": "${1:super_class}.instance_method(:${0:method}).bind(self).call",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "super_call": true
        },
        "options": {}
      },
      {
        "content": "accepts_nested_attributes_for :${1:association_name}${2:${3:, allow_destroy: true}${4:, reject_if: proc \\{ |obj| ${5:obj.blank?} \\}}}\n",
        "doc": "",
        "grammar": "snu",
        "label": "accepts_nested_attributes_for",
        "matches": {
          "anaf": true
        },
        "options": {}
      },
      {
        "content": "t.binary :${1:title}${2:, limit: ${3:2}.megabytes}\n$0",
        "doc": "",
        "grammar": "snu",
        "label": "Create binary column",
        "matches": {
          "tcbi": true
        },
        "options": {}
      },
      {
        "content": "t.boolean :${1:title}\n$0",
        "doc": "",
        "grammar": "snu",
        "label": "Create boolean column",
        "matches": {
          "tcb": true
        },
        "options": {}
      },
      {
        "content": "class ${1:Model}Controller < ApplicationController\n\tbefore_action :find_${2:model}\n\n\t$0\n\n\tprivate\n\tdef find_$2\n\t\t@$2 = ${3:$1}.find(params[:id]) if params[:id]\n\tend\nend",
        "doc": "",
        "grammar": "snu",
        "label": "Create controller class",
        "matches": {
          "clac": true
        },
        "options": {}
      },
      {
        "content": "t.date :${1:title}\n$0",
        "doc": "",
        "grammar": "snu",
        "label": "Create date column",
        "matches": {
          "tcda": true
        },
        "options": {}
      },
      {
        "content": "t.datetime :${1:title}\n$0",
        "doc": "",
        "grammar": "snu",
        "label": "Create datetime column",
        "matches": {
          "tcdt": true
        },
        "options": {}
      },
      {
        "content": "t.decimal :${1:title}${2:${3:, precision: ${4:10}}${5:, scale: ${6:2}}}\n$0",
        "doc": "",
        "grammar": "snu",
        "label": "Create decimal column",
        "matches": {
          "tcd": true
        },
        "options": {}
      },
      {
        "content": "t.float :${1:title}\n$0",
        "doc": "",
        "grammar": "snu",
        "label": "Create float column",
        "matches": {
          "tcf": true
        },
        "options": {}
      },
      {
        "content": "require 'test_helper'\n\nclass ${1:Model}ControllerTest < ActionController::TestCase\n\ttest$0\nend\n",
        "doc": "",
        "grammar": "snu",
        "label": "Create functional test class",
        "matches": {
          "clact": true
        },
        "options": {}
      },
      {
        "content": "t.integer :${1:title}\n$0",
        "doc": "",
        "grammar": "snu",
        "label": "Create integer column",
        "matches": {
          "tci": true
        },
        "options": {}
      },
      {
        "content": "t.integer :lock_version, null: false, default: 0\n$0",
        "doc": "",
        "grammar": "snu",
        "label": "Create lock_version column",
        "matches": {
          "tcl": true
        },
        "options": {}
      },
      {
        "content": "t.references :${1:taggable}${2:, polymorphic: ${3:{ default: '${4:Photo}' }}}\n$0",
        "doc": "",
        "grammar": "snu",
        "label": "Create references column",
        "matches": {
          "tcr": true
        },
        "options": {}
      },
      {
        "content": "t.string :${1:title}\n$0",
        "doc": "",
        "grammar": "snu",
        "label": "Create string column",
        "matches": {
          "tcs": true
        },
        "options": {}
      },
      {
        "content": "t.text :${1:title}\n$0",
        "doc": "",
        "grammar": "snu",
        "label": "Create text column",
        "matches": {
          "tct": true
        },
        "options": {}
      },
      {
        "content": "t.time :${1:title}\n$0",
        "doc": "",
        "grammar": "snu",
        "label": "Create time column",
        "matches": {
          "tcti": true
        },
        "options": {}
      },
      {
        "content": "t.timestamp :${1:title}\n$0",
        "doc": "",
        "grammar": "snu",
        "label": "Create timestamp column",
        "matches": {
          "tcts": true
        },
        "options": {}
      },
      {
        "content": "t.timestamps\n$0",
        "doc": "",
        "grammar": "snu",
        "label": "Create timestamps columns",
        "matches": {
          "tctss": true
        },
        "options": {}
      },
      {
        "content": "t.column ${1:title}, :${2:string}\n$0",
        "doc": "",
        "grammar": "snu",
        "label": "Migration Create Column (mcc)",
        "matches": {
          "mcol": true
        },
        "options": {}
      },
      {
        "content": "t.column ${1:title}, :${2:string}\nmccc$0",
        "doc": "",
        "grammar": "snu",
        "label": "Migration Create Column Continue (mccc)",
        "matches": {
          "mccc": true
        },
        "options": {}
      },
      {
        "content": "drop_table :${1:table}${2: [press tab twice to generate create_table]}",
        "doc": "",
        "grammar": "snu",
        "label": "Migration Drop Create Table (mdct)",
        "matches": {
          "mtab": true
        },
        "options": {}
      },
      {
        "content": "remove_column :${1:table}, :${2:column}${3: [press tab twice to generate add_column]}",
        "doc": "",
        "grammar": "snu",
        "label": "Migration Remove and Add Column (mrac)",
        "matches": {
          "mcol": true
        },
        "options": {}
      },
      {
        "content": "RAILS_DEFAULT_LOGGER.debug \"${1:message}\"$0",
        "doc": "",
        "grammar": "snu",
        "label": "RAILS_DEFAULT_LOGGER.debug (rdb)",
        "matches": {
          "rdb": true
        },
        "options": {}
      },
      {
        "content": "t.rename(:${1:old_column_name}, :${2:new_column_name})\n$0",
        "doc": "",
        "grammar": "snu",
        "label": "Table column(s) rename",
        "matches": {
          "tre": true
        },
        "options": {}
      },
      {
        "content": "assert_redirected_to ${2:action: \"${1:index}\"}",
        "doc": "",
        "grammar": "snu",
        "label": "Test Assert Redirected To (art)",
        "matches": {
          "art": true
        },
        "options": {}
      },
      {
        "content": "assert_response :${1:success}, @response.body$0",
        "doc": "",
        "grammar": "snu",
        "label": "Test Assert Response (are)",
        "matches": {
          "asre": true
        },
        "options": {}
      },
      {
        "content": "after_create $0",
        "doc": "",
        "grammar": "snu",
        "label": "after_create",
        "matches": {
          "aftc": true
        },
        "options": {}
      },
      {
        "content": "after_destroy $0",
        "doc": "",
        "grammar": "snu",
        "label": "after_destroy",
        "matches": {
          "aftd": true
        },
        "options": {}
      },
      {
        "content": "after_save $0",
        "doc": "",
        "grammar": "snu",
        "label": "after_save",
        "matches": {
          "afts": true
        },
        "options": {}
      },
      {
        "content": "after_update $0",
        "doc": "",
        "grammar": "snu",
        "label": "after_update",
        "matches": {
          "aftu": true
        },
        "options": {}
      },
      {
        "content": "after_validation $0",
        "doc": "",
        "grammar": "snu",
        "label": "after_validation",
        "matches": {
          "aftv": true
        },
        "options": {}
      },
      {
        "content": "after_validation_on_create $0",
        "doc": "",
        "grammar": "snu",
        "label": "after_validation_on_create",
        "matches": {
          "aftvoc": true
        },
        "options": {}
      },
      {
        "content": "after_validation_on_update $0",
        "doc": "",
        "grammar": "snu",
        "label": "after_validation_on_update",
        "matches": {
          "aftvou": true
        },
        "options": {}
      },
      {
        "content": "assert(${1:var} = assigns(:$1), \"Cannot find @$1\")\n$0",
        "doc": "",
        "grammar": "snu",
        "label": "assert(var = assigns(:var))",
        "matches": {
          "asg": true
        },
        "options": {}
      },
      {
        "content": "assert_difference \"${1:Model}.${2:count}\", ${3:1} do\n\t$0\nend",
        "doc": "",
        "grammar": "snu",
        "label": "assert_difference",
        "matches": {
          "asd": true
        },
        "options": {}
      },
      {
        "content": "assert_no_difference \"${1:Model}.${2:count}\" do\n\t$0\nend",
        "doc": "",
        "grammar": "snu",
        "label": "assert_no_difference",
        "matches": {
          "asnd": true
        },
        "options": {}
      },
      {
        "content": "assert_redirected_to ${10:${2:parent}_${3:child}_path(${4:@}${5:$2})}",
        "doc": "",
        "grammar": "snu",
        "label": "assert_redirected_to (nested path plural)",
        "matches": {
          "artnpp": true
        },
        "options": {}
      },
      {
        "content": "assert_redirected_to ${2:${12:parent}_${13:child}_path(${14:@}${15:$12}, ${16:@}${17:$13})}",
        "doc": "",
        "grammar": "snu",
        "label": "assert_redirected_to (nested path)",
        "matches": {
          "artnp": true
        },
        "options": {}
      },
      {
        "content": "assert_redirected_to ${10:${2:model}s_path}",
        "doc": "",
        "grammar": "snu",
        "label": "assert_redirected_to (path plural)",
        "matches": {
          "artpp": true
        },
        "options": {}
      },
      {
        "content": "assert_redirected_to ${2:${12:model}_path(${13:@}${14:$12})}",
        "doc": "",
        "grammar": "snu",
        "label": "assert_redirected_to (path)",
        "matches": {
          "artp": true
        },
        "options": {}
      },
      {
        "content": "assert_rjs :${1:replace}, ${2:\"${3:dom id}\"}",
        "doc": "",
        "grammar": "snu",
        "label": "assert_rjs",
        "matches": {
          "asrj": true
        },
        "options": {}
      },
      {
        "content": "assert_select '${1:path}'${2:, ${3:text}: ${4:'${5:inner_html}'}}${6: do\n\t$0\nend}",
        "doc": "",
        "grammar": "snu",
        "label": "assert_select",
        "matches": {
          "ass": true
        },
        "options": {}
      },
      {
        "content": "before_create $0",
        "doc": "",
        "grammar": "snu",
        "label": "before_create",
        "matches": {
          "befc": true
        },
        "options": {}
      },
      {
        "content": "before_destroy $0",
        "doc": "",
        "grammar": "snu",
        "label": "before_destroy",
        "matches": {
          "befd": true
        },
        "options": {}
      },
      {
        "content": "before_save $0",
        "doc": "",
        "grammar": "snu",
        "label": "before_save",
        "matches": {
          "befs": true
        },
        "options": {}
      },
      {
        "content": "before_update $0",
        "doc": "",
        "grammar": "snu",
        "label": "before_update",
        "matches": {
          "befu": true
        },
        "options": {}
      },
      {
        "content": "before_validation $0",
        "doc": "",
        "grammar": "snu",
        "label": "before_validation",
        "matches": {
          "befv": true
        },
        "options": {}
      },
      {
        "content": "before_validation_on_create $0",
        "doc": "",
        "grammar": "snu",
        "label": "before_validation_on_create",
        "matches": {
          "befvoc": true
        },
        "options": {}
      },
      {
        "content": "before_validation_on_update",
        "doc": "",
        "grammar": "snu",
        "label": "before_validation_on_update",
        "matches": {
          "befvou": true
        },
        "options": {}
      },
      {
        "content": "cattr_accessor :${0:attr_names}",
        "doc": "",
        "grammar": "snu",
        "label": "cattr_accessor",
        "matches": {
          "crw": true
        },
        "options": {}
      },
      {
        "content": "test \"${1:something interesting}\" do\n\t$0\nend",
        "doc": "",
        "grammar": "snu",
        "label": "test do..end",
        "matches": {
          "test": true
        },
        "options": {}
      },
      {
        "content": "def test_should_get_${1:action}\n\t${2:@${3:model} = ${4:$3s}(:${5:fixture_name})\n\t}get :$1${6:, id: @$3.to_param}\n\tassert_response :success\n\t$0\nend",
        "doc": "",
        "grammar": "snu",
        "label": "def get request",
        "matches": {
          "deftg": true
        },
        "options": {}
      },
      {
        "content": "def test_should_post_${1:action}\n\t${3:@$2 = ${4:$2s}(:${5:fixture_name})\n\t}post :$1${6:, id: @$2.to_param}, ${2:model}: { $0 }\n\tassert_response :redirect\n\nend",
        "doc": "",
        "grammar": "snu",
        "label": "def post request",
        "matches": {
          "deftp": true
        },
        "options": {}
      },
      {
        "content": "find(:all${1:, conditions: ['${2:${3:field} = ?}', ${5:true}]})",
        "doc": "",
        "grammar": "snu",
        "label": "find(:all)",
        "matches": {
          "fina": true
        },
        "options": {}
      },
      {
        "content": "find(:first${1:, conditions: ['${2:${3:field} = ?}', ${5:true}]})",
        "doc": "",
        "grammar": "snu",
        "label": "find(:first)",
        "matches": {
          "finf": true
        },
        "options": {}
      },
      {
        "content": "find(${1:id})",
        "doc": "",
        "grammar": "snu",
        "label": "find(id)",
        "matches": {
          "fini": true
        },
        "options": {}
      },
      {
        "content": "has_and_belongs_to_many :${1:object}${2:, join_table: \"${3:table_name}\", foreign_key: \"${4:$1_id}\"}",
        "doc": "",
        "grammar": "snu",
        "label": "has_and_belongs_to_many (habtm)",
        "matches": {
          "habtm": true
        },
        "options": {}
      },
      {
        "content": "has_many :${1:object}s${2:, class_name: \"$1\", foreign_key: \"${4:reference}_id\"}",
        "doc": "",
        "grammar": "snu",
        "label": "has_many (hm)",
        "matches": {
          "hm": true
        },
        "options": {}
      },
      {
        "content": "has_many :${1:objects}, through: :${2:join_association}${3:, source: :${4:$2_table_foreign_key_to_$1_table}}",
        "doc": "",
        "grammar": "snu",
        "label": "has_many (through)",
        "matches": {
          "hmt": true
        },
        "options": {}
      },
      {
        "content": "has_many :${1:object}s${2:, class_name: \"$1\", foreign_key: \"${4:reference}_id\"}, dependent: :destroy$0",
        "doc": "",
        "grammar": "snu",
        "label": "has_many dependent: :destroy",
        "matches": {
          "hmd": true
        },
        "options": {}
      },
      {
        "content": "${1:Rails.}logger.debug { \"${1:message}\" }$0",
        "doc": "",
        "grammar": "snu",
        "label": "logger.debug",
        "matches": {
          "logd": true
        },
        "options": {}
      },
      {
        "content": "logger.error { \"${1:message}\" }$0",
        "doc": "",
        "grammar": "snu",
        "label": "logger.error",
        "matches": {
          "loge": true
        },
        "options": {}
      },
      {
        "content": "logger.fatal { \"${1:message}\" }$0",
        "doc": "",
        "grammar": "snu",
        "label": "logger.fatal",
        "matches": {
          "logf": true
        },
        "options": {}
      },
      {
        "content": "logger.info { \"${1:message}\" }$0",
        "doc": "",
        "grammar": "snu",
        "label": "logger.info",
        "matches": {
          "logi": true
        },
        "options": {}
      },
      {
        "content": "logger.warn { \"${1:message}\" }$0",
        "doc": "",
        "grammar": "snu",
        "label": "logger.warn",
        "matches": {
          "logw": true
        },
        "options": {}
      },
      {
        "content": "map(&:${1:id})",
        "doc": "",
        "grammar": "snu",
        "label": "map(&:sym_proc)",
        "matches": {
          "mp": true
        },
        "options": {}
      },
      {
        "content": "${1:map}.catch_all \"*${2:anything}\", controller: \"${3:default}\", action: \"${4:error}\"\n",
        "doc": "",
        "grammar": "snu",
        "label": "map.catch_all",
        "matches": {
          "mapca": true
        },
        "options": {}
      },
      {
        "content": "${1:map}.${2:connect} '${3::controller/:action/:id}'",
        "doc": "",
        "grammar": "snu",
        "label": "map.named_route",
        "matches": {
          "map": true
        },
        "options": {}
      },
      {
        "content": "${1:map}.resource :${2:resource}${10: do |${11:$2}|\n\t$0\nend}",
        "doc": "",
        "grammar": "snu",
        "label": "map.resource",
        "matches": {
          "mapr": true
        },
        "options": {}
      },
      {
        "content": "${1:map}.resources :${2:resource}${10: do |${11:$2}|\n\t$0\nend}",
        "doc": "",
        "grammar": "snu",
        "label": "map.resources",
        "matches": {
          "maprs": true
        },
        "options": {}
      },
      {
        "content": "mattr_accessor :${0:attr_names}",
        "doc": "",
        "grammar": "snu",
        "label": "mattr_accessor",
        "matches": {
          "mrw": true
        },
        "options": {}
      },
      {
        "content": "named_scope :name${1:, joins: :${2:table}}, conditions: ${3:['${4:${5:field} = ?}', ${6:true}]}\n",
        "doc": "",
        "grammar": "snu",
        "label": "named_scope",
        "matches": {
          "nc": true
        },
        "options": {}
      },
      {
        "content": "default_scope ${1:order(${2:'${3:created_at DESC}'})}",
        "doc": "",
        "grammar": "snu",
        "label": "default_scope",
        "matches": {
          "dscope": true
        },
        "options": {}
      },
      {
        "content": "flash[:${1:notice}] = \"${2:Successfully created...}\"$0",
        "doc": "",
        "grammar": "snu",
        "label": "flash[...]",
        "matches": {
          "flash": true
        },
        "options": {}
      },
      {
        "content": "redirect_to action: \"${1:index}\"",
        "doc": "",
        "grammar": "snu",
        "label": "redirect_to (action)",
        "matches": {
          "rea": true
        },
        "options": {}
      },
      {
        "content": "redirect_to action: \"${1:show}\", id: ${0:@item}",
        "doc": "",
        "grammar": "snu",
        "label": "redirect_to (action, id)",
        "matches": {
          "reai": true
        },
        "options": {}
      },
      {
        "content": "redirect_to controller: \"${1:items}\"",
        "doc": "",
        "grammar": "snu",
        "label": "redirect_to (controller)",
        "matches": {
          "rec": true
        },
        "options": {}
      },
      {
        "content": "redirect_to controller: \"${1:items}\", action: \"${2:list}\"",
        "doc": "",
        "grammar": "snu",
        "label": "redirect_to (controller, action)",
        "matches": {
          "reca": true
        },
        "options": {}
      },
      {
        "content": "redirect_to controller: \"${1:items}\", action: \"${2:show}\", id: ${0:@item}",
        "doc": "",
        "grammar": "snu",
        "label": "redirect_to (controller, action, id)",
        "matches": {
          "recai": true
        },
        "options": {}
      },
      {
        "content": "redirect_to(${2:${10:parent}_${11:child}_path(${12:@}${13:$10})})",
        "doc": "",
        "grammar": "snu",
        "label": "redirect_to (nested path plural)",
        "matches": {
          "renpp": true
        },
        "options": {}
      },
      {
        "content": "redirect_to(${2:${12:parent}_${13:child}_path(${14:@}${15:$12}, ${16:@}${17:$13})})",
        "doc": "",
        "grammar": "snu",
        "label": "redirect_to (nested path)",
        "matches": {
          "renp": true
        },
        "options": {}
      },
      {
        "content": "redirect_to(${2:${10:model}s_path})",
        "doc": "",
        "grammar": "snu",
        "label": "redirect_to (path plural)",
        "matches": {
          "repp": true
        },
        "options": {}
      },
      {
        "content": "redirect_to(${2:${12:model}_path(${13:@}${14:$12})})",
        "doc": "",
        "grammar": "snu",
        "label": "redirect_to (path)",
        "matches": {
          "rep": true
        },
        "options": {}
      },
      {
        "content": "redirect_to :back",
        "doc": "",
        "grammar": "snu",
        "label": "redirect_to :back",
        "matches": {
          "reb": true
        },
        "options": {}
      },
      {
        "content": "render action: \"${1:action}\"",
        "doc": "",
        "grammar": "snu",
        "label": "render (action)... (ra)",
        "matches": {
          "ra": true
        },
        "options": {}
      },
      {
        "content": "render action: \"${1:action}\", layout: \"${2:layoutname}\"",
        "doc": "",
        "grammar": "snu",
        "label": "render (action,layout) (ral)",
        "matches": {
          "ral": true
        },
        "options": {}
      },
      {
        "content": "render file: \"${1:filepath}\"",
        "doc": "",
        "grammar": "snu",
        "label": "render (file) (rf)",
        "matches": {
          "rf": true
        },
        "options": {}
      },
      {
        "content": "render file: \"${1:filepath}\", use_full_path: ${2:false}",
        "doc": "",
        "grammar": "snu",
        "label": "render (file,use_full_path) (rfu)",
        "matches": {
          "rfu": true
        },
        "options": {}
      },
      {
        "content": "render inline: \"${1:<%= 'hello' %>}\"",
        "doc": "",
        "grammar": "snu",
        "label": "render (inline) (ri)",
        "matches": {
          "ri": true
        },
        "options": {}
      },
      {
        "content": "render inline: \"${1:<%= 'hello' %>}\", locals { ${2::name}: \"${3:value}\"$4 }",
        "doc": "",
        "grammar": "snu",
        "label": "render (inline,locals) (ril)",
        "matches": {
          "ril": true
        },
        "options": {}
      },
      {
        "content": "render inline: \"${1:<%= 'hello' %>}\", type: ${2::rjson}",
        "doc": "",
        "grammar": "snu",
        "label": "render (inline,type) (rit)",
        "matches": {
          "rit": true
        },
        "options": {}
      },
      {
        "content": "render layout: \"${1:layoutname}\"",
        "doc": "",
        "grammar": "snu",
        "label": "render (layout) (rl)",
        "matches": {
          "rl": true
        },
        "options": {}
      },
      {
        "content": "render nothing: ${1:true}",
        "doc": "",
        "grammar": "snu",
        "label": "render (nothing) (rn)",
        "matches": {
          "rn": true
        },
        "options": {}
      },
      {
        "content": "render nothing: ${1:true}, status: ${2:401}",
        "doc": "",
        "grammar": "snu",
        "label": "render (nothing,status) (rns)",
        "matches": {
          "rns": true
        },
        "options": {}
      },
      {
        "content": "render text: \"${1:text to render...}\"",
        "doc": "",
        "grammar": "snu",
        "label": "render (text) (rt)",
        "matches": {
          "rt": true
        },
        "options": {}
      },
      {
        "content": "render text: \"${1:text to render...}\", layout: \"${2:layoutname}\"",
        "doc": "",
        "grammar": "snu",
        "label": "render (text,layout) (rtl)",
        "matches": {
          "rtl": true
        },
        "options": {}
      },
      {
        "content": "render text: \"${1:text to render...}\", layout: ${2:true}",
        "doc": "",
        "grammar": "snu",
        "label": "render (text,layout => true) (rtlt)",
        "matches": {
          "rtlt": true
        },
        "options": {}
      },
      {
        "content": "render text: \"${1:text to render...}\", status: ${2:401}",
        "doc": "",
        "grammar": "snu",
        "label": "render (text,status) (rts)",
        "matches": {
          "rts": true
        },
        "options": {}
      },
      {
        "content": "render :update do |${2:page}|\n\t$2.$0\nend",
        "doc": "",
        "grammar": "snu",
        "label": "render (update)",
        "matches": {
          "ru": true
        },
        "options": {}
      },
      {
        "content": "respond_to do |wants|\n\twants.${1:html}${2: { $0 }}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "respond_to",
        "matches": {
          "rest": true
        },
        "options": {}
      },
      {
        "content": "t.binary :${1:title}${2:, limit: ${3:2}.megabytes}\nt.$0",
        "doc": "",
        "grammar": "snu",
        "label": "t.binary (tcbi)",
        "matches": {
          "t.": true
        },
        "options": {}
      },
      {
        "content": "t.boolean :${1:title}\nt.$0",
        "doc": "",
        "grammar": "snu",
        "label": "t.boolean (tcb)",
        "matches": {
          "t.": true
        },
        "options": {}
      },
      {
        "content": "t.date :${1:title}\nt.$0",
        "doc": "",
        "grammar": "snu",
        "label": "t.date (tcda)",
        "matches": {
          "t.": true
        },
        "options": {}
      },
      {
        "content": "t.datetime :${1:title}\nt.$0",
        "doc": "",
        "grammar": "snu",
        "label": "t.datetime (tcdt)",
        "matches": {
          "t.": true
        },
        "options": {}
      },
      {
        "content": "t.decimal :${1:title}${2:${3:, precision: ${4:10}}${5:, scale: ${6:2}}}\nt.$0",
        "doc": "",
        "grammar": "snu",
        "label": "t.decimal (tcd)",
        "matches": {
          "t.": true
        },
        "options": {}
      },
      {
        "content": "t.float :${1:title}\nt.$0",
        "doc": "",
        "grammar": "snu",
        "label": "t.float (tcf)",
        "matches": {
          "t.": true
        },
        "options": {}
      },
      {
        "content": "t.integer :${1:title}\nt.$0",
        "doc": "",
        "grammar": "snu",
        "label": "t.integer (tci)",
        "matches": {
          "t.": true
        },
        "options": {}
      },
      {
        "content": "t.integer :lock_version, null: false, default: 0\nt.$0",
        "doc": "",
        "grammar": "snu",
        "label": "t.lock_version (tcl)",
        "matches": {
          "t.": true
        },
        "options": {}
      },
      {
        "content": "t.references :${1:taggable}${2:, polymorphic: ${3:{ default: '${4:Photo}' }}}\nt.$0",
        "doc": "",
        "grammar": "snu",
        "label": "t.references (tcr)",
        "matches": {
          "t.": true
        },
        "options": {}
      },
      {
        "content": "t.rename(:${1:old_column_name}, :${2:new_column_name})\nt.$0",
        "doc": "",
        "grammar": "snu",
        "label": "t.rename (tre)",
        "matches": {
          "t.": true
        },
        "options": {}
      },
      {
        "content": "t.string :${1:title}\nt.$0",
        "doc": "",
        "grammar": "snu",
        "label": "t.string (tcs)",
        "matches": {
          "t.": true
        },
        "options": {}
      },
      {
        "content": "t.text :${1:title}\nt.$0",
        "doc": "",
        "grammar": "snu",
        "label": "t.text (tct)",
        "matches": {
          "t.": true
        },
        "options": {}
      },
      {
        "content": "t.time :${1:title}\nt.$0",
        "doc": "",
        "grammar": "snu",
        "label": "t.time (tcti)",
        "matches": {
          "t.": true
        },
        "options": {}
      },
      {
        "content": "t.timestamp :${1:title}\nt.$0",
        "doc": "",
        "grammar": "snu",
        "label": "t.timestamp (tcts)",
        "matches": {
          "t.": true
        },
        "options": {}
      },
      {
        "content": "t.timestamps\nt.$0",
        "doc": "",
        "grammar": "snu",
        "label": "t.timestamps (tctss)",
        "matches": {
          "t.": true
        },
        "options": {}
      },
      {
        "content": "validates_acceptance_of :${1:terms}${2:${3:, accept: \"${4:1}\"}${5:, message: \"${6:You must accept the terms of service}\"}}, if: proc { |obj| ${7:obj.condition?} }}",
        "doc": "",
        "grammar": "snu",
        "label": "validates_acceptance_of if",
        "matches": {
          "vaoif": true
        },
        "options": {}
      },
      {
        "content": "validates :${1:terms}${2:, acceptance: ${3:{ accept: \"${4:1}\"${5:, message: \"${6:You must accept the terms of service}\"}}} }",
        "doc": "",
        "grammar": "snu",
        "label": "validates_acceptance_of",
        "matches": {
          "vao": true
        },
        "options": {}
      },
      {
        "content": "validates_associated :${1:attribute}${2:, on: :${3:create}}",
        "doc": "",
        "grammar": "snu",
        "label": "validates_associated (va)",
        "matches": {
          "va": true
        },
        "options": {}
      },
      {
        "content": "validates_associated :${1:attribute}${2:, on: :${3:create}, if: proc { |obj| ${5:obj.condition?} }}",
        "doc": "",
        "grammar": "snu",
        "label": "validates_associated if (vaif)",
        "matches": {
          "vaif": true
        },
        "options": {}
      },
      {
        "content": "validates_confirmation_of :${1:attribute}${2:, on: :${3:create}, message: \"${4:should match confirmation}\"}",
        "doc": "",
        "grammar": "snu",
        "label": "validates_confirmation_of (vc)",
        "matches": {
          "vc": true
        },
        "options": {}
      },
      {
        "content": "validates_confirmation_of :${1:attribute}${2:, on: :${3:create}, message: \"${4:should match confirmation}\", if: proc { |obj| ${5:obj.condition?} }}",
        "doc": "",
        "grammar": "snu",
        "label": "validates_confirmation_of if (vcif)",
        "matches": {
          "vcif": true
        },
        "options": {}
      },
      {
        "content": "validates_exclusion_of :${1:attribute}${2:, in: ${3:%w( ${4:mov avi} )}, on: :${5:create}, message: \"${6:extension %s is not allowed}\"}",
        "doc": "",
        "grammar": "snu",
        "label": "validates_exclusion_of (ve)",
        "matches": {
          "ve": true
        },
        "options": {}
      },
      {
        "content": "validates_exclusion_of :${1:attribute}${2:, in: ${3:%w( ${4:mov avi} )}, on: :${5:create}, message: \"${6:extension %s is not allowed}\"}, if: proc { |obj| ${7:obj.condition?} }}",
        "doc": "",
        "grammar": "snu",
        "label": "validates_exclusion_of if (veif)",
        "matches": {
          "veif": true
        },
        "options": {}
      },
      {
        "content": "validates_format_of :${1:attribute}, with: /${2:^[${3:\\w\\d}]+\\$}/${4:, on: :${5:create}, message: \"${6:is invalid}\"}, if: proc { |obj| ${7:obj.condition?} }}",
        "doc": "",
        "grammar": "snu",
        "label": "validates_format_of if",
        "matches": {
          "vfif": true
        },
        "options": {}
      },
      {
        "content": "validates_format_of :${1:attribute}, with: /${2:^[${3:\\w\\d}]+\\$}/${4:, on: :${5:create}, message: \"${6:is invalid}\"}",
        "doc": "",
        "grammar": "snu",
        "label": "validates_format_of",
        "matches": {
          "vf": true
        },
        "options": {}
      },
      {
        "content": "validates_inclusion_of :${1:attribute}${2:, in: ${3:%w( ${4:mov avi} )}, on: :${5:create}, message: \"${6:extension %s is not included in the list}\"}, if: proc { |obj| ${7:obj.condition?} }}",
        "doc": "",
        "grammar": "snu",
        "label": "validates_inclusion_of if",
        "matches": {
          "viif": true
        },
        "options": {}
      },
      {
        "content": "validates_inclusion_of :${1:attribute}${2:, in: ${3:%w( ${4:mov avi} )}, on: :${5:create}, message: \"${6:extension %s is not included in the list}\"}",
        "doc": "",
        "grammar": "snu",
        "label": "validates_inclusion_of",
        "matches": {
          "vi": true
        },
        "options": {}
      },
      {
        "content": "validates_length_of :${1:attribute}, within: ${2:3..20}${3:, on: :${4:create}, message: \"${5:must be present}\"}",
        "doc": "",
        "grammar": "snu",
        "label": "validates_length_of (vl)",
        "matches": {
          "vl": true
        },
        "options": {}
      },
      {
        "content": "validates_length_of :${1:attribute}, within: ${2:3..20}${3:, on: :${4:create}, message: \"${5:must be present}\"}, if: proc { |obj| ${6:obj.condition?} }}",
        "doc": "",
        "grammar": "snu",
        "label": "validates_length_of if",
        "matches": {
          "vlif": true
        },
        "options": {}
      },
      {
        "content": "validates_numericality_of :${1:attribute}${2:, on: :${3:create}, message: \"${4:is not a number}\"}, if: proc { |obj| ${5:obj.condition?} }}",
        "doc": "",
        "grammar": "snu",
        "label": "validates_numericality_of if",
        "matches": {
          "vnif": true
        },
        "options": {}
      },
      {
        "content": "validates_numericality_of :${1:attribute}${2:, on: :${3:create}, message: \"${4:is not a number}\"}",
        "doc": "",
        "grammar": "snu",
        "label": "validates_numericality_of",
        "matches": {
          "vn": true
        },
        "options": {}
      },
      {
        "content": "validates_presence_of :${1:attribute}${2:, on: :${3:create}, message: \"${4:can't be blank}\"}",
        "doc": "",
        "grammar": "snu",
        "label": "validates_presence_of (vp)",
        "matches": {
          "vp": true
        },
        "options": {}
      },
      {
        "content": "validates_presence_of :${1:attribute}${2:, on: :${3:create}, message: \"${4:can't be blank}\"}, if: proc { |obj| ${5:obj.condition?} }}",
        "doc": "",
        "grammar": "snu",
        "label": "validates_presence_of if (vpif) 2",
        "matches": {
          "vpif": true
        },
        "options": {}
      },
      {
        "content": "validates_uniqueness_of :${1:attribute}${2:, on: :${3:create}, message: \"${4:must be unique}\"}",
        "doc": "",
        "grammar": "snu",
        "label": "validates_uniqueness_of (vu)",
        "matches": {
          "vu": true
        },
        "options": {}
      },
      {
        "content": "validates_uniqueness_of :${1:attribute}${2:, on: :${3:create}, message: \"${4:must be unique}\", if: proc { |obj| ${6:obj.condition?} }}",
        "doc": "",
        "grammar": "snu",
        "label": "validates_uniqueness_of if (vuif)",
        "matches": {
          "vuif": true
        },
        "options": {}
      },
      {
        "content": "verify only: [:$1], method: :post, render {:status: 500, text: \"use HTTP-POST\"}\n",
        "doc": "",
        "grammar": "snu",
        "label": "verify -- render",
        "matches": {
          "verify": true
        },
        "options": {}
      },
      {
        "content": "verify only: [:$1], session: :user, params: :id, redirect_to {:action: '${2:index}'}\n",
        "doc": "",
        "grammar": "snu",
        "label": "verify -- redirect",
        "matches": {
          "verify": true
        },
        "options": {}
      },
      {
        "content": "wants.${1:js|json|html}${2: { $0 }}",
        "doc": "",
        "grammar": "snu",
        "label": "wants_format",
        "matches": {
          "wants": true
        },
        "options": {}
      },
      {
        "content": "xhr :delete, :${1:destroy}, id: ${2:1}$0",
        "doc": "",
        "grammar": "snu",
        "label": "xhr delete",
        "matches": {
          "xdelete": true
        },
        "options": {}
      },
      {
        "content": "xhr :get, :${1:show}${2:, id: ${3:1}}$0",
        "doc": "",
        "grammar": "snu",
        "label": "xhr get",
        "matches": {
          "xget": true
        },
        "options": {}
      },
      {
        "content": "xhr :post, :${1:create}, ${2:object}: { $3 }",
        "doc": "",
        "grammar": "snu",
        "label": "xhr post",
        "matches": {
          "xpost": true
        },
        "options": {}
      },
      {
        "content": "xhr :put, :${1:update}, id: ${2:1}, ${3:object}: { $4 }$0",
        "doc": "",
        "grammar": "snu",
        "label": "xhr put",
        "matches": {
          "xput": true
        },
        "options": {}
      },
      {
        "content": "collection do\n\t${1:get :${2:action}}\n\t${3:put :${4:action}}\n\t${5:post :${6:action}}\n\t${7:delete :${8:action}}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "collection routes",
        "matches": {
          "col": true
        },
        "options": {}
      },
      {
        "content": "format.${1:html|xml|json|js|any} { $0 }",
        "doc": "",
        "grammar": "snu",
        "label": "format (respond_with)",
        "matches": {
          "format": true
        },
        "options": {}
      },
      {
        "content": "gem '${1:name}'${2:${3:, \"${4:1.0}\"}${5:${6:, require: ${7:\"${8:$1}\"}}${9:, group: :${10:test}}}}",
        "doc": "",
        "grammar": "snu",
        "label": "gem",
        "matches": {
          "gem": true
        },
        "options": {}
      },
      {
        "content": "gem '${1:paperclip}', git: \"${2:git://github.com/thoughtbot/paperclip.git}\"${3:, branch: \"${4:rails3}\"}",
        "doc": "",
        "grammar": "snu",
        "label": "gem :git",
        "matches": {
          "gemg": true
        },
        "options": {}
      },
      {
        "content": "match '${1:${2::controller}${3:/${4::action}${5:/${6::id}${7:(.:format)}}}}'${8: '${9:$2}#${10:$4}'${11:, as: :${12:$10}}}",
        "doc": "",
        "grammar": "snu",
        "label": "match",
        "matches": {
          "match": true
        },
        "options": {}
      },
      {
        "content": "member do\n\t${1:get :${2:action}}\n\t${3:put :${4:action}}\n\t${5:post :${6:action}}\n\t${7:delete :${8:action}}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "member routes",
        "matches": {
          "member": true
        },
        "options": {}
      },
      {
        "content": "resources :${1:posts}${2: do\n\t$3\nend}",
        "doc": "",
        "grammar": "snu",
        "label": "resources",
        "matches": {
          "res": true
        },
        "options": {}
      },
      {
        "content": "scope :${1:name}, { ${2:joins(:${3:table}).}where(${4:'${5:$3.${6:field}} = ?', ${7:'${8:value}'}}) }",
        "doc": "",
        "grammar": "snu",
        "label": "scope",
        "matches": {
          "scope": true
        },
        "options": {}
      },
      {
        "content": "scope :${1:name}, lambda { |${2:param}| ${3:where(${4::${5:field}: ${6:\"${7:value}\"}})} }",
        "doc": "",
        "grammar": "snu",
        "label": "scope lambda",
        "matches": {
          "scopel": true
        },
        "options": {}
      },
      {
        "content": "scope :${1:name}, { ${2:where(${3::${4:field}: ${5:'${6:value}'}})} } do\n\tdef ${7:method_name}\n\t\t$0\n\tend\nend",
        "doc": "",
        "grammar": "snu",
        "label": "scope with extension",
        "matches": {
          "scopee": true
        },
        "options": {}
      },
      {
        "content": "scoped_by_${1:attribute}(${2:id})",
        "doc": "",
        "grammar": "snu",
        "label": "scoped_by",
        "matches": {
          "sb": true
        },
        "options": {}
      },
      {
        "content": "setup do\n\t$0\nend",
        "doc": "",
        "grammar": "snu",
        "label": "setup do..end",
        "matches": {
          "setup": true
        },
        "options": {}
      }
    ],
    "react": [
      {
        "content": "import React from 'react'\n",
        "doc": "import React",
        "grammar": "lsp",
        "label": "import-react",
        "matches": {
          "imr": true,
          "react import": true
        },
        "options": {}
      },
      {
        "content": "import React, { Component } from 'react'\n",
        "doc": "",
        "grammar": "lsp",
        "label": "import-react-component",
        "matches": {
          "imrc": true,
          "react import component": true
        },
        "options": {}
      },
      {
        "content": "import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\n",
        "doc": "",
        "grammar": "lsp",
        "label": "import-react-component-prop-types",
        "matches": {
          "imrcp": true,
          "react import component proptypes": true
        },
        "options": {}
      },
      {
        "content": "import React, { PureComponent } from 'react'\n",
        "doc": "",
        "grammar": "lsp",
        "label": "import-react-purecomponent",
        "matches": {
          "imrpc": true,
          "react import purecomponent": true
        },
        "options": {}
      },
      {
        "content": "import React, { PureComponent } from 'react'\nimport PropTypes from 'prop-types'\n",
        "doc": "",
        "grammar": "lsp",
        "label": "import-react-pure-component-prop-types",
        "matches": {
          "imrpcp": true,
          "react import purecomponent proptypes": true
        },
        "options": {}
      },
      {
        "content": "import React, { memo } from 'react'\n",
        "doc": "",
        "grammar": "lsp",
        "label": "import-react-memo",
        "matches": {
          "imrm": true,
          "react import memo": true
        },
        "options": {}
      },
      {
        "content": "import React, { memo } from 'react'\nimport PropTypes from 'prop-types'\n",
        "doc": "",
        "grammar": "lsp",
        "label": "import-react-memo-prop-types",
        "matches": {
          "imrmp": true,
          "react import memo proptypes": true
        },
        "options": {}
      },
      {
        "content": "import React, { useState } from 'react'\n",
        "doc": "",
        "grammar": "lsp",
        "label": "import-react-usestate",
        "matches": {
          "imrs": true,
          "react import usestate": true
        },
        "options": {}
      },
      {
        "content": "import React, { useState, useEffect } from 'react'\n",
        "doc": "",
        "grammar": "lsp",
        "label": "import-react-usestate-useeffect",
        "matches": {
          "imrse": true,
          "react import usestate useeffect": true
        },
        "options": {}
      },
      {
        "content": "constructor(props) {\n\tsuper(props)\n\n\tthis.state = {\n\t\t $0\n\t}\n}\n",
        "doc": "Adds a default constructor for it('', () => {})the class that contains props as arguments",
        "grammar": "lsp",
        "label": "react-class-constructor",
        "matches": {
          "rconst": true,
          "react class constructor": true
        },
        "options": {}
      },
      {
        "content": "state = {\n\t$1\n}\n",
        "doc": "Creates empty state object. To be used in a constructor.",
        "grammar": "lsp",
        "label": "react-empty-state",
        "matches": {
          "est": true,
          "react empty state": true
        },
        "options": {}
      },
      {
        "content": "componentWillMount() {\n\t$0\n}\n",
        "doc": "DEPRECATED!!!. Invoked once, both on the client and server, immediately before the initial rendering occurs",
        "grammar": "lsp",
        "label": "react-componentwillmount",
        "matches": {
          "cwm": true,
          "react componentwillmount": true
        },
        "options": {}
      },
      {
        "content": "componentDidMount() {\n\t$0\n}\n",
        "doc": "Invoked once, only on the client (not on the server), immediately after the initial rendering occurs.",
        "grammar": "lsp",
        "label": "react-componentdidmount",
        "matches": {
          "cdm": true,
          "react componentdidmount": true
        },
        "options": {}
      },
      {
        "content": "componentWillReceiveProps(nextProps) {\n\t$0\n}\n",
        "doc": "DEPRECATED!!!. Invoked when a component is receiving new props. This method is not called for the initial render.",
        "grammar": "lsp",
        "label": "react-componentwillreceiveprops",
        "matches": {
          "cwr": true,
          "react componentwillreceiveprops": true
        },
        "options": {}
      },
      {
        "content": "shouldComponentUpdate(nextProps, nextState) {\n\t$0\n}\n",
        "doc": "Invoked before rendering when new props or state are being received. ",
        "grammar": "lsp",
        "label": "react-shouldcomponentupdate",
        "matches": {
          "react shouldcomponentupdate": true,
          "scu": true
        },
        "options": {}
      },
      {
        "content": "componentWillUpdate(nextProps, nextState) {\n\t$0\n}\n",
        "doc": "DEPRECATED!!!. Invoked immediately before rendering when new props or state are being received.",
        "grammar": "lsp",
        "label": "react-componentwillupdate",
        "matches": {
          "cwup": true,
          "react componentwillupdate": true
        },
        "options": {}
      },
      {
        "content": "componentDidUpdate(prevProps, prevState) {\n\t$0\n}\n",
        "doc": "Invoked immediately after the component's updates are flushed to the DOM.",
        "grammar": "lsp",
        "label": "react-componentdidupdate",
        "matches": {
          "cdup": true,
          "react componentdidupdate": true
        },
        "options": {}
      },
      {
        "content": "componentWillUnmount() {\n\t$0\n}\n",
        "doc": "Invoked immediately before a component is unmounted from the DOM.",
        "grammar": "lsp",
        "label": "react-componentwillunmount",
        "matches": {
          "cwun": true,
          "react componentwillunmount": true
        },
        "options": {}
      },
      {
        "content": "static getDerivedStateFromProps(props, state) {\n\t${1}\n}",
        "doc": "Invoked right before calling the render method, both on the initial mount and on subsequent updates.",
        "grammar": "lsp",
        "label": "react-getderivedstatefromprops",
        "matches": {
          "gdsfp": true,
          "react getderivedstatefromprops": true
        },
        "options": {}
      },
      {
        "content": "getSnapshotBeforeUpdate = (prevProps, prevState) => {\n\t$0\n}\n",
        "doc": "Called right before mutations are made (e.g. before the DOM is updated)",
        "grammar": "lsp",
        "label": "react-getsnapshotbeforeupdate",
        "matches": {
          "gsbu": true,
          "react getsnapshotbeforeupdate": true
        },
        "options": {}
      },
      {
        "content": "render() {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}",
        "doc": "Basic render.",
        "grammar": "lsp",
        "label": "react-component-render",
        "matches": {
          "react component render": true,
          "ren": true
        },
        "options": {}
      },
      {
        "content": "const ${1:contextName} = React.createContext()\n",
        "doc": "Create React context",
        "grammar": "lsp",
        "label": "react-createcontext",
        "matches": {
          "rcontext": true,
          "react createcontext": true
        },
        "options": {}
      },
      {
        "content": "this.${1:refName}Ref = React.createRef()\n",
        "doc": "Create ref statement used inside constructor",
        "grammar": "lsp",
        "label": "react-createref",
        "matches": {
          "cref": true,
          "react createref": true
        },
        "options": {}
      },
      {
        "content": "const ref = React.createRef()\n",
        "doc": "Forward ref statement used inside component",
        "grammar": "lsp",
        "label": "react-forwardref",
        "matches": {
          "fref": true,
          "react forwardref": true
        },
        "options": {}
      },
      {
        "content": "this.setState({$0})",
        "doc": "Performs a shallow merge of nextState into current state",
        "grammar": "lsp",
        "label": "react-component-set-state-object",
        "matches": {
          "react componentsetstateobject": true,
          "sst": true
        },
        "options": {}
      },
      {
        "content": "this.setState((state, props) => { return { $0 }})\n",
        "doc": "Performs a shallow merge of nextState into current state",
        "grammar": "lsp",
        "label": "react-component-set-state-func",
        "matches": {
          "react component setstate func": true,
          "ssf": true
        },
        "options": {}
      },
      {
        "content": "this.props.$0",
        "doc": "Access component's props",
        "grammar": "lsp",
        "label": "react-component-props",
        "matches": {
          "props": true,
          "react component props": true
        },
        "options": {}
      },
      {
        "content": "this.state.$0",
        "doc": "",
        "grammar": "lsp",
        "label": "react-component-state",
        "matches": {
          "react component state": true,
          "state": true
        },
        "options": {}
      },
      {
        "content": "this.${1:methodName} = this.${1:methodName}.bind(this)$0",
        "doc": "Binds this to a method",
        "grammar": "lsp",
        "label": "react-bind-this",
        "matches": {
          "bnd": true,
          "react bind this": true
        },
        "options": {}
      },
      {
        "content": "import React from 'react'\nimport PropTypes from 'prop-types'\n\nexport default (WrappedComponent) => {\n\tconst hocComponent = ({ ...props }) => <WrappedComponent {...props} />\n\n\thocComponent.propTypes = {\n\t}\n\n\treturn hocComponent\n}\n",
        "doc": "",
        "grammar": "lsp",
        "label": "react-hoc",
        "matches": {
          "hoc": true,
          "react hoc": true
        },
        "options": {}
      },
      {
        "content": "useEffect(() => {\n\t${1:effect}\n\treturn () => {\n\t\t${2:cleanup}\n\t};\n}, [${3:input}])",
        "doc": "",
        "grammar": "lsp",
        "label": "react-useeffect",
        "matches": {
          "react useeffect": true,
          "useeffect": true
        },
        "options": {}
      },
      {
        "content": "const ${1:context} = useContext(${2:contextValue})",
        "doc": "",
        "grammar": "lsp",
        "label": "react-usecontext",
        "matches": {
          "react usecontext": true,
          "usecontext": true
        },
        "options": {}
      },
      {
        "content": "useCallback(\n\t() => {\n\t\t${1:callback}\n\t},\n\t[${2:input}],\n)",
        "doc": "",
        "grammar": "lsp",
        "label": "react-usecallback",
        "matches": {
          "react usecallback": true,
          "usecallback": true
        },
        "options": {}
      },
      {
        "content": "useMemo(() => ${1:function}, ${2:input})",
        "doc": "",
        "grammar": "lsp",
        "label": "react-usememo",
        "matches": {
          "react usememo": true,
          "usememo": true
        },
        "options": {}
      },
      {
        "content": "const ${1:ref} = useRef(${2:initialValue})",
        "doc": "",
        "grammar": "lsp",
        "label": "react-useref",
        "matches": {
          "react useref": true,
          "useref": true
        },
        "options": {}
      },
      {
        "content": "useImperativeHandle(\n\t${1:ref},\n\t() => {\n\t\t${2:handler}\n\t},\n\t[${3:input}],\n)",
        "doc": "",
        "grammar": "lsp",
        "label": "react-useimperativehandle",
        "matches": {
          "react useimperativehandle": true,
          "useimperativehandle": true
        },
        "options": {}
      },
      {
        "content": "useDebugValue(${1:value})",
        "doc": "",
        "grammar": "lsp",
        "label": "react-usedebugvalue",
        "matches": {
          "react usedebugvalue": true,
          "usedebugvalue": true
        },
        "options": {}
      },
      {
        "content": "useLayoutEffect(() => {\n\t${1:effect}\n\treturn () => {\n\t\t${2:cleanup}\n\t};\n}, [${3:input}])",
        "doc": "",
        "grammar": "lsp",
        "label": "react-uselayouteffect",
        "matches": {
          "react uselayouteffect": true,
          "uselayouteffect": true
        },
        "options": {}
      }
    ],
    "react-helmet": [
      {
        "content": "import { Helmet } from 'react-helmet';",
        "doc": "",
        "grammar": "lsp",
        "label": "react-helmet-import",
        "matches": {
          "react-helmet import": true
        },
        "options": {}
      },
      {
        "content": "<Helmet>\n  <title>${1:title}</title>\n</Helmet>",
        "doc": "",
        "grammar": "lsp",
        "label": "react-helmet-title",
        "matches": {
          "react-helmet title": true
        },
        "options": {}
      },
      {
        "content": "<Helmet>\n${1:example}\n</Helmet>",
        "doc": "",
        "grammar": "lsp",
        "label": "react-helmet-component",
        "matches": {
          "react-helmet component": true
        },
        "options": {}
      }
    ],
    "react-intersection-observer": [
      {
        "content": "const [ref, inView, entry] = useInView(options)",
        "doc": "The new React Hooks make it easier than ever to monitor the inView state of your components. Call the useInView hook with the (optional) options you need. It will return an array containing a ref, the inView status and the current IntersectionObserverEntry. Assign the ref to the DOM element you want to monitor, and the hook will report the status. \n\nOptions\nroot(type: Element, default: window, required: false)\nThe Element that is used as the viewport for checking visibility of the target. Defaults to the browser viewport (window) if not specified or if null.\n\nrootMargin(type: String, default: '0px', required: false)\nMargin around the root. Can have values similar to the CSS margin property.\n\nthreshold(type: Number, default: 0, required: false)\nNumber between 0 and 1 indicating the percentage that should be visible before triggering. Can also be an array of numbers, to create multiple trigger points.\n\ntriggerOnce(type: Boolean, default: false, required: false)\nOnly trigger this method once",
        "grammar": "lsp",
        "label": "react-intersection-observer-use-in-view",
        "matches": {
          "react-intersection-observer useinview": true,
          "rio useinview": true
        },
        "options": {}
      },
      {
        "content": "import { useInView } from 'react-intersection-observer';",
        "doc": "",
        "grammar": "lsp",
        "label": "react-intersection-observer-import",
        "matches": {
          "react-intersection-observer import": true,
          "rio import": true
        },
        "options": {}
      }
    ],
    "react-modal": [
      {
        "content": "import Modal from 'react-modal'",
        "doc": "import react-modal",
        "grammar": "lsp",
        "label": "react-modal-import",
        "matches": {
          "imrm": true,
          "react-modal import": true
        },
        "options": {}
      }
    ],
    "reason": [
      {
        "content": "/*\n\t${0}\n */",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "doc": true
        },
        "options": {}
      },
      {
        "content": "let ${1} = ${0};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "let": true
        },
        "options": {}
      },
      {
        "content": "let ${1} = (${2}) => {\n\t${0}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fn": true
        },
        "options": {}
      },
      {
        "content": "fun ${1} => ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fun": true
        },
        "options": {}
      },
      {
        "content": "type ${1} = ${0};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ty": true
        },
        "options": {}
      },
      {
        "content": "module ${1} = {\n\t${0}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mod": true
        },
        "options": {}
      },
      {
        "content": "module type ${1} = {\n\t${0}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "modty": true
        },
        "options": {}
      },
      {
        "content": "switch (${1}) {\n| ${2} => ${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sw": true
        },
        "options": {}
      },
      {
        "content": "| ${1} => ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "|": true
        },
        "options": {}
      },
      {
        "content": "|> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p": true
        },
        "options": {}
      },
      {
        "content": "if (${1}) {\n\t${2}\n} else {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      }
    ],
    "redux": [
      {
        "content": "import { connect } from 'react-redux'\n",
        "doc": "Import connect from Redux",
        "grammar": "lsp",
        "label": "redux-import-connect",
        "matches": {
          "redux import connect": true
        },
        "options": {}
      },
      {
        "content": "const mapStateToProps = (state) => ({\n\t${1}\n})\n\nconst mapDispatchToProps = {\n\t\n}\n",
        "doc": "Creates mapStateToProps function.",
        "grammar": "lsp",
        "label": "redux-map-to-props",
        "matches": {
          "redux map props": true
        },
        "options": {}
      },
      {
        "content": "export const ${1:constantName} = '${1:constantName}'",
        "doc": "",
        "grammar": "lsp",
        "label": "redux-const",
        "matches": {
          "redux const": true,
          "rxconst": true
        },
        "options": {}
      },
      {
        "content": "const initialState = {\n\n}\n\nexport default (state = initialState, { type, payload }) => {\n\tswitch (type) {\n\n\tcase ${1:typeName}:\n\t\treturn { ...state, ...payload }\n\n\tdefault:\n\t\treturn state\n\t}\n}\n",
        "doc": "Redux reducer template",
        "grammar": "lsp",
        "label": "redux-reducer",
        "matches": {
          "redux reducer": true,
          "rxreducer": true
        },
        "options": {}
      },
      {
        "content": "const ${1:actionCreatorName} = ${2:payload} => {\n  return {\n    type: '${3:ACTION_TYPE}',\n    payload: ${2:payload},\n  };\n};",
        "doc": "Redux action template",
        "grammar": "lsp",
        "label": "redux-action",
        "matches": {
          "redux action": true,
          "rxaction": true
        },
        "options": {}
      },
      {
        "content": "import { useSelector, useDispatch } from 'react-redux';",
        "doc": "Import Redux hooks (useSelector, useDispatch)",
        "grammar": "lsp",
        "label": "redux-import-hooks",
        "matches": {
          "irrh": true,
          "redux import hooks": true
        },
        "options": {}
      },
      {
        "content": "const $1 = useSelector(state => state.$1);",
        "doc": "Redux useSelector() hook",
        "grammar": "lsp",
        "label": "redux-useselector",
        "matches": {
          "redux useselector": true,
          "uss": true
        },
        "options": {}
      },
      {
        "content": "const dispatch = useDispatch();",
        "doc": "Redux useDispatch() hook",
        "grammar": "lsp",
        "label": "redux-usedispatch-hook",
        "matches": {
          "redux usedispatch": true,
          "rxusdh": true
        },
        "options": {}
      },
      {
        "content": "const $1 = $2 => dispatch($3);",
        "doc": "Redux dispatch hook",
        "grammar": "lsp",
        "label": "redux-dispatch-hook",
        "matches": {
          "redux dispatch": true,
          "rxd": true
        },
        "options": {}
      }
    ],
    "redux-thunk": [
      {
        "content": "import thunk from 'redux-thunk'",
        "doc": "Import thunk from redux-thunk",
        "grammar": "lsp",
        "label": "redux-thunk-import",
        "matches": {
          "redux-thunk import": true
        },
        "options": {}
      },
      {
        "content": "import { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport ${1:rootReducer} from '${1:./reducers/index}';\n\nconst store = createStore(\n  ${1:rootReducer},\n  applyMiddleware(thunk)\n);",
        "doc": "Create store with thunk template",
        "grammar": "lsp",
        "label": "redux-thunk-store",
        "matches": {
          "redux-thunk createstore": true
        },
        "options": {}
      }
    ],
    "requirejs_coffee": [
      {
        "content": "define [\"${1:#dependencies1}\"], (${2:#dependencies2}) ->\n\t${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "def": true
        },
        "options": {}
      },
      {
        "content": "define \"${1:#name}\", [\"${2:#dependencies1}\"], (${3:#dependencies2}) ->\n\t${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defn": true
        },
        "options": {}
      },
      {
        "content": "require [\"${1:#dependencies1}\"], (${2:#dependencies2}) ->\n\t${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "reqjs": true
        },
        "options": {}
      }
    ],
    "rmarkdown": [
      {
        "content": "**${1:${TM_SELECTED_TEXT}}**$0",
        "doc": "Insert bold text",
        "grammar": "lsp",
        "label": "Insert bold text",
        "matches": {
          "bold": true
        },
        "options": {}
      },
      {
        "content": "*${1:${TM_SELECTED_TEXT}}*$0",
        "doc": "Insert italic text",
        "grammar": "lsp",
        "label": "Insert italic text",
        "matches": {
          "italic": true
        },
        "options": {}
      },
      {
        "content": "> ${1:${TM_SELECTED_TEXT}}",
        "doc": "Insert quoted text",
        "grammar": "lsp",
        "label": "Insert quoted text",
        "matches": {
          "quote": true
        },
        "options": {}
      },
      {
        "content": "`${1:${TM_SELECTED_TEXT}}`$0",
        "doc": "Insert code",
        "grammar": "lsp",
        "label": "Insert code",
        "matches": {
          "code": true
        },
        "options": {}
      },
      {
        "content": "```${1:language}\n$0\n```",
        "doc": "Insert fenced code block",
        "grammar": "lsp",
        "label": "Insert fenced code block",
        "matches": {
          "fenced codeblock": true
        },
        "options": {}
      },
      {
        "content": "# ${1:text}",
        "doc": "Insert heading",
        "grammar": "lsp",
        "label": "Insert heading",
        "matches": {
          "heading": true
        },
        "options": {}
      },
      {
        "content": "- ${1:first}\n- ${2:second}\n- ${3:third}\n$0",
        "doc": "Insert unordered list",
        "grammar": "lsp",
        "label": "Insert unordered list",
        "matches": {
          "unordered list": true
        },
        "options": {}
      },
      {
        "content": "1. ${1:first}\n2. ${2:second}\n3. ${3:third}\n$0",
        "doc": "Insert ordered list",
        "grammar": "lsp",
        "label": "Insert ordered list",
        "matches": {
          "ordered list": true
        },
        "options": {}
      },
      {
        "content": "----------\n",
        "doc": "Insert horizontal rule",
        "grammar": "lsp",
        "label": "Insert horizontal rule",
        "matches": {
          "horizontal rule": true
        },
        "options": {}
      },
      {
        "content": "[${1:text}](http://${2:link})$0",
        "doc": "Insert link",
        "grammar": "lsp",
        "label": "Insert link",
        "matches": {
          "link": true
        },
        "options": {}
      },
      {
        "content": "![${1:alt}](http://${2:link})$0",
        "doc": "Insert image",
        "grammar": "lsp",
        "label": "Insert image",
        "matches": {
          "image": true
        },
        "options": {}
      },
      {
        "content": "```{${1:language}}\n$0\n```",
        "doc": "Insert code chunk",
        "grammar": "lsp",
        "label": "Insert code chunk",
        "matches": {
          "code chunk": true
        },
        "options": {}
      },
      {
        "content": "```{r}\n$0\n```",
        "doc": "Insert R code chunk",
        "grammar": "lsp",
        "label": "Insert R code chunk",
        "matches": {
          "r code chunk": true
        },
        "options": {}
      }
    ],
    "rmd": [
      {
        "content": "${1:term}\n  ~  ${2:definition}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "::": true
        },
        "options": {}
      },
      {
        "content": "[${1:link}](http://${2:url} \"${3:title}\")${4}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "[": true
        },
        "options": {}
      },
      {
        "content": "[${1:id}]: http://${2:url} \"${3:title}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "[:": true
        },
        "options": {}
      },
      {
        "content": "[${1:link}](mailto:${2:email})${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "[@": true
        },
        "options": {}
      },
      {
        "content": "[${1:id}]: mailto:${2:email} \"${3:title}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "[:@": true
        },
        "options": {}
      },
      {
        "content": "![${1:alt}](${2:url} \"${3:title}\")${4}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "![": true
        },
        "options": {}
      },
      {
        "content": "![${1:id}]: ${2:url} \"${3:title}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "![:": true
        },
        "options": {}
      },
      {
        "content": "[^${1:id}]: ${2:note}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "[^:": true
        },
        "options": {}
      },
      {
        "content": "require(${1:}, quietly = TRUE)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "req": true
        },
        "options": {}
      },
      {
        "content": "if ( ${1:condition} )\n{\n\t${2:}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "else\n{\n\t${1:}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "el": true
        },
        "options": {}
      },
      {
        "content": "${1:funname} <- \t\t\t# ${2:}\n\tfunction\n(\n \t${3:}\n)\n{\n  ${4:}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fun": true
        },
        "options": {}
      },
      {
        "content": "repeat{\n  ${2:}\n  if(${1:condition}) break\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "re": true
        },
        "options": {}
      },
      {
        "content": "matrix(NA, nrow = ${1:}, ncol = ${2:})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ma": true
        },
        "options": {}
      },
      {
        "content": "data.frame(${1:}, header = TRUE)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "df": true
        },
        "options": {}
      },
      {
        "content": "args <- commandArgs(TRUE)\nif (length(args) == 0)\n    stop(\"Please give ${1:}!\")\nif (!all(file.exists(args)))\n     stop(\"Couln't find input files!\")",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cmdarg": true
        },
        "options": {}
      },
      {
        "content": "require('getopt', quietly = TRUE)\nopt_spec <- matrix(c(\n\t\t\t\t'help',     'h', 0, \"logical\", \t\"Getting help\",\n\t\t\t\t'file',     'f', 1, \"character\",\"File to process\"\n                ), ncol = 5, byrow = TRUE)\nopt <- getopt(spec = opt_spec)\nif ( !is.null(opt$help) || is.null(commandArgs()) )   {\n    cat(getopt(spec = opt_spec, usage = TRUE, command = \"yourCmd\"))\n    q(status=0)\n}\n# some inital value\nif ( is.null(opt$???) )    { opt$??? <- ??? }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "getopt": true
        },
        "options": {}
      },
      {
        "content": "require(\"optparse\", quietly = TRUE)\noption_list <-\n    list(make_option(c(\"-n\", \"--add_numbers\"), action=\"store_true\", default=FALSE,\n                     help=\"Print line number at the beginning of each line [default]\")\n         )\nparser <- OptionParser(usage = \"%prog [options] file\", option_list=option_list)\narguments <- parse_args(parser, positional_arguments = TRUE)\nopt <- arguments$options\nif(length(arguments$args) != 1) {\n    cat(\"Incorrect number of required positional arguments\\n\\n\")\n    print_help(parser)\n    stop()\n} else {\n    file <- arguments$args\n}\nif( file.access(file) == -1) {\n    stop(sprintf(\"Specified file ( %s ) does not exist\", file))\n} else {\n    file_text <- readLines(file)\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "optparse": true
        },
        "options": {}
      },
      {
        "content": "#!/usr/bin/env Rscript",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#!": true
        },
        "options": {}
      },
      {
        "content": "# Development & Debugging, don't forget to uncomment afterwards!\n#--------------------------------------------------------------------------------\n#setwd(\"~/Projekte/${1:}\")\n#opt <- list(${2:}\n#            )\n#--------------------------------------------------------------------------------",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "debug": true
        },
        "options": {}
      }
    ],
    "rnoweb": [],
    "robot": [
      {
        "content": "\\${${1:name}}=    Catenate    SEPARATOR=${2:---}    ${3:Hello}    ${4:world}",
        "doc": "",
        "grammar": "snu",
        "label": "Catenate",
        "matches": {
          "cat": true
        },
        "options": {}
      },
      {
        "content": "\\${${1:val}}=    Evaluate    ${2:${x} - 10}",
        "doc": "",
        "grammar": "snu",
        "label": "Evaluate",
        "matches": {
          "eval": true
        },
        "options": {}
      },
      {
        "content": "No Operation",
        "doc": "",
        "grammar": "snu",
        "label": "No Operation",
        "matches": {
          "nop": true
        },
        "options": {}
      },
      {
        "content": "Return From Keyword    ${1:${optional return value}}",
        "doc": "",
        "grammar": "snu",
        "label": "Return From Keyword",
        "matches": {
          "rfk": true
        },
        "options": {}
      },
      {
        "content": "Return From Keyword If    '\\${${1:rc}}' != '${2:abc}'    ${3:${optional return value}}",
        "doc": "",
        "grammar": "snu",
        "label": "Return From Keyword If",
        "matches": {
          "rfki": true
        },
        "options": {}
      },
      {
        "content": "Run Keyword    ${1:${kw}}    ${2:${args}}",
        "doc": "",
        "grammar": "snu",
        "label": "Run Keyword",
        "matches": {
          "rk": true
        },
        "options": {}
      },
      {
        "content": "Run Keyword And Continue On Failure    ${1:${kw}}    ${2:${args}}",
        "doc": "",
        "grammar": "snu",
        "label": "Run Keyword And Continue On Failure",
        "matches": {
          "rkacof": true
        },
        "options": {}
      },
      {
        "content": "Run Keyword And Expect Error    ${1:My error}    ${2:${kw}}    ${3:${args}}",
        "doc": "",
        "grammar": "snu",
        "label": "Run Keyword And Expect Error",
        "matches": {
          "rkaee": true
        },
        "options": {}
      },
      {
        "content": "Run Keyword And Ignore Error    ${1:${kw}}    ${2:${args}}\n\\${${3:result}}    \\${${4:return_value}}=    Run Keyword And Ignore Error    ${1:${kw}}    ${2:${args}}",
        "doc": "",
        "grammar": "snu",
        "label": "Run Keyword And Ignore Error",
        "matches": {
          "rkaie": true
        },
        "options": {}
      },
      {
        "content": "Run Keyword And Return    ${1:${kw}}    ${2:${args}}",
        "doc": "",
        "grammar": "snu",
        "label": "Run Keyword And Return",
        "matches": {
          "rkar": true
        },
        "options": {}
      },
      {
        "content": "Run Keyword And Return If    '\\${${1:rc}}' != '${2:abc}'    ${3:${kw}}    ${4:${args}}",
        "doc": "",
        "grammar": "snu",
        "label": "Run Keyword And Return If",
        "matches": {
          "rkari": true
        },
        "options": {}
      },
      {
        "content": "\\${${3:result}}=    Run Keyword And Return Status    ${1:${kw}}    ${2:${args}}",
        "doc": "",
        "grammar": "snu",
        "label": "Run Keyword And Return Status",
        "matches": {
          "rkars": true
        },
        "options": {}
      },
      {
        "content": "Run Keyword If Any Critical Tests Failed    ${1:${kw}}    ${2:${args}}",
        "doc": "",
        "grammar": "snu",
        "label": "Run Keyword If Any Critical Tests Failed",
        "matches": {
          "rkiactf": true
        },
        "options": {}
      },
      {
        "content": "Run Keyword If All Critical Tests Passed    ${1:${kw}}    ${2:${args}}",
        "doc": "",
        "grammar": "snu",
        "label": "Run Keyword If All Critical Tests Passed",
        "matches": {
          "rkiactp": true
        },
        "options": {}
      },
      {
        "content": "Run Keyword If Any Tests Failed    ${1:${kw}}    ${2:${args}}",
        "doc": "",
        "grammar": "snu",
        "label": "Run Keyword If Any Tests Failed",
        "matches": {
          "rkiatf": true
        },
        "options": {}
      },
      {
        "content": "Run Keyword If All Tests Passed    ${1:${kw}}    ${2:${args}}",
        "doc": "",
        "grammar": "snu",
        "label": "Run Keyword If All Tests Passed",
        "matches": {
          "rkiatp": true
        },
        "options": {}
      },
      {
        "content": "Run Keyword If Test Failed    ${1:${kw}}    ${2:${args}}",
        "doc": "",
        "grammar": "snu",
        "label": "Run Keyword If Test Failed",
        "matches": {
          "rkitf": true
        },
        "options": {}
      },
      {
        "content": "Run Keyword If Test Passed    ${1:${kw}}    ${2:${args}}",
        "doc": "",
        "grammar": "snu",
        "label": "Run Keyword If Test Passed",
        "matches": {
          "rkitp": true
        },
        "options": {}
      },
      {
        "content": "Run Keyword If Timeout Occurred    ${1:${kw}}    ${2:${args}}",
        "doc": "",
        "grammar": "snu",
        "label": "Run Keyword If Timeout Occurred",
        "matches": {
          "rkito": true
        },
        "options": {}
      },
      {
        "content": "Run Keyword Unless    '\\${${1:rc}}' != '${2:abc}'    ${3:${kw}}    ${4:${args}}",
        "doc": "",
        "grammar": "snu",
        "label": "Run Keyword Unless",
        "matches": {
          "rku": true
        },
        "options": {}
      },
      {
        "content": "Set Global Variable    \\${${1:name}}    ${2:${value}}",
        "doc": "",
        "grammar": "snu",
        "label": "Set Global Variable",
        "matches": {
          "sgv": true
        },
        "options": {}
      },
      {
        "content": "Should Be Equal    \"\\${${1:var}}\"    \"${2:expected value}\"    ${3:\"optional error msg\"}\t${4:ignore_case=True}",
        "doc": "",
        "grammar": "snu",
        "label": "Should Be Equal",
        "matches": {
          "sbe": true
        },
        "options": {}
      },
      {
        "content": "Sleep    ${1:2 minutes 10 seconds}",
        "doc": "",
        "grammar": "snu",
        "label": "Sleep",
        "matches": {
          "sleep": true
        },
        "options": {}
      },
      {
        "content": "Set Suite Variable    \\${${1:name}}    ${2:${value}}",
        "doc": "",
        "grammar": "snu",
        "label": "Set Suite Variable",
        "matches": {
          "ssv": true
        },
        "options": {}
      },
      {
        "content": "Set Test Variable    \\${${1:name}}    ${2:${value}}",
        "doc": "",
        "grammar": "snu",
        "label": "Set Test Variable",
        "matches": {
          "stv": true
        },
        "options": {}
      },
      {
        "content": "\\${${1:name}}=    Set Variable    ${2:${value}}",
        "doc": "",
        "grammar": "snu",
        "label": "Set Variable",
        "matches": {
          "sv": true
        },
        "options": {}
      },
      {
        "content": "Import library    Dialogs\nPause execution",
        "doc": "",
        "grammar": "snu",
        "label": "Pause test execution",
        "matches": {
          "pause": true
        },
        "options": {}
      },
      {
        "content": "[Teardown]    Run Keyword If Test Failed    Run Keywords\n...    Import library    Dialogs    AND\n...    Pause execution",
        "doc": "",
        "grammar": "snu",
        "label": "Teardown Pause - pause test execution only on failure",
        "matches": {
          "tpause": true
        },
        "options": {}
      },
      {
        "content": "Capture Page Screenshot    ${1:${optional filename}}",
        "doc": "",
        "grammar": "snu",
        "label": "Capture Page Screenshot",
        "matches": {
          "cps": true
        },
        "options": {}
      },
      {
        "content": "Element Should Be Disabled    \\${${1:locator}}",
        "doc": "",
        "grammar": "snu",
        "label": "Element Should Be Disabled",
        "matches": {
          "esbd": true
        },
        "options": {}
      },
      {
        "content": "Element Should Be Enabled    ${${1:locator}}",
        "doc": "",
        "grammar": "snu",
        "label": "Element Should Be Enabled",
        "matches": {
          "esbe": true
        },
        "options": {}
      },
      {
        "content": "Element Should Be Focused    ${${1:locator}}",
        "doc": "",
        "grammar": "snu",
        "label": "Element Should Be Focused",
        "matches": {
          "esbf": true
        },
        "options": {}
      },
      {
        "content": "Element Should Be Visible    ${${1:locator}}    ${2:${optional message}}",
        "doc": "",
        "grammar": "snu",
        "label": "Element Should Be Visible",
        "matches": {
          "esbv": true
        },
        "options": {}
      },
      {
        "content": "Element Should Contain    ${${1:locator}}    ${2:${expected}}    ${3:${optional message}}",
        "doc": "",
        "grammar": "snu",
        "label": "Element Should Contain",
        "matches": {
          "esc": true
        },
        "options": {}
      },
      {
        "content": "Element Should Not Be Visible    ${${1:locator}}    ${2:${optional message}}",
        "doc": "",
        "grammar": "snu",
        "label": "Element Should Not Be Visible",
        "matches": {
          "esnbv": true
        },
        "options": {}
      },
      {
        "content": "Element Should Not Contain    ${${1:locator}}    ${2:${expected}}    ${3:${optional message}}",
        "doc": "",
        "grammar": "snu",
        "label": "Element Should Not Contain",
        "matches": {
          "esnc": true
        },
        "options": {}
      },
      {
        "content": "Element Text Should Be    ${${1:locator}}    ${2:${expected}}    ${3:${optional message}}",
        "doc": "",
        "grammar": "snu",
        "label": "Element Text Should Be",
        "matches": {
          "etsb": true
        },
        "options": {}
      },
      {
        "content": "Execute Async Javascript    ${1:${code line 1}}    ${2:${code line 2}}",
        "doc": "",
        "grammar": "snu",
        "label": "Execute Async Javascript",
        "matches": {
          "eaj": true
        },
        "options": {}
      },
      {
        "content": "Execute Javascript    ${1:${code line 1}}    ${2:${code line 2}}",
        "doc": "",
        "grammar": "snu",
        "label": "Execute Javascript",
        "matches": {
          "ej": true
        },
        "options": {}
      },
      {
        "content": "\\${${1:x}}    \\${${2:y}}=    Get Window Position",
        "doc": "",
        "grammar": "snu",
        "label": "Get Window Position",
        "matches": {
          "gwp": true
        },
        "options": {}
      },
      {
        "content": "\\${${1:width}}    \\${${2:height}}=    Get Window Size",
        "doc": "",
        "grammar": "snu",
        "label": "Get Window Size",
        "matches": {
          "gws": true
        },
        "options": {}
      },
      {
        "content": "Maximize Browser Window",
        "doc": "",
        "grammar": "snu",
        "label": "Maximize Browser Window",
        "matches": {
          "mbw": true
        },
        "options": {}
      },
      {
        "content": "Mouse Down    ${${1:locator}}",
        "doc": "",
        "grammar": "snu",
        "label": "Mouse Down",
        "matches": {
          "md": true
        },
        "options": {}
      },
      {
        "content": "Mouse Down On Image    ${1:${locator}}",
        "doc": "",
        "grammar": "snu",
        "label": "Mouse Down On Image",
        "matches": {
          "mdoi": true
        },
        "options": {}
      },
      {
        "content": "Mouse Down On Link    ${1:${locator}}",
        "doc": "",
        "grammar": "snu",
        "label": "Mouse Down On Link",
        "matches": {
          "mdol": true
        },
        "options": {}
      },
      {
        "content": "Mouse Out    ${1:${locator}}",
        "doc": "",
        "grammar": "snu",
        "label": "Mouse Out",
        "matches": {
          "mout": true
        },
        "options": {}
      },
      {
        "content": "Mouse Over    ${1:${locator}}",
        "doc": "",
        "grammar": "snu",
        "label": "Mouse Over",
        "matches": {
          "mover": true
        },
        "options": {}
      },
      {
        "content": "Mouse Up    ${1:${locator}}",
        "doc": "",
        "grammar": "snu",
        "label": "Mouse Up",
        "matches": {
          "mu": true
        },
        "options": {}
      },
      {
        "content": "Open Browser    ${1:${url}}    ${2:${browser=firefox}}    ${3:${alias=None}}    ${4:${remote_url=False}}    ${5:${desired_capabilities=None}}    ${6:${ff_profile_dir=None}}",
        "doc": "",
        "grammar": "snu",
        "label": "Open Browser",
        "matches": {
          "ob": true
        },
        "options": {}
      },
      {
        "content": "Open Context Menu    ${1:${locator}}",
        "doc": "",
        "grammar": "snu",
        "label": "Open Context Menu",
        "matches": {
          "ocm": true
        },
        "options": {}
      },
      {
        "content": "Page Should Contain    ${1:${text}}    ${2:loglevel=INFO}",
        "doc": "",
        "grammar": "snu",
        "label": "Page Should Contain",
        "matches": {
          "psc": true
        },
        "options": {}
      },
      {
        "content": "Page Should Contain Button    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}",
        "doc": "",
        "grammar": "snu",
        "label": "Page Should Contain Button",
        "matches": {
          "pscb": true
        },
        "options": {}
      },
      {
        "content": "Page Should Contain Checkbox    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}",
        "doc": "",
        "grammar": "snu",
        "label": "Page Should Contain Checkbox",
        "matches": {
          "pscc": true
        },
        "options": {}
      },
      {
        "content": "Page Should Contain Element    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}",
        "doc": "",
        "grammar": "snu",
        "label": "Page Should Contain Element",
        "matches": {
          "psce": true
        },
        "options": {}
      },
      {
        "content": "Page Should Contain Image    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}",
        "doc": "",
        "grammar": "snu",
        "label": "Page Should Contain Image",
        "matches": {
          "psci": true
        },
        "options": {}
      },
      {
        "content": "Page Should Contain Link    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}",
        "doc": "",
        "grammar": "snu",
        "label": "Page Should Contain Link",
        "matches": {
          "pscl": true
        },
        "options": {}
      },
      {
        "content": "Page Should Contain Radio Button    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}",
        "doc": "",
        "grammar": "snu",
        "label": "Page Should Contain Radio Button",
        "matches": {
          "pscrb": true
        },
        "options": {}
      },
      {
        "content": "Page Should Contain Textfield    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}",
        "doc": "",
        "grammar": "snu",
        "label": "Page Should Contain Textfield",
        "matches": {
          "psct": true
        },
        "options": {}
      },
      {
        "content": "Page Should Not Contain    ${1:${text}}    ${2:loglevel=INFO}",
        "doc": "",
        "grammar": "snu",
        "label": "Page Should Not Contain",
        "matches": {
          "psnc": true
        },
        "options": {}
      },
      {
        "content": "Page Should Not Contain Button    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}",
        "doc": "",
        "grammar": "snu",
        "label": "Page Should Not Contain Button",
        "matches": {
          "psncb": true
        },
        "options": {}
      },
      {
        "content": "Page Should Not Contain Checkbox    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}",
        "doc": "",
        "grammar": "snu",
        "label": "Page Should Not Contain Checkbox",
        "matches": {
          "psncc": true
        },
        "options": {}
      },
      {
        "content": "Page Should Not Contain Element    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}",
        "doc": "",
        "grammar": "snu",
        "label": "Page Should Not Contain Element",
        "matches": {
          "psnce": true
        },
        "options": {}
      },
      {
        "content": "Page Should Not Contain Image    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}",
        "doc": "",
        "grammar": "snu",
        "label": "Page Should Not Contain Image",
        "matches": {
          "psnci": true
        },
        "options": {}
      },
      {
        "content": "Page Should Not Contain Link    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}",
        "doc": "",
        "grammar": "snu",
        "label": "Page Should Not Contain Link",
        "matches": {
          "psncl": true
        },
        "options": {}
      },
      {
        "content": "Page Should Not Contain Radio Button    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}",
        "doc": "",
        "grammar": "snu",
        "label": "Page Should Not Contain Radio Button",
        "matches": {
          "psncrb": true
        },
        "options": {}
      },
      {
        "content": "Page Should Not Contain Textfield    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}",
        "doc": "",
        "grammar": "snu",
        "label": "Page Should Not Contain Textfield",
        "matches": {
          "psnct": true
        },
        "options": {}
      },
      {
        "content": "Register Keyword To Run On Failure    ${1:${kw}}",
        "doc": "",
        "grammar": "snu",
        "label": "Register Keyword To Run On Failure",
        "matches": {
          "rktrof": true
        },
        "options": {}
      },
      {
        "content": "Wait Until Element Contains    ${1:${locator}}    ${2:${text}}    ${3:${timeout=None}}    ${4:${error=None}}",
        "doc": "",
        "grammar": "snu",
        "label": "Wait Until Element Contains",
        "matches": {
          "wuec": true
        },
        "options": {}
      },
      {
        "content": "Wait Until Element Does Not Contain    ${1:${locator}}    ${2:${text}}    ${3:${timeout=None}}    ${4:${error=None}}",
        "doc": "",
        "grammar": "snu",
        "label": "Wait Until Element Does Not Contain",
        "matches": {
          "wuednc": true
        },
        "options": {}
      },
      {
        "content": "Wait Until Element Is Enabled    ${1:${locator}}    ${2:${timeout=None}}    ${3:${error=None}}",
        "doc": "",
        "grammar": "snu",
        "label": "Wait Until Element Is Enabled",
        "matches": {
          "wueie": true
        },
        "options": {}
      },
      {
        "content": "Wait Until Element Is Not Visible    ${1:${locator}}    ${2:${timeout=None}}    ${3:${error=None}}",
        "doc": "",
        "grammar": "snu",
        "label": "Wait Until Element Is Not Visible",
        "matches": {
          "wueinv": true
        },
        "options": {}
      },
      {
        "content": "Wait Until Element Is Visible    ${1:${locator}}    ${2:${timeout=None}}    ${3:${error=None}}",
        "doc": "",
        "grammar": "snu",
        "label": "Wait Until Element Is Visible",
        "matches": {
          "wueiv": true
        },
        "options": {}
      },
      {
        "content": "Wait Until Page Contains    ${1:${text}}    ${2:${timeout=None}}    ${3:${error=None}}",
        "doc": "",
        "grammar": "snu",
        "label": "Wait Until Page Contains",
        "matches": {
          "wupc": true
        },
        "options": {}
      },
      {
        "content": "Wait Until Page Contains Element    ${1:${locator}}    ${2:${timeout=None}}    ${3:${error=None}}",
        "doc": "",
        "grammar": "snu",
        "label": "Wait Until Page Contains Element",
        "matches": {
          "wupce": true
        },
        "options": {}
      },
      {
        "content": "Wait Until Page Does Not Contain    ${1:${text}}    ${2:${timeout=None}}    ${3:${error=None}}",
        "doc": "",
        "grammar": "snu",
        "label": "Wait Until Page Does Not Contain",
        "matches": {
          "wupdnc": true
        },
        "options": {}
      },
      {
        "content": "Wait Until Page Does Not Contain Element    ${1:${locator}}    ${2:${timeout=None}}    ${3:${error=None}}",
        "doc": "",
        "grammar": "snu",
        "label": "Wait Until Page Does Not Contain Element",
        "matches": {
          "wupdnce": true
        },
        "options": {}
      }
    ],
    "rst": [
      {
        "content": "===========================\n${1:#:content_name}\n===========================\n.. contents:: contents_name\ntitle1\n====================================\nsubtitle1\n-----------------------------------\nsubtitle2\n-----------------------------------\nsubtitle3\n-----------------------------------\ntitle2\n====================================\nsubtitle1\n-----------------------------------\nsubtitle2\n-----------------------------------\nsubtitle3\n-----------------------------------\ntitle3\n====================================\nsubtitle1\n-----------------------------------\nsubtitle2\n-----------------------------------\nsubtitle3\n-----------------------------------",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "quickstart": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": ".. contents:: ${1:#:contents_name}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "contnents": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "${1:#:title}\n====================================",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "title": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "${1:#:subtitle}\n-----------------------------------",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "subtitle": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": ".. code-block:: ${1:#:filetype}\n${2:#:content}",
        "doc": "",
        "grammar": "snu",
        "label": "code",
        "matches": {
          "code_block": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "+------------------+------------+-----------------------+------------+\n|${1:#:cel} | | | |\n+==================+============+=======================+============+\n| | | | |\n+------------------+------------+-----------------------+------------+\n| | | | |\n+------------------+------------+-----------------------+------------+",
        "doc": "",
        "grammar": "snu",
        "label": "grid_table",
        "matches": {
          "table_grid": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": ":${1:#:text}:\n: :\n: :\n: :",
        "doc": "",
        "grammar": "snu",
        "label": "simple_table",
        "matches": {
          "table_simple": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "-\n-\n-\n-",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "- ${1:#:text}\n-\n-\n-",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nested_list": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "[#]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "caption": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": ".. image:: ${1:#:path}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "image": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "**${1:#:text}**",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "strong": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": ".. toctree::\n\t:maxdepth: ${1:2}\n\t${2:#:FILES}",
        "doc": "",
        "grammar": "snu",
        "label": "directive_toctree",
        "matches": {
          "toctree": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": ".. code-block:: ${1:python}\n\t${1:#:TERGET}",
        "doc": "",
        "grammar": "snu",
        "label": "syntax",
        "matches": {
          "syntax": true
        },
        "options": {
          "indent": true
        }
      },
      {
        "content": ".. _${1:#:NAME}:\n${2:#:CURSOR}",
        "doc": "",
        "grammar": "snu",
        "label": "label",
        "matches": {
          "label": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": ".. contents::\n\t:depth: ${1:2}\n\t${2::local:}",
        "doc": "",
        "grammar": "snu",
        "label": "directive_content",
        "matches": {
          "content": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": ".. table:: ${1:#:TITLE}\n\t${0:#:CURSOR}",
        "doc": "",
        "grammar": "snu",
        "label": "directive_table",
        "matches": {
          "table": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": ".. csv-table:: ${1:#:TITLE}\n\t:header: \"${2:#:Header1}\", \"${3:#:Header2}\"${4:#:Headers}\n\t\"${5:#:Column1}\", \"${6:#:Column2}\"${0:#:CURSOR}",
        "doc": "",
        "grammar": "snu",
        "label": "directive_csvtable",
        "matches": {
          "csvtable": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": ".. ${1:#:NAME}:: ${0:#:CURSOR}",
        "doc": "",
        "grammar": "snu",
        "label": "directive",
        "matches": {
          "directive": true
        },
        "options": {}
      },
      {
        "content": ".. note:: ${0:#:CURSOR}",
        "doc": "",
        "grammar": "snu",
        "label": "note",
        "matches": {
          "note": true
        },
        "options": {}
      },
      {
        "content": ".. tip:: ${0:#:CURSOR}",
        "doc": "",
        "grammar": "snu",
        "label": "tip",
        "matches": {
          "tip": true
        },
        "options": {}
      },
      {
        "content": ".. warning:: ${0:#:CURSOR}",
        "doc": "",
        "grammar": "snu",
        "label": "warning",
        "matches": {
          "warning": true
        },
        "options": {}
      },
      {
        "content": ".. attention:: ${0:#:CURSOR}",
        "doc": "",
        "grammar": "snu",
        "label": "attention",
        "matches": {
          "attention": true
        },
        "options": {}
      },
      {
        "content": ".. caution:: ${0:#:CURSOR}",
        "doc": "",
        "grammar": "snu",
        "label": "caution",
        "matches": {
          "caution": true
        },
        "options": {}
      },
      {
        "content": ".. danger:: ${0:#:CURSOR}",
        "doc": "",
        "grammar": "snu",
        "label": "danger",
        "matches": {
          "danger": true
        },
        "options": {}
      },
      {
        "content": ".. error:: ${0:#:CURSOR}",
        "doc": "",
        "grammar": "snu",
        "label": "error",
        "matches": {
          "error": true
        },
        "options": {}
      },
      {
        "content": ".. hint:: ${0:#:CURSOR}",
        "doc": "",
        "grammar": "snu",
        "label": "hint",
        "matches": {
          "hint": true
        },
        "options": {}
      },
      {
        "content": ".. important:: ${0:#:CURSOR}",
        "doc": "",
        "grammar": "snu",
        "label": "important",
        "matches": {
          "important": true
        },
        "options": {}
      },
      {
        "content": ".. seealso:: ${0:#:CURSOR}",
        "doc": "",
        "grammar": "snu",
        "label": "seealso",
        "matches": {
          "seealso": true
        },
        "options": {}
      },
      {
        "content": ":${1:field name}: ${0:field body}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":": true
        },
        "options": {}
      },
      {
        "content": "*${1:Emphasis}* ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "*": true
        },
        "options": {}
      },
      {
        "content": "**${1:Strong emphasis}** ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "**": true
        },
        "options": {}
      },
      {
        "content": "${1:Title}\n=====${2:=}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "=": true
        },
        "options": {}
      },
      {
        "content": "${1:Title}\n-----${2:-}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "-": true
        },
        "options": {}
      },
      {
        "content": ".. |${1:alias}| image:: ${0:img}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "img:": true
        },
        "options": {}
      },
      {
        "content": ".. figure:: ${1:img}\n\t:alt: ${2:alter text}\n\t$0",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fig:": true
        },
        "options": {}
      },
      {
        "content": ".. contents:: ${1:Table of Contents}\n\t${0:content}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "con:": true
        },
        "options": {}
      },
      {
        "content": ".. code:: ${1:type}\n\t${0:write some code}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cod:": true
        },
        "options": {}
      },
      {
        "content": ".. tip::\n\t${0:my tips}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tip:": true
        },
        "options": {}
      },
      {
        "content": ".. note::\n\t${0:my notes}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "not:": true
        },
        "options": {}
      },
      {
        "content": ".. warning::\n\t${0:attention!}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "war:": true
        },
        "options": {}
      },
      {
        "content": ".. important::\n\t${0:this is importatnt}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "imp:": true
        },
        "options": {}
      },
      {
        "content": ".. attention::\n\t${0:hey!}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "att:": true
        },
        "options": {}
      },
      {
        "content": ".. danger::\n\t${0:ah!}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dan:": true
        },
        "options": {}
      },
      {
        "content": ".. error::\n\t${0:Error occur}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "err:": true
        },
        "options": {}
      },
      {
        "content": ".. caution::\n\t${0:Watch out!}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cau:": true
        },
        "options": {}
      },
      {
        "content": ".. sidebar:: ${1:Title}\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sid:": true
        },
        "options": {}
      },
      {
        "content": ".. todo::\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tod:": true
        },
        "options": {}
      },
      {
        "content": ".. list-table:: ${1:Title}\n\t:header-rows: 1\n\t:stub-columns: 0\n\t* - ${0:R1C1}\n\t  - R1C2\n\t* - R2C1\n\t  - R2C2",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lis:": true
        },
        "options": {}
      },
      {
        "content": ".. csv-table:: ${1:Title}\n\t:header-rows: 1\n\t:stub-columns: 0\n\t${0:R1C1}, R1C2\n\tR2C1, R2C2",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "csv:": true
        },
        "options": {}
      },
      {
        "content": ".. toctree::\n\t:maxdepth: 2\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "toc:": true
        },
        "options": {}
      },
      {
        "content": "\\ *${1:Emphasis}*\\ ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "*c": true
        },
        "options": {}
      },
      {
        "content": "\\ **${1:Strong emphasis}**\\ ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "**c": true
        },
        "options": {}
      }
    ],
    "ruby": [
      {
        "content": "#!/usr/bin/env ruby\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "#!/usr/bin/env ruby",
        "matches": {
          "#!": true,
          "shebang": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "if ${1:#:condition}\n  ${0:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "if ... end",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "unless ${1:#:condition}\n  ${0:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "unless ... end",
        "matches": {
          "unless": true
        },
        "options": {}
      },
      {
        "content": "def ${1:#:method_name}\n  ${0:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "def ... end",
        "matches": {
          "def": true
        },
        "options": {}
      },
      {
        "content": "def ${1:#:method_name}\n  ${2:TARGET}\nrescue ${3:#:StandardError} => ${4:error}\n  ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "def ... rescue ... end",
        "matches": {
          "defr": true,
          "defrescue": true
        },
        "options": {}
      },
      {
        "content": "do\n  ${0:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "do ... end",
        "matches": {
          "do": true
        },
        "options": {}
      },
      {
        "content": "do |${1:#:var}|\n  ${0:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "do |var| ... end",
        "matches": {
          "dovar": true
        },
        "options": {}
      },
      {
        "content": "{\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "{ ... }",
        "matches": {
          "block": true
        },
        "options": {}
      },
      {
        "content": "{|${1:#:var}|\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "{|var| ... }",
        "matches": {
          "blockvar": true
        },
        "options": {}
      },
      {
        "content": "File.open(${1:#:filename}, '${2:#:mode}') do |${3:io}|\n  ${0:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "File.open(filename) do ... end",
        "matches": {
          "fileopen": true,
          "open": true
        },
        "options": {}
      },
      {
        "content": "end",
        "doc": "",
        "grammar": "snu",
        "label": "=> end?",
        "matches": {
          "edn": true
        },
        "options": {}
      },
      {
        "content": "# coding: utf-8\nrequire 'erb'\nputs ERB::Util.url_encode '${1}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "urlencode": true
        },
        "options": {}
      },
      {
        "content": "# coding: utf-8\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "enc": true,
          "encoding": true
        },
        "options": {}
      },
      {
        "content": "each do |${1:#:variable}|\n  ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "each": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "each_byte {|${1:#:variable}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "each_byte": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "each_char {|${1:#:variable}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "each_char": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "each_index {|${1:#:variable}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "each_index": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "each_key {|${1:#:variable}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "each_key": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "each_line {|${1:#:variable}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "each_line": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "each_with_index {|${1:#:variable}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "each_with_index": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "each_pair {|${1:#:key}, ${2:value}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "each_pair": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "each_pair do |${1:key}, ${2:value}|\n  ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "each_pair_do": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "map {|${1:#:variable}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "map": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "sort {|${1:x}, ${2:y}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sort": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "sort_by {|${1:#:variable}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sort_by": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "-> (${1:#:args}) { ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lambda": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "lambda {|${1:#:args}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lambda-keyword": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "if __FILE__ == \\$0\n  ${0:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "main": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "File.dirname(File.expand_path(__FILE__))",
        "doc": "",
        "grammar": "snu",
        "label": "File.dirname(...)",
        "matches": {
          "__dir__": true,
          "filedir-legacy-compatibility": true
        },
        "options": {}
      },
      {
        "content": "Dir.glob(${1:'**/*'}) do |fname|\n  ${0:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "glob": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "case ${1}\nwhen ${2}\n  ${3}\nelse\n  ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "case ... when ... else ... end",
        "matches": {
          "case": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "# encoding: utf-8",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "enc": true
        },
        "options": {}
      },
      {
        "content": "# frozen_string_literal: true",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "frozen": true
        },
        "options": {}
      },
      {
        "content": "#!/usr/bin/env ruby",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#!": true
        },
        "options": {}
      },
      {
        "content": "=begin rdoc\n\t${0}\n=end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "=b": true
        },
        "options": {}
      },
      {
        "content": "protected\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prot": true
        },
        "options": {}
      },
      {
        "content": "private\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "priv": true
        },
        "options": {}
      },
      {
        "content": ":yields: ${0:arguments}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "y": true
        },
        "options": {}
      },
      {
        "content": "#!/usr/bin/env ruby -wKU",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rb": true
        },
        "options": {}
      },
      {
        "content": "begin\n\t${0}\nrescue ${1:StandardError} => ${2:e}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "beg": true
        },
        "options": {}
      },
      {
        "content": "require '${1}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "req require": true
        },
        "options": {}
      },
      {
        "content": "require_relative '${1}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "reqr": true
        },
        "options": {}
      },
      {
        "content": "# =>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#": true
        },
        "options": {}
      },
      {
        "content": "case ${1:object}\nwhen ${2:condition}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case": true
        },
        "options": {}
      },
      {
        "content": "when ${1:condition}\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "when": true
        },
        "options": {}
      },
      {
        "content": "def ${1:method_name}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "def": true
        },
        "options": {}
      },
      {
        "content": "def test_${1:case_name}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "deft": true
        },
        "options": {}
      },
      {
        "content": "class Class\n\tdef descendants\n\t\tObjectSpace.each_object(::Class).select { |klass| klass < self }\n\tend\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "descendants": true
        },
        "options": {}
      },
      {
        "content": "if ${1:condition}\n\t${0:${VISUAL}}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "if ${1:condition}\n\t${2:${VISUAL}}\nelse\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "elsif ${1:condition}\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eif": true
        },
        "options": {}
      },
      {
        "content": "if ${1:condition}\n\t$2\nelsif ${3:condition}\n\t$4\nelse\n\t$0\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifee": true
        },
        "options": {}
      },
      {
        "content": "unless ${1:condition}\n\t${0:${VISUAL}}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "unless": true
        },
        "options": {}
      },
      {
        "content": "unless ${1:condition}\n\t$2\nelse\n\t$0\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "unlesse": true
        },
        "options": {}
      },
      {
        "content": "unless ${1:condition}\n\t$2\nelsif ${3:condition}\n\t$4\nelse\n\t$0\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "unlesee": true
        },
        "options": {}
      },
      {
        "content": "while ${1:condition}\n\t${0:${VISUAL}}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh": true
        },
        "options": {}
      },
      {
        "content": "for ${1:e} in ${2:c}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "until ${1:condition}\n\t${0:${VISUAL}}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "until": true
        },
        "options": {}
      },
      {
        "content": "class ${0:BlankSlate}\n\tinstance_methods.each { |meth| undef_method(meth) unless meth =~ /\\A__/ }\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "blankslate class BlankSlate .. initialize .. end": true
        },
        "options": {}
      },
      {
        "content": "class << ${1:self}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "claself class << self .. end": true
        },
        "options": {}
      },
      {
        "content": "attr_reader :${0:attr_names}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "r": true
        },
        "options": {}
      },
      {
        "content": "attr_writer :${0:attr_names}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "w": true
        },
        "options": {}
      },
      {
        "content": "attr_accessor :${0:attr_names}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rw": true
        },
        "options": {}
      },
      {
        "content": "attr_protected :${0:attr_names}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "atp": true
        },
        "options": {}
      },
      {
        "content": "attr_accessible :${0:attr_names}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ata": true
        },
        "options": {}
      },
      {
        "content": "accepts_nested_attributes_for :${0:association}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ana": true
        },
        "options": {}
      },
      {
        "content": "@${1:variable_name} ||= ${0:cached_value}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ivc": true
        },
        "options": {}
      },
      {
        "content": "include Enumerable\ndef each(&block)\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Enum": true
        },
        "options": {}
      },
      {
        "content": "include Comparable\ndef <=>(other)\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Comp": true
        },
        "options": {}
      },
      {
        "content": "extend Forwardable",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Forw-": true
        },
        "options": {}
      },
      {
        "content": "def self.${1:class_method_name}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defs": true
        },
        "options": {}
      },
      {
        "content": "def initialize(${1:args})\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "definit": true
        },
        "options": {}
      },
      {
        "content": "def method_missing(meth, *args, &blk)\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defmm": true
        },
        "options": {}
      },
      {
        "content": "def_delegator :${1:@del_obj}, :${2:del_meth}, :${0:new_name}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defd": true
        },
        "options": {}
      },
      {
        "content": "def_delegators :${1:@del_obj}, :${0:del_methods}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defds": true
        },
        "options": {}
      },
      {
        "content": "alias_method :${1:new_name}, :${0:old_name}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "am": true
        },
        "options": {}
      },
      {
        "content": "if __FILE__ == $PROGRAM_NAME\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "app": true
        },
        "options": {}
      },
      {
        "content": "if ARGV.${1}\n\tabort \"Usage: #{$PROGRAM_NAME} ${2:ARGS_GO_HERE}\"${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "usai": true
        },
        "options": {}
      },
      {
        "content": "unless ARGV.${1}\n\tabort \"Usage: #{$PROGRAM_NAME} ${2:ARGS_GO_HERE}\"${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "usau": true
        },
        "options": {}
      },
      {
        "content": "Array.new(${1:10}) { |${2:i}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "array": true
        },
        "options": {}
      },
      {
        "content": "Hash.new { |${1:hash}, ${2:key}| $1[$2] = ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "hash": true
        },
        "options": {}
      },
      {
        "content": "File.foreach(${1:'path/to/file'}) { |${2:line}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "file File.foreach() { |line| .. }": true
        },
        "options": {}
      },
      {
        "content": "File.read(${1:'path/to/file'})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "file File.read()": true
        },
        "options": {}
      },
      {
        "content": "Dir.glob(${1:'dir/glob/*'}) { |${2:file}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Dir Dir.global() { |file| .. }": true
        },
        "options": {}
      },
      {
        "content": "Dir[${1:'glob/**/*.rb'}]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Dir Dir[\"..\"]": true
        },
        "options": {}
      },
      {
        "content": "Filename.dirname(__FILE__)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dir": true
        },
        "options": {}
      },
      {
        "content": "delete_if { |${1:e}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "deli": true
        },
        "options": {}
      },
      {
        "content": "fill(${1:range}) { |${2:i}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fil": true
        },
        "options": {}
      },
      {
        "content": "reduce(Array.new) { |${1:arr}, ${2:a}| $1.push(*$2) }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "flao": true
        },
        "options": {}
      },
      {
        "content": "zip(${1:enums}) { |${2:row}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "zip": true
        },
        "options": {}
      },
      {
        "content": "downto(${1:0}) { |${2:n}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dow": true
        },
        "options": {}
      },
      {
        "content": "step(${1:2}) { |${2:n}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ste": true
        },
        "options": {}
      },
      {
        "content": "times { |${1:n}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tim": true
        },
        "options": {}
      },
      {
        "content": "upto(${1:1.0/0.0}) { |${2:n}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "upt": true
        },
        "options": {}
      },
      {
        "content": "loop { ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "loo": true
        },
        "options": {}
      },
      {
        "content": "each { |${1:e}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ea": true
        },
        "options": {}
      },
      {
        "content": "each do |${1:e}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ead": true
        },
        "options": {}
      },
      {
        "content": "each_byte { |${1:byte}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eab": true
        },
        "options": {}
      },
      {
        "content": "each_char { |${1:chr}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eac- each_char { |chr| .. }": true
        },
        "options": {}
      },
      {
        "content": "each_cons(${1:2}) { |${2:group}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eac- each_cons(..) { |group| .. }": true
        },
        "options": {}
      },
      {
        "content": "each_index { |${1:i}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eai": true
        },
        "options": {}
      },
      {
        "content": "each_index do |${1:i}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eaid": true
        },
        "options": {}
      },
      {
        "content": "each_key { |${1:key}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eak": true
        },
        "options": {}
      },
      {
        "content": "each_key do |${1:key}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eakd": true
        },
        "options": {}
      },
      {
        "content": "each_line { |${1:line}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eal": true
        },
        "options": {}
      },
      {
        "content": "each_line do |${1:line}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eald": true
        },
        "options": {}
      },
      {
        "content": "each_pair { |${1:name}, ${2:val}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eap": true
        },
        "options": {}
      },
      {
        "content": "each_pair do |${1:name}, ${2:val}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eapd": true
        },
        "options": {}
      },
      {
        "content": "each_slice(${1:2}) { |${2:group}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eas-": true
        },
        "options": {}
      },
      {
        "content": "each_slice(${1:2}) do |${2:group}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "easd-": true
        },
        "options": {}
      },
      {
        "content": "each_value { |${1:val}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eav": true
        },
        "options": {}
      },
      {
        "content": "each_value do |${1:val}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eavd": true
        },
        "options": {}
      },
      {
        "content": "each_with_index { |${1:e}, ${2:i}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eawi": true
        },
        "options": {}
      },
      {
        "content": "each_with_index do |${1:e}, ${2:i}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eawid": true
        },
        "options": {}
      },
      {
        "content": "each_with_object(${1:init}) { |${2:e}, ${3:var}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eawo": true
        },
        "options": {}
      },
      {
        "content": "each_with_object(${1:init}) do |${2:e}, ${3:var}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eawod": true
        },
        "options": {}
      },
      {
        "content": "reverse_each { |${1:e}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "reve": true
        },
        "options": {}
      },
      {
        "content": "reverse_each do |${1:e}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "reved": true
        },
        "options": {}
      },
      {
        "content": "inject(${1:init}) { |${2:mem}, ${3:var}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "inj": true
        },
        "options": {}
      },
      {
        "content": "inject(${1:init}) do |${2:mem}, ${3:var}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "injd": true
        },
        "options": {}
      },
      {
        "content": "reduce(${1:init}) { |${2:mem}, ${3:var}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "red": true
        },
        "options": {}
      },
      {
        "content": "reduce(${1:init}) do |${2:mem}, ${3:var}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "redd": true
        },
        "options": {}
      },
      {
        "content": "map { |${1:e}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "map": true
        },
        "options": {}
      },
      {
        "content": "map do |${1:e}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mapd": true
        },
        "options": {}
      },
      {
        "content": "enum_with_index.map { |${1:e}, ${2:i}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mapwi-": true
        },
        "options": {}
      },
      {
        "content": "sort { |a, b| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sor": true
        },
        "options": {}
      },
      {
        "content": "sort_by { |${1:e}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sorb": true
        },
        "options": {}
      },
      {
        "content": "sort_by { rand }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ran": true
        },
        "options": {}
      },
      {
        "content": "all? { |${1:e}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "all": true
        },
        "options": {}
      },
      {
        "content": "any? { |${1:e}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "any": true
        },
        "options": {}
      },
      {
        "content": "classify { |${1:e}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cl": true
        },
        "options": {}
      },
      {
        "content": "collect { |${1:e}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "col": true
        },
        "options": {}
      },
      {
        "content": "collect do |${1:e}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cold": true
        },
        "options": {}
      },
      {
        "content": "detect { |${1:e}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "det": true
        },
        "options": {}
      },
      {
        "content": "detect do |${1:e}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "detd": true
        },
        "options": {}
      },
      {
        "content": "fetch(${1:name}) { |${2:key}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fet": true
        },
        "options": {}
      },
      {
        "content": "find { |${1:e}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fin": true
        },
        "options": {}
      },
      {
        "content": "find do |${1:e}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "find": true
        },
        "options": {}
      },
      {
        "content": "find_all { |${1:e}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fina": true
        },
        "options": {}
      },
      {
        "content": "find_all do |${1:e}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "finad": true
        },
        "options": {}
      },
      {
        "content": "grep(${1:/pattern/}) { |${2:match}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gre": true
        },
        "options": {}
      },
      {
        "content": "${1:g}sub(${2:/pattern/}) { |${3:match}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sub": true
        },
        "options": {}
      },
      {
        "content": "scan(${1:/pattern/}) { |${2:match}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sca": true
        },
        "options": {}
      },
      {
        "content": "scan(${1:/pattern/}) do |${2:match}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "scad": true
        },
        "options": {}
      },
      {
        "content": "max { |a, b| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "max": true
        },
        "options": {}
      },
      {
        "content": "min { |a, b| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "min": true
        },
        "options": {}
      },
      {
        "content": "partition { |${1:e}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "par": true
        },
        "options": {}
      },
      {
        "content": "partition do |${1:e}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pard": true
        },
        "options": {}
      },
      {
        "content": "reject { |${1:e}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rej": true
        },
        "options": {}
      },
      {
        "content": "reject do |${1:e}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rejd": true
        },
        "options": {}
      },
      {
        "content": "select { |${1:e}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sel": true
        },
        "options": {}
      },
      {
        "content": "select do |${1:e}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "seld": true
        },
        "options": {}
      },
      {
        "content": "lambda { |${1:args}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lam": true
        },
        "options": {}
      },
      {
        "content": "-> { ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "->": true
        },
        "options": {}
      },
      {
        "content": "->(${1:args}) { ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "->a": true
        },
        "options": {}
      },
      {
        "content": "do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "do": true
        },
        "options": {}
      },
      {
        "content": "do |${1:v}|\n\t${2}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dov": true
        },
        "options": {}
      },
      {
        "content": "${1:key}: ${2:'value'}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":": true
        },
        "options": {}
      },
      {
        "content": "open('${1:path/or/url/or/pipe}', '${2:w}') { |${3:io}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ope": true
        },
        "options": {}
      },
      {
        "content": "File.join(File.dirname(__FILE__), *['${1:rel path here}'])",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fpath": true
        },
        "options": {}
      },
      {
        "content": "ARGF.each_line${1} do |${2:line}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "unif": true
        },
        "options": {}
      },
      {
        "content": "require 'optparse'\noptions = { ${0:default: 'args'} }\nARGV.options do |opts|\n\topts.banner = \"Usage: #{File.basename($PROGRAM_NAME)}\"\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "optp": true
        },
        "options": {}
      },
      {
        "content": "opts.on('-${1:o}', '--${2:long-option-name}', ${3:String}, '${4:Option description.}') do |${5:opt}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "opt": true
        },
        "options": {}
      },
      {
        "content": "require 'test/unit'\nrequire '${1:library_file_name}'\nclass Test${2:$1} < Test::Unit::TestCase\n\tdef test_${3:case_name}\n\t\t${0}\n\tend\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tc": true
        },
        "options": {}
      },
      {
        "content": "require 'test/unit'\nrequire 'tc_${1:test_case_file}'\nrequire 'tc_${2:test_case_file}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ts": true
        },
        "options": {}
      },
      {
        "content": "assert ${1:test}, '${2:Failure message.}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as": true
        },
        "options": {}
      },
      {
        "content": "assert_equal ${1:expected}, ${2:actual}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ase": true
        },
        "options": {}
      },
      {
        "content": "assert_not_equal ${1:unexpected}, ${2:actual}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asne": true
        },
        "options": {}
      },
      {
        "content": "assert_in_delta ${1:expected_float}, ${2:actual_float}, ${3:2**-20}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asid": true
        },
        "options": {}
      },
      {
        "content": "assert_includes ${1:collection}, ${2:object}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asi": true
        },
        "options": {}
      },
      {
        "content": "assert_instance_of ${1:ExpectedClass}, ${2:actual_instance}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asio": true
        },
        "options": {}
      },
      {
        "content": "assert_kind_of ${1:ExpectedKind}, ${2:actual_instance}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asko": true
        },
        "options": {}
      },
      {
        "content": "assert_nil ${1:instance}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asn": true
        },
        "options": {}
      },
      {
        "content": "assert_not_nil ${1:instance}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asnn": true
        },
        "options": {}
      },
      {
        "content": "assert_match(/${1:expected_pattern}/, ${2:actual_string})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asm": true
        },
        "options": {}
      },
      {
        "content": "assert_no_match(/${1:unexpected_pattern}/, ${2:actual_string})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asnm": true
        },
        "options": {}
      },
      {
        "content": "assert_operator ${1:left}, :${2:operator}, ${3:right}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "aso": true
        },
        "options": {}
      },
      {
        "content": "assert_raises(${1:StandardError}) { ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asr": true
        },
        "options": {}
      },
      {
        "content": "assert_raises ${1:StandardError} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asrd": true
        },
        "options": {}
      },
      {
        "content": "assert_nothing_raised(${1:StandardError}) { ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asnr": true
        },
        "options": {}
      },
      {
        "content": "assert_nothing_raised ${1:StandardError} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asnrd": true
        },
        "options": {}
      },
      {
        "content": "assert_respond_to ${1:object}, :${2:method}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asrt": true
        },
        "options": {}
      },
      {
        "content": "assert_same ${1:expected}, ${2:actual}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ass assert_same(..)": true
        },
        "options": {}
      },
      {
        "content": "assert_send [${1:object}, :${2:message}, ${3:args}]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asss assert_send(..)": true
        },
        "options": {}
      },
      {
        "content": "assert_not_same ${1:unexpected}, ${2:actual}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asns": true
        },
        "options": {}
      },
      {
        "content": "assert_throws :${1:expected}, -> { ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ast": true
        },
        "options": {}
      },
      {
        "content": "assert_throws :${1:expected} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "astd": true
        },
        "options": {}
      },
      {
        "content": "assert_nothing_thrown { ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asnt": true
        },
        "options": {}
      },
      {
        "content": "assert_nothing_thrown do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asntd": true
        },
        "options": {}
      },
      {
        "content": "flunk '${1:Failure message.}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fl": true
        },
        "options": {}
      },
      {
        "content": "refute ${1:test}, '${2:Failure message.}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rf": true
        },
        "options": {}
      },
      {
        "content": "refute_equal ${1:unexpected}, ${2:actual}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rfe": true
        },
        "options": {}
      },
      {
        "content": "refute_kind_of ${1:UnexpectedKind}, ${2:actual_instance}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rfko": true
        },
        "options": {}
      },
      {
        "content": "refute_nil ${1:instance}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rfn": true
        },
        "options": {}
      },
      {
        "content": "refute_operator ${1:left}, :${2:operator}, ${3:right}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rfo": true
        },
        "options": {}
      },
      {
        "content": "refute_includes ${1:collection}, ${2:object}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rfi": true
        },
        "options": {}
      },
      {
        "content": "refute_in_delta ${1:unexpected_float}, ${2:actual_float}, ${3:2**-20}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rfid": true
        },
        "options": {}
      },
      {
        "content": "refute_instance_of ${1:UnexpectedClass}, ${2:actual_instance}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rfio": true
        },
        "options": {}
      },
      {
        "content": "refute_same ${1:unexpected}, ${2:actual}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rfs": true
        },
        "options": {}
      },
      {
        "content": "TESTS = ${1:10_000}\nBenchmark.bmbm do |results|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bm-": true
        },
        "options": {}
      },
      {
        "content": "results.report('${1:name}:') { TESTS.times { ${0} } }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rep": true
        },
        "options": {}
      },
      {
        "content": "File.open('${1:path/to/file.dump}', 'wb') { |${2:file}| Marshal.dump(${3:obj}, $2) }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Md": true
        },
        "options": {}
      },
      {
        "content": "File.open('${1:path/to/file.dump}', 'rb') { |${2:file}| Marshal.load($2) }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Ml": true
        },
        "options": {}
      },
      {
        "content": "Marshal.load(Marshal.dump(${1:obj_to_copy}))",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "deec": true
        },
        "options": {}
      },
      {
        "content": "PStore.new('${1:file_name.pstore}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Pn-": true
        },
        "options": {}
      },
      {
        "content": "transaction(${1:true}) { ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tra": true
        },
        "options": {}
      },
      {
        "content": "REXML::Document.new(File.read('${1:path/to/file}'))",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "xml-": true
        },
        "options": {}
      },
      {
        "content": "elements.each('${1://Xpath}') do |${2:node}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "xpa": true
        },
        "options": {}
      },
      {
        "content": "split('::').inject(Object) { |par, const| par.const_get(const) }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "clafn": true
        },
        "options": {}
      },
      {
        "content": "class << self; self end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sinc": true
        },
        "options": {}
      },
      {
        "content": "desc '${1:Task description}'\ntask ${2:task_name: [:dependent, :tasks]} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tas": true
        },
        "options": {}
      },
      {
        "content": "{ |${1:var}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "b": true
        },
        "options": {}
      },
      {
        "content": "begin\n\tfail 'A test exception.'\nrescue StandardError => e\n\tputs e.message\n\tputs e.backtrace.inspect\nelse\n\t# other exception\nensure\n\t# always executed\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "begin": true
        },
        "options": {}
      },
      {
        "content": "require 'byebug'; byebug",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "debug": true
        },
        "options": {}
      },
      {
        "content": "require 'debugger'; debugger",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "debug19": true
        },
        "options": {}
      },
      {
        "content": "require 'ruby-debug'; debugger",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "debug18": true
        },
        "options": {}
      },
      {
        "content": "require 'pry'; binding.pry",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pry": true
        },
        "options": {}
      },
      {
        "content": "strftime('${1:%Y-%m-%d %H:%M:%S %z}')${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "strf": true
        },
        "options": {}
      },
      {
        "content": "must_be ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mb": true
        },
        "options": {}
      },
      {
        "content": "wont_be ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wb": true
        },
        "options": {}
      },
      {
        "content": "must_be_empty",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mbe": true
        },
        "options": {}
      },
      {
        "content": "wont_be_empty",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wbe": true
        },
        "options": {}
      },
      {
        "content": "must_be_instance_of ${0:Class}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mbio": true
        },
        "options": {}
      },
      {
        "content": "wont_be_instance_of ${0:Class}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wbio": true
        },
        "options": {}
      },
      {
        "content": "must_be_kind_of ${0:Class}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mbko": true
        },
        "options": {}
      },
      {
        "content": "wont_be_kind_of ${0:Class}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wbko": true
        },
        "options": {}
      },
      {
        "content": "must_be_nil",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mbn": true
        },
        "options": {}
      },
      {
        "content": "wont_be_nil",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wbn": true
        },
        "options": {}
      },
      {
        "content": "must_be_same_as ${0:other}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mbsa": true
        },
        "options": {}
      },
      {
        "content": "wont_be_same_as ${0:other}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wbsa": true
        },
        "options": {}
      },
      {
        "content": "-> { ${0} }.must_be_silent",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mbsi": true
        },
        "options": {}
      },
      {
        "content": "must_be_within_delta ${1:0.1}, ${2:0.1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mbwd": true
        },
        "options": {}
      },
      {
        "content": "wont_be_within_delta ${1:0.1}, ${2:0.1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wbwd": true
        },
        "options": {}
      },
      {
        "content": "must_be_within_epsilon ${1:0.1}, ${2:0.1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mbwe": true
        },
        "options": {}
      },
      {
        "content": "wont_be_within_epsilon ${1:0.1}, ${2:0.1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wbwe": true
        },
        "options": {}
      },
      {
        "content": "must_equal ${0:other}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "me": true
        },
        "options": {}
      },
      {
        "content": "wont_equal ${0:other}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "we": true
        },
        "options": {}
      },
      {
        "content": "must_include ${0:what}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mi": true
        },
        "options": {}
      },
      {
        "content": "wont_include ${0:what}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wi": true
        },
        "options": {}
      },
      {
        "content": "must_match /${0:regex}/",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mm": true
        },
        "options": {}
      },
      {
        "content": "wont_match /${0:regex}/",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wm": true
        },
        "options": {}
      },
      {
        "content": "-> { ${1} }.must_output '${0}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mout": true
        },
        "options": {}
      },
      {
        "content": "-> { ${1} }.must_raise ${0:StandardError}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mra": true
        },
        "options": {}
      },
      {
        "content": "must_respond_to :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mrt": true
        },
        "options": {}
      },
      {
        "content": "wont_respond_to :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wrt": true
        },
        "options": {}
      },
      {
        "content": "must_send [ ${1:what}, :${2:method}, ${3:args} ]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "msend": true
        },
        "options": {}
      },
      {
        "content": "-> { throw :${1:error} }.must_throw :${2:error}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mthrow": true
        },
        "options": {}
      },
      {
        "content": "describe '${1:#method}' do\n\t${0:pending 'Not implemented'}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "descm": true
        },
        "options": {}
      },
      {
        "content": "context '${1:message}' do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cont": true
        },
        "options": {}
      },
      {
        "content": "before :${1:each} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bef": true
        },
        "options": {}
      },
      {
        "content": "after :${1:each} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "aft": true
        },
        "options": {}
      },
      {
        "content": "let(:${1:object}) { ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "let": true
        },
        "options": {}
      },
      {
        "content": "let!(:${1:object}) { ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "let!": true
        },
        "options": {}
      },
      {
        "content": "subject { ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "subj": true
        },
        "options": {}
      },
      {
        "content": "subject.${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "s.": true
        },
        "options": {}
      },
      {
        "content": "specify { subject.${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "spec": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:object}).to ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "exp": true
        },
        "options": {}
      },
      {
        "content": "expect { ${1:object} }.to ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "expb": true
        },
        "options": {}
      },
      {
        "content": "expect { ${1:object} }.to raise_error ${2:StandardError}, /${0:message_regex}/",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "experr": true
        },
        "options": {}
      },
      {
        "content": "allow(${1:object}).to ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "allow": true
        },
        "options": {}
      },
      {
        "content": "shared_examples ${0:'shared examples name'}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "shared": true
        },
        "options": {}
      },
      {
        "content": "it_behaves_like ${0:'shared examples name'}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ibl": true
        },
        "options": {}
      },
      {
        "content": "it '${1:spec_name}' do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "it": true
        },
        "options": {}
      },
      {
        "content": "its(:${1:method}) { should ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "its": true
        },
        "options": {}
      },
      {
        "content": "it { should ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "is": true
        },
        "options": {}
      },
      {
        "content": "it { should_not ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isn": true
        },
        "options": {}
      },
      {
        "content": "it { expect(${1:object}).${2} ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "iexp": true
        },
        "options": {}
      },
      {
        "content": "it { expect { ${1:object} }.${2} ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "iexpb": true
        },
        "options": {}
      },
      {
        "content": "it { is_expected.to ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "iiexp": true
        },
        "options": {}
      },
      {
        "content": "it { is_expected.not_to ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "iiexpn": true
        },
        "options": {}
      },
      {
        "content": "aggregate_failures '${1:message}' do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "agg": true
        },
        "options": {}
      }
    ],
    "rust": [
      {
        "content": "fn ${1:#:func_name}(${2:#:args}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "fn () {}",
        "matches": {
          "fn": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "fn ${1:#:func_name}(${2:#:args}) -> ${3:#:()} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "fn () {}",
        "matches": {
          "fn-": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "pub fn ${1:#:func_name}(${2:#:args}) -> ${3:#:()} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "pubfn () {}",
        "matches": {
          "pubfn": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "#[test]\nfn ${1:#:test_function_name}() {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "test": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "pub fn new(${1}) -> ${2:#:Name} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "pub fn new() {}",
        "matches": {
          "pubnew": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "impl ${1} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "impl": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "impl ${1} for ${2} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "implfor": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "trait ${1} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "trait": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "${1:#:macro_name}!(${2})${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "macro": true
        },
        "options": {}
      },
      {
        "content": "bitflags! {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "bitflags!",
        "matches": {
          "bfl": true
        },
        "options": {}
      },
      {
        "content": "println!(${1:\"\\{\\}\"}, ${0:TARGET});",
        "doc": "",
        "grammar": "snu",
        "label": "println!",
        "matches": {
          "pln": true
        },
        "options": {}
      },
      {
        "content": "format!(\"${1:\\{\\}}\", ${0:TARGET});",
        "doc": "",
        "grammar": "snu",
        "label": "format!",
        "matches": {
          "fm": true
        },
        "options": {}
      },
      {
        "content": "extern crate ${0:TARGET};",
        "doc": "",
        "grammar": "snu",
        "label": "extern crate",
        "matches": {
          "ec": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "#![feature(phase)]\n#[phase(plugin, link)] extern crate log;",
        "doc": "",
        "grammar": "snu",
        "label": "extern crate log",
        "matches": {
          "ecl": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "#![crate_name=${1:#:crate_name}]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "crate": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "#[derive(${1:TARGET})]${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "derive": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "mod ${1:#:mod_name} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mod": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "let ${1:TARGET} = ${2};${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "let": true
        },
        "options": {}
      },
      {
        "content": "if ${1:#:condition} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if {}",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "else {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "else": true
        },
        "options": {}
      },
      {
        "content": "} else if (${1:#:condition}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "elseif": true
        },
        "options": {}
      },
      {
        "content": "if ${1:#:condition} {\n    ${2:TARGET}\n} else {\n    ${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if () {} else {}",
        "matches": {
          "ifelse": true
        },
        "options": {}
      },
      {
        "content": "for ${1} in ${2} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "forin  {}",
        "matches": {
          "forin": true
        },
        "options": {}
      },
      {
        "content": "match ${1:TARGET} {\n    ${2:#:pattern} => ${3:#expr},${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "match": true
        },
        "options": {}
      },
      {
        "content": "${1:TARGET} => ${2:#expr},${3}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case": true,
          "mcase": true
        },
        "options": {}
      },
      {
        "content": "struct ${1} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "struct": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "pub struct ${1} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "pub struct",
        "matches": {
          "pubstruct": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "enum ${1} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "enum": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "Option<${1:()}>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "Option<A>",
        "matches": {
          "opt": true
        },
        "options": {}
      },
      {
        "content": "Result<${1:#:~str}, ${2:#:()}>${3}",
        "doc": "",
        "grammar": "snu",
        "label": "Result<A, B>",
        "matches": {
          "res": true
        },
        "options": {}
      },
      {
        "content": "fn ${1:function_name}(${2})${3} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fn \"Function definition\"": true
        },
        "options": {}
      },
      {
        "content": "pub fn ${1:function_name}(${2})${3} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pfn \"Function definition\"": true
        },
        "options": {}
      },
      {
        "content": "async fn ${1:function_name}(${2})${3} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "afn \"Async function definition\"": true
        },
        "options": {}
      },
      {
        "content": "pub async fn ${1:function_name}(${2})${3} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pafn \"Async function definition\"": true
        },
        "options": {}
      },
      {
        "content": "#[bench]\nfn ${1:bench_function_name}(b: &mut test::Bencher) {\n\tb.iter(|| {\n\t\t${0}\n\t})\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bench \"Bench function\" b": true
        },
        "options": {}
      },
      {
        "content": "pub fn new(${2}) -> ${1:Self} {\n\t$1 { ${3} }\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "new \"Constructor function\"": true
        },
        "options": {}
      },
      {
        "content": "pub fn main() {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "main \"Main function\"": true
        },
        "options": {}
      },
      {
        "content": "let ${1} = ${2};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "let \"let variable declaration with type inference\"": true
        },
        "options": {}
      },
      {
        "content": "let ${1}: ${2} = ${3};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lett \"let variable declaration with explicit type annotation\"": true
        },
        "options": {}
      },
      {
        "content": "let mut ${1} = ${2};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "letm \"let mut variable declaration with type inference\"": true
        },
        "options": {}
      },
      {
        "content": "let mut ${1}: ${2} = ${3};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lettm \"let mut variable declaration with explicit type annotation\"": true
        },
        "options": {}
      },
      {
        "content": "print!(\"${1}\");",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pri \"print!\"": true
        },
        "options": {}
      },
      {
        "content": "print!(\"${1}{${2}}\", ${3});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pri, \"print! with format param\"": true
        },
        "options": {}
      },
      {
        "content": "println!(\"${1}\");",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pln \"println!\"": true
        },
        "options": {}
      },
      {
        "content": "println!(\"${1}{${2}}\", ${3});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pln, \"println! with format param\"": true
        },
        "options": {}
      },
      {
        "content": "format!(\"${1}{${2}}\", ${3});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fmt \"format!\"": true
        },
        "options": {}
      },
      {
        "content": "dbg!(${0:${VISUAL}})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d \"dbg! debugging macro\"": true
        },
        "options": {}
      },
      {
        "content": "dbg!(&${1});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d; \"dbg! debugging macro statement\"": true
        },
        "options": {}
      },
      {
        "content": "extern crate ${1:sync};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ec \"extern crate\"": true
        },
        "options": {}
      },
      {
        "content": "#[macro_use]\nextern crate log;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ecl \"extern crate log\"": true
        },
        "options": {}
      },
      {
        "content": "assert!(${1:predicate});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as \"assert!\"": true
        },
        "options": {}
      },
      {
        "content": "assert_eq!(${1:expected}, ${2:actual});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ase \"assert_eq!\"": true
        },
        "options": {}
      },
      {
        "content": "#[test]\nfn ${1:function_name}_test() {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "test \"Unit test function\"": true
        },
        "options": {}
      },
      {
        "content": "#[cfg(test)]\nmod tests {\n\tuse super::${1:*};\n\ttest${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "testmod \"Test module\" b": true
        },
        "options": {}
      },
      {
        "content": "#[ignore]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ig \"#[ignore]\"": true
        },
        "options": {}
      },
      {
        "content": "#[allow(${1:unused_variables})]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "allow \"allow lint attribute\" b": true
        },
        "options": {}
      },
      {
        "content": "#[cfg(${1:target_os = \"linux\"})]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cfg \"cfg attribute\" b": true
        },
        "options": {}
      },
      {
        "content": "#![feature(${1:plugin})]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "feat \"feature attribute\" b": true
        },
        "options": {}
      },
      {
        "content": "#[derive(${1:Debug})]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "der \"#[derive(..)]\" b": true
        },
        "options": {}
      },
      {
        "content": "#[${1:inline}]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "attr \"#[..]\" b": true
        },
        "options": {}
      },
      {
        "content": "// Crate name\n#![crate_name = \"${1:crate_name}\"]\n// Additional metadata attributes\n#![desc = \"${2:Description.}\"]\n#![license = \"${3:BSD}\"]\n#![comment = \"${4:Comment.}\"]\n// Specify the output type\n#![crate_type = \"${5:lib}\"]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "crate \"Define create meta attributes\"": true
        },
        "options": {}
      },
      {
        "content": "Option<${1:i32}>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "opt \"Option<T>\"": true
        },
        "options": {}
      },
      {
        "content": "Result<${1:&str}, ${2:()}>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "res \"Result<T, E>\"": true
        },
        "options": {}
      },
      {
        "content": "if ${1} {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "if ${1} {\n\t${2:${VISUAL}}\n} else {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife \"if / else\"": true
        },
        "options": {}
      },
      {
        "content": "if let ${1:Some($2)} = $3 {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifl \"if let (...)\"": true
        },
        "options": {}
      },
      {
        "content": "else {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "el \"else\"": true
        },
        "options": {}
      },
      {
        "content": "else if ${1} {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eli \"else if\"": true
        },
        "options": {}
      },
      {
        "content": "match ${1} {\n\t${2} => ${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mat \"match pattern\"": true
        },
        "options": {}
      },
      {
        "content": "${1:_} => ${2:expression}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case \"Case clause of pattern match\"": true
        },
        "options": {}
      },
      {
        "content": "=> $0",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "= \"=> \"": true
        },
        "options": {}
      },
      {
        "content": "loop {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "loop \"loop {}\" b": true
        },
        "options": {}
      },
      {
        "content": "while ${1:condition} {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh \"while loop\"": true
        },
        "options": {}
      },
      {
        "content": "while let ${1:Some($2)} = $3 {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whl \"while let (...)\"": true
        },
        "options": {}
      },
      {
        "content": "for ${1:i} in ${2} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for \"for ... in ... loop\"": true
        },
        "options": {}
      },
      {
        "content": "// TODO: $0",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "todo \"TODO comment\"": true
        },
        "options": {}
      },
      {
        "content": "// FIXME: $0",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fixme \"FIXME comment\"": true
        },
        "options": {}
      },
      {
        "content": "impl ${1:Type/Trait}${2: for $3} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "impl \"Struct/Trait implementation\"": true
        },
        "options": {}
      },
      {
        "content": "type ${1:NewName} = $2;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ty \"Type alias\"": true
        },
        "options": {}
      },
      {
        "content": "enum ${1:Name} {\n\t${2},\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "enum \"enum definition\"": true
        },
        "options": {}
      },
      {
        "content": "pub enum ${1:Name} {\n\t${2},\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "penum \"pub enum definition\"": true
        },
        "options": {}
      },
      {
        "content": "trait ${1:Name} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "trait \"Trait definition\"": true
        },
        "options": {}
      },
      {
        "content": "impl Drop for $1 {\n\tfn drop(&mut self) {\n\t\t${0}\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "drop \"Drop trait implementation (destructor)\"": true
        },
        "options": {}
      },
      {
        "content": "static ${1}: &'static str = \"${0}\";",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ss \"static string declaration\"": true
        },
        "options": {}
      },
      {
        "content": "static ${1}: ${2:usize} = ${0};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "stat \"static item declaration\"": true
        },
        "options": {}
      },
      {
        "content": "thread::spawn(${1:move }|| {\n\t${0}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "spawn \"spawn a thread\"": true
        },
        "options": {}
      },
      {
        "content": "let (${1:tx}, ${2:rx}): (Sender<${3:i32}>, Receiver<${4:i32}>) = channel();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "chan \"Declare (Sender, Receiver) pair of asynchronous channel()\"": true
        },
        "options": {}
      },
      {
        "content": "impl AsRef<${1:Ref}> for ${2:Type} {\n\tfn as_ref(&self) -> &${3:$1} {\n\t\t&self.${0:field}\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asref \"AsRef trait implementation\"": true
        },
        "options": {}
      },
      {
        "content": "impl AsMut<${1:Ref}> for ${2:Type} {\n\tfn as_mut(&mut self) -> &mut ${3:$1} {\n\t\t&mut self.${0:field}\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "asmut \"AsMut trait implementation\"": true
        },
        "options": {}
      },
      {
        "content": "${1:name}: ${2:Type},",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fd \"Struct field definition\" w": true
        },
        "options": {}
      },
      {
        "content": "${1:move }|$2| { $3 }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "|| \"Closure, anonymous function (inline)\" i": true
        },
        "options": {}
      },
      {
        "content": "${1:move }|$2| {\n\t$3\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "|} \"Closure, anonymous function (block)\" i": true
        },
        "options": {}
      },
      {
        "content": "macro_rules! ${1:name} {\n\t(${2:matcher}) => (\n\t\t$3\n\t)\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "macro \"macro_rules!\" b": true
        },
        "options": {}
      },
      {
        "content": "Box::new(${0:${VISUAL}})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "boxp \"Box::new()\"": true
        },
        "options": {}
      },
      {
        "content": "Rc::new(${0:${VISUAL}})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rc \"Rc::new()\"": true
        },
        "options": {}
      },
      {
        "content": "unimplemented!()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "unim \"unimplemented!()\"": true
        },
        "options": {}
      },
      {
        "content": "use ${1:std::$2};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "use \"use ...;\" b": true
        },
        "options": {}
      },
      {
        "content": ".iter()$0",
        "doc": "",
        "grammar": "snu",
        "label": ".iter()",
        "matches": {
          ".it": true
        },
        "options": {
          "i": true
        }
      },
      {
        "content": "impl$4 ${1:Type/Trait}${2: for ${3:Type}}${4:<${5:T}>} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "Struct/Trait implementation",
        "matches": {
          "impl": true
        },
        "options": {
          "b": true
        }
      }
    ],
    "sass": [
      {
        "content": "$${1:variable}: ${0:value}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "$": true
        },
        "options": {}
      },
      {
        "content": "@import '${0}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "imp": true
        },
        "options": {}
      },
      {
        "content": "=${1:name}(${2})\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mix": true
        },
        "options": {}
      },
      {
        "content": "+${1:mixin}(${2})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "inc": true
        },
        "options": {}
      },
      {
        "content": "@extend ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ext": true
        },
        "options": {}
      },
      {
        "content": "@function ${1:name}(${2:args})\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fun": true
        },
        "options": {}
      },
      {
        "content": "@if ${1:condition}\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "@if ${1:condition}\n\t${2:${VISUAL}}\n@else\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "@else if ${1:condition}\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eif": true
        },
        "options": {}
      },
      {
        "content": "@for ${1:$i} from ${2:1} through ${3:3}\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "@each ${1:$item} in ${2:items}\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "each": true
        },
        "options": {}
      },
      {
        "content": "@while ${1:$i} ${2:>} ${3:0}\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "while": true
        },
        "options": {}
      },
      {
        "content": "!important",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "!": true
        },
        "options": {}
      },
      {
        "content": "align-content: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac": true
        },
        "options": {}
      },
      {
        "content": "align-content: start",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:s": true
        },
        "options": {}
      },
      {
        "content": "align-content: end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:e": true
        },
        "options": {}
      },
      {
        "content": "align-content: center",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:c": true
        },
        "options": {}
      },
      {
        "content": "align-content: flex-start",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:fs": true
        },
        "options": {}
      },
      {
        "content": "align-content: flex-end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:fe": true
        },
        "options": {}
      },
      {
        "content": "align-content: space-between",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:sb": true
        },
        "options": {}
      },
      {
        "content": "align-content: space-around",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:sa": true
        },
        "options": {}
      },
      {
        "content": "align-content: space-evenly",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:se": true
        },
        "options": {}
      },
      {
        "content": "align-content: stretch",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:st": true
        },
        "options": {}
      },
      {
        "content": "align-content: baseline",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:b": true
        },
        "options": {}
      },
      {
        "content": "align-content: first baseline",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:fb": true
        },
        "options": {}
      },
      {
        "content": "align-content: last baseline",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:lb": true
        },
        "options": {}
      },
      {
        "content": "align-items: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ai": true
        },
        "options": {}
      },
      {
        "content": "align-items: start",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ai:s": true
        },
        "options": {}
      },
      {
        "content": "align-items: end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ai:e": true
        },
        "options": {}
      },
      {
        "content": "align-items: center",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ai:c": true
        },
        "options": {}
      },
      {
        "content": "align-items: flex-start",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ai:fs": true
        },
        "options": {}
      },
      {
        "content": "align-items: flex-end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ai:fe": true
        },
        "options": {}
      },
      {
        "content": "align-items: stretch",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ai:st": true
        },
        "options": {}
      },
      {
        "content": "align-items: baseline",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ai:b": true
        },
        "options": {}
      },
      {
        "content": "align-items: first baseline",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ai:fb": true
        },
        "options": {}
      },
      {
        "content": "align-items: last baseline",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ai:lb": true
        },
        "options": {}
      },
      {
        "content": "align-self: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as": true
        },
        "options": {}
      },
      {
        "content": "align-self: start",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as:s": true
        },
        "options": {}
      },
      {
        "content": "align-self: end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as:e": true
        },
        "options": {}
      },
      {
        "content": "align-self: center",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as:c": true
        },
        "options": {}
      },
      {
        "content": "align-self: stretch",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as:st": true
        },
        "options": {}
      },
      {
        "content": "align-self: flex-start",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as:fs": true
        },
        "options": {}
      },
      {
        "content": "align-self: flex-end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as:fe": true
        },
        "options": {}
      },
      {
        "content": "align-self: baseline",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as:b": true
        },
        "options": {}
      },
      {
        "content": "align-self: first baseline",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as:fb": true
        },
        "options": {}
      },
      {
        "content": "align-self: last baseline",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as:lb": true
        },
        "options": {}
      },
      {
        "content": "-moz-border-image: url('${1}') ${2:0} ${3:0} ${4:0} ${5:0} ${6:stretch} ${0:stretch}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdi:m+": true
        },
        "options": {}
      },
      {
        "content": "-moz-border-image: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdi:m": true
        },
        "options": {}
      },
      {
        "content": "-moz-border-radius: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdrz:m": true
        },
        "options": {}
      },
      {
        "content": "-moz-box-shadow: ${1:0} ${2:0} ${3:0} #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bxsh:m+": true
        },
        "options": {}
      },
      {
        "content": "-moz-box-shadow: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bxsh:m": true
        },
        "options": {}
      },
      {
        "content": "-webkit-border-image: url('${1}') ${2:0} ${3:0} ${4:0} ${5:0} ${6:stretch} ${0:stretch}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdi:w+": true
        },
        "options": {}
      },
      {
        "content": "-webkit-border-image: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdi:w": true
        },
        "options": {}
      },
      {
        "content": "-webkit-border-radius: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdrz:w": true
        },
        "options": {}
      },
      {
        "content": "-webkit-box-shadow: ${1:0} ${2:0} ${3:0} #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bxsh:w+": true
        },
        "options": {}
      },
      {
        "content": "-webkit-box-shadow: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bxsh:w": true
        },
        "options": {}
      },
      {
        "content": "@font-face\n\tfont-family: ${1}\n\tsrc: url('${0}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@f": true
        },
        "options": {}
      },
      {
        "content": "@import url('${0}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@i": true
        },
        "options": {}
      },
      {
        "content": "@media ${1:print}\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@m": true
        },
        "options": {}
      },
      {
        "content": "background: #${1:fff} url('${2}') ${3:0} ${4:0} ${0:no-repeat}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bg+": true
        },
        "options": {}
      },
      {
        "content": "background-attachment: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bga": true
        },
        "options": {}
      },
      {
        "content": "background-attachment: fixed",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bga:f": true
        },
        "options": {}
      },
      {
        "content": "background-attachment: scroll",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bga:s": true
        },
        "options": {}
      },
      {
        "content": "background-break: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgbk": true
        },
        "options": {}
      },
      {
        "content": "background-break: bounding-box",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgbk:bb": true
        },
        "options": {}
      },
      {
        "content": "background-break: continuous",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgbk:c": true
        },
        "options": {}
      },
      {
        "content": "background-break: each-box",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgbk:eb": true
        },
        "options": {}
      },
      {
        "content": "background-clip: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgcp": true
        },
        "options": {}
      },
      {
        "content": "background-clip: border-box",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgcp:bb": true
        },
        "options": {}
      },
      {
        "content": "background-clip: content-box",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgcp:cb": true
        },
        "options": {}
      },
      {
        "content": "background-clip: no-clip",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgcp:nc": true
        },
        "options": {}
      },
      {
        "content": "background-clip: padding-box",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgcp:pb": true
        },
        "options": {}
      },
      {
        "content": "background-color: #${0:fff}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgc": true
        },
        "options": {}
      },
      {
        "content": "background-color: transparent",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgc:t": true
        },
        "options": {}
      },
      {
        "content": "background-image: url('${0}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgi": true
        },
        "options": {}
      },
      {
        "content": "background-image: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgi:n": true
        },
        "options": {}
      },
      {
        "content": "background-origin: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgo": true
        },
        "options": {}
      },
      {
        "content": "background-origin: border-box",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgo:bb": true
        },
        "options": {}
      },
      {
        "content": "background-origin: content-box",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgo:cb": true
        },
        "options": {}
      },
      {
        "content": "background-origin: padding-box",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgo:pb": true
        },
        "options": {}
      },
      {
        "content": "background-position-x: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgpx": true
        },
        "options": {}
      },
      {
        "content": "background-position-y: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgpy": true
        },
        "options": {}
      },
      {
        "content": "background-position: ${1:0} ${0:0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgp": true
        },
        "options": {}
      },
      {
        "content": "background-repeat: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgr": true
        },
        "options": {}
      },
      {
        "content": "background-repeat: no-repeat",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgr:n": true
        },
        "options": {}
      },
      {
        "content": "background-repeat: repeat-x",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgr:x": true
        },
        "options": {}
      },
      {
        "content": "background-repeat: repeat-y",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgr:y": true
        },
        "options": {}
      },
      {
        "content": "background-repeat: repeat",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgr:r": true
        },
        "options": {}
      },
      {
        "content": "background-size: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgz": true
        },
        "options": {}
      },
      {
        "content": "background-size: auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgz:a": true
        },
        "options": {}
      },
      {
        "content": "background-size: contain",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgz:ct": true
        },
        "options": {}
      },
      {
        "content": "background-size: cover",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgz:cv": true
        },
        "options": {}
      },
      {
        "content": "background: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bg": true
        },
        "options": {}
      },
      {
        "content": "filter: progid:DXImageTransform.Microsoft.AlphaImageLoader(src='${1}',sizingMethod='${0:crop}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bg:ie": true
        },
        "options": {}
      },
      {
        "content": "background: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bg:n": true
        },
        "options": {}
      },
      {
        "content": "border: ${1:1px} ${2:solid} #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bd+": true
        },
        "options": {}
      },
      {
        "content": "border-bottom: ${1:1px} ${2:solid} #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdb+": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-color: #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbc": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-image: url('${0}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbi": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-image: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbi:n": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-left-image: url('${0}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbli": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-left-image: continue",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbli:c": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-left-image: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbli:n": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-left-radius: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdblrz": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-right-image: url('${0}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbri": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-right-image: continue",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbri:c": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-right-image: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbri:n": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-right-radius: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbrrz": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-style: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbs": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-style: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbs:n": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-width: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbw": true
        },
        "options": {}
      },
      {
        "content": "border-bottom: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdb": true
        },
        "options": {}
      },
      {
        "content": "border-bottom: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdb:n": true
        },
        "options": {}
      },
      {
        "content": "border-break: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbk": true
        },
        "options": {}
      },
      {
        "content": "border-break: close",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbk:c": true
        },
        "options": {}
      },
      {
        "content": "border-collapse: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdcl": true
        },
        "options": {}
      },
      {
        "content": "border-collapse: collapse",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdcl:c": true
        },
        "options": {}
      },
      {
        "content": "border-collapse: separate",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdcl:s": true
        },
        "options": {}
      },
      {
        "content": "border-color: #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdc": true
        },
        "options": {}
      },
      {
        "content": "border-corner-image: url('${0}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdci": true
        },
        "options": {}
      },
      {
        "content": "border-corner-image: continue",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdci:c": true
        },
        "options": {}
      },
      {
        "content": "border-corner-image: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdci:n": true
        },
        "options": {}
      },
      {
        "content": "border-fit: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdf": true
        },
        "options": {}
      },
      {
        "content": "border-fit: clip",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdf:c": true
        },
        "options": {}
      },
      {
        "content": "border-fit: overwrite",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdf:of": true
        },
        "options": {}
      },
      {
        "content": "border-fit: overwrite",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdf:ow": true
        },
        "options": {}
      },
      {
        "content": "border-fit: repeat",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdf:r": true
        },
        "options": {}
      },
      {
        "content": "border-fit: scale",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdf:sc": true
        },
        "options": {}
      },
      {
        "content": "border-fit: space",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdf:sp": true
        },
        "options": {}
      },
      {
        "content": "border-fit: stretch",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdf:st": true
        },
        "options": {}
      },
      {
        "content": "border-image: url('${1}') ${2:0} ${3:0} ${4:0} ${5:0} ${6:stretch} ${0:stretch}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdi": true
        },
        "options": {}
      },
      {
        "content": "border-image: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdi:n": true
        },
        "options": {}
      },
      {
        "content": "border-left: ${1:1px} ${2:solid} #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdl+": true
        },
        "options": {}
      },
      {
        "content": "border-left-color: #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdlc": true
        },
        "options": {}
      },
      {
        "content": "border-left-image: url('${0}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdli": true
        },
        "options": {}
      },
      {
        "content": "border-left-image: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdli:n": true
        },
        "options": {}
      },
      {
        "content": "border-left-style: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdls": true
        },
        "options": {}
      },
      {
        "content": "border-left-style: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdls:n": true
        },
        "options": {}
      },
      {
        "content": "border-left-width: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdlw": true
        },
        "options": {}
      },
      {
        "content": "border-left: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdl": true
        },
        "options": {}
      },
      {
        "content": "border-left: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdl:n": true
        },
        "options": {}
      },
      {
        "content": "border-length: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdlt": true
        },
        "options": {}
      },
      {
        "content": "border-length: auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdlt:a": true
        },
        "options": {}
      },
      {
        "content": "border-radius: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdrz": true
        },
        "options": {}
      },
      {
        "content": "border-right: ${1:1px} ${2:solid} #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdr+": true
        },
        "options": {}
      },
      {
        "content": "border-right-color: #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdrc": true
        },
        "options": {}
      },
      {
        "content": "border-right-image: url('${0}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdri": true
        },
        "options": {}
      },
      {
        "content": "border-right-image: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdri:n": true
        },
        "options": {}
      },
      {
        "content": "border-right-style: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdrs": true
        },
        "options": {}
      },
      {
        "content": "border-right-style: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdrs:n": true
        },
        "options": {}
      },
      {
        "content": "border-right-width: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdrw": true
        },
        "options": {}
      },
      {
        "content": "border-right: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdr": true
        },
        "options": {}
      },
      {
        "content": "border-right: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdr:n": true
        },
        "options": {}
      },
      {
        "content": "border-spacing: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdsp": true
        },
        "options": {}
      },
      {
        "content": "border-style: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds": true
        },
        "options": {}
      },
      {
        "content": "border-style: dashed",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:ds": true
        },
        "options": {}
      },
      {
        "content": "border-style: dot-dash",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:dtds": true
        },
        "options": {}
      },
      {
        "content": "border-style: dot-dot-dash",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:dtdtds": true
        },
        "options": {}
      },
      {
        "content": "border-style: dotted",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:dt": true
        },
        "options": {}
      },
      {
        "content": "border-style: double",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:db": true
        },
        "options": {}
      },
      {
        "content": "border-style: groove",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:g": true
        },
        "options": {}
      },
      {
        "content": "border-style: hidden",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:h": true
        },
        "options": {}
      },
      {
        "content": "border-style: inset",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:i": true
        },
        "options": {}
      },
      {
        "content": "border-style: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:n": true
        },
        "options": {}
      },
      {
        "content": "border-style: outset",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:o": true
        },
        "options": {}
      },
      {
        "content": "border-style: ridge",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:r": true
        },
        "options": {}
      },
      {
        "content": "border-style: solid",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:s": true
        },
        "options": {}
      },
      {
        "content": "border-style: wave",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:w": true
        },
        "options": {}
      },
      {
        "content": "border-top: ${1:1px} ${2:solid} #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdt+": true
        },
        "options": {}
      },
      {
        "content": "border-top-color: #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdtc": true
        },
        "options": {}
      },
      {
        "content": "border-top-image: url('${0}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdti": true
        },
        "options": {}
      },
      {
        "content": "border-top-image: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdti:n": true
        },
        "options": {}
      },
      {
        "content": "border-top-left-image: url('${0}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdtli": true
        },
        "options": {}
      },
      {
        "content": "border-corner-image: continue",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdtli:c": true
        },
        "options": {}
      },
      {
        "content": "border-corner-image: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdtli:n": true
        },
        "options": {}
      },
      {
        "content": "border-top-left-radius: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdtlrz": true
        },
        "options": {}
      },
      {
        "content": "border-top-right-image: url('${0}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdtri": true
        },
        "options": {}
      },
      {
        "content": "border-top-right-image: continue",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdtri:c": true
        },
        "options": {}
      },
      {
        "content": "border-top-right-image: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdtri:n": true
        },
        "options": {}
      },
      {
        "content": "border-top-right-radius: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdtrrz": true
        },
        "options": {}
      },
      {
        "content": "border-top-style: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdts": true
        },
        "options": {}
      },
      {
        "content": "border-top-style: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdts:n": true
        },
        "options": {}
      },
      {
        "content": "border-top-width: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdtw": true
        },
        "options": {}
      },
      {
        "content": "border-top: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdt": true
        },
        "options": {}
      },
      {
        "content": "border-top: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdt:n": true
        },
        "options": {}
      },
      {
        "content": "border-width: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdw": true
        },
        "options": {}
      },
      {
        "content": "border: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bd": true
        },
        "options": {}
      },
      {
        "content": "border: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bd:n": true
        },
        "options": {}
      },
      {
        "content": "bottom: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "b": true
        },
        "options": {}
      },
      {
        "content": "bottom: auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "b:a": true
        },
        "options": {}
      },
      {
        "content": "box-shadow: ${1:0} ${2:0} ${3:0} #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bxsh+": true
        },
        "options": {}
      },
      {
        "content": "box-shadow: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bxsh": true
        },
        "options": {}
      },
      {
        "content": "box-shadow: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bxsh:n": true
        },
        "options": {}
      },
      {
        "content": "box-sizing: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bxz": true
        },
        "options": {}
      },
      {
        "content": "box-sizing: border-box",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bxz:bb": true
        },
        "options": {}
      },
      {
        "content": "box-sizing: content-box",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bxz:cb": true
        },
        "options": {}
      },
      {
        "content": "caption-side: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cps": true
        },
        "options": {}
      },
      {
        "content": "caption-side: bottom",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cps:b": true
        },
        "options": {}
      },
      {
        "content": "caption-side: top",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cps:t": true
        },
        "options": {}
      },
      {
        "content": "clear: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cl": true
        },
        "options": {}
      },
      {
        "content": "clear: both",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cl:b": true
        },
        "options": {}
      },
      {
        "content": "clear: left",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cl:l": true
        },
        "options": {}
      },
      {
        "content": "clear: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cl:n": true
        },
        "options": {}
      },
      {
        "content": "clear: right",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cl:r": true
        },
        "options": {}
      },
      {
        "content": "clip: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cp": true
        },
        "options": {}
      },
      {
        "content": "clip: auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cp:a": true
        },
        "options": {}
      },
      {
        "content": "clip: rect(${1:0} ${2:0} ${3:0} ${0:0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cp:r": true
        },
        "options": {}
      },
      {
        "content": "color: #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "c": true
        },
        "options": {}
      },
      {
        "content": "content: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ct": true
        },
        "options": {}
      },
      {
        "content": "content: attr(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ct:a": true
        },
        "options": {}
      },
      {
        "content": "content: close-quote",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ct:cq": true
        },
        "options": {}
      },
      {
        "content": "content: counter(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ct:c": true
        },
        "options": {}
      },
      {
        "content": "content: counters(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ct:cs": true
        },
        "options": {}
      },
      {
        "content": "content: no-close-quote",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ct:ncq": true
        },
        "options": {}
      },
      {
        "content": "content: no-open-quote",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ct:noq": true
        },
        "options": {}
      },
      {
        "content": "content: normal",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ct:n": true
        },
        "options": {}
      },
      {
        "content": "content: open-quote",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ct:oq": true
        },
        "options": {}
      },
      {
        "content": "counter-increment: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "coi": true
        },
        "options": {}
      },
      {
        "content": "counter-reset: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cor": true
        },
        "options": {}
      },
      {
        "content": "cursor: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cur": true
        },
        "options": {}
      },
      {
        "content": "cursor: auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cur:a": true
        },
        "options": {}
      },
      {
        "content": "cursor: crosshair",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cur:c": true
        },
        "options": {}
      },
      {
        "content": "cursor: default",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cur:d": true
        },
        "options": {}
      },
      {
        "content": "cursor: hand",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cur:ha": true
        },
        "options": {}
      },
      {
        "content": "cursor: help",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cur:he": true
        },
        "options": {}
      },
      {
        "content": "cursor: move",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cur:m": true
        },
        "options": {}
      },
      {
        "content": "cursor: pointer",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cur:p": true
        },
        "options": {}
      },
      {
        "content": "cursor: text",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cur:t": true
        },
        "options": {}
      },
      {
        "content": "display: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d": true
        },
        "options": {}
      },
      {
        "content": "display: -moz-inline-box",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:mib": true
        },
        "options": {}
      },
      {
        "content": "display: -moz-inline-stack",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:mis": true
        },
        "options": {}
      },
      {
        "content": "display: block",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:b": true
        },
        "options": {}
      },
      {
        "content": "display: compact",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:cp": true
        },
        "options": {}
      },
      {
        "content": "display: grid",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:g": true
        },
        "options": {}
      },
      {
        "content": "display: flex",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:f": true
        },
        "options": {}
      },
      {
        "content": "display: inline-block",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:ib": true
        },
        "options": {}
      },
      {
        "content": "display: inline-table",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:itb": true
        },
        "options": {}
      },
      {
        "content": "display: inline",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:i": true
        },
        "options": {}
      },
      {
        "content": "display: list-item",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:li": true
        },
        "options": {}
      },
      {
        "content": "display: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:n": true
        },
        "options": {}
      },
      {
        "content": "display: run-in",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:ri": true
        },
        "options": {}
      },
      {
        "content": "display: table-caption",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:tbcp": true
        },
        "options": {}
      },
      {
        "content": "display: table-cell",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:tbc": true
        },
        "options": {}
      },
      {
        "content": "display: table-column-group",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:tbclg": true
        },
        "options": {}
      },
      {
        "content": "display: table-column",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:tbcl": true
        },
        "options": {}
      },
      {
        "content": "display: table-footer-group",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:tbfg": true
        },
        "options": {}
      },
      {
        "content": "display: table-header-group",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:tbhg": true
        },
        "options": {}
      },
      {
        "content": "display: table-row-group",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:tbrg": true
        },
        "options": {}
      },
      {
        "content": "display: table-row",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:tbr": true
        },
        "options": {}
      },
      {
        "content": "display: table",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:tb": true
        },
        "options": {}
      },
      {
        "content": "empty-cells: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ec": true
        },
        "options": {}
      },
      {
        "content": "empty-cells: hide",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ec:h": true
        },
        "options": {}
      },
      {
        "content": "empty-cells: show",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ec:s": true
        },
        "options": {}
      },
      {
        "content": "expression()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "exp": true
        },
        "options": {}
      },
      {
        "content": "float: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fl": true
        },
        "options": {}
      },
      {
        "content": "float: left",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fl:l": true
        },
        "options": {}
      },
      {
        "content": "float: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fl:n": true
        },
        "options": {}
      },
      {
        "content": "float: right",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fl:r": true
        },
        "options": {}
      },
      {
        "content": "font: ${1:1em} ${2:Arial},${0:sans-serif}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "f+": true
        },
        "options": {}
      },
      {
        "content": "font-effect: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fef": true
        },
        "options": {}
      },
      {
        "content": "font-effect: emboss",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fef:eb": true
        },
        "options": {}
      },
      {
        "content": "font-effect: engrave",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fef:eg": true
        },
        "options": {}
      },
      {
        "content": "font-effect: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fef:n": true
        },
        "options": {}
      },
      {
        "content": "font-effect: outline",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fef:o": true
        },
        "options": {}
      },
      {
        "content": "font-emphasize-position: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "femp": true
        },
        "options": {}
      },
      {
        "content": "font-emphasize-position: after",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "femp:a": true
        },
        "options": {}
      },
      {
        "content": "font-emphasize-position: before",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "femp:b": true
        },
        "options": {}
      },
      {
        "content": "font-emphasize-style: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fems": true
        },
        "options": {}
      },
      {
        "content": "font-emphasize-style: accent",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fems:ac": true
        },
        "options": {}
      },
      {
        "content": "font-emphasize-style: circle",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fems:c": true
        },
        "options": {}
      },
      {
        "content": "font-emphasize-style: disc",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fems:ds": true
        },
        "options": {}
      },
      {
        "content": "font-emphasize-style: dot",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fems:dt": true
        },
        "options": {}
      },
      {
        "content": "font-emphasize-style: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fems:n": true
        },
        "options": {}
      },
      {
        "content": "font-emphasize: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fem": true
        },
        "options": {}
      },
      {
        "content": "font-family: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ff": true
        },
        "options": {}
      },
      {
        "content": "font-family: ${0:'Monotype Corsiva','Comic Sans MS'},cursive",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ff:c": true
        },
        "options": {}
      },
      {
        "content": "font-family: ${0:Capitals,Impact},fantasy",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ff:f": true
        },
        "options": {}
      },
      {
        "content": "font-family: ${0:Monaco,'Courier New'},monospace",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ff:m": true
        },
        "options": {}
      },
      {
        "content": "font-family: ${0:Helvetica,Arial},sans-serif",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ff:ss": true
        },
        "options": {}
      },
      {
        "content": "font-family: ${0:Georgia,'Times New Roman'},serif",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ff:s": true
        },
        "options": {}
      },
      {
        "content": "font-size-adjust: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fza": true
        },
        "options": {}
      },
      {
        "content": "font-size-adjust: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fza:n": true
        },
        "options": {}
      },
      {
        "content": "font-size: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fz": true
        },
        "options": {}
      },
      {
        "content": "font-smooth: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fsm": true
        },
        "options": {}
      },
      {
        "content": "font-smooth: always",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fsm:aw": true
        },
        "options": {}
      },
      {
        "content": "font-smooth: auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fsm:a": true
        },
        "options": {}
      },
      {
        "content": "font-smooth: never",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fsm:n": true
        },
        "options": {}
      },
      {
        "content": "font-stretch: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fst": true
        },
        "options": {}
      },
      {
        "content": "font-stretch: condensed",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fst:c": true
        },
        "options": {}
      },
      {
        "content": "font-stretch: expanded",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fst:e": true
        },
        "options": {}
      },
      {
        "content": "font-stretch: extra-condensed",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fst:ec": true
        },
        "options": {}
      },
      {
        "content": "font-stretch: extra-expanded",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fst:ee": true
        },
        "options": {}
      },
      {
        "content": "font-stretch: normal",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fst:n": true
        },
        "options": {}
      },
      {
        "content": "font-stretch: semi-condensed",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fst:sc": true
        },
        "options": {}
      },
      {
        "content": "font-stretch: semi-expanded",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fst:se": true
        },
        "options": {}
      },
      {
        "content": "font-stretch: ultra-condensed",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fst:uc": true
        },
        "options": {}
      },
      {
        "content": "font-stretch: ultra-expanded",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fst:ue": true
        },
        "options": {}
      },
      {
        "content": "font-style: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fs": true
        },
        "options": {}
      },
      {
        "content": "font-style: italic",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fs:i": true
        },
        "options": {}
      },
      {
        "content": "font-style: normal",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fs:n": true
        },
        "options": {}
      },
      {
        "content": "font-style: oblique",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fs:o": true
        },
        "options": {}
      },
      {
        "content": "font-variant: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fv": true
        },
        "options": {}
      },
      {
        "content": "font-variant: normal",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fv:n": true
        },
        "options": {}
      },
      {
        "content": "font-variant: small-caps",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fv:sc": true
        },
        "options": {}
      },
      {
        "content": "font-weight: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fw": true
        },
        "options": {}
      },
      {
        "content": "font-weight: bold",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fw:b": true
        },
        "options": {}
      },
      {
        "content": "font-weight: bolder",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fw:br": true
        },
        "options": {}
      },
      {
        "content": "font-weight: lighter",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fw:lr": true
        },
        "options": {}
      },
      {
        "content": "font-weight: normal",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fw:n": true
        },
        "options": {}
      },
      {
        "content": "font: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "f": true
        },
        "options": {}
      },
      {
        "content": "grid: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "g": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-flow: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gaf": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-flow: ${1:row} ${0:dense}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gaf+": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-flow: row",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gaf:r": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-flow: column",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gaf:c": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-flow: dense",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gaf:d": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-flow: row dense",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gaf:rd": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-flow: column dense",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gaf:cd": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-rows: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gar": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-rows: auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gar:a": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-rows: max-content",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gar:mac": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-rows: min-content",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gar:mic": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-columns: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gac": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-columns: auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gac:a": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-columns: max-content",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gac:mac": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-columns: min-content",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gac:mic": true
        },
        "options": {}
      },
      {
        "content": "grid-template: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gt": true
        },
        "options": {}
      },
      {
        "content": "grid-template: ${1} / ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gt+": true
        },
        "options": {}
      },
      {
        "content": "grid-template-rows: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gtr": true
        },
        "options": {}
      },
      {
        "content": "grid-template-columns: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gtc": true
        },
        "options": {}
      },
      {
        "content": "grid-template-areas: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gta": true
        },
        "options": {}
      },
      {
        "content": "grid-gap: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gg": true
        },
        "options": {}
      },
      {
        "content": "grid-gap: ${1} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gg+": true
        },
        "options": {}
      },
      {
        "content": "grid-gap: 0",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gg:0": true
        },
        "options": {}
      },
      {
        "content": "grid-row-gap: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "grg": true
        },
        "options": {}
      },
      {
        "content": "grid-row-gap: 0",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "grg:0": true
        },
        "options": {}
      },
      {
        "content": "grid-column-gap: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gcg": true
        },
        "options": {}
      },
      {
        "content": "grid-column-gap: 0",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gcg:0": true
        },
        "options": {}
      },
      {
        "content": "grid-row: ${1} / ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gr": true
        },
        "options": {}
      },
      {
        "content": "grid-row-start: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "grs": true
        },
        "options": {}
      },
      {
        "content": "grid-row-end: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gre": true
        },
        "options": {}
      },
      {
        "content": "grid-column: ${1} / ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gc": true
        },
        "options": {}
      },
      {
        "content": "grid-column-start: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gcs": true
        },
        "options": {}
      },
      {
        "content": "grid-column-end: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gce": true
        },
        "options": {}
      },
      {
        "content": "height: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "h": true
        },
        "options": {}
      },
      {
        "content": "height: auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "h:a": true
        },
        "options": {}
      },
      {
        "content": "justify-content: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc": true
        },
        "options": {}
      },
      {
        "content": "justify-content: start",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc:s": true
        },
        "options": {}
      },
      {
        "content": "justify-content: end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc:e": true
        },
        "options": {}
      },
      {
        "content": "justify-content: center",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc:c": true
        },
        "options": {}
      },
      {
        "content": "justify-content: flex-start",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc:fs": true
        },
        "options": {}
      },
      {
        "content": "justify-content: flex-end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc:fe": true
        },
        "options": {}
      },
      {
        "content": "justify-content: space-between",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc:sb": true
        },
        "options": {}
      },
      {
        "content": "justify-content: space-around",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc:sa": true
        },
        "options": {}
      },
      {
        "content": "justify-content: space-evenly",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc:se": true
        },
        "options": {}
      },
      {
        "content": "justify-content: stretch",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc:st": true
        },
        "options": {}
      },
      {
        "content": "justify-content: left",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc:l": true
        },
        "options": {}
      },
      {
        "content": "justify-content: right",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc:r": true
        },
        "options": {}
      },
      {
        "content": "justify-items: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ji": true
        },
        "options": {}
      },
      {
        "content": "justify-items: start",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ji:s": true
        },
        "options": {}
      },
      {
        "content": "justify-items: end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ji:e": true
        },
        "options": {}
      },
      {
        "content": "justify-items: center",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ji:c": true
        },
        "options": {}
      },
      {
        "content": "justify-items: stretch",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ji:st": true
        },
        "options": {}
      },
      {
        "content": "justify-self: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "js": true
        },
        "options": {}
      },
      {
        "content": "justify-self: start",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "js:s": true
        },
        "options": {}
      },
      {
        "content": "justify-self: end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "js:e": true
        },
        "options": {}
      },
      {
        "content": "justify-self: center",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "js:c": true
        },
        "options": {}
      },
      {
        "content": "justify-self: stretch",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "js:st": true
        },
        "options": {}
      },
      {
        "content": "left: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "l": true
        },
        "options": {}
      },
      {
        "content": "left: auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "l:a": true
        },
        "options": {}
      },
      {
        "content": "letter-spacing: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lts": true
        },
        "options": {}
      },
      {
        "content": "line-height: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lh": true
        },
        "options": {}
      },
      {
        "content": "list-style-image: url('${0}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lisi": true
        },
        "options": {}
      },
      {
        "content": "list-style-image: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lisi:n": true
        },
        "options": {}
      },
      {
        "content": "list-style-position: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lisp": true
        },
        "options": {}
      },
      {
        "content": "list-style-position: inside",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lisp:i": true
        },
        "options": {}
      },
      {
        "content": "list-style-position: outside",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lisp:o": true
        },
        "options": {}
      },
      {
        "content": "list-style-type: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list": true
        },
        "options": {}
      },
      {
        "content": "list-style-type: circle",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list:c": true
        },
        "options": {}
      },
      {
        "content": "list-style-type: decimal-leading-zero",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list:dclz": true
        },
        "options": {}
      },
      {
        "content": "list-style-type: decimal",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list:dc": true
        },
        "options": {}
      },
      {
        "content": "list-style-type: disc",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list:d": true
        },
        "options": {}
      },
      {
        "content": "list-style-type: lower-roman",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list:lr": true
        },
        "options": {}
      },
      {
        "content": "list-style-type: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list:n": true
        },
        "options": {}
      },
      {
        "content": "list-style-type: square",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list:s": true
        },
        "options": {}
      },
      {
        "content": "list-style-type: upper-roman",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list:ur": true
        },
        "options": {}
      },
      {
        "content": "list-style: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lis": true
        },
        "options": {}
      },
      {
        "content": "list-style: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lis:n": true
        },
        "options": {}
      },
      {
        "content": "margin-bottom: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mb": true
        },
        "options": {}
      },
      {
        "content": "margin-bottom: auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mb:a": true
        },
        "options": {}
      },
      {
        "content": "margin-left: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ml": true
        },
        "options": {}
      },
      {
        "content": "margin-left: auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ml:a": true
        },
        "options": {}
      },
      {
        "content": "margin-right: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mr": true
        },
        "options": {}
      },
      {
        "content": "margin-right: auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mr:a": true
        },
        "options": {}
      },
      {
        "content": "margin-top: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mt": true
        },
        "options": {}
      },
      {
        "content": "margin-top: auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mt:a": true
        },
        "options": {}
      },
      {
        "content": "margin: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "m": true
        },
        "options": {}
      },
      {
        "content": "margin: ${1:0} ${2:0} ${3:0} ${0:0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "m:4": true
        },
        "options": {}
      },
      {
        "content": "margin: ${1:0} ${2:0} ${0:0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "m:3": true
        },
        "options": {}
      },
      {
        "content": "margin: ${1:0} ${0:0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "m:2": true
        },
        "options": {}
      },
      {
        "content": "margin: 0",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "m:0": true
        },
        "options": {}
      },
      {
        "content": "margin: auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "m:a": true
        },
        "options": {}
      },
      {
        "content": "max-height: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mah": true
        },
        "options": {}
      },
      {
        "content": "max-height: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mah:n": true
        },
        "options": {}
      },
      {
        "content": "max-width: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "maw": true
        },
        "options": {}
      },
      {
        "content": "max-width: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "maw:n": true
        },
        "options": {}
      },
      {
        "content": "min-height: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mih": true
        },
        "options": {}
      },
      {
        "content": "min-width: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "miw": true
        },
        "options": {}
      },
      {
        "content": "opacity: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "op": true
        },
        "options": {}
      },
      {
        "content": "filter: progid:DXImageTransform.Microsoft.Alpha(Opacity=${0:100})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "op:ie": true
        },
        "options": {}
      },
      {
        "content": "-ms-filter: 'progid:DXImageTransform.Microsoft.Alpha(Opacity=${0:100})'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "op:ms": true
        },
        "options": {}
      },
      {
        "content": "orphans: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "orp": true
        },
        "options": {}
      },
      {
        "content": "outline: ${1:1px} ${2:solid} #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "o+": true
        },
        "options": {}
      },
      {
        "content": "outline-color: ${0:#000}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "oc": true
        },
        "options": {}
      },
      {
        "content": "outline-color: invert",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "oc:i": true
        },
        "options": {}
      },
      {
        "content": "outline-offset: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "oo": true
        },
        "options": {}
      },
      {
        "content": "outline-style: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "os": true
        },
        "options": {}
      },
      {
        "content": "outline-width: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ow": true
        },
        "options": {}
      },
      {
        "content": "outline: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "o": true
        },
        "options": {}
      },
      {
        "content": "outline: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "o:n": true
        },
        "options": {}
      },
      {
        "content": "overflow-style: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovs": true
        },
        "options": {}
      },
      {
        "content": "overflow-style: auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovs:a": true
        },
        "options": {}
      },
      {
        "content": "overflow-style: marquee",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovs:mq": true
        },
        "options": {}
      },
      {
        "content": "overflow-style: move",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovs:mv": true
        },
        "options": {}
      },
      {
        "content": "overflow-style: panner",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovs:p": true
        },
        "options": {}
      },
      {
        "content": "overflow-style: scrollbar",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovs:s": true
        },
        "options": {}
      },
      {
        "content": "overflow-x: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovx": true
        },
        "options": {}
      },
      {
        "content": "overflow-x: auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovx:a": true
        },
        "options": {}
      },
      {
        "content": "overflow-x: hidden",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovx:h": true
        },
        "options": {}
      },
      {
        "content": "overflow-x: scroll",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovx:s": true
        },
        "options": {}
      },
      {
        "content": "overflow-x: visible",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovx:v": true
        },
        "options": {}
      },
      {
        "content": "overflow-y: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovy": true
        },
        "options": {}
      },
      {
        "content": "overflow-y: auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovy:a": true
        },
        "options": {}
      },
      {
        "content": "overflow-y: hidden",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovy:h": true
        },
        "options": {}
      },
      {
        "content": "overflow-y: scroll",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovy:s": true
        },
        "options": {}
      },
      {
        "content": "overflow-y: visible",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovy:v": true
        },
        "options": {}
      },
      {
        "content": "overflow: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ov": true
        },
        "options": {}
      },
      {
        "content": "overflow: auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ov:a": true
        },
        "options": {}
      },
      {
        "content": "overflow: hidden",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ov:h": true
        },
        "options": {}
      },
      {
        "content": "overflow: scroll",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ov:s": true
        },
        "options": {}
      },
      {
        "content": "overflow: visible",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ov:v": true
        },
        "options": {}
      },
      {
        "content": "padding-bottom: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pb": true
        },
        "options": {}
      },
      {
        "content": "padding-left: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pl": true
        },
        "options": {}
      },
      {
        "content": "padding-right: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pr": true
        },
        "options": {}
      },
      {
        "content": "padding-top: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pt": true
        },
        "options": {}
      },
      {
        "content": "padding: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p": true
        },
        "options": {}
      },
      {
        "content": "padding: ${1:0} ${2:0} ${3:0} ${0:0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p:4": true
        },
        "options": {}
      },
      {
        "content": "padding: ${1:0} ${2:0} ${0:0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p:3": true
        },
        "options": {}
      },
      {
        "content": "padding: ${1:0} ${0:0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p:2": true
        },
        "options": {}
      },
      {
        "content": "padding: 0",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p:0": true
        },
        "options": {}
      },
      {
        "content": "place-content: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc": true
        },
        "options": {}
      },
      {
        "content": "place-content: ${1} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc+": true
        },
        "options": {}
      },
      {
        "content": "place-content: start",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc:s": true
        },
        "options": {}
      },
      {
        "content": "place-content: end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc:e": true
        },
        "options": {}
      },
      {
        "content": "place-content: center",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc:c": true
        },
        "options": {}
      },
      {
        "content": "place-content: flex-start",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc:fs": true
        },
        "options": {}
      },
      {
        "content": "place-content: flex-end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc:fe": true
        },
        "options": {}
      },
      {
        "content": "place-content: space-between",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc:sb": true
        },
        "options": {}
      },
      {
        "content": "place-content: space-around",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc:sa": true
        },
        "options": {}
      },
      {
        "content": "place-content: space-evenly",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc:se": true
        },
        "options": {}
      },
      {
        "content": "place-content: stretch",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc:st": true
        },
        "options": {}
      },
      {
        "content": "page-break-after: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgba": true
        },
        "options": {}
      },
      {
        "content": "page-break-after: always",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgba:aw": true
        },
        "options": {}
      },
      {
        "content": "page-break-after: auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgba:a": true
        },
        "options": {}
      },
      {
        "content": "page-break-after: left",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgba:l": true
        },
        "options": {}
      },
      {
        "content": "page-break-after: right",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgba:r": true
        },
        "options": {}
      },
      {
        "content": "page-break-before: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgbb": true
        },
        "options": {}
      },
      {
        "content": "page-break-before: always",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgbb:aw": true
        },
        "options": {}
      },
      {
        "content": "page-break-before: auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgbb:a": true
        },
        "options": {}
      },
      {
        "content": "page-break-before: left",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgbb:l": true
        },
        "options": {}
      },
      {
        "content": "page-break-before: right",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgbb:r": true
        },
        "options": {}
      },
      {
        "content": "page-break-inside: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgbi": true
        },
        "options": {}
      },
      {
        "content": "page-break-inside: auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgbi:a": true
        },
        "options": {}
      },
      {
        "content": "page-break-inside: avoid",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgbi:av": true
        },
        "options": {}
      },
      {
        "content": "place-items: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pi": true
        },
        "options": {}
      },
      {
        "content": "place-items: ${1:stretch} ${0:stretch}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pi+": true
        },
        "options": {}
      },
      {
        "content": "place-items: start",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pi:s": true
        },
        "options": {}
      },
      {
        "content": "place-items: end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pi:e": true
        },
        "options": {}
      },
      {
        "content": "place-items: center",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pi:c": true
        },
        "options": {}
      },
      {
        "content": "place-items: stretch",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pi:st": true
        },
        "options": {}
      },
      {
        "content": "position: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pos": true
        },
        "options": {}
      },
      {
        "content": "position: absolute",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pos:a": true
        },
        "options": {}
      },
      {
        "content": "position: fixed",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pos:f": true
        },
        "options": {}
      },
      {
        "content": "position: relative",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pos:r": true
        },
        "options": {}
      },
      {
        "content": "position: static",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pos:s": true
        },
        "options": {}
      },
      {
        "content": "place-self: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ps": true
        },
        "options": {}
      },
      {
        "content": "place-self: ${1:stretch} ${0:stretch}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ps+": true
        },
        "options": {}
      },
      {
        "content": "place-self: start",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ps:s": true
        },
        "options": {}
      },
      {
        "content": "place-self: end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ps:e": true
        },
        "options": {}
      },
      {
        "content": "place-self: center",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ps:c": true
        },
        "options": {}
      },
      {
        "content": "place-self: stretch",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ps:st": true
        },
        "options": {}
      },
      {
        "content": "quotes: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "q": true
        },
        "options": {}
      },
      {
        "content": "quotes: '\\201C' '\\201D' '\\2018' '\\2019'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "q:en": true
        },
        "options": {}
      },
      {
        "content": "quotes: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "q:n": true
        },
        "options": {}
      },
      {
        "content": "quotes: '\\00AB' '\\00BB' '\\201E' '\\201C'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "q:ru": true
        },
        "options": {}
      },
      {
        "content": "resize: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rz": true
        },
        "options": {}
      },
      {
        "content": "resize: both",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rz:b": true
        },
        "options": {}
      },
      {
        "content": "resize: horizontal",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rz:h": true
        },
        "options": {}
      },
      {
        "content": "resize: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rz:n": true
        },
        "options": {}
      },
      {
        "content": "resize: vertical",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rz:v": true
        },
        "options": {}
      },
      {
        "content": "right: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "r": true
        },
        "options": {}
      },
      {
        "content": "right: auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "r:a": true
        },
        "options": {}
      },
      {
        "content": "table-layout: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tbl": true
        },
        "options": {}
      },
      {
        "content": "table-layout: auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tbl:a": true
        },
        "options": {}
      },
      {
        "content": "table-layout: fixed",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tbl:f": true
        },
        "options": {}
      },
      {
        "content": "text-align-last: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tal": true
        },
        "options": {}
      },
      {
        "content": "text-align-last: auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tal:a": true
        },
        "options": {}
      },
      {
        "content": "text-align-last: center",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tal:c": true
        },
        "options": {}
      },
      {
        "content": "text-align-last: left",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tal:l": true
        },
        "options": {}
      },
      {
        "content": "text-align-last: right",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tal:r": true
        },
        "options": {}
      },
      {
        "content": "text-align: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ta": true
        },
        "options": {}
      },
      {
        "content": "text-align: center",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ta:c": true
        },
        "options": {}
      },
      {
        "content": "text-align: left",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ta:l": true
        },
        "options": {}
      },
      {
        "content": "text-align: right",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ta:r": true
        },
        "options": {}
      },
      {
        "content": "text-decoration: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "td": true
        },
        "options": {}
      },
      {
        "content": "text-decoration: line-through",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "td:l": true
        },
        "options": {}
      },
      {
        "content": "text-decoration: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "td:n": true
        },
        "options": {}
      },
      {
        "content": "text-decoration: overline",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "td:o": true
        },
        "options": {}
      },
      {
        "content": "text-decoration: underline",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "td:u": true
        },
        "options": {}
      },
      {
        "content": "text-emphasis: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "te": true
        },
        "options": {}
      },
      {
        "content": "text-emphasis: accent",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "te:ac": true
        },
        "options": {}
      },
      {
        "content": "text-emphasis: after",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "te:a": true
        },
        "options": {}
      },
      {
        "content": "text-emphasis: before",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "te:b": true
        },
        "options": {}
      },
      {
        "content": "text-emphasis: circle",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "te:c": true
        },
        "options": {}
      },
      {
        "content": "text-emphasis: disc",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "te:ds": true
        },
        "options": {}
      },
      {
        "content": "text-emphasis: dot",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "te:dt": true
        },
        "options": {}
      },
      {
        "content": "text-emphasis: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "te:n": true
        },
        "options": {}
      },
      {
        "content": "text-height: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "th": true
        },
        "options": {}
      },
      {
        "content": "text-height: auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "th:a": true
        },
        "options": {}
      },
      {
        "content": "text-height: font-size",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "th:f": true
        },
        "options": {}
      },
      {
        "content": "text-height: max-size",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "th:m": true
        },
        "options": {}
      },
      {
        "content": "text-height: text-size",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "th:t": true
        },
        "options": {}
      },
      {
        "content": "text-indent: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ti": true
        },
        "options": {}
      },
      {
        "content": "text-indent: -9999px",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ti:-": true
        },
        "options": {}
      },
      {
        "content": "text-justify: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tj": true
        },
        "options": {}
      },
      {
        "content": "text-justify: auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tj:a": true
        },
        "options": {}
      },
      {
        "content": "text-justify: distribute",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tj:d": true
        },
        "options": {}
      },
      {
        "content": "text-justify: inter-cluster",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tj:ic": true
        },
        "options": {}
      },
      {
        "content": "text-justify: inter-ideograph",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tj:ii": true
        },
        "options": {}
      },
      {
        "content": "text-justify: inter-word",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tj:iw": true
        },
        "options": {}
      },
      {
        "content": "text-justify: kashida",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tj:k": true
        },
        "options": {}
      },
      {
        "content": "text-justify: tibetan",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tj:t": true
        },
        "options": {}
      },
      {
        "content": "text-outline: ${1:0} ${2:0} #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "to+": true
        },
        "options": {}
      },
      {
        "content": "text-outline: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "to": true
        },
        "options": {}
      },
      {
        "content": "text-outline: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "to:n": true
        },
        "options": {}
      },
      {
        "content": "text-replace: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tr": true
        },
        "options": {}
      },
      {
        "content": "text-replace: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tr:n": true
        },
        "options": {}
      },
      {
        "content": "text-shadow: ${1:0} ${2:0} ${3:0} #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tsh+": true
        },
        "options": {}
      },
      {
        "content": "text-shadow: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tsh": true
        },
        "options": {}
      },
      {
        "content": "text-shadow: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tsh:n": true
        },
        "options": {}
      },
      {
        "content": "text-transform: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tt": true
        },
        "options": {}
      },
      {
        "content": "text-transform: capitalize",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tt:c": true
        },
        "options": {}
      },
      {
        "content": "text-transform: lowercase",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tt:l": true
        },
        "options": {}
      },
      {
        "content": "text-transform: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tt:n": true
        },
        "options": {}
      },
      {
        "content": "text-transform: uppercase",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tt:u": true
        },
        "options": {}
      },
      {
        "content": "text-wrap: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tw": true
        },
        "options": {}
      },
      {
        "content": "text-wrap: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tw:no": true
        },
        "options": {}
      },
      {
        "content": "text-wrap: normal",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tw:n": true
        },
        "options": {}
      },
      {
        "content": "text-wrap: suppress",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tw:s": true
        },
        "options": {}
      },
      {
        "content": "text-wrap: unrestricted",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tw:u": true
        },
        "options": {}
      },
      {
        "content": "top: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "t": true
        },
        "options": {}
      },
      {
        "content": "top: auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "t:a": true
        },
        "options": {}
      },
      {
        "content": "vertical-align: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "va": true
        },
        "options": {}
      },
      {
        "content": "vertical-align: baseline",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "va:bl": true
        },
        "options": {}
      },
      {
        "content": "vertical-align: bottom",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "va:b": true
        },
        "options": {}
      },
      {
        "content": "vertical-align: middle",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "va:m": true
        },
        "options": {}
      },
      {
        "content": "vertical-align: sub",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "va:sub": true
        },
        "options": {}
      },
      {
        "content": "vertical-align: super",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "va:sup": true
        },
        "options": {}
      },
      {
        "content": "vertical-align: text-bottom",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "va:tb": true
        },
        "options": {}
      },
      {
        "content": "vertical-align: text-top",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "va:tt": true
        },
        "options": {}
      },
      {
        "content": "vertical-align: top",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "va:t": true
        },
        "options": {}
      },
      {
        "content": "visibility: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "v": true
        },
        "options": {}
      },
      {
        "content": "visibility: collapse",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "v:c": true
        },
        "options": {}
      },
      {
        "content": "visibility: hidden",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "v:h": true
        },
        "options": {}
      },
      {
        "content": "visibility: visible",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "v:v": true
        },
        "options": {}
      },
      {
        "content": "white-space-collapse: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whsc": true
        },
        "options": {}
      },
      {
        "content": "white-space-collapse: break-all",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whsc:ba": true
        },
        "options": {}
      },
      {
        "content": "white-space-collapse: break-strict",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whsc:bs": true
        },
        "options": {}
      },
      {
        "content": "white-space-collapse: keep-all",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whsc:k": true
        },
        "options": {}
      },
      {
        "content": "white-space-collapse: loose",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whsc:l": true
        },
        "options": {}
      },
      {
        "content": "white-space-collapse: normal",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whsc:n": true
        },
        "options": {}
      },
      {
        "content": "white-space: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whs": true
        },
        "options": {}
      },
      {
        "content": "white-space: normal",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whs:n": true
        },
        "options": {}
      },
      {
        "content": "white-space: nowrap",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whs:nw": true
        },
        "options": {}
      },
      {
        "content": "white-space: pre-line",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whs:pl": true
        },
        "options": {}
      },
      {
        "content": "white-space: pre-wrap",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whs:pw": true
        },
        "options": {}
      },
      {
        "content": "white-space: pre",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whs:p": true
        },
        "options": {}
      },
      {
        "content": "widows: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wid": true
        },
        "options": {}
      },
      {
        "content": "width: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "w": true
        },
        "options": {}
      },
      {
        "content": "width: auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "w:a": true
        },
        "options": {}
      },
      {
        "content": "word-break: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wob": true
        },
        "options": {}
      },
      {
        "content": "word-break: break-all",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wob:ba": true
        },
        "options": {}
      },
      {
        "content": "word-break: break-strict",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wob:bs": true
        },
        "options": {}
      },
      {
        "content": "word-break: keep-all",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wob:k": true
        },
        "options": {}
      },
      {
        "content": "word-break: loose",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wob:l": true
        },
        "options": {}
      },
      {
        "content": "word-break: normal",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wob:n": true
        },
        "options": {}
      },
      {
        "content": "word-spacing: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wos": true
        },
        "options": {}
      },
      {
        "content": "word-wrap: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wow": true
        },
        "options": {}
      },
      {
        "content": "word-wrap: none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wow:no": true
        },
        "options": {}
      },
      {
        "content": "word-wrap: normal",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wow:n": true
        },
        "options": {}
      },
      {
        "content": "word-wrap: suppress",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wow:s": true
        },
        "options": {}
      },
      {
        "content": "word-wrap: unrestricted",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wow:u": true
        },
        "options": {}
      },
      {
        "content": "z-index: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "z": true
        },
        "options": {}
      },
      {
        "content": "z-index: auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "z:a": true
        },
        "options": {}
      },
      {
        "content": "zoom: 1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "zoo": true
        },
        "options": {}
      },
      {
        "content": ":hover",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":h": true
        },
        "options": {}
      },
      {
        "content": ":first-child",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":fc": true
        },
        "options": {}
      },
      {
        "content": ":last-child",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":lc": true
        },
        "options": {}
      },
      {
        "content": ":nth-child(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":nc": true
        },
        "options": {}
      },
      {
        "content": ":nth-last-child(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":nlc": true
        },
        "options": {}
      },
      {
        "content": ":only-child",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":oc": true
        },
        "options": {}
      },
      {
        "content": ":after",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":a": true
        },
        "options": {}
      },
      {
        "content": ":before",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":b": true
        },
        "options": {}
      },
      {
        "content": "::after",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "::a": true
        },
        "options": {}
      },
      {
        "content": "::before",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "::b": true
        },
        "options": {}
      }
    ],
    "scala": [
      {
        "content": "match {\n\tcase ${1} => ${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "match {\\n  case .. => ..",
        "matches": {
          "match": true
        },
        "options": {}
      },
      {
        "content": "case ${1} => ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "case .. => ..",
        "matches": {
          "case": true
        },
        "options": {}
      },
      {
        "content": "try {\n\t${1:TARGET}\n} catch {\n\tcase e${2:: Exception} => ${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "try {} catch { case ... }",
        "matches": {
          "try": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "for {\n\t${1}\n} yield ${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "if (${1}) {\n\t${2}\n}${3: else}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "println(${1})",
        "doc": "",
        "grammar": "snu",
        "label": "println()",
        "matches": {
          "p": true
        },
        "options": {}
      },
      {
        "content": "println('${1:#:name}, $1)",
        "doc": "",
        "grammar": "snu",
        "label": "println('name, name)",
        "matches": {
          "pn": true
        },
        "options": {}
      },
      {
        "content": "_ = println(${1})",
        "doc": "",
        "grammar": "snu",
        "label": "p in for",
        "matches": {
          "pf": true
        },
        "options": {}
      },
      {
        "content": "object ${1:X} {\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "object": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "class ${1:X()} {\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "class": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "should \"${1}\" in {\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "should-scalatest": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "import akka.actor.{ActorSystem, Actor, ActorLogging, Props}\nobject ${1:X} {\n\tdef props(${2}) = Props(new X($2))\n}\nclass $1($2) extends Actor with ActorLogging {\n\tdef receive = {\n\t\tcase e =>\n\t\t\t${0:TARGET:println(e)}\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "akka-actor": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "case class ${1}(${2}: ${0})",
        "doc": "",
        "grammar": "snu",
        "label": "case class ..(..: ..)",
        "matches": {
          "cclass": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "if (${1})\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "if (!${1})\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifn": true
        },
        "options": {}
      },
      {
        "content": "if (${1})\n\t${2:${VISUAL}}\nelse\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "if (${1})\n\t${2:${VISUAL}}\nelse if (${3})\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifelif": true
        },
        "options": {}
      },
      {
        "content": "else if (${3})\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eif": true
        },
        "options": {}
      },
      {
        "content": "while (${1:obj}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh": true
        },
        "options": {}
      },
      {
        "content": "for (${1:item} <- ${2:obj}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "for (${1:i} <- ${2:0} to ${3:obj}.length) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fori": true
        },
        "options": {}
      },
      {
        "content": "for {\n\t${1:item} <- ${2:obj}\n} yield ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fory": true
        },
        "options": {}
      },
      {
        "content": "try {\n\t${1:${VISUAL}}\n} catch {\n\tcase e: FileNotFoundException => ${2}\n\tcase e: IOException => ${3}\n} finally {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "try": true
        },
        "options": {}
      },
      {
        "content": "${1:${VISUAL}} match {\n\tcase ${2} => ${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mat": true
        },
        "options": {}
      },
      {
        "content": "${1: obj} match {\n\tcase ${2:e} => ${3}\n\tcase _ => ${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "match": true
        },
        "options": {}
      },
      {
        "content": "case ${1:${VISUAL}} => ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case": true
        },
        "options": {}
      },
      {
        "content": "${1:a}: ${2:T}${0:, arg}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "arg": true
        },
        "options": {}
      },
      {
        "content": "${1:args}: ${0:T}*",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "args": true
        },
        "options": {}
      },
      {
        "content": "def ${1:name}(${2:arg}) = ${0:}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "def": true
        },
        "options": {}
      },
      {
        "content": "private def ${1:name}(${2:arg}) = ${0:}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prdef": true
        },
        "options": {}
      },
      {
        "content": "override def ${1:name}(${2:arg}) = ${0:}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovdef": true
        },
        "options": {}
      },
      {
        "content": "(${1:a}: ${2:T}) => $1 ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fcf": true
        },
        "options": {}
      },
      {
        "content": "${1:name} => ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "=>": true
        },
        "options": {}
      },
      {
        "content": "def ${1:name}(${0:arg}) =\n\tif($2) $2\n\telse $1($2)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rec": true
        },
        "options": {}
      },
      {
        "content": "def ${1:name}(${2:arg})(${3:arg}) = ${0:}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "crdef": true
        },
        "options": {}
      },
      {
        "content": "def main(args: Array[String]):${1:T} = ${0:}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "main": true
        },
        "options": {}
      },
      {
        "content": "dbl",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "T Double": true
        },
        "options": {}
      },
      {
        "content": "int",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "T Int": true
        },
        "options": {}
      },
      {
        "content": "lng",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "T Long": true
        },
        "options": {}
      },
      {
        "content": "chr",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "T Char": true
        },
        "options": {}
      },
      {
        "content": "str",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "T String": true
        },
        "options": {}
      },
      {
        "content": "arr",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "T Array": true
        },
        "options": {}
      },
      {
        "content": "buf",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "T Buffer": true
        },
        "options": {}
      },
      {
        "content": "list",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "T List": true
        },
        "options": {}
      },
      {
        "content": "tpl",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "T Tuple": true
        },
        "options": {}
      },
      {
        "content": "set",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "T Set": true
        },
        "options": {}
      },
      {
        "content": "map",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "T Map": true
        },
        "options": {}
      },
      {
        "content": "hset",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "T HashSet": true
        },
        "options": {}
      },
      {
        "content": "hmap",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "T HashMap": true
        },
        "options": {}
      },
      {
        "content": "bool",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "T Boolean": true
        },
        "options": {}
      },
      {
        "content": "Boolean",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bool": true
        },
        "options": {}
      },
      {
        "content": "AnyRef",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "anyr": true
        },
        "options": {}
      },
      {
        "content": "Double",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dbl": true
        },
        "options": {}
      },
      {
        "content": "Int",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "int": true
        },
        "options": {}
      },
      {
        "content": "String",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "str": true
        },
        "options": {}
      },
      {
        "content": "Char",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "chr": true
        },
        "options": {}
      },
      {
        "content": "Long",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lng": true
        },
        "options": {}
      },
      {
        "content": "Array${1:[T]}${0:()}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "arr": true
        },
        "options": {}
      },
      {
        "content": "Buffer${1:[T]}${0:()}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "buf": true
        },
        "options": {}
      },
      {
        "content": "List${1:[T]}${0:()}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list": true
        },
        "options": {}
      },
      {
        "content": "Tuple${1:2}[${2:T},${0:T}]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tpl": true
        },
        "options": {}
      },
      {
        "content": "Set${1:[T]}${0:()}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "set": true
        },
        "options": {}
      },
      {
        "content": "HashSet${1:[T]}${0:()}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "hset": true
        },
        "options": {}
      },
      {
        "content": "mutable.HashSet${1:[T]}${0:()}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mhset": true
        },
        "options": {}
      },
      {
        "content": "${1:key}->${2:val}${0:, keyval}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "keyval": true
        },
        "options": {}
      },
      {
        "content": "Map[${1:T},${2:T}]${0:(keyval)}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "map": true
        },
        "options": {}
      },
      {
        "content": "HashMap[${1:T},${2:T}]${0:(keyval)}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "hmap": true
        },
        "options": {}
      },
      {
        "content": "mutable.Map[${1:T},${2:T}]${0:(keyval)}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mmap": true
        },
        "options": {}
      },
      {
        "content": "mutable.HashMap[${1:T},${2:T}]${0:(keyval)}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mhmap": true
        },
        "options": {}
      },
      {
        "content": "${1:name}.asInstanceOf[${2:T}]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as": true
        },
        "options": {}
      },
      {
        "content": "${1:name}.isInstanceOf[${2:T}]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "is": true
        },
        "options": {}
      },
      {
        "content": "(${1:a} => ${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "(a": true
        },
        "options": {}
      },
      {
        "content": "{(${1:a},${2:b}) =>\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "{(": true
        },
        "options": {}
      },
      {
        "content": "${0:name}.filter (a",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "filter": true
        },
        "options": {}
      },
      {
        "content": "${0:name}.map (a",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mapf": true
        },
        "options": {}
      },
      {
        "content": "${1:name}.flatMap${0:[T]}(a",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "flatmap": true
        },
        "options": {}
      },
      {
        "content": "${1:name}.foldLeft(${0:first}) {(",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fldl": true
        },
        "options": {}
      },
      {
        "content": "${1:name}.foldRight(${0:first}) {(",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fldr": true
        },
        "options": {}
      },
      {
        "content": "(${1:first}/:${2:name})(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "/:": true
        },
        "options": {}
      },
      {
        "content": "(${1:first}:\\${2:name})(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":\\": true
        },
        "options": {}
      },
      {
        "content": "${1:name}.reduceLeft[${0:T}] {(",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "redl": true
        },
        "options": {}
      },
      {
        "content": "${1:name}.reduceRight[${0:T}] {(",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "redr": true
        },
        "options": {}
      },
      {
        "content": "${0:name}.view.zipWithIndex",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "zipwi": true
        },
        "options": {}
      },
      {
        "content": "${1:name}.split(\"${0:,}\")",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "spl": true
        },
        "options": {}
      },
      {
        "content": "val ${1:name}${2:: T} = ${0:value}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "val": true
        },
        "options": {}
      },
      {
        "content": "var ${1:name}${2:: T} = ${0:value}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "var": true
        },
        "options": {}
      },
      {
        "content": "extends ${0:what}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "extends": true
        },
        "options": {}
      },
      {
        "content": "with ${1:what}${0: with}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "with": true
        },
        "options": {}
      },
      {
        "content": "def this(arg) = this(arg)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "athis": true
        },
        "options": {}
      },
      {
        "content": "abstract class ${1:name}${2:(arg)}${3: extends }${4: with} {\n\t${5:override def toString = \"$1\"}\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "abstract": true
        },
        "options": {}
      },
      {
        "content": "class ${1:name}${2:(arg)}${3: extends }${4: with} {\n\t${5:override def toString = \"$1\"}\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "class": true
        },
        "options": {}
      },
      {
        "content": "object ${1:name}${2:(arg)}${3: extends }${4: with} ${0:}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "object": true
        },
        "options": {}
      },
      {
        "content": "trait ${1:name}${2: extends }${3: with} {\n\t${0:}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "trait": true
        },
        "options": {}
      },
      {
        "content": "class ${1:name}${2:(arg)} extends Ordered[$1] ${3: with} {\n\t${4:override def toString = \"$1\"}\n\tdef compare(that: $1) = ${5:this - that}\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ordered": true
        },
        "options": {}
      },
      {
        "content": "case class ${1:name}${2:(arg)}${3: extends }${4: with} ${0:}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "casecl": true
        },
        "options": {}
      },
      {
        "content": "${1:import org.scalatest.Suite}\n${0:import org.scalatest.FunSuite}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "scalatest": true
        },
        "options": {}
      },
      {
        "content": "assert(${1:a} === ${0:b})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "assert": true
        },
        "options": {}
      },
      {
        "content": "ifel ensuring(${1:a}==${0:b})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ensuring": true
        },
        "options": {}
      },
      {
        "content": "expect(${1:what}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "expect": true
        },
        "options": {}
      },
      {
        "content": "intercept[${1:IllegalArgumentException}] {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "intercept": true
        },
        "options": {}
      },
      {
        "content": "test(\"${1:description}\") {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "test": true
        },
        "options": {}
      },
      {
        "content": "class ${0:name} extends Suite {\n\tdef test() {\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "suite": true
        },
        "options": {}
      },
      {
        "content": "class ${1:name} extends FunSuite {\n\ttest(\"${0:description}\") {\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fsuite": true
        },
        "options": {}
      },
      {
        "content": "import sbt._\nclass ${1:Name}(info: ProjectInfo) extends DefaultWebProject(info) {\n\tval liftVersion = \"${0:2.3}\"\n\toverride def libraryDependencies = Set(\n\t) ++ super.libraryDependencies\n\tval snapshots = ScalaToolsSnapshots\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "webproject": true
        },
        "options": {}
      },
      {
        "content": "\"net.liftweb\" %% \"${0:lib}\" % liftVersion % \"compile->default\",",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "liftjar": true
        },
        "options": {}
      },
      {
        "content": "\"org.mortbay.jetty\" % \"jetty\" % \"${0:version}\" % \"test->default\",",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jettyjar": true
        },
        "options": {}
      },
      {
        "content": "import _root_.net.liftweb.http._\nimport S._\nimport _root_.net.liftweb.util._\nimport Helpers._\nimport _root_.scala.xml._",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "liftimports": true
        },
        "options": {}
      }
    ],
    "scheme": [
      {
        "content": "(cond\n  ((${1}) ${2})\n  (${0:else}))",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cond": true
        },
        "options": {}
      },
      {
        "content": "(case ${1}\n  ((${2}) ${3})\n  (${0:else}))",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case": true
        },
        "options": {}
      },
      {
        "content": "(use gauche.test)\n(test-start \"${1}.scm\")\n(load \"$1.scm\")\n(test* \"${2}\" ${3:expected} ${4:actual})",
        "doc": "",
        "grammar": "snu",
        "label": "(use gauche.test)(test-start ...",
        "matches": {
          "gauche-testsuite": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "(+ ${1}\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "+": true
        },
        "options": {}
      },
      {
        "content": "(- ${1}\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "-": true
        },
        "options": {}
      },
      {
        "content": "(/ ${1}\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "/": true
        },
        "options": {}
      },
      {
        "content": "(* ${1}\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "*": true
        },
        "options": {}
      },
      {
        "content": "(define (${1:name})\n\t\t(${0:definition}))",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "def": true
        },
        "options": {}
      },
      {
        "content": "(define ${1:name}\n\t(lambda (x)(${0:definition})))",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defl": true
        },
        "options": {}
      },
      {
        "content": "(cond ((${1:predicate}) (${2:action}))\n\t((${3:predicate}) (${0:action})))",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cond": true
        },
        "options": {}
      },
      {
        "content": "(if (${1:predicate})\n\t(${2:true-action})\n\t(${0:false-action}))",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      }
    ],
    "scss": [
      {
        "content": "@mixin ${1:NAME}(${2:#:ARGS}) {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "@mixin(...){...}",
        "matches": {
          "mixin": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "@include ${1:NAME}(${2:#:ARGS});",
        "doc": "",
        "grammar": "snu",
        "label": "@include ...",
        "matches": {
          "include": true
        },
        "options": {}
      },
      {
        "content": "@import '${0:TARGET}';",
        "doc": "",
        "grammar": "snu",
        "label": "@import '...';",
        "matches": {
          "import": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "@extend ${0:TARGET};",
        "doc": "",
        "grammar": "snu",
        "label": "@extend ...;",
        "matches": {
          "extend": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "$${1:variable}: ${0:value};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "$": true
        },
        "options": {}
      },
      {
        "content": "@import '${0}';",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "imp": true
        },
        "options": {}
      },
      {
        "content": "@mixin ${1:name}(${2}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mix": true
        },
        "options": {}
      },
      {
        "content": "@include ${1:mixin}(${2});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "inc": true
        },
        "options": {}
      },
      {
        "content": "@extend ${0};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ext": true
        },
        "options": {}
      },
      {
        "content": "@function ${1:name}(${2:args}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fun": true
        },
        "options": {}
      },
      {
        "content": "@if ${1:condition} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "@if ${1:condition} {\n\t${2}\n} @else {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "@else if ${1:condition} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eif": true
        },
        "options": {}
      },
      {
        "content": "@for ${1:$i} from ${2:1} through ${3:3} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "@each ${1:$item} in ${2:items} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "each": true
        },
        "options": {}
      },
      {
        "content": "@while ${1:$i} ${2:>} ${3:0} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "while": true
        },
        "options": {}
      }
    ],
    "sh": [
      {
        "content": "#!/bin/${1:sh}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "#!/bin/sh",
        "matches": {
          "#!": true,
          "shebang": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "if [ ${1:#:condition} ]; then\n\t${0:TARGET}\nfi",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "else\n\t${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "el": true
        },
        "options": {}
      },
      {
        "content": "elif [ ${1:#:condition} ]; then\n\t${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "elif": true
        },
        "options": {}
      },
      {
        "content": "for ${1:i} in ${2:#:words}; do\n\t${0:TARGET}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "while ${1:#:condition} ; do\n\t${0:TARGET}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh": true,
          "while": true
        },
        "options": {}
      },
      {
        "content": "until ${1:#:condition} ; do\n\t${0:TARGET}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "until": true
        },
        "options": {}
      },
      {
        "content": "<< ${1:EOF}\n\t${0:#:TARGET}\n$1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "h <<": true,
          "heredoc": true
        },
        "options": {}
      },
      {
        "content": "#!/usr/bin/env ${1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "env": true
        },
        "options": {}
      },
      {
        "content": "${1:TMPFILE}=$(mktemp ${2:XXX})\ntrap \"rm -f '${$1}'\" 0               # EXIT\ntrap \"rm -f '${$1}'; exit 1\" 2       # INT\ntrap \"rm -f '${$1}'; exit 1\" 1 15    # HUP TERM\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tmp": true
        },
        "options": {}
      },
      {
        "content": "${1:#:name}()\n{\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "func": true,
          "function": true
        },
        "options": {}
      },
      {
        "content": "if [[ $${1:string} =~ ${2:^regexp.*} ]]; then\n\t${0}\nfi",
        "doc": "",
        "grammar": "snu",
        "label": "=~",
        "matches": {
          "match-regexp": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "${1:name}=\"${2:something}\"",
        "doc": "",
        "grammar": "snu",
        "label": "var-assign",
        "matches": {
          "assign": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "case \"$${1:{name\\}}\" in\n\t${2:pattern*})\n\t\t${0}\n\t\t;;\n\t*)\n\t\t${3:echo \"$$1 Didn't match anything\"}\nesac",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "echo \"${0:TARGET}\" 1>&2",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "warn": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "echo \"${0:TARGET}\" 1>&2\nexit 1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "abort": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "#!/usr/bin/env sh",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#!": true
        },
        "options": {}
      },
      {
        "content": "#!/usr/bin/env sh\nset -eu",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "s#!": true
        },
        "options": {}
      },
      {
        "content": "set -eu",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "safe": true
        },
        "options": {}
      },
      {
        "content": "#!/usr/bin/env bash",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bash": true
        },
        "options": {}
      },
      {
        "content": "#!/usr/bin/env bash\nset -euo pipefail\nIFS=$'\\n\\t'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sbash": true
        },
        "options": {}
      },
      {
        "content": "if [[ ${1:condition} ]]; then\n\t${0:${VISUAL}}\nfi",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "elif [[ ${1:condition} ]]; then\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "elif": true
        },
        "options": {}
      },
      {
        "content": "for (( ${2:i} = 0; $2 < ${1:count}; $2++ )); do\n\t${0:${VISUAL}}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "for ${1:needle} in ${2:haystack} ; do\n\t${0:${VISUAL}}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fori": true
        },
        "options": {}
      },
      {
        "content": "while [[ ${1:condition} ]]; do\n\t${0:${VISUAL}}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh": true
        },
        "options": {}
      },
      {
        "content": "until [[ ${1:condition} ]]; do\n\t${0:${VISUAL}}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "until": true
        },
        "options": {}
      },
      {
        "content": "case ${1:word} in\n\t${2:pattern})\n\t\t${0};;\nesac",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case": true
        },
        "options": {}
      },
      {
        "content": "while getopts '${1:o}' ${2:opts}\ndo\n\tcase $$2 in\n\t${3:o0})\n\t\t${0:#staments};;\n\tesac\ndone",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "go": true
        },
        "options": {}
      },
      {
        "content": "SCRIPT_DIR=\"$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" && pwd )\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sdir": true
        },
        "options": {}
      },
      {
        "content": "__ScriptVersion=\"${1:version}\"\n#===  FUNCTION  ================================================================\n#         NAME:  usage\n#  DESCRIPTION:  Display usage information.\n#===============================================================================\nfunction usage ()\n{\n\techo \"Usage :  $${0:0} [options] [--]\n    Options:\n    -h|help       Display this message\n    -v|version    Display script version\"\n}    # ----------  end of function usage  ----------\n#-----------------------------------------------------------------------\n#  Handle command line arguments\n#-----------------------------------------------------------------------\nwhile getopts \":hv\" opt\ndo\n  case $opt in\n\th|help     )  usage; exit 0   ;;\n\tv|version  )  echo \"$${0:0} -- Version $__ScriptVersion\"; exit 0   ;;\n\t* )  echo -e \"\\n  Option does not exist : $OPTARG\\n\"\n\t\t  usage; exit 1   ;;\n  esac    # --- end of case ---\ndone\nshift $(($OPTIND-1))",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "getopt": true
        },
        "options": {}
      },
      {
        "content": "if [ \\$(id -u) -ne 0 ]; then exec sudo \\$0; fi",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "root": true
        },
        "options": {}
      },
      {
        "content": "${1:function_name}() {\n\t${0:#function_body}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fun-sh": true
        },
        "options": {}
      },
      {
        "content": "function ${1:function_name}() {\n\t${0:#function_body}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fun": true
        },
        "options": {}
      }
    ],
    "simplemvcf": [
      {
        "content": "<?php\n\tnamespace Controllers;\n\tuse Core\\View;\n\tuse Core\\Controller;\n\tclass ${1:class_name} extends Controller\n\t{\n\t\tpublic function __construct()\n\t\t{\n\t\t\tparent::__construct();\n\t\t}\n\t\tpublic function index()\n\t\t{\n\t\t\t${2:}\n\t\t}\n\t}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sm_controller": true
        },
        "options": {}
      },
      {
        "content": "<?php \n\tnamespace Models;\n\tuse Core\\Model;\n\tclass ${1:class_name} extends Model \n\t{    \n\t\tfunction __construct()\n\t\t{\n\t\t\tparent::__construct();\n\t\t}  \n\t}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sm_model": true
        },
        "options": {}
      },
      {
        "content": "<?php \n\tnamespace Models;\n\tuse Core\\Model;\n\tclass ${1:class_name} extends Model \n\t{    \n\t\tprivate $${2:table};\n\t\tfunction __construct()\n\t\t{\n\t\t\tparent::__construct();\n\t\t}  \n\t\tpublic function getRow($where)\n\t\t{\n\t\t\treturn $this->db->select('SELECT * FROM '.$table.' WHERE ${3:where}', $data);\n\t\t}\n\t\tpublic function getRows($where)\n\t\t{\n\t\t\treturn $this->db->select('SELECT * FROM '.$table.');\n\t\t}\n\t\tpublic function insert($data)\n\t\t{\n\t\t\t$this->db->insert($table, $data);\n\t\t}\n\t\tpublic function update($data, $where)\n\t\t{\n\t\t\t$this->db->update($table ,$data, $where);\n\t\t}\n\t\tpublic function delete($where)\n\t\t{\n\t\t\t$this->db->delete($table, $where);\n\t\t}\n\t}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sm_model_crud": true
        },
        "options": {}
      },
      {
        "content": "View::render('${1:view}', $${2:array});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sm_render": true
        },
        "options": {}
      },
      {
        "content": "View::renderTemplate('${1:part}', $${2:array});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sm_render_template": true
        },
        "options": {}
      },
      {
        "content": "$this->db->select(${1:sql}, ${2:where});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sm_db_select": true
        },
        "options": {}
      },
      {
        "content": "$this->db->insert(${1:table}, ${2:data});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sm_db_insert": true
        },
        "options": {}
      },
      {
        "content": "$this->db->update(${1:table}, ${2:data}, ${3:where});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sm_db_update": true
        },
        "options": {}
      },
      {
        "content": "$this->db->delete(${1:table}, ${2:where});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sm_db_delete": true
        },
        "options": {}
      },
      {
        "content": "$this->db->delete(${1:table});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sm_db_truncate": true
        },
        "options": {}
      },
      {
        "content": "Session::set(${1:key}, ${2:value});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sm_session_set": true
        },
        "options": {}
      },
      {
        "content": "Session::get(${1:key});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sm_session_get": true
        },
        "options": {}
      },
      {
        "content": "Session::pull(${1:key});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sm_session_pull": true
        },
        "options": {}
      },
      {
        "content": "Session::id();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sm_session_id": true
        },
        "options": {}
      },
      {
        "content": "Session::set(${1:key});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sm_session_destroy": true
        },
        "options": {}
      },
      {
        "content": "Session::display();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sm_session_display": true
        },
        "options": {}
      },
      {
        "content": "Url:redirect('${1:path}');",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sm_url_redirect": true
        },
        "options": {}
      },
      {
        "content": "Url:previous();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sm_url_previous": true
        },
        "options": {}
      },
      {
        "content": "Url:templatePath();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sm_url_templatepath": true
        },
        "options": {}
      },
      {
        "content": "Url:autolink('${1:string}');",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sm_url_autolink": true
        },
        "options": {}
      }
    ],
    "slim": [
      {
        "content": "- binding.pry",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pry": true
        },
        "options": {}
      },
      {
        "content": "= render partial: '${0}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "renp": true
        },
        "options": {}
      },
      {
        "content": "fieldset\n\tlegend ${1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fieldset": true
        },
        "options": {}
      },
      {
        "content": "link rel=\"stylesheet\" href=\"${1:style.css}\" type=\"text/css\" media=\"${2:all}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "css": true
        },
        "options": {}
      },
      {
        "content": "script src=\"${1:script.js}\" type=\"text/javascript\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "script": true
        },
        "options": {}
      },
      {
        "content": "&nbsp;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nbs": true
        },
        "options": {}
      },
      {
        "content": "&#x2190;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "left": true
        },
        "options": {}
      },
      {
        "content": "&#x2192;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "right": true
        },
        "options": {}
      },
      {
        "content": "&#x2191;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "up": true
        },
        "options": {}
      },
      {
        "content": "&#x2193;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "down": true
        },
        "options": {}
      },
      {
        "content": "&#x21A9;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "return": true
        },
        "options": {}
      },
      {
        "content": "&#x21E4;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "backtab": true
        },
        "options": {}
      },
      {
        "content": "&#x21E5;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tab": true
        },
        "options": {}
      },
      {
        "content": "&#x21E7;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "shift": true
        },
        "options": {}
      },
      {
        "content": "&#x2303;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ctrl": true
        },
        "options": {}
      },
      {
        "content": "&#x2305;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "enter": true
        },
        "options": {}
      },
      {
        "content": "&#x2318;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cmd": true
        },
        "options": {}
      },
      {
        "content": "&#x2325;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "option": true
        },
        "options": {}
      },
      {
        "content": "&#x2326;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "delete": true
        },
        "options": {}
      },
      {
        "content": "&#x232B;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "backspace": true
        },
        "options": {}
      },
      {
        "content": "&#x238B;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "esc": true
        },
        "options": {}
      }
    ],
    "snippets": [
      {
        "content": "import styled from 'styled-components/native';\n\nexport const ${1:Container} = styled.${2:View}`\n  ${3}\n`;\n",
        "doc": "Create React Native Styled Components file",
        "grammar": "lsp",
        "label": "styles",
        "matches": {
          "styled-react-native": true
        },
        "options": {}
      },
      {
        "content": "import ${2:moduleName} from '${1:module}'$0",
        "doc": "",
        "grammar": "lsp",
        "label": "import",
        "matches": {
          "imp": true
        },
        "options": {}
      },
      {
        "content": "import '${1:module}'$0",
        "doc": "",
        "grammar": "lsp",
        "label": "importNoModuleName",
        "matches": {
          "imn": true
        },
        "options": {}
      },
      {
        "content": "import { $2 } from '${1:module}'$0",
        "doc": "",
        "grammar": "lsp",
        "label": "importDestructing",
        "matches": {
          "imd": true
        },
        "options": {}
      },
      {
        "content": "import * as ${2:alias} from '${1:module}'$0",
        "doc": "",
        "grammar": "lsp",
        "label": "importEverything",
        "matches": {
          "ime": true
        },
        "options": {}
      },
      {
        "content": "import { ${2:originalName} as ${3:alias} } from '${1:module}'$0",
        "doc": "",
        "grammar": "lsp",
        "label": "importAs",
        "matches": {
          "ima": true
        },
        "options": {}
      },
      {
        "content": "export default $1$0",
        "doc": "",
        "grammar": "lsp",
        "label": "exportDefault",
        "matches": {
          "exp": true
        },
        "options": {}
      },
      {
        "content": "export { $2 } from '${1:module}'$0",
        "doc": "",
        "grammar": "lsp",
        "label": "exportDestructing",
        "matches": {
          "exd": true
        },
        "options": {}
      },
      {
        "content": "export { ${2:originalName} as ${3:alias} } from '${1:module}'$0",
        "doc": "",
        "grammar": "lsp",
        "label": "exportAs",
        "matches": {
          "exa": true
        },
        "options": {}
      },
      {
        "content": "export const ${1:functionName} = (${2:params}) => {\n\t$0\n}\n",
        "doc": "Export named function in ES7 syntax",
        "grammar": "lsp",
        "label": "exportNamedFunction",
        "matches": {
          "enf": true
        },
        "options": {}
      },
      {
        "content": "export default (${1:params}) => {\n\t$0\n}\n",
        "doc": "Export default function in ES7 syntax",
        "grammar": "lsp",
        "label": "exportDefaultFunction",
        "matches": {
          "edf": true
        },
        "options": {}
      },
      {
        "content": "${1:methodName} = (${2:params}) => {\n\t${0}\n}\n",
        "doc": "Creates a method inside a class in ES7 syntax",
        "grammar": "lsp",
        "label": "method",
        "matches": {
          "met": true
        },
        "options": {}
      },
      {
        "content": "get ${1:propertyName}() {\n\treturn this.${0}\n}\n",
        "doc": "Creates a getter property inside a class in ES7 syntax",
        "grammar": "lsp",
        "label": "propertyGet",
        "matches": {
          "pge": true
        },
        "options": {}
      },
      {
        "content": "set ${1:propertyName}(${2:value}) {\n\t${0}\n}\n",
        "doc": "Creates a setter property inside a class in ES7 syntax",
        "grammar": "lsp",
        "label": "propertySet",
        "matches": {
          "pse": true
        },
        "options": {}
      },
      {
        "content": "${1:array}.forEach(${2:currentItem} => {\n\t${0}\n})\n",
        "doc": "Creates a forEach statement in ES7 syntax",
        "grammar": "lsp",
        "label": "forEach",
        "matches": {
          "fre": true
        },
        "options": {}
      },
      {
        "content": "for(let ${1:item} of ${2:object}) {\n\t${0}\n}\n",
        "doc": "Iterating over property names of iterable objects",
        "grammar": "lsp",
        "label": "forOf",
        "matches": {
          "fof": true
        },
        "options": {}
      },
      {
        "content": "for(let ${1:item} in ${2:object}) {\n\t${0}\n}\n",
        "doc": "Iterating over property values of iterable objects",
        "grammar": "lsp",
        "label": "forIn",
        "matches": {
          "fin": true
        },
        "options": {}
      },
      {
        "content": "(${1:params}) => {\n\t${2}\n}",
        "doc": "Creates an anonymous function in ES7 syntax",
        "grammar": "lsp",
        "label": "anonymousFunction",
        "matches": {
          "anfn": true
        },
        "options": {}
      },
      {
        "content": "const ${1:name} = (${2:params}) => {\n\t${3}\n}\n",
        "doc": "Creates a named function in ES7 syntax",
        "grammar": "lsp",
        "label": "namedFunction",
        "matches": {
          "nfn": true
        },
        "options": {}
      },
      {
        "content": "const {${1:propertyName}} = ${2:objectToDestruct}",
        "doc": "Creates and assigns a local variable using object destructing",
        "grammar": "lsp",
        "label": "destructingObject",
        "matches": {
          "dob": true
        },
        "options": {}
      },
      {
        "content": "const [${1:propertyName}] = ${2:arrayToDestruct}",
        "doc": "Creates and assigns a local variable using array destructing",
        "grammar": "lsp",
        "label": "destructingArray",
        "matches": {
          "dar": true
        },
        "options": {}
      },
      {
        "content": "setInterval(() => {\n\t${2}\n}, ${0:intervalInms})\n",
        "doc": "Executes the given function at specified intervals in ES7 syntax",
        "grammar": "lsp",
        "label": "setInterval",
        "matches": {
          "sti": true
        },
        "options": {}
      },
      {
        "content": "setTimeout(() => {\n\t${2}\n}, ${1:delayInms})\n",
        "doc": "Executes the given function after the specified delay in ES7 syntax",
        "grammar": "lsp",
        "label": "setTimeOut",
        "matches": {
          "sto": true
        },
        "options": {}
      },
      {
        "content": "return new Promise((resolve, reject) => {\n\t${1}\n})\n",
        "doc": "Creates and returns a new Promise in the standard ES7 syntax",
        "grammar": "lsp",
        "label": "promise",
        "matches": {
          "prom": true
        },
        "options": {}
      },
      {
        "content": "console.assert(${1:expression}, ${2:object})",
        "doc": "If the specified expression is false, the message is written to the console along with a stack trace",
        "grammar": "lsp",
        "label": "consoleAssert",
        "matches": {
          "cas": true
        },
        "options": {}
      },
      {
        "content": "console.clear()",
        "doc": "Clears the console",
        "grammar": "lsp",
        "label": "consoleClear",
        "matches": {
          "ccl": true
        },
        "options": {}
      },
      {
        "content": "console.count(${1:label})",
        "doc": "Writes the the number of times that count() has been invoked at the same line and with the same label",
        "grammar": "lsp",
        "label": "consoleCount",
        "matches": {
          "cco": true
        },
        "options": {}
      },
      {
        "content": "console.dir(${1:object})",
        "doc": "Prints a JavaScript representation of the specified object",
        "grammar": "lsp",
        "label": "consoleDir",
        "matches": {
          "cdi": true
        },
        "options": {}
      },
      {
        "content": "console.error(${1:object})",
        "doc": "Displays a message in the console and also includes a stack trace from where the method was called",
        "grammar": "lsp",
        "label": "consoleError",
        "matches": {
          "cer": true
        },
        "options": {}
      },
      {
        "content": "console.group(\"${1:label}\")",
        "doc": "Groups and indents all following output by an additional level, until console.groupEnd() is called.",
        "grammar": "lsp",
        "label": "consoleGroup",
        "matches": {
          "cgr": true
        },
        "options": {}
      },
      {
        "content": "console.groupEnd()",
        "doc": "Closes out the corresponding console.group().",
        "grammar": "lsp",
        "label": "consoleGroupEnd",
        "matches": {
          "cge": true
        },
        "options": {}
      },
      {
        "content": "console.log(${1:object})",
        "doc": "Displays a message in the console",
        "grammar": "lsp",
        "label": "consoleLog",
        "matches": {
          "clg": true
        },
        "options": {}
      },
      {
        "content": "console.trace(${1:object})",
        "doc": "Prints a stack trace from the point where the method was called",
        "grammar": "lsp",
        "label": "consoleTrace",
        "matches": {
          "ctr": true
        },
        "options": {}
      },
      {
        "content": "console.log(`${1:object}`, ${1:object})",
        "doc": "Logs property with name.",
        "grammar": "lsp",
        "label": "consoleLogObject",
        "matches": {
          "clo": true
        },
        "options": {}
      },
      {
        "content": "console.time(`${1:object}`)",
        "doc": "Console time wrapper",
        "grammar": "lsp",
        "label": "consoleTime",
        "matches": {
          "ctm": true
        },
        "options": {}
      },
      {
        "content": "console.timeEnd(`${1:object}`)",
        "doc": "Console time end wrapper",
        "grammar": "lsp",
        "label": "consoleTimeEnd",
        "matches": {
          "cte": true
        },
        "options": {}
      },
      {
        "content": "console.warn(${1:object})",
        "doc": "Displays a message in the console but also displays a yellow warning icon along with the logged message",
        "grammar": "lsp",
        "label": "consoleWarn",
        "matches": {
          "cwa": true
        },
        "options": {}
      },
      {
        "content": "console.info(${1:object})",
        "doc": "Displays a message in the console but also displays a blue information icon along with the logged message",
        "grammar": "lsp",
        "label": "consoleInfo",
        "matches": {
          "cin": true
        },
        "options": {}
      },
      {
        "content": "const { $1 } = this.props",
        "doc": "Creates and assigns a local variable using props destructing",
        "grammar": "lsp",
        "label": "destructProps",
        "matches": {
          "cp": true
        },
        "options": {}
      },
      {
        "content": "const { $1 } = this.state",
        "doc": "Creates and assigns a local variable using state destructing",
        "grammar": "lsp",
        "label": "destructState",
        "matches": {
          "cs": true
        },
        "options": {}
      },
      {
        "content": "import React from 'react'\n",
        "doc": "",
        "grammar": "lsp",
        "label": "import React",
        "matches": {
          "imr": true
        },
        "options": {}
      },
      {
        "content": "import ReactDOM from 'react-dom'\n",
        "doc": "",
        "grammar": "lsp",
        "label": "import ReactDOM",
        "matches": {
          "imrd": true
        },
        "options": {}
      },
      {
        "content": "import React, { Component } from 'react'\n",
        "doc": "",
        "grammar": "lsp",
        "label": "import React, { Component }",
        "matches": {
          "imrc": true
        },
        "options": {}
      },
      {
        "content": "import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\n",
        "doc": "",
        "grammar": "lsp",
        "label": "import React, { Component } & PropTypes",
        "matches": {
          "imrcp": true
        },
        "options": {}
      },
      {
        "content": "import React, { PureComponent } from 'react'\n",
        "doc": "",
        "grammar": "lsp",
        "label": "import React, { PureComponent }",
        "matches": {
          "imrpc": true
        },
        "options": {}
      },
      {
        "content": "import React, { PureComponent } from 'react'\nimport PropTypes from 'prop-types'\n",
        "doc": "",
        "grammar": "lsp",
        "label": "import React, { PureComponent } & PropTypes",
        "matches": {
          "imrpcp": true
        },
        "options": {}
      },
      {
        "content": "import React, { memo } from 'react'\n",
        "doc": "",
        "grammar": "lsp",
        "label": "import React, { memo }",
        "matches": {
          "imrm": true
        },
        "options": {}
      },
      {
        "content": "import React, { memo } from 'react'\nimport PropTypes from 'prop-types'\n",
        "doc": "",
        "grammar": "lsp",
        "label": "import React, { memo } & PropTypes",
        "matches": {
          "imrmp": true
        },
        "options": {}
      },
      {
        "content": "import React, { useState } from 'react'\n",
        "doc": "",
        "grammar": "lsp",
        "label": "import React, {useState}",
        "matches": {
          "imrs": true
        },
        "options": {}
      },
      {
        "content": "import React, { useEffect } from 'react'\n",
        "doc": "",
        "grammar": "lsp",
        "label": "import React, {useEffect}",
        "matches": {
          "imre": true
        },
        "options": {}
      },
      {
        "content": "import React, { useRef } from 'react'\n",
        "doc": "",
        "grammar": "lsp",
        "label": "import React, {useRef}",
        "matches": {
          "imrr": true
        },
        "options": {}
      },
      {
        "content": "import React, { useState, useEffect } from 'react'\n",
        "doc": "",
        "grammar": "lsp",
        "label": "import React, {useState, useEffect}",
        "matches": {
          "imrse": true
        },
        "options": {}
      },
      {
        "content": "import PropTypes from 'prop-types'\n",
        "doc": "",
        "grammar": "lsp",
        "label": "import PropTypes",
        "matches": {
          "impt": true
        },
        "options": {}
      },
      {
        "content": "import { BrowserRouter as Router, Route, NavLink } from 'react-router-dom'\n",
        "doc": "",
        "grammar": "lsp",
        "label": "import React Router",
        "matches": {
          "imrr": true
        },
        "options": {}
      },
      {
        "content": "import { BrowserRouter as Router } from 'react-router-dom'\n",
        "doc": "",
        "grammar": "lsp",
        "label": "import React Browser Router",
        "matches": {
          "imbr": true
        },
        "options": {}
      },
      {
        "content": "import { Route } from 'react-router-dom'\n",
        "doc": "",
        "grammar": "lsp",
        "label": "import React Browser Router - Route",
        "matches": {
          "imbrr": true
        },
        "options": {}
      },
      {
        "content": "import { Route, Switch, NavLink, Link } from 'react-router-dom'\n",
        "doc": "",
        "grammar": "lsp",
        "label": "import React Browser Router - Route Combo",
        "matches": {
          "imbrc": true
        },
        "options": {}
      },
      {
        "content": "import { Switch } from 'react-router-dom'\n",
        "doc": "",
        "grammar": "lsp",
        "label": "import React Browser Router - Switch",
        "matches": {
          "imbrs": true
        },
        "options": {}
      },
      {
        "content": "import { Link } from 'react-router-dom'\n",
        "doc": "",
        "grammar": "lsp",
        "label": "import React Browser Router - Link",
        "matches": {
          "imbrl": true
        },
        "options": {}
      },
      {
        "content": "import { NavLink } from 'react-router-dom'\n",
        "doc": "",
        "grammar": "lsp",
        "label": "import React Browser Router - NavLink",
        "matches": {
          "imbrnl": true
        },
        "options": {}
      },
      {
        "content": "import { connect } from 'react-redux'\n",
        "doc": "",
        "grammar": "lsp",
        "label": "import redux statement",
        "matches": {
          "redux": true
        },
        "options": {}
      },
      {
        "content": "import React, { Component } from 'react'\n\nexport default class ${1:${TM_FILENAME_BASE}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n",
        "doc": "Creates a React component class with ES7 module system",
        "grammar": "lsp",
        "label": "reactClassComponent",
        "matches": {
          "rcc": true
        },
        "options": {}
      },
      {
        "content": "import React, { Component } from 'react'\n\nexport class ${1:${TM_FILENAME_BASE}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "Creates a React component class with ES7 module system",
        "grammar": "lsp",
        "label": "reactClassExportComponent",
        "matches": {
          "rce": true
        },
        "options": {}
      },
      {
        "content": "import React from 'react'\n\nfunction ${1:${TM_FILENAME_BASE}}() {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "Creates a React Functional Component with ES7 module system",
        "grammar": "lsp",
        "label": "reactFunctionalExportComponent",
        "matches": {
          "rfce": true
        },
        "options": {}
      },
      {
        "content": "import React from 'react'\n\nexport default function ${1:${TM_FILENAME_BASE}}() {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n",
        "doc": "Creates a React Functional Component with ES7 module system",
        "grammar": "lsp",
        "label": "reactFunctionalComponent",
        "matches": {
          "rfc": true
        },
        "options": {}
      },
      {
        "content": "import React from 'react'\nimport PropTypes from 'prop-types'\n\nfunction ${1:${TM_FILENAME_BASE}}(props) {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n\n",
        "doc": "Creates a React Functional Component with ES7 module system with PropTypes",
        "grammar": "lsp",
        "label": "reactFunctionalComponentWithPropTypes",
        "matches": {
          "rfcp": true
        },
        "options": {}
      },
      {
        "content": "import React from 'react'\n\nconst ${1:${TM_FILENAME_BASE}} = () => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "Creates a React Arrow Function Component with ES7 module system",
        "grammar": "lsp",
        "label": "reactArrowFunctionExportComponent",
        "matches": {
          "rafce": true
        },
        "options": {}
      },
      {
        "content": "import React from 'react'\n\nexport const ${1:${TM_FILENAME_BASE}} = () => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n",
        "doc": "Creates a React Arrow Function Component with ES7 module system",
        "grammar": "lsp",
        "label": "reactArrowFunctionComponent",
        "matches": {
          "rafc": true
        },
        "options": {}
      },
      {
        "content": "import React from 'react'\nimport PropTypes from 'prop-types'\n\nconst ${1:${TM_FILENAME_BASE}} = props => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "Creates a React Arrow Function Component with ES7 module system with PropTypes",
        "grammar": "lsp",
        "label": "reactArrowFunctionComponentWithPropTypes",
        "matches": {
          "rafcp": true
        },
        "options": {}
      },
      {
        "content": "import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\n\nexport class ${1:${TM_FILENAME_BASE}} extends Component {\n\tstatic propTypes = {\n\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "Creates a React component class with ES7 module system",
        "grammar": "lsp",
        "label": "reactClassExportComponentWithPropTypes",
        "matches": {
          "rcep": true
        },
        "options": {}
      },
      {
        "content": "import React, { PureComponent } from 'react'\n\nexport default class ${1:${TM_FILENAME_BASE}} extends PureComponent {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n",
        "doc": "Creates a React pure component class with ES7 module system",
        "grammar": "lsp",
        "label": "reactClassPureComponent",
        "matches": {
          "rpc": true
        },
        "options": {}
      },
      {
        "content": "import React, { PureComponent } from 'react'\n\nexport class ${1:${TM_FILENAME_BASE}} extends PureComponent {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n\nexport default ${1:$TM_FILENAME_BASE}\n",
        "doc": "Creates a React pure component class with ES7 module system export",
        "grammar": "lsp",
        "label": "reactClassExportPureComponent",
        "matches": {
          "rpce": true
        },
        "options": {}
      },
      {
        "content": "import React, { PureComponent } from 'react'\nimport PropTypes from 'prop-types'\n\nexport default class ${1:${TM_FILENAME_BASE}} extends PureComponent {\n\tstatic propTypes = {\n\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n",
        "doc": "Creates a React component class with ES7 module system",
        "grammar": "lsp",
        "label": "reactClassPureComponentWithPropTypes",
        "matches": {
          "rpcp": true
        },
        "options": {}
      },
      {
        "content": "import React, { memo } from 'react'\n\nexport default memo(function ${1:${TM_FILENAME_BASE}}() {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n})\n",
        "doc": "Creates a React Memo Function Component with ES7 module system",
        "grammar": "lsp",
        "label": "reactFunctionMemoComponent",
        "matches": {
          "rmc": true
        },
        "options": {}
      },
      {
        "content": "import React, { memo } from 'react'\nimport PropTypes from 'prop-types'\n\nconst ${1:${TM_FILENAME_BASE}} = memo(function ${1:${TM_FILENAME_BASE}}(props) {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n})\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "Creates a React Memo Function Component with ES7 module system with PropTypes",
        "grammar": "lsp",
        "label": "reactFunctionMemoComponentWithPropTypes",
        "matches": {
          "rmcp": true
        },
        "options": {}
      },
      {
        "content": "import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\n\nexport default class ${1:${TM_FILENAME_BASE}} extends Component {\n\tstatic propTypes = {\n\t\t${2:prop}: ${3:PropTypes}\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n",
        "doc": "Creates a React component class with PropTypes and ES7 module system",
        "grammar": "lsp",
        "label": "reactClassCompomentPropTypes",
        "matches": {
          "rccp": true
        },
        "options": {}
      },
      {
        "content": "import React, { Component } from 'react'\nimport { connect } from 'react-redux'\n\nexport class ${1:${TM_FILENAME_BASE}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n\nconst mapStateToProps = (state) => ({\n\t\n})\n\nconst mapDispatchToProps = {\n\t\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(${1:${TM_FILENAME_BASE}})\n",
        "doc": "Creates a React component class with connected redux and ES7 module system",
        "grammar": "lsp",
        "label": "reactClassCompomentRedux",
        "matches": {
          "rcredux": true
        },
        "options": {}
      },
      {
        "content": "import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\nimport { connect } from 'react-redux'\n\nexport class ${1:${TM_FILENAME_BASE}} extends Component {\n\tstatic propTypes = {\n\t\t${2:prop}: ${3:PropTypes}\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n\nconst mapStateToProps = (state) => ({\n\t\n})\n\nconst mapDispatchToProps = {\n\t\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(${1:${TM_FILENAME_BASE}})\n",
        "doc": "Creates a React component class with PropTypes with connected redux and ES7 module system",
        "grammar": "lsp",
        "label": "reactClassCompomentReduxPropTypes",
        "matches": {
          "rcreduxp": true
        },
        "options": {}
      },
      {
        "content": "import React from 'react'\nimport { connect } from 'react-redux'\n\nexport const ${1:${TM_FILENAME_BASE}} = (props) => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\nconst mapStateToProps = (state) => ({\n\t\n})\n\nconst mapDispatchToProps = {\n\t\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(${1:${TM_FILENAME_BASE}})\n",
        "doc": "Creates a React functional component with connected redux and ES7 module system",
        "grammar": "lsp",
        "label": "reactFunctionalCompomentRedux",
        "matches": {
          "rfcredux": true
        },
        "options": {}
      },
      {
        "content": "import React from 'react'\nimport PropTypes from 'prop-types'\nimport { connect } from 'react-redux'\n\nexport const ${1:${TM_FILENAME_BASE}} = (props) => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\t${2:props}: ${3:PropTypes}\n}\n\nconst mapStateToProps = (state) => ({\n\t\n})\n\nconst mapDispatchToProps = {\n\t\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(${1:${TM_FILENAME_BASE}})\n",
        "doc": "Creates a React functional component with PropTypes with connected redux and ES7 module system",
        "grammar": "lsp",
        "label": "reactFunctionalCompomentReduxPropTypes",
        "matches": {
          "rfcreduxp": true
        },
        "options": {}
      },
      {
        "content": "const mapStateToProps = (state) => ({\n\t${1}\n})\n\nconst mapDispatchToProps = {\n\t\n}\n",
        "doc": "",
        "grammar": "lsp",
        "label": "mappingToProps",
        "matches": {
          "reduxmap": true
        },
        "options": {}
      },
      {
        "content": "constructor(props) {\n\tsuper(props)\n\n\tthis.state = {\n\t\t $0\n\t}\n}\n",
        "doc": "Adds a default constructor for it('', () => {})the class that contains props as arguments",
        "grammar": "lsp",
        "label": "classConstructor",
        "matches": {
          "rconst": true
        },
        "options": {}
      },
      {
        "content": "state = {\n\t$1\n}\n",
        "doc": "Creates empty state object. To be used in a constructor.",
        "grammar": "lsp",
        "label": "emptyState",
        "matches": {
          "est": true
        },
        "options": {}
      },
      {
        "content": "componentWillMount() {\n\t$0\n}\n",
        "doc": "DEPRECATED!!!. Invoked once, both on the client and server, immediately before the initial rendering occurs",
        "grammar": "lsp",
        "label": "componentWillMount",
        "matches": {
          "cwm": true
        },
        "options": {}
      },
      {
        "content": "componentDidMount() {\n\t$0\n}\n",
        "doc": "Invoked once, only on the client (not on the server), immediately after the initial rendering occurs.",
        "grammar": "lsp",
        "label": "componentDidMount",
        "matches": {
          "cdm": true
        },
        "options": {}
      },
      {
        "content": "componentWillReceiveProps(nextProps) {\n\t$0\n}\n",
        "doc": "DEPRECATED!!!. Invoked when a component is receiving new props. This method is not called for the initial render.",
        "grammar": "lsp",
        "label": "componentWillReceiveProps",
        "matches": {
          "cwr": true
        },
        "options": {}
      },
      {
        "content": "shouldComponentUpdate(nextProps, nextState) {\n\t$0\n}\n",
        "doc": "Invoked before rendering when new props or state are being received. ",
        "grammar": "lsp",
        "label": "shouldComponentUpdate",
        "matches": {
          "scu": true
        },
        "options": {}
      },
      {
        "content": "componentWillUpdate(nextProps, nextState) {\n\t$0\n}\n",
        "doc": "DEPRECATED!!!. Invoked immediately before rendering when new props or state are being received.",
        "grammar": "lsp",
        "label": "componentWillUpdate",
        "matches": {
          "cwup": true
        },
        "options": {}
      },
      {
        "content": "componentDidUpdate(prevProps, prevState) {\n\t$0\n}\n",
        "doc": "Invoked immediately after the component's updates are flushed to the DOM.",
        "grammar": "lsp",
        "label": "componentDidUpdate",
        "matches": {
          "cdup": true
        },
        "options": {}
      },
      {
        "content": "componentWillUnmount() {\n\t$0\n}\n",
        "doc": "Invoked immediately before a component is unmounted from the DOM.",
        "grammar": "lsp",
        "label": "componentWillUnmount",
        "matches": {
          "cwun": true
        },
        "options": {}
      },
      {
        "content": "static getDerivedStateFromProps(props, state) {\n\t${1}\n}",
        "doc": "Invoked right before calling the render method, both on the initial mount and on subsequent updates.",
        "grammar": "lsp",
        "label": "getDerivedStateFromProps",
        "matches": {
          "gdsfp": true
        },
        "options": {}
      },
      {
        "content": "getSnapshotBeforeUpdate = (prevProps, prevState) => {\n\t$0\n}\n",
        "doc": "Called right before mutations are made (e.g. before the DOM is updated)",
        "grammar": "lsp",
        "label": "getSnapshotBeforeUpdate",
        "matches": {
          "gsbu": true
        },
        "options": {}
      },
      {
        "content": "render() {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}",
        "doc": "Basic render.",
        "grammar": "lsp",
        "label": "componentRender",
        "matches": {
          "ren": true
        },
        "options": {}
      },
      {
        "content": "const ${1:contextName} = React.createContext()\n",
        "doc": "Create React context",
        "grammar": "lsp",
        "label": "createContext",
        "matches": {
          "rcontext": true
        },
        "options": {}
      },
      {
        "content": "this.${1:refName}Ref = React.createRef()\n",
        "doc": "Create ref statement used inside constructor",
        "grammar": "lsp",
        "label": "createRef",
        "matches": {
          "cref": true
        },
        "options": {}
      },
      {
        "content": "const ref = React.createRef()\n",
        "doc": "Forward ref statement used inside component",
        "grammar": "lsp",
        "label": "forwardRef",
        "matches": {
          "fref": true
        },
        "options": {}
      },
      {
        "content": "this.setState({$0})",
        "doc": "Performs a shallow merge of nextState into current state",
        "grammar": "lsp",
        "label": "componentSetStateObject",
        "matches": {
          "sst": true
        },
        "options": {}
      },
      {
        "content": "this.setState((state, props) => { return { $0 }})\n",
        "doc": "Performs a shallow merge of nextState into current state",
        "grammar": "lsp",
        "label": "componentSetStateFunc",
        "matches": {
          "ssf": true
        },
        "options": {}
      },
      {
        "content": "this.props.$0",
        "doc": "Access component's props",
        "grammar": "lsp",
        "label": "componentProps",
        "matches": {
          "props": true
        },
        "options": {}
      },
      {
        "content": "this.state.$0",
        "doc": "",
        "grammar": "lsp",
        "label": "componentState",
        "matches": {
          "state": true
        },
        "options": {}
      },
      {
        "content": "this.${1:methodName} = this.${1:methodName}.bind(this)$0",
        "doc": "Binds this to a method",
        "grammar": "lsp",
        "label": "bindThis",
        "matches": {
          "bnd": true
        },
        "options": {}
      },
      {
        "content": "export const ${1:actionName} = (payload) => ({\n\ttype: ${3:type},\n\tpayload\n})\n",
        "doc": "",
        "grammar": "lsp",
        "label": "reduxAction",
        "matches": {
          "rxaction": true
        },
        "options": {}
      },
      {
        "content": "export const ${1:constantName} = '${1:constantName}'",
        "doc": "",
        "grammar": "lsp",
        "label": "reduxConst",
        "matches": {
          "rxconst": true
        },
        "options": {}
      },
      {
        "content": "const initialState = {\n\n}\n\nexport default (state = initialState, { type, payload }) => {\n\tswitch (type) {\n\n\tcase ${1:typeName}:\n\t\treturn { ...state, ...payload }\n\n\tdefault:\n\t\treturn state\n\t}\n}\n",
        "doc": "",
        "grammar": "lsp",
        "label": "reduxReducer",
        "matches": {
          "rxreducer": true
        },
        "options": {}
      },
      {
        "content": "import { createSelector } from 'reselect'\n\nexport const ${1:selectorName} = state => state.${2:selector}\n",
        "doc": "",
        "grammar": "lsp",
        "label": "reduxSelector",
        "matches": {
          "rxselect": true
        },
        "options": {}
      },
      {
        "content": "import { createSlice } from '@reduxjs/toolkit'\n\nconst initialState = {\n\n}\n\nconst ${1:${TM_FILENAME_BASE}} = createSlice({\n\tname: ${2:sliceName},\n\tinitialState,\n\treducers: {\n\t\n\t}\n});\n\nexport const {\n\n} = ${1:${TM_FILENAME_BASE}}.actions\nexport default ${1:${TM_FILENAME_BASE}}.reducer",
        "doc": "",
        "grammar": "lsp",
        "label": "reduxSlice",
        "matches": {
          "rxslice": true
        },
        "options": {}
      },
      {
        "content": "import React, { Component } from 'react'\nimport { Text, View } from 'react-native'\n\nexport default class ${1:${TM_FILENAME_BASE}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<View>\n\t\t\t\t<Text> ${2:textInComponent} </Text>\n\t\t\t</View>\n\t\t)\n\t}\n}\n",
        "doc": "",
        "grammar": "lsp",
        "label": "reactNativeComponent",
        "matches": {
          "rnc": true
        },
        "options": {}
      },
      {
        "content": "import React, { Component } from 'react'\nimport { Text, StyleSheet, View } from 'react-native'\n\nexport default class ${1:${TM_FILENAME_BASE}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<View>\n\t\t\t\t<Text> ${2:textInComponent} </Text>\n\t\t\t</View>\n\t\t)\n\t}\n}\n\nconst styles = StyleSheet.create({})\n",
        "doc": "",
        "grammar": "lsp",
        "label": "reactNativeComponentWithStyles",
        "matches": {
          "rncs": true
        },
        "options": {}
      },
      {
        "content": "import React, { Component } from 'react'\nimport { Text, View } from 'react-native'\n\nexport class ${1:${TM_FILENAME_BASE}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<View>\n\t\t\t\t<Text> ${2:textInComponent} </Text>\n\t\t\t</View>\n\t\t)\n\t}\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "",
        "grammar": "lsp",
        "label": "reactNativeComponentExport",
        "matches": {
          "rnce": true
        },
        "options": {}
      },
      {
        "content": "import React, { PureComponent } from 'react'\nimport { Text, View } from 'react-native'\n\nexport default class ${1:${TM_FILENAME_BASE}} extends PureComponent {\n\trender() {\n\t\treturn (\n\t\t\t<View>\n\t\t\t\t<Text> ${2:textInComponent} </Text>\n\t\t\t</View>\n\t\t)\n\t}\n}\n",
        "doc": "",
        "grammar": "lsp",
        "label": "reactNativePureComponent",
        "matches": {
          "rnpc": true
        },
        "options": {}
      },
      {
        "content": "import React, { PureComponent } from 'react'\nimport { Text, View } from 'react-native'\n\nexport class ${1:${TM_FILENAME_BASE}} extends PureComponent {\n\trender() {\n\t\treturn (\n\t\t\t<View>\n\t\t\t\t<Text> ${2:textInComponent} </Text>\n\t\t\t</View>\n\t\t)\n\t}\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "",
        "grammar": "lsp",
        "label": "reactNativePureComponentExport",
        "matches": {
          "rnpce": true
        },
        "options": {}
      },
      {
        "content": "import React, { Component } from 'react'\nimport { View, Text } from 'react-native'\nimport PropTypes from 'prop-types'\nimport { connect } from 'react-redux'\n\nexport class ${1:${TM_FILENAME_BASE}} extends Component {\n\tstatic propTypes = {\n\t\t${2:prop}: ${3:PropTypes}\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<View>\n\t\t\t\t<Text> ${2:textInComponent} </Text>\n\t\t\t</View>\n\t\t)\n\t}\n}\n\nconst mapStateToProps = (state) => ({\n\t\n})\n\nconst mapDispatchToProps = {\n\t\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(${1:${TM_FILENAME_BASE}})\n",
        "doc": "Creates a React Native component class with PropTypes with connected redux and ES7 module system",
        "grammar": "lsp",
        "label": "reactNativeClassComponentRedux",
        "matches": {
          "rncredux": true
        },
        "options": {}
      },
      {
        "content": "import React from 'react'\nimport { View, Text } from 'react-native'\n\nconst ${1:${TM_FILENAME_BASE}} = () => {\n\treturn (\n\t\t<View>\n\t\t\t<Text>$0</Text>\n\t\t</View>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "",
        "grammar": "lsp",
        "label": "reactNativeFunctionalExportComponent",
        "matches": {
          "rnfe": true
        },
        "options": {}
      },
      {
        "content": "import React from 'react'\nimport { StyleSheet, Text, View } from 'react-native'\n\nconst ${1:${TM_FILENAME_BASE}} = () => {\n\treturn (\n\t\t<View>\n\t\t\t<Text>$0</Text>\n\t\t</View>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n\nconst styles = StyleSheet.create({})\n",
        "doc": "",
        "grammar": "lsp",
        "label": "reactNativeFunctionalExportComponentWithStyles",
        "matches": {
          "rnfes": true
        },
        "options": {}
      },
      {
        "content": "import React from 'react'\nimport { View, Text } from 'react-native'\n\nexport default function ${1:${TM_FILENAME_BASE}}() {\n\treturn (\n\t\t<View>\n\t\t\t<Text>$0</Text>\n\t\t</View>\n\t)\n}\n",
        "doc": "",
        "grammar": "lsp",
        "label": "reactNativeFunctionalComponent",
        "matches": {
          "rnf": true
        },
        "options": {}
      },
      {
        "content": "import React from 'react'\nimport { StyleSheet, Text, View } from 'react-native'\n\nexport default function ${1:${TM_FILENAME_BASE}}() {\n\treturn (\n\t\t<View>\n\t\t\t<Text>$0</Text>\n\t\t</View>\n\t)\n}\n\nconst styles = StyleSheet.create({})\n",
        "doc": "",
        "grammar": "lsp",
        "label": "reactNativeFunctionalComponentWithStyles",
        "matches": {
          "rnfs": true
        },
        "options": {}
      },
      {
        "content": "import { ${1:moduleName} } from 'react-native'",
        "doc": "",
        "grammar": "lsp",
        "label": "reactNativeImport",
        "matches": {
          "imrn": true
        },
        "options": {}
      },
      {
        "content": "const styles = StyleSheet.create({\n\t${1:style}\n})\n",
        "doc": "",
        "grammar": "lsp",
        "label": "reactNativeStyles",
        "matches": {
          "rnstyle": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.array,",
        "doc": "Array prop type",
        "grammar": "lsp",
        "label": "propTypeArray",
        "matches": {
          "pta": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.array.isRequired,",
        "doc": "Array prop type required",
        "grammar": "lsp",
        "label": "propTypeArrayRequired",
        "matches": {
          "ptar": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.bool,",
        "doc": "Bool prop type",
        "grammar": "lsp",
        "label": "propTypeBool",
        "matches": {
          "ptb": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.bool.isRequired,",
        "doc": "Bool prop type required",
        "grammar": "lsp",
        "label": "propTypeBoolRequired",
        "matches": {
          "ptbr": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.func,",
        "doc": "Func prop type",
        "grammar": "lsp",
        "label": "propTypeFunc",
        "matches": {
          "ptf": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.func.isRequired,",
        "doc": "Func prop type required",
        "grammar": "lsp",
        "label": "propTypeFuncRequired",
        "matches": {
          "ptfr": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.number,",
        "doc": "Number prop type",
        "grammar": "lsp",
        "label": "propTypeNumber",
        "matches": {
          "ptn": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.number.isRequired,",
        "doc": "Number prop type required",
        "grammar": "lsp",
        "label": "propTypeNumberRequired",
        "matches": {
          "ptnr": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.object,",
        "doc": "Object prop type",
        "grammar": "lsp",
        "label": "propTypeObject",
        "matches": {
          "pto": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.object.isRequired,",
        "doc": "Object prop type required",
        "grammar": "lsp",
        "label": "propTypeObjectRequired",
        "matches": {
          "ptor": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.string,",
        "doc": "String prop type",
        "grammar": "lsp",
        "label": "propTypeString",
        "matches": {
          "pts": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.string.isRequired,",
        "doc": "String prop type required",
        "grammar": "lsp",
        "label": "propTypeStringRequired",
        "matches": {
          "ptsr": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.node,",
        "doc": "Anything that can be rendered: numbers, strings, elements or an array",
        "grammar": "lsp",
        "label": "propTypeNode",
        "matches": {
          "ptnd": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.node.isRequired,",
        "doc": "Anything that can be rendered: numbers, strings, elements or an array required",
        "grammar": "lsp",
        "label": "propTypeNodeRequired",
        "matches": {
          "ptndr": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.element,",
        "doc": "React element prop type",
        "grammar": "lsp",
        "label": "propTypeElement",
        "matches": {
          "ptel": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.element.isRequired,",
        "doc": "React element prop type required",
        "grammar": "lsp",
        "label": "propTypeElementRequired",
        "matches": {
          "ptelr": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.instanceOf($0),",
        "doc": "Is an instance of a class prop type",
        "grammar": "lsp",
        "label": "propTypeInstanceOf",
        "matches": {
          "pti": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.instanceOf($0).isRequired,",
        "doc": "Is an instance of a class prop type required",
        "grammar": "lsp",
        "label": "propTypeInstanceOfRequired",
        "matches": {
          "ptir": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.oneOf(['$0']),",
        "doc": "Prop type limited to specific values by treating it as an enum",
        "grammar": "lsp",
        "label": "propTypeEnum",
        "matches": {
          "pte": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.oneOf(['$0']).isRequired,",
        "doc": "Prop type limited to specific values by treating it as an enum required",
        "grammar": "lsp",
        "label": "propTypeEnumRequired",
        "matches": {
          "pter": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.oneOfType([\n\t$0\n]),",
        "doc": "An object that could be one of many types",
        "grammar": "lsp",
        "label": "propTypeOneOfType",
        "matches": {
          "ptet": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.oneOfType([\n\t$0\n]).isRequired,",
        "doc": "An object that could be one of many types required",
        "grammar": "lsp",
        "label": "propTypeOneOfTypeRequired",
        "matches": {
          "ptetr": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.arrayOf($0),",
        "doc": "An array of a certain type",
        "grammar": "lsp",
        "label": "propTypeArrayOf",
        "matches": {
          "ptao": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.arrayOf($0).isRequired,",
        "doc": "An array of a certain type required",
        "grammar": "lsp",
        "label": "propTypeArrayOfRequired",
        "matches": {
          "ptaor": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.objectOf($0),",
        "doc": "An object with property values of a certain type",
        "grammar": "lsp",
        "label": "propTypeObjectOf",
        "matches": {
          "ptoo": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.objectOf($0).isRequired,",
        "doc": "An object with property values of a certain type required",
        "grammar": "lsp",
        "label": "propTypeObjectOfRequired",
        "matches": {
          "ptoor": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.shape({\n\t$0\n}),",
        "doc": "An object taking on a particular shape",
        "grammar": "lsp",
        "label": "propTypeShape",
        "matches": {
          "ptsh": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.shape({\n\t$0\n}).isRequired,",
        "doc": "An object taking on a particular shape required",
        "grammar": "lsp",
        "label": "propTypeShapeRequired",
        "matches": {
          "ptshr": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.exact({\n\t$0\n}),",
        "doc": "An object with warnings on extra properties",
        "grammar": "lsp",
        "label": "propTypeExact",
        "matches": {
          "ptex": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.exact({\n\t$0\n}).isRequired,",
        "doc": "An object with warnings on extra properties required",
        "grammar": "lsp",
        "label": "propTypeExactRequired",
        "matches": {
          "ptexr": true
        },
        "options": {}
      },
      {
        "content": "static propTypes = {\n$0\n}\n",
        "doc": "",
        "grammar": "lsp",
        "label": "staticPropTpyes",
        "matches": {
          "ptypes": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.any,",
        "doc": "Any prop type",
        "grammar": "lsp",
        "label": "propTypeAny",
        "matches": {
          "ptany": true
        },
        "options": {}
      },
      {
        "content": "/**\n * ${0}\n */",
        "doc": "",
        "grammar": "lsp",
        "label": "Comment Big Block",
        "matches": {
          "cmmb": true
        },
        "options": {}
      },
      {
        "content": "describe('$1', () => {\n\t$0\n})\n",
        "doc": "Testing `describe` block",
        "grammar": "lsp",
        "label": "describeBlock",
        "matches": {
          "desc": true
        },
        "options": {}
      },
      {
        "content": "test('should $1', () => {\n\t$0\n})\n",
        "doc": "Testing `test` block",
        "grammar": "lsp",
        "label": "testBlock",
        "matches": {
          "test": true
        },
        "options": {}
      },
      {
        "content": "test('should $1', async () => {\n\t$0\n})\n",
        "doc": "Testing `asynchronous test` block",
        "grammar": "lsp",
        "label": "testAsyncBlock",
        "matches": {
          "testa": true
        },
        "options": {}
      },
      {
        "content": "it('should $1', () => {\n\t$0\n})\n",
        "doc": "Testing `it` block",
        "grammar": "lsp",
        "label": "itBlock",
        "matches": {
          "tit": true
        },
        "options": {}
      },
      {
        "content": "it('should $1', async () => {\n\t$0\n})\n",
        "doc": "Testing asynchronous `it` block",
        "grammar": "lsp",
        "label": "itAsyncBlock",
        "matches": {
          "tita": true
        },
        "options": {}
      },
      {
        "content": "import React from 'react'\nimport renderer from 'react-test-renderer'\n\nimport { ${1:${TM_FILENAME_BASE}} } from '../${1:${TM_FILENAME_BASE}}'\n\ndescribe('<${1:${TM_FILENAME_BASE}} />', () => {\n\tconst defaultProps = {}\n\tconst wrapper = renderer.create(<${1:${TM_FILENAME_BASE}} {...defaultProps} />)\n\n\ttest('render', () => {\n\t\texpect(wrapper).toMatchSnapshot()\n\t})\n})\n",
        "doc": "",
        "grammar": "lsp",
        "label": "setupReactTest",
        "matches": {
          "stest": true
        },
        "options": {}
      },
      {
        "content": "import 'react-native'\nimport React from 'react'\nimport renderer from 'react-test-renderer'\n\nimport ${1:${TM_FILENAME_BASE}} from '../${1:${TM_FILENAME_BASE}}'\n\ndescribe('<${1:${TM_FILENAME_BASE}} />', () => {\n\tconst defaultProps = {}\n\tconst wrapper = renderer.create(<${1:${TM_FILENAME_BASE}} {...defaultProps} />)\n\n\ttest('render', () => {\n\t\texpect(wrapper).toMatchSnapshot()\n\t})\n})\n",
        "doc": "",
        "grammar": "lsp",
        "label": "setupReactNativeTest",
        "matches": {
          "sntest": true
        },
        "options": {}
      },
      {
        "content": "import React from 'react'\nimport renderer from 'react-test-renderer'\nimport { Provider } from 'react-redux'\n\nimport store from 'src/store'\nimport { ${1:${TM_FILENAME_BASE}} } from '../${1:${TM_FILENAME_BASE}}'\n\ndescribe('<${1:${TM_FILENAME_BASE}} />', () => {\n\tconst defaultProps = {}\n\tconst wrapper = renderer.create(\n\t\t<Provider store={store}>\n\t\t <${1:${TM_FILENAME_BASE}} {...defaultProps} />\n\t\t</Provider>,\n\t)\n\n\ttest('render', () => {\n\t\texpect(wrapper).toMatchSnapshot()\n\t})\n})\n",
        "doc": "Create test component",
        "grammar": "lsp",
        "label": "setupReactComponentTestWithRedux",
        "matches": {
          "srtest": true
        },
        "options": {}
      },
      {
        "content": "import 'react-native'\nimport React from 'react'\nimport renderer from 'react-test-renderer'\nimport { Provider } from 'react-redux'\n\nimport store from 'src/store'\nimport ${1:${TM_FILENAME_BASE}} from '../${1:${TM_FILENAME_BASE}}'\n\ndescribe('<${1:${TM_FILENAME_BASE}} />', () => {\n\tconst defaultProps = {}\n\tconst wrapper = renderer.create(\n\t\t<Provider store={store}>\n\t\t\t<${1:${TM_FILENAME_BASE}} {...defaultProps} />\n\t\t</Provider>,\n\t)\n\n\ttest('render', () => {\n\t\texpect(wrapper).toMatchSnapshot()\n\t})\n})\n",
        "doc": "",
        "grammar": "lsp",
        "label": "setupReactNativeTestWithRedux",
        "matches": {
          "snrtest": true
        },
        "options": {}
      },
      {
        "content": "import { compose, graphql } from 'react-apollo'\n",
        "doc": "",
        "grammar": "lsp",
        "label": "graphQLForComponent",
        "matches": {
          "graphql": true
        },
        "options": {}
      },
      {
        "content": "export default compose(\n\tgraphql(${1:queryOrMutation}, { name: ${2:name} }),\n)(${1:${TM_FILENAME_BASE}})",
        "doc": "",
        "grammar": "lsp",
        "label": "exportGraphQL",
        "matches": {
          "expgql": true
        },
        "options": {}
      },
      {
        "content": "import React from 'react'\nimport PropTypes from 'prop-types'\nimport { connect } from 'react-redux'\n\nexport const mapStateToProps = state => ({\n\n})\n\nexport const mapDispatchToProps = {\n \n}\n\nexport const ${1:hocComponentName} = (WrappedComponent) => {\n\tconst hocComponent = ({ ...props }) => <WrappedComponent {...props} />\n\n\thocComponent.propTypes = {\n\t}\n\n\treturn hocComponent\n}\n\nexport default WrapperComponent => connect(mapStateToProps, mapDispatchToProps)(${1:hocComponentName}(WrapperComponent))\n",
        "doc": "",
        "grammar": "lsp",
        "label": "hocComponentWithRedux",
        "matches": {
          "hocredux": true
        },
        "options": {}
      },
      {
        "content": "import React from 'react'\nimport PropTypes from 'prop-types'\n\nexport default (WrappedComponent) => {\n\tconst hocComponent = ({ ...props }) => <WrappedComponent {...props} />\n\n\thocComponent.propTypes = {\n\t}\n\n\treturn hocComponent\n}\n",
        "doc": "",
        "grammar": "lsp",
        "label": "hocComponent",
        "matches": {
          "hoc": true
        },
        "options": {}
      },
      {
        "content": "useEffect(() => {\n\t${1:effect}\n\treturn () => {\n\t\t${2:cleanup}\n\t}\n}, [${3:input}])",
        "doc": "",
        "grammar": "lsp",
        "label": "useEffect",
        "matches": {
          "useEffect": true
        },
        "options": {}
      },
      {
        "content": "const ${1:context} = useContext(${2:contextValue})",
        "doc": "",
        "grammar": "lsp",
        "label": "useContext",
        "matches": {
          "useContext": true
        },
        "options": {}
      },
      {
        "content": "const [state, dispatch] = useReducer(${1:reducer}, ${2:initialState}, ${3:init})",
        "doc": "",
        "grammar": "lsp",
        "label": "useReducer",
        "matches": {
          "useReducer": true
        },
        "options": {}
      },
      {
        "content": "useCallback(\n\t() => {\n\t\t${1:callback}\n\t},\n\t[${2:input}],\n)",
        "doc": "",
        "grammar": "lsp",
        "label": "useCallback",
        "matches": {
          "useCallback": true
        },
        "options": {}
      },
      {
        "content": "useMemo(() => ${1:function}, ${2:input})",
        "doc": "",
        "grammar": "lsp",
        "label": "useMemo",
        "matches": {
          "useMemo": true
        },
        "options": {}
      },
      {
        "content": "const ${1:ref} = useRef(${2:initialValue})",
        "doc": "",
        "grammar": "lsp",
        "label": "useRef",
        "matches": {
          "useRef": true
        },
        "options": {}
      },
      {
        "content": "useImperativeHandle(\n\t${1:ref},\n\t() => {\n\t\t${2:handler}\n\t},\n\t[${3:input}],\n)",
        "doc": "",
        "grammar": "lsp",
        "label": "useImperativeHandle",
        "matches": {
          "useImperativeHandle": true
        },
        "options": {}
      },
      {
        "content": "useDebugValue(${1:value})",
        "doc": "",
        "grammar": "lsp",
        "label": "useDebugValue",
        "matches": {
          "useDebugValue": true
        },
        "options": {}
      },
      {
        "content": "useLayoutEffect(() => {\n\t${1:effect}\n\treturn () => {\n\t\t${2:cleanup}\n\t};\n}, [${3:input}])",
        "doc": "",
        "grammar": "lsp",
        "label": "useLayoutEffect",
        "matches": {
          "useLayoutEffect": true
        },
        "options": {}
      },
      {
        "content": "const ${1:state} = useSelector(state => state.${1:state})",
        "doc": "",
        "grammar": "lsp",
        "label": "useSelector",
        "matches": {
          "useSelector": true
        },
        "options": {}
      },
      {
        "content": "const dispatch = useDispatch(${1:function})",
        "doc": "",
        "grammar": "lsp",
        "label": "useDispatch",
        "matches": {
          "useDispatch": true
        },
        "options": {}
      },
      {
        "content": "typeof ${0}",
        "doc": "",
        "grammar": "lsp",
        "label": "typeof",
        "matches": {
          "tpf": true
        },
        "options": {}
      },
      {
        "content": "function ${1:${TM_FILENAME_BASE}}() {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "Creates a React 17 Functional Component with ES7 module system",
        "grammar": "lsp",
        "label": "_reactFunctionalExportComponent",
        "matches": {
          "_rfce": true
        },
        "options": {}
      },
      {
        "content": "export default function ${1:${TM_FILENAME_BASE}}() {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n",
        "doc": "Creates a React 17 Functional Component with ES7 module system",
        "grammar": "lsp",
        "label": "_reactFunctionalComponent",
        "matches": {
          "_rfc": true
        },
        "options": {}
      },
      {
        "content": "import PropTypes from 'prop-types'\n\nfunction ${1:${TM_FILENAME_BASE}}(props) {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n\n",
        "doc": "Creates a React 17 Functional Component with ES7 module system with PropTypes",
        "grammar": "lsp",
        "label": "_reactFunctionalComponentWithPropTypes",
        "matches": {
          "_rfcp": true
        },
        "options": {}
      },
      {
        "content": "const ${1:${TM_FILENAME_BASE}} = () => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "Creates a React 17 Arrow Function Component with ES7 module system",
        "grammar": "lsp",
        "label": "_reactArrowFunctionExportComponent",
        "matches": {
          "_rafce": true
        },
        "options": {}
      },
      {
        "content": "export const ${1:${TM_FILENAME_BASE}} = () => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n",
        "doc": "Creates a React 17 Arrow Function Component with ES7 module system",
        "grammar": "lsp",
        "label": "_reactArrowFunctionComponent",
        "matches": {
          "_rafc": true
        },
        "options": {}
      },
      {
        "content": "import PropTypes from 'prop-types'\n\nconst ${1:${TM_FILENAME_BASE}} = props => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "Creates a React 17 Arrow Function Component with ES7 module system with PropTypes",
        "grammar": "lsp",
        "label": "_reactArrowFunctionComponentWithPropTypes",
        "matches": {
          "_rafcp": true
        },
        "options": {}
      },
      {
        "content": "import { View, Text } from 'react-native'\n\nconst ${1:${TM_FILENAME_BASE}} = () => {\n\treturn (\n\t\t<View>\n\t\t\t<Text>$0</Text>\n\t\t</View>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "",
        "grammar": "lsp",
        "label": "_reactNativeFunctionalExportComponent",
        "matches": {
          "_rnfe": true
        },
        "options": {}
      },
      {
        "content": "import { StyleSheet, Text, View } from 'react-native'\n\nconst ${1:${TM_FILENAME_BASE}} = () => {\n\treturn (\n\t\t<View>\n\t\t\t<Text>$0</Text>\n\t\t</View>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n\nconst styles = StyleSheet.create({})\n",
        "doc": "",
        "grammar": "lsp",
        "label": "_reactNativeFunctionalExportComponentWithStyles",
        "matches": {
          "_rnfes": true
        },
        "options": {}
      },
      {
        "content": "import { View, Text } from 'react-native'\n\nexport default function ${1:${TM_FILENAME_BASE}}() {\n\treturn (\n\t\t<View>\n\t\t\t<Text>$0</Text>\n\t\t</View>\n\t)\n}\n",
        "doc": "",
        "grammar": "lsp",
        "label": "_reactNativeFunctionalComponent",
        "matches": {
          "_rnf": true
        },
        "options": {}
      },
      {
        "content": "import { StyleSheet, Text, View } from 'react-native'\n\nexport default function ${1:${TM_FILENAME_BASE}}() {\n\treturn (\n\t\t<View>\n\t\t\t<Text>$0</Text>\n\t\t</View>\n\t)\n}\n\nconst styles = StyleSheet.create({})\n",
        "doc": "",
        "grammar": "lsp",
        "label": "_reactNativeFunctionalComponentWithStyles",
        "matches": {
          "_rnfs": true
        },
        "options": {}
      },
      {
        "content": "import renderer from 'react-test-renderer'\n\nimport { ${1:${TM_FILENAME_BASE}} } from '../${1:${TM_FILENAME_BASE}}'\n\ndescribe('<${1:${TM_FILENAME_BASE}} />', () => {\n\tconst defaultProps = {}\n\tconst wrapper = renderer.create(<${1:${TM_FILENAME_BASE}} {...defaultProps} />)\n\n\ttest('render', () => {\n\t\texpect(wrapper).toMatchSnapshot()\n\t})\n})\n",
        "doc": "",
        "grammar": "lsp",
        "label": "_setupReactTest",
        "matches": {
          "_stest": true
        },
        "options": {}
      },
      {
        "content": "import 'react-native'\nimport renderer from 'react-test-renderer'\n\nimport ${1:${TM_FILENAME_BASE}} from '../${1:${TM_FILENAME_BASE}}'\n\ndescribe('<${1:${TM_FILENAME_BASE}} />', () => {\n\tconst defaultProps = {}\n\tconst wrapper = renderer.create(<${1:${TM_FILENAME_BASE}} {...defaultProps} />)\n\n\ttest('render', () => {\n\t\texpect(wrapper).toMatchSnapshot()\n\t})\n})\n",
        "doc": "",
        "grammar": "lsp",
        "label": "_setupReactNativeTest",
        "matches": {
          "_sntest": true
        },
        "options": {}
      },
      {
        "content": "import renderer from 'react-test-renderer'\nimport { Provider } from 'react-redux'\n\nimport store from 'src/store'\nimport { ${1:${TM_FILENAME_BASE}} } from '../${1:${TM_FILENAME_BASE}}'\n\ndescribe('<${1:${TM_FILENAME_BASE}} />', () => {\n\tconst defaultProps = {}\n\tconst wrapper = renderer.create(\n\t\t<Provider store={store}>\n\t\t <${1:${TM_FILENAME_BASE}} {...defaultProps} />\n\t\t</Provider>,\n\t)\n\n\ttest('render', () => {\n\t\texpect(wrapper).toMatchSnapshot()\n\t})\n})\n",
        "doc": "Create test component",
        "grammar": "lsp",
        "label": "_setupReactComponentTestWithRedux",
        "matches": {
          "_srtest": true
        },
        "options": {}
      },
      {
        "content": "import 'react-native'\nimport renderer from 'react-test-renderer'\nimport { Provider } from 'react-redux'\n\nimport store from 'src/store'\nimport ${1:${TM_FILENAME_BASE}} from '../${1:${TM_FILENAME_BASE}}'\n\ndescribe('<${1:${TM_FILENAME_BASE}} />', () => {\n\tconst defaultProps = {}\n\tconst wrapper = renderer.create(\n\t\t<Provider store={store}>\n\t\t\t<${1:${TM_FILENAME_BASE}} {...defaultProps} />\n\t\t</Provider>,\n\t)\n\n\ttest('render', () => {\n\t\texpect(wrapper).toMatchSnapshot()\n\t})\n})\n",
        "doc": "",
        "grammar": "lsp",
        "label": "_setupReactNativeTestWithRedux",
        "matches": {
          "_snrtest": true
        },
        "options": {}
      },
      {
        "content": "import PropTypes from 'prop-types'\nimport { connect } from 'react-redux'\n\nexport const mapStateToProps = state => ({\n\n})\n\nexport const mapDispatchToProps = {\n \n}\n\nexport const ${1:hocComponentName} = (WrappedComponent) => {\n\tconst hocComponent = ({ ...props }) => <WrappedComponent {...props} />\n\n\thocComponent.propTypes = {\n\t}\n\n\treturn hocComponent\n}\n\nexport default WrapperComponent => connect(mapStateToProps, mapDispatchToProps)(${1:hocComponentName}(WrapperComponent))\n",
        "doc": "",
        "grammar": "lsp",
        "label": "_hocComponentWithRedux",
        "matches": {
          "_hocredux": true
        },
        "options": {}
      },
      {
        "content": "import PropTypes from 'prop-types'\n\nexport default (WrappedComponent) => {\n\tconst hocComponent = ({ ...props }) => <WrappedComponent {...props} />\n\n\thocComponent.propTypes = {\n\t}\n\n\treturn hocComponent\n}\n",
        "doc": "",
        "grammar": "lsp",
        "label": "_hocComponent",
        "matches": {
          "_hoc": true
        },
        "options": {}
      },
      {
        "content": "const ${1:${TM_FILENAME_BASE}} = () => {\n\t$2\n}\n\nexport default ${1:${TM_FILENAME_BASE}}",
        "doc": "Creates a React Custom Hook with ES7 module system",
        "grammar": "lsp",
        "label": "reactCustomHook",
        "matches": {
          "rch": true
        },
        "options": {}
      },
      {
        "content": "import ${2:moduleName} from '${1:module}';$0",
        "doc": "Imports entire module statement in ES6 syntax",
        "grammar": "lsp",
        "label": "import",
        "matches": {
          "imp": true
        },
        "options": {}
      },
      {
        "content": "import '${1:module}';$0",
        "doc": "Imports entire module in ES6 syntax without module name",
        "grammar": "lsp",
        "label": "importNoModuleName",
        "matches": {
          "imn": true
        },
        "options": {}
      },
      {
        "content": "import { $2 } from '${1:module}';$0",
        "doc": "Imports only a portion of the module in ES6 syntax",
        "grammar": "lsp",
        "label": "importDestructing",
        "matches": {
          "imd": true
        },
        "options": {}
      },
      {
        "content": "import * as ${2:alias} from '${1:module}';$0",
        "doc": "Imports everything as alias from the module in ES6 syntax",
        "grammar": "lsp",
        "label": "importEverything",
        "matches": {
          "ime": true
        },
        "options": {}
      },
      {
        "content": "import { ${2:originalName} as ${3:alias} } from '${1:module}';$0",
        "doc": "Imports a specific portion of the module by assigning a local alias in ES6 syntax",
        "grammar": "lsp",
        "label": "importAs",
        "matches": {
          "ima": true
        },
        "options": {}
      },
      {
        "content": "require('${1:package}');",
        "doc": "Require a package",
        "grammar": "lsp",
        "label": "require",
        "matches": {
          "rqr": true
        },
        "options": {}
      },
      {
        "content": "const ${1:packageName} = require('${1:package}');$0",
        "doc": "Require a package to const",
        "grammar": "lsp",
        "label": "requireToConst",
        "matches": {
          "req": true
        },
        "options": {}
      },
      {
        "content": "module.exports = {\n\t$0\n};\n",
        "doc": "Module exports from Common JS, node syntax at ES6",
        "grammar": "lsp",
        "label": "moduleExports",
        "matches": {
          "mde": true
        },
        "options": {}
      },
      {
        "content": "export const ${1:exportVariable} = ${2:localVariable};\n",
        "doc": "Export named variable in ES6 syntax",
        "grammar": "lsp",
        "label": "exportNamedVariable",
        "matches": {
          "env": true
        },
        "options": {}
      },
      {
        "content": "export const ${1:functionName} = (${2:params}) => {\n\t$0\n};\n",
        "doc": "Export named function in ES6 syntax",
        "grammar": "lsp",
        "label": "exportNamedFunction",
        "matches": {
          "enf": true
        },
        "options": {}
      },
      {
        "content": "export default function ${1:${TM_FILENAME_BASE}}(${2:params}) {\n\t$0\n};\n",
        "doc": "Export default function in ES6 syntax",
        "grammar": "lsp",
        "label": "exportDefaultFunction",
        "matches": {
          "edf": true
        },
        "options": {}
      },
      {
        "content": "export default class ${1:className} {\n\t$0\n};\n",
        "doc": "Export default class in ES6 syntax",
        "grammar": "lsp",
        "label": "exportClass",
        "matches": {
          "ecl": true
        },
        "options": {}
      },
      {
        "content": "export default class ${1:className} extends ${2:baseclassName} {\n\t$0\n};\n",
        "doc": "Export default class which extends a base one in ES6 syntax",
        "grammar": "lsp",
        "label": "exportClassExtends",
        "matches": {
          "ece": true
        },
        "options": {}
      },
      {
        "content": "constructor(${1:params}) {\n\t${0}\n}",
        "doc": "Add default constructor in a class in ES6 syntax",
        "grammar": "lsp",
        "label": "constructor",
        "matches": {
          "con": true
        },
        "options": {}
      },
      {
        "content": "${1:methodName}(${2:params}) {\n\t${0}\n}",
        "doc": "Creates a method inside a class in ES6 syntax",
        "grammar": "lsp",
        "label": "method",
        "matches": {
          "met": true
        },
        "options": {}
      },
      {
        "content": "get ${1:propertyName}() {\n\treturn this.${0};\n}",
        "doc": "Creates a getter property inside a class in ES6 syntax",
        "grammar": "lsp",
        "label": "propertyGet",
        "matches": {
          "pge": true
        },
        "options": {}
      },
      {
        "content": "set ${1:propertyName}(${2:value}) {\n\t${0};\n}",
        "doc": "Creates a setter property inside a class in ES6 syntax",
        "grammar": "lsp",
        "label": "propertyset",
        "matches": {
          "pse": true
        },
        "options": {}
      },
      {
        "content": "${1:array}.forEach(${2:currentItem} => {\n\t${0}\n});",
        "doc": "Creates a forEach statement in ES6 syntax",
        "grammar": "lsp",
        "label": "forEach",
        "matches": {
          "fre": true
        },
        "options": {}
      },
      {
        "content": "for (const ${1:item} of ${2:object}) {\n\t${0}\n}",
        "doc": "Iterating over property names of iterable objects",
        "grammar": "lsp",
        "label": "forOf",
        "matches": {
          "fof": true
        },
        "options": {}
      },
      {
        "content": "for (const ${1:item} in ${2:object}) {\n\t${0}\n}",
        "doc": "Iterating over property values of iterable objects",
        "grammar": "lsp",
        "label": "forIn",
        "matches": {
          "fin": true
        },
        "options": {}
      },
      {
        "content": "(${1:params}) => {\n\t${2}\n}",
        "doc": "Creates an anonymous function in ES6 syntax",
        "grammar": "lsp",
        "label": "anonymousFunction",
        "matches": {
          "anfn": true
        },
        "options": {}
      },
      {
        "content": "const ${1:name} = (${2:params}) => {\n\t${3}\n}",
        "doc": "Creates a named function in ES6 syntax",
        "grammar": "lsp",
        "label": "namedFunction",
        "matches": {
          "nfn": true
        },
        "options": {}
      },
      {
        "content": "const {${2:propertyName}} = ${1:objectToDestruct};",
        "doc": "Creates and assigns a local variable using object destructing",
        "grammar": "lsp",
        "label": "destructingObject",
        "matches": {
          "dob": true
        },
        "options": {}
      },
      {
        "content": "const [${2:propertyName}] = ${1:arrayToDestruct};",
        "doc": "Creates and assigns a local variable using array destructing",
        "grammar": "lsp",
        "label": "destructingArray",
        "matches": {
          "dar": true
        },
        "options": {}
      },
      {
        "content": "setInterval(() => {\n\t${2}\n}, ${0:intervalInms});",
        "doc": "Executes the given function at specified intervals in ES6 syntax",
        "grammar": "lsp",
        "label": "setInterval",
        "matches": {
          "sti": true
        },
        "options": {}
      },
      {
        "content": "setTimeout(() => {\n\t${2}\n}, ${1:delayInms});",
        "doc": "Executes the given function after the specified delay in ES6 syntax",
        "grammar": "lsp",
        "label": "setTimeOut",
        "matches": {
          "sto": true
        },
        "options": {}
      },
      {
        "content": "return new Promise((resolve, reject) => {\n\t${1}\n});",
        "doc": "Creates and returns a new Promise in the standard ES6 syntax",
        "grammar": "lsp",
        "label": "promise",
        "matches": {
          "prom": true
        },
        "options": {}
      },
      {
        "content": ".then((${1:result}) => {\n\t${2}\n}).catch((${3:err}) => {\n\t${4}\n});",
        "doc": "Add the .then and .catch methods to handle promises",
        "grammar": "lsp",
        "label": "thenCatch",
        "matches": {
          "thenc": true
        },
        "options": {}
      },
      {
        "content": "console.assert(${1:expression}, ${2:object});",
        "doc": "If the specified expression is false, the message is written to the console along with a stack trace",
        "grammar": "lsp",
        "label": "consoleAssert",
        "matches": {
          "cas": true
        },
        "options": {}
      },
      {
        "content": "console.clear();",
        "doc": "Clears the console",
        "grammar": "lsp",
        "label": "consoleClear",
        "matches": {
          "ccl": true
        },
        "options": {}
      },
      {
        "content": "console.count(${1:label});",
        "doc": "Writes the the number of times that count() has been invoked at the same line and with the same label",
        "grammar": "lsp",
        "label": "consoleCount",
        "matches": {
          "cco": true
        },
        "options": {}
      },
      {
        "content": "console.debug(${1:object});",
        "doc": "Displays a message in the console. Also display a blue right arrow icon along with the logged message in Safari",
        "grammar": "lsp",
        "label": "consoleDebug",
        "matches": {
          "cdb": true
        },
        "options": {}
      },
      {
        "content": "console.dir(${1:object});",
        "doc": "Prints a JavaScript representation of the specified object",
        "grammar": "lsp",
        "label": "consoleDir",
        "matches": {
          "cdi": true
        },
        "options": {}
      },
      {
        "content": "console.error(${1:object});",
        "doc": "Displays a message in the console and also includes a stack trace from where the method was called",
        "grammar": "lsp",
        "label": "consoleError",
        "matches": {
          "cer": true
        },
        "options": {}
      },
      {
        "content": "console.group('${1:label}');",
        "doc": "Groups and indents all following output by an additional level, until console.groupEnd() is called.",
        "grammar": "lsp",
        "label": "consoleGroup",
        "matches": {
          "cgr": true
        },
        "options": {}
      },
      {
        "content": "console.groupEnd();",
        "doc": "Closes out the corresponding console.group().",
        "grammar": "lsp",
        "label": "consoleGroupEnd",
        "matches": {
          "cge": true
        },
        "options": {}
      },
      {
        "content": "console.log(${1:object});",
        "doc": "Displays a message in the console",
        "grammar": "lsp",
        "label": "consoleLog",
        "matches": {
          "clg": true
        },
        "options": {}
      },
      {
        "content": "console.log('${1:object} :>> ', ${1:object});",
        "doc": "Displays an object in the console with its name",
        "grammar": "lsp",
        "label": "consoleLogObject",
        "matches": {
          "clo": true
        },
        "options": {}
      },
      {
        "content": "console.trace(${1:object});",
        "doc": "Prints a stack trace from the point where the method was called",
        "grammar": "lsp",
        "label": "consoleTrace",
        "matches": {
          "ctr": true
        },
        "options": {}
      },
      {
        "content": "console.warn(${1:object});",
        "doc": "Displays a message in the console but also displays a yellow warning icon along with the logged message",
        "grammar": "lsp",
        "label": "consoleWarn",
        "matches": {
          "cwa": true
        },
        "options": {}
      },
      {
        "content": "console.info(${1:object});",
        "doc": "Displays a message in the console but also displays a blue information icon along with the logged message",
        "grammar": "lsp",
        "label": "consoleInfo",
        "matches": {
          "cin": true
        },
        "options": {}
      },
      {
        "content": "console.table(${1:object});",
        "doc": "Displays tabular data as a table.",
        "grammar": "lsp",
        "label": "consoleTable",
        "matches": {
          "clt": true
        },
        "options": {}
      },
      {
        "content": "console.time(${1:object});",
        "doc": "Sets starting point for execution time measurement",
        "grammar": "lsp",
        "label": "consoleTime",
        "matches": {
          "cti": true
        },
        "options": {}
      },
      {
        "content": "console.timeEnd(${1:object});",
        "doc": "Sets end point for execution time measurement",
        "grammar": "lsp",
        "label": "consoleTimeEnd",
        "matches": {
          "cte": true
        },
        "options": {}
      },
      {
        "content": "import React, { Component } from 'react';\n\nclass ${1:${TM_FILENAME_BASE}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t);\n\t}\n}\n\nexport default ${1:${TM_FILENAME_BASE}};",
        "doc": "Creates a React component class with ES6 module system",
        "grammar": "lsp",
        "label": "reactClassComponent",
        "matches": {
          "rcc": true
        },
        "options": {}
      },
      {
        "content": "import React, { Component } from 'react';\nimport { connect } from 'react-redux';\n\nfunction mapStateToProps(state) {\n\treturn {\n\n\t};\n}\n\nclass ${1:${TM_FILENAME_BASE}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t);\n\t}\n}\n\nexport default connect(\n\tmapStateToProps,\n)(${1:${TM_FILENAME_BASE}});",
        "doc": "Creates a React component class connected to redux",
        "grammar": "lsp",
        "label": "reactReduxComponent",
        "matches": {
          "rrc": true
        },
        "options": {}
      },
      {
        "content": "import React, { Component } from 'react';\nimport { connect } from 'react-redux';\n\nfunction mapStateToProps(state) {\n\treturn {\n\n\t};\n}\n\nfunction mapDispatchToProps(dispatch) {\n\treturn {\n\n\t};\n}\n\nclass ${1:${TM_FILENAME_BASE}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t);\n\t}\n}\n\nexport default connect(\n\tmapStateToProps,\n)(${1:${TM_FILENAME_BASE}});",
        "doc": "Creates a React component class connected to redux with dispatch",
        "grammar": "lsp",
        "label": "reactReduxDispatchComponent",
        "matches": {
          "rrdc": true
        },
        "options": {}
      },
      {
        "content": "class ${1:${TM_FILENAME_BASE}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t);\n\t}\n}\n",
        "doc": "Creates a React component class with ES6 module system",
        "grammar": "lsp",
        "label": "reactJustClassComponent",
        "matches": {
          "rcjc": true
        },
        "options": {}
      },
      {
        "content": "import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nclass ${1:${TM_FILENAME_BASE}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t);\n\t}\n}\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\n};\n\nexport default ${1:${TM_FILENAME_BASE}};",
        "doc": "Creates a React component class with PropTypes and ES6 module system",
        "grammar": "lsp",
        "label": "reactClassComponentPropTypes",
        "matches": {
          "rccp": true
        },
        "options": {}
      },
      {
        "content": "import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nclass ${1:${TM_FILENAME_BASE}} extends Component {\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tthis.state = {\n\t\t\t\n\t\t}\n\t}\n\n\tstatic getDerivedStateFromProps() {\n\t\treturn null\n\t}\n\n\tcomponentDidMount() {\n\t\t\n\t}\n\n\t// shouldComponentUpdate(nextProps, nextState) {}\n\n\tgetSnapshotBeforeUpdate(prevProps, prevState) {\n\t\treturn null\n\t}\n\n\tcomponentDidUpdate(prevProps, prevState, snapshot) {\n\t\t\n\t}\n\n\tcomponentWillUnmount() {\n\t\t\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t\n\t\t\t</div>\n\t\t);\n\t}\n}\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\t\n};\n\nexport default ${1:${TM_FILENAME_BASE}};",
        "doc": "Creates a React component class with PropTypes and all lifecycle methods and ES6 module system",
        "grammar": "lsp",
        "label": "reactClassComponentWithMethods",
        "matches": {
          "rcfc": true
        },
        "options": {}
      },
      {
        "content": "class ${1:${TM_FILENAME_BASE}} extends React.Component {\n\tconstructor(props) {\n\t\tsuper(props);\n\n\t\tthis.state = {};\n\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t);\n\t}\n}\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\n};\n\nexport default ${1:${TM_FILENAME_BASE}};",
        "doc": "Creates a React component class with constructor, empty state, proptypes and export in ES6 module system without imports. (Mostly used when React, Proptypes are provided by webpack provide plugin)",
        "grammar": "lsp",
        "label": "reactWithWebpackDefaults",
        "matches": {
          "rwwd": true
        },
        "options": {}
      },
      {
        "content": "import React, { PureComponent } from 'react';\nimport PropTypes from 'prop-types';\n\nclass ${1:${TM_FILENAME_BASE}} extends PureComponent {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t);\n\t}\n}\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\n};\n\nexport default ${1:${TM_FILENAME_BASE}};",
        "doc": "Creates a React pure component class with PropTypes and ES6 module system",
        "grammar": "lsp",
        "label": "reactPureComponent",
        "matches": {
          "rpc": true
        },
        "options": {}
      },
      {
        "content": "import React from 'react';\n\nconst ${1:${TM_FILENAME_BASE}} = () => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t);\n};\n\nexport default ${1:${TM_FILENAME_BASE}};",
        "doc": "Creates a stateless React component without PropTypes and ES6 module system",
        "grammar": "lsp",
        "label": "reactStateless",
        "matches": {
          "rsc": true
        },
        "options": {}
      },
      {
        "content": "import React from 'react';\nimport PropTypes from 'prop-types';\n\nconst ${1:${TM_FILENAME_BASE}} = props => {\n\treturn (\n\t\t<div>\n\t\t\t\n\t\t</div>\n\t);\n};\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\t$0\n};\n\nexport default ${1:${TM_FILENAME_BASE}};",
        "doc": "Creates a stateless React component with PropTypes and ES6 module system",
        "grammar": "lsp",
        "label": "reactStatelessProps",
        "matches": {
          "rscp": true
        },
        "options": {}
      },
      {
        "content": "import React,{ useState } from 'react';\nimport PropTypes from 'prop-types';\n\nconst ${1:${TM_FILENAME_BASE}} = props => {\n\treturn (\n\t\t<div>\n\t\t\t\n\t\t</div>\n\t);\n};\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\t$0\n};\n\nexport default ${1:${TM_FILENAME_BASE}};",
        "doc": "Creates a stateless React component with PropTypes and ES6 module system",
        "grammar": "lsp",
        "label": "reactHookProps",
        "matches": {
          "rhc": true
        },
        "options": {}
      },
      {
        "content": "import React, { memo } from 'react';\n\nconst ${1:${TM_FILENAME_BASE}} = memo(() => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t);\n});\n\nexport default ${1:${TM_FILENAME_BASE}};",
        "doc": "Creates a memoized stateless React component without PropTypes and ES6 module system",
        "grammar": "lsp",
        "label": "reactMemo",
        "matches": {
          "rscm": true
        },
        "options": {}
      },
      {
        "content": "import React, { memo } from 'react';\nimport PropTypes from 'prop-types';\n\nconst ${1:${TM_FILENAME_BASE}} = memo((props) => {\n\treturn (\n\t\t<div>\n\t\t\t\n\t\t</div>\n\t);\n});\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\t$0\n};\n\nexport default ${1:${TM_FILENAME_BASE}};",
        "doc": "Creates a memoized stateless React component with PropTypes and ES6 module system",
        "grammar": "lsp",
        "label": "reactMemoProps",
        "matches": {
          "rscpm": true
        },
        "options": {}
      },
      {
        "content": "// @flow \nimport * as React from 'react';\ntype Props = {\n\t$0\n};\nexport const ${1:${TM_FILENAME_BASE}} = (props: Props) => {\n\treturn (\n\t\t<div>\n\t\t\t\n\t\t</div>\n\t);\n};",
        "doc": "Creates a stateless React component with FlowTypes and ES6 module system",
        "grammar": "lsp",
        "label": "flowStatelessComponent",
        "matches": {
          "fsc": true
        },
        "options": {}
      },
      {
        "content": "// @flow\nimport * as React from 'react';\ntype Props = {\n  $0\n};\nexport function ${1:${TM_FILENAME_BASE}}(props: Props) {\n  return (\n    <div>\n      \n    </div>\n  );\n};",
        "doc": "Creates a stateless React component as a named function with FlowTypes",
        "grammar": "lsp",
        "label": "flowStatelessFunction",
        "matches": {
          "fsf": true
        },
        "options": {}
      },
      {
        "content": "// @flow\nimport * as React from 'react';\ntype Props = {\n  $0\n};\ntype State = {\n  $1\n};\nexport class ${2:${TM_FILENAME_BASE}} extends React.Component<Props, State>{\n  render() {\n    return (\n      <div>\n        \n      </div>\n    );\n  };\n};",
        "doc": "Creates a React component class with FlowTypes",
        "grammar": "lsp",
        "label": "flowClassComponent",
        "matches": {
          "fcc": true
        },
        "options": {}
      },
      {
        "content": "import React from 'react';\n\nfunction ${1:${TM_FILENAME_BASE}}(props) {\n\treturn (\n\t\t<div>\n\t\t\t\n\t\t</div>\n\t);\n}\n\nexport default ${1:${TM_FILENAME_BASE}};",
        "doc": "Creates a stateless React component as a named function without PropTypes",
        "grammar": "lsp",
        "label": "reactStatelessFunction",
        "matches": {
          "rsf": true
        },
        "options": {}
      },
      {
        "content": "import React from 'react';\nimport PropTypes from 'prop-types';\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\t$0\n};\n\nfunction ${1:${TM_FILENAME_BASE}}(props) {\n\treturn (\n\t\t<div>\n\t\t\t\n\t\t</div>\n\t);\n}\n\nexport default ${1:${TM_FILENAME_BASE}};",
        "doc": "Creates a stateless React component as a named function with PropTypes",
        "grammar": "lsp",
        "label": "reactStatelessFunctionProps",
        "matches": {
          "rsfp": true
        },
        "options": {}
      },
      {
        "content": "import React from 'react';\n\nconst ${1:${TM_FILENAME_BASE}} = (props) => (\n\t\t\t$0\n\t);\n\nexport default ${1:${TM_FILENAME_BASE}};",
        "doc": "Creates a stateless React component without PropTypes and ES6 module system but with Implicit Return and props",
        "grammar": "lsp",
        "label": "reactStatelessImplicitReturn",
        "matches": {
          "rsi": true
        },
        "options": {}
      },
      {
        "content": "constructor(props) {\n\tsuper(props);\n\t$0\n}\n",
        "doc": "Adds a default constructor for the class that contains props as arguments",
        "grammar": "lsp",
        "label": "classConstructor",
        "matches": {
          "con": true
        },
        "options": {}
      },
      {
        "content": "constructor(props, context) {\n\tsuper(props, context);\n\t$0\n}\n",
        "doc": "Adds a default constructor for the class that contains props and context as arguments",
        "grammar": "lsp",
        "label": "classConstructorContext",
        "matches": {
          "conc": true
        },
        "options": {}
      },
      {
        "content": "this.state = {\n\t$1\n};",
        "doc": "Creates empty state object. To be used in a constructor.",
        "grammar": "lsp",
        "label": "emptyState",
        "matches": {
          "est": true
        },
        "options": {}
      },
      {
        "content": "\ncomponentWillMount() {\n\t$0\n}\n",
        "doc": "Invoked once, both on the client and server, immediately before the initial rendering occurs",
        "grammar": "lsp",
        "label": "componentWillMount",
        "matches": {
          "cwm": true
        },
        "options": {}
      },
      {
        "content": "componentDidMount() {\n\t$0\n}\n",
        "doc": "Invoked once, only on the client (not on the server), immediately after the initial rendering occurs.",
        "grammar": "lsp",
        "label": "componentDidMount",
        "matches": {
          "cdm": true
        },
        "options": {}
      },
      {
        "content": "componentWillReceiveProps(nextProps) {\n\t$0\n}\n",
        "doc": "Invoked when a component is receiving new props. This method is not called for the initial render. [DEPRECATION NOTE]: This method is deprecated in React 16.3",
        "grammar": "lsp",
        "label": "componentWillReceiveProps",
        "matches": {
          "cwr": true
        },
        "options": {}
      },
      {
        "content": "shouldComponentUpdate(nextProps, nextState) {\n\t$0\n}\n",
        "doc": "Invoked before rendering when new props or state are being received. ",
        "grammar": "lsp",
        "label": "shouldComponentUpdate",
        "matches": {
          "scu": true
        },
        "options": {}
      },
      {
        "content": "componentWillUpdate(nextProps, nextState) {\n\t$0\n}\n",
        "doc": "Invoked immediately before rendering when new props or state are being received. [DEPRECATION NOTE]: This method is deprecated in React 16.3",
        "grammar": "lsp",
        "label": "componentWillUpdate",
        "matches": {
          "cwup": true
        },
        "options": {}
      },
      {
        "content": "componentDidUpdate(prevProps, prevState) {\n\t$0\n}\n",
        "doc": "Invoked immediately after the component's updates are flushed to the DOM.",
        "grammar": "lsp",
        "label": "componentDidUpdate",
        "matches": {
          "cdup": true
        },
        "options": {}
      },
      {
        "content": "componentWillUnmount() {\n\t$0\n}\n",
        "doc": "Invoked immediately before a component is unmounted from the DOM.",
        "grammar": "lsp",
        "label": "componentWillUnmount",
        "matches": {
          "cwun": true
        },
        "options": {}
      },
      {
        "content": "render() {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t);\n}",
        "doc": "When called, it should examine this.props and this.state and return a single child element.",
        "grammar": "lsp",
        "label": "componentRender",
        "matches": {
          "ren": true
        },
        "options": {}
      },
      {
        "content": "this.setState($0);",
        "doc": "Performs a shallow merge of nextState into current state",
        "grammar": "lsp",
        "label": "componentSetStateObject",
        "matches": {
          "sst": true
        },
        "options": {}
      },
      {
        "content": "this.setState((state, props) => { return { $0 }});\n",
        "doc": "Performs a shallow merge of nextState into current state",
        "grammar": "lsp",
        "label": "componentSetStateFunc",
        "matches": {
          "ssf": true
        },
        "options": {}
      },
      {
        "content": "this.props.$0",
        "doc": "Access component's props",
        "grammar": "lsp",
        "label": "componentProps",
        "matches": {
          "props": true
        },
        "options": {}
      },
      {
        "content": "this.state.$0",
        "doc": "Access component's state",
        "grammar": "lsp",
        "label": "componentState",
        "matches": {
          "state": true
        },
        "options": {}
      },
      {
        "content": "this.$1 = this.$1.bind(this);$0",
        "doc": "Binds the this of a method. To be used inside a constructor",
        "grammar": "lsp",
        "label": "bindThis",
        "matches": {
          "bnd": true
        },
        "options": {}
      },
      {
        "content": "${1:$TM_FILENAME_BASE}.propTypes = {\n\t$2\n};",
        "doc": "Creates empty propTypes declaration",
        "grammar": "lsp",
        "label": "propTypes",
        "matches": {
          "rpt": true
        },
        "options": {}
      },
      {
        "content": "${1:$TM_FILENAME_BASE}.defaultProps = {\n\t$2\n};",
        "doc": "Creates empty defaultProps declaration",
        "grammar": "lsp",
        "label": "defaultProps",
        "matches": {
          "rdp": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.array,",
        "doc": "Array prop type",
        "grammar": "lsp",
        "label": "propTypeArray",
        "matches": {
          "pta": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.array.isRequired,",
        "doc": "Array prop type required",
        "grammar": "lsp",
        "label": "propTypeArrayRequired",
        "matches": {
          "ptar": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.bool,",
        "doc": "Bool prop type",
        "grammar": "lsp",
        "label": "propTypeBool",
        "matches": {
          "ptb": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.bool.isRequired,",
        "doc": "Bool prop type required",
        "grammar": "lsp",
        "label": "propTypeBoolRequired",
        "matches": {
          "ptbr": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.func,",
        "doc": "Func prop type",
        "grammar": "lsp",
        "label": "propTypeFunc",
        "matches": {
          "ptf": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.func.isRequired,",
        "doc": "Func prop type required",
        "grammar": "lsp",
        "label": "propTypeFuncRequired",
        "matches": {
          "ptfr": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.number,",
        "doc": "Number prop type",
        "grammar": "lsp",
        "label": "propTypeNumber",
        "matches": {
          "ptn": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.number.isRequired,",
        "doc": "Number prop type required",
        "grammar": "lsp",
        "label": "propTypeNumberRequired",
        "matches": {
          "ptnr": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.object,",
        "doc": "Object prop type",
        "grammar": "lsp",
        "label": "propTypeObject",
        "matches": {
          "pto": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.object.isRequired,",
        "doc": "Object prop type required",
        "grammar": "lsp",
        "label": "propTypeObjectRequired",
        "matches": {
          "ptor": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.string,",
        "doc": "String prop type",
        "grammar": "lsp",
        "label": "propTypeString",
        "matches": {
          "pts": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.string.isRequired,",
        "doc": "String prop type required",
        "grammar": "lsp",
        "label": "propTypeStringRequired",
        "matches": {
          "ptsr": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.symbol,",
        "doc": "Symbol prop type",
        "grammar": "lsp",
        "label": "propTypeSymbol",
        "matches": {
          "ptsm": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.symbol.isRequired,",
        "doc": "Symbol prop type required",
        "grammar": "lsp",
        "label": "propTypeSymbolRequired",
        "matches": {
          "ptsmr": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.any,",
        "doc": "Any prop type",
        "grammar": "lsp",
        "label": "propTypeAny",
        "matches": {
          "ptan": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.any.isRequired,",
        "doc": "Any prop type required",
        "grammar": "lsp",
        "label": "propTypeAnyRequired",
        "matches": {
          "ptanr": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.node,",
        "doc": "Anything that can be rendered: numbers, strings, elements or an array",
        "grammar": "lsp",
        "label": "propTypeNode",
        "matches": {
          "ptnd": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.node.isRequired,",
        "doc": "Anything that can be rendered: numbers, strings, elements or an array required",
        "grammar": "lsp",
        "label": "propTypeNodeRequired",
        "matches": {
          "ptndr": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.element,",
        "doc": "React element prop type",
        "grammar": "lsp",
        "label": "propTypeElement",
        "matches": {
          "ptel": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.element.isRequired,",
        "doc": "React element prop type required",
        "grammar": "lsp",
        "label": "propTypeElementRequired",
        "matches": {
          "ptelr": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.instanceOf($0),",
        "doc": "Is an instance of a class prop type",
        "grammar": "lsp",
        "label": "propTypeInstanceOf",
        "matches": {
          "pti": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.instanceOf($0).isRequired,",
        "doc": "Is an instance of a class prop type required",
        "grammar": "lsp",
        "label": "propTypeInstanceOfRequired",
        "matches": {
          "ptir": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.oneOf(['$0']),",
        "doc": "Prop type limited to specific values by treating it as an enum",
        "grammar": "lsp",
        "label": "propTypeEnum",
        "matches": {
          "pte": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.oneOf(['$0']).isRequired,",
        "doc": "Prop type limited to specific values by treating it as an enum required",
        "grammar": "lsp",
        "label": "propTypeEnumRequired",
        "matches": {
          "pter": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.oneOfType([\n\t$0\n]),",
        "doc": "An object that could be one of many types",
        "grammar": "lsp",
        "label": "propTypeOneOfType",
        "matches": {
          "ptet": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.oneOfType([\n\t$0\n]).isRequired,",
        "doc": "An object that could be one of many types required",
        "grammar": "lsp",
        "label": "propTypeOneOfTypeRequired",
        "matches": {
          "ptetr": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.arrayOf($0),",
        "doc": "An array of a certain type",
        "grammar": "lsp",
        "label": "propTypeArrayOf",
        "matches": {
          "ptao": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.arrayOf($0).isRequired,",
        "doc": "An array of a certain type required",
        "grammar": "lsp",
        "label": "propTypeArrayOfRequired",
        "matches": {
          "ptaor": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.objectOf($0),",
        "doc": "An object with property values of a certain type",
        "grammar": "lsp",
        "label": "propTypeObjectOf",
        "matches": {
          "ptoo": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.objectOf($0).isRequired,",
        "doc": "An object with property values of a certain type required",
        "grammar": "lsp",
        "label": "propTypeObjectOfRequired",
        "matches": {
          "ptoor": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.objectOf(PropTypes.shape($0)),",
        "doc": "An object whose keys are known ahead of time",
        "grammar": "lsp",
        "label": "propTypeObjectOfShape",
        "matches": {
          "ptoos": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.objectOf(PropTypes.shape($0)).isRequired,",
        "doc": "An object whose keys are known ahead of time required",
        "grammar": "lsp",
        "label": "propTypeObjectOfShapeRequired",
        "matches": {
          "ptoosr": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.shape({\n\t$0\n}),",
        "doc": "An object taking on a particular shape",
        "grammar": "lsp",
        "label": "propTypeShape",
        "matches": {
          "ptsh": true
        },
        "options": {}
      },
      {
        "content": "PropTypes.shape({\n\t$0\n}).isRequired,",
        "doc": "An object taking on a particular shape required",
        "grammar": "lsp",
        "label": "propTypeShapeRequired",
        "matches": {
          "ptshr": true
        },
        "options": {}
      },
      {
        "content": "getSnapshotBeforeUpdate(prevProps, prevState) {\n\t$0\n}\n",
        "doc": "Invoked right before the most recently rendered output is committed to e.g. the DOM. It enables your component to capture current values",
        "grammar": "lsp",
        "label": "getSnapshotBeforeUpdate",
        "matches": {
          "gsbu": true
        },
        "options": {}
      },
      {
        "content": "static getDerivedStateFromProps(nextProps, prevState) {\n\t$0\n}\n",
        "doc": "Invoked after a component is instantiated as well as when it receives new props.",
        "grammar": "lsp",
        "label": "getDerivedStateFromProps",
        "matches": {
          "gdsfp": true
        },
        "options": {}
      },
      {
        "content": "componentDidCatch(error, info) {\n\t$0\n}\n",
        "doc": "Error boundaries catch errors during rendering, in lifecycle methods, and in constructors of the whole tree below them.",
        "grammar": "lsp",
        "label": "componentDidCatch",
        "matches": {
          "cdc": true
        },
        "options": {}
      },
      {
        "content": "function mapDispatchToProps(dispatch) {\n\treturn {\n\t}\n\n}",
        "doc": "Adds the redux mapDispatchToProps function",
        "grammar": "lsp",
        "label": "dispatchRedux",
        "matches": {
          "disp": true
        },
        "options": {}
      },
      {
        "content": "useEffect(() => {\n$0\n})",
        "doc": "Adds use effect",
        "grammar": "lsp",
        "label": "useEffect",
        "matches": {
          "usf": true
        },
        "options": {}
      },
      {
        "content": "useEffect(() => {\n$0 return () => {\n$0\n\t}\n})",
        "doc": "Adds use effect",
        "grammar": "lsp",
        "label": "useEffectUnMount",
        "matches": {
          "usfu": true
        },
        "options": {}
      },
      {
        "content": "useEffect(() => {\n$0\n},[])",
        "doc": "Adds use effect",
        "grammar": "lsp",
        "label": "useEffectDidMount",
        "matches": {
          "usfd": true
        },
        "options": {}
      },
      {
        "content": "snippet ${1:trigger} \"${2:description}\"\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "snip": true
        },
        "options": {}
      },
      {
        "content": "{VISUAL}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "v": true
        },
        "options": {}
      },
      {
        "content": "${${1:1}:${0:text}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "$": true
        },
        "options": {}
      },
      {
        "content": "\\$\\{VISUAL${1:${2:default}${3:/transform/}}\\}",
        "doc": "",
        "grammar": "snu",
        "label": "${VISUAL}",
        "matches": {
          "vis": true
        },
        "options": {
          "i": true
        }
      }
    ],
    "snippets-ts": [
      {
        "content": "import styled from 'styled-components/native';\n\nexport const ${1:Container} = styled.${2:View}`\n  ${3}\n`;\n",
        "doc": "Create React Native Styled Components file",
        "grammar": "lsp",
        "label": "styles",
        "matches": {
          "styled-react-native": true
        },
        "options": {}
      }
    ],
    "soy": [
      {
        "content": "{namespace ${1:name}}",
        "doc": "",
        "grammar": "snu",
        "label": "Namespace",
        "matches": {
          "ns": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "{msg desc=\"${1:description}\"}\n\t$0\n{/msg}",
        "doc": "",
        "grammar": "snu",
        "label": "Message",
        "matches": {
          "msg": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "{let $${1:identifier}: ${2:expression} /}",
        "doc": "",
        "grammar": "snu",
        "label": "let command",
        "matches": {
          "let": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "{if ${1:expression}}\n\t$0\n{/if}",
        "doc": "",
        "grammar": "snu",
        "label": "if .. (if)",
        "matches": {
          "if": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "{if ${1:expression}}\n\t$2\n{else}\n\t$0\n{/if}",
        "doc": "",
        "grammar": "snu",
        "label": "if .. else (ife)",
        "matches": {
          "ife": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "{elif ${1:expression}}\n\t$0",
        "doc": "",
        "grammar": "snu",
        "label": "else if .. (eli)",
        "matches": {
          "eli": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "{foreach $${1:var} in ${2:ref}}\n\t$0\n{/foreach}",
        "doc": "",
        "grammar": "snu",
        "label": "foreach command",
        "matches": {
          "fore": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "{for $${1:var} in range(${2:rangeexpr})}\n\t$0\n{/for}",
        "doc": "",
        "grammar": "snu",
        "label": "for command",
        "matches": {
          "for": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "{call ${1:tmpl}}\n\t$0\n{/call}",
        "doc": "",
        "grammar": "snu",
        "label": "template call",
        "matches": {
          "call": true
        },
        "options": {
          "b": true
        }
      }
    ],
    "sql": [
      {
        "content": "CREATE TABLE ${1:cities} (\n  ${0:name varchar(80), country_name text}\n);",
        "doc": "",
        "grammar": "snu",
        "label": "CREATE TABLE { ... }",
        "matches": {
          "CREATE_TABLE": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "CREATE INDEX ${1:_name} ON ${2:cities} (${3:name});",
        "doc": "",
        "grammar": "snu",
        "label": "CREATE INDEX ... ON ... ( ... )",
        "matches": {
          "CREATE_INDEX": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "DROP TABLE IF EXISTS ${1:table};",
        "doc": "",
        "grammar": "snu",
        "label": "DROP TABLE IF EXISTS ...",
        "matches": {
          "DROP_TABLE": true
        },
        "options": {}
      },
      {
        "content": "ALTER TABLE ${1:table}\nMODIFY ${2:column} ${3:new_column_desc};",
        "doc": "",
        "grammar": "snu",
        "label": "ALTER TABLE ... MODIFY ...",
        "matches": {
          "ALTER_TABLE": true
        },
        "options": {}
      },
      {
        "content": "TRUNCATE TABLE ${1:table};",
        "doc": "",
        "grammar": "snu",
        "label": "TRUNCATE TABLE ...",
        "matches": {
          "TRUNCATE_TABLE": true
        },
        "options": {}
      },
      {
        "content": "INSERT INTO ${1:cities}\nVALUES (${0:'Vancouver', 'Canada'});",
        "doc": "",
        "grammar": "snu",
        "label": "INSERT INTO ... VALUES ( ... )",
        "matches": {
          "INSERT_DATA": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "UPDATE ${1:table}\nSET ${2:column} = ${3:value}\nWHERE ${4:condition};",
        "doc": "",
        "grammar": "snu",
        "label": "UPDATE ... SET ... WHERE ...",
        "matches": {
          "UPDATE_DATA": true
        },
        "options": {}
      },
      {
        "content": "SELECT ${1:*}\nFROM ${2:cities} ${3:WHERE area = 'Asia'}\n${4: ORDER BY distance}\n${5: LIMIT 30};",
        "doc": "",
        "grammar": "snu",
        "label": "SELECT * from ... ORDER BY ... LIMIT ...",
        "matches": {
          "SELECT_DATA": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "SELECT ${1:*}\nFROM ${2:table1} ${3:T1}\nJOIN ${4:table2} ${5:T2}\nON T1.${6:column1} = T2.${7:column2}",
        "doc": "",
        "grammar": "snu",
        "label": "SELECT * FROM T1 JOIN T2 ... ON",
        "matches": {
          "SELECT_JOIN_DATA": true
        },
        "options": {}
      },
      {
        "content": "DELETE FROM ${1:table}\nWHERE ${2:condition};",
        "doc": "",
        "grammar": "snu",
        "label": "DELETE FROM ... WHERE ...",
        "matches": {
          "DELETE_DATA": true
        },
        "options": {}
      },
      {
        "content": "BEGIN TRANSACTION;\n${0:TARGET}\nCOMMIT;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "BEGIN TRANSACTION": true,
          "TRANSACTION": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "create table ${1:table} (\n\t${0:columns}\n);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tbl": true
        },
        "options": {}
      },
      {
        "content": "${1:name}\t${2:type}\t${3:default ''}\t${0:not null}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "col": true
        },
        "options": {}
      },
      {
        "content": "${1:name}\tvarchar2(${2:size})\t${3:default ''}\t${0:not null}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ccol": true
        },
        "options": {}
      },
      {
        "content": "${1:name}\tnumber\t${3:default 0}\t${0:not null}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ncol": true
        },
        "options": {}
      },
      {
        "content": "${1:name}\tdate\t${3:default sysdate}\t${0:not null}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dcol": true
        },
        "options": {}
      },
      {
        "content": "create index ${0:$1_$2} on ${1:table}(${2:column});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ind": true
        },
        "options": {}
      },
      {
        "content": "create unique index ${1:name} on ${2:table}(${0:column});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "uind": true
        },
        "options": {}
      },
      {
        "content": "comment on table ${1:table} is '${0:comment}';",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tblcom": true
        },
        "options": {}
      },
      {
        "content": "comment on column ${1:table}.${2:column} is '${0:comment}';",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "colcom": true
        },
        "options": {}
      },
      {
        "content": "alter table ${1:table} add (${2:column} ${0:type});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "addcol": true
        },
        "options": {}
      },
      {
        "content": "create sequence ${1:name} start with ${2:1} increment by ${3:1} minvalue ${0:1};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "seq": true
        },
        "options": {}
      },
      {
        "content": "select * from ${0:table}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "s*": true
        },
        "options": {}
      }
    ],
    "sshconfig": [
      {
        "content": "Host ${1:name}\n\tHostName $1.${2:domain}\n\tPort ${3}\n\t${4:User }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Host": true
        },
        "options": {
          "head": true
        }
      }
    ],
    "styled-components": [
      {
        "content": "import styled from 'styled-components';",
        "doc": "import styled from 'styled-components'",
        "grammar": "lsp",
        "label": "styled-components-import-styled-from-styled-components",
        "matches": {
          "imsc": true,
          "styled-components import styled": true
        },
        "options": {}
      },
      {
        "content": "import styled from 'styled-components/native';",
        "doc": "import styled from 'styled-components/native'",
        "grammar": "lsp",
        "label": "styled-components-import-styled-from-styled-components-native",
        "matches": {
          "imscn": true,
          "styled-components import styled native'": true
        },
        "options": {}
      },
      {
        "content": "import { createGlobalStyle } from 'styled-components';",
        "doc": "import { createGlobalStyle } from 'styled-components'",
        "grammar": "lsp",
        "label": "styled-components-import-create-global-style-from-styled-components",
        "matches": {
          "imscg": true,
          "styled-components import createglobalstyle": true
        },
        "options": {}
      },
      {
        "content": "import { css } from 'styled-components';",
        "doc": "import { css } from 'styled-components'",
        "grammar": "lsp",
        "label": "styled-components-import-css-from-styled-components",
        "matches": {
          "imsccss": true,
          "styled-components import css": true
        },
        "options": {}
      },
      {
        "content": "import { withTheme } from 'styled-components';",
        "doc": "import { withTheme } from 'styled-components'",
        "grammar": "lsp",
        "label": "styled-components-import-with-theme-from-styled-components",
        "matches": {
          "imsct": true,
          "styled-components import withtheme": true
        },
        "options": {}
      },
      {
        "content": "const ${1} = styled.${2}`\n  ${3}\n`;",
        "doc": "Styled-Component",
        "grammar": "lsp",
        "label": "styled-components-styled-component",
        "matches": {
          "sc": true,
          "styled-components component": true
        },
        "options": {}
      },
      {
        "content": "export const ${1} = styled.${2}`\n  ${3}\n`;",
        "doc": "Export styled-component",
        "grammar": "lsp",
        "label": "styled-components-export-styled-component",
        "matches": {
          "exsc": true,
          "styled-components export component": true
        },
        "options": {}
      },
      {
        "content": "const Global${1} = createGlobalStyle`\n  ${2}\n`;",
        "doc": "createGlobalStyle",
        "grammar": "lsp",
        "label": "styled-components-create-global-style",
        "matches": {
          "scg": true,
          "styled-components createglobalstyle": true
        },
        "options": {}
      },
      {
        "content": "export const Global${1} = createGlobalStyle`\n  ${2}\n`;",
        "doc": "Export createGlobalStyle",
        "grammar": "lsp",
        "label": "styled-components-export-create-global-style",
        "matches": {
          "exscg": true,
          "styled-components export createglobalstyle": true
        },
        "options": {}
      },
      {
        "content": "const ${1} = styled(${2})`\n  ${3}\n`;",
        "doc": "Styled-Component from existing component",
        "grammar": "lsp",
        "label": "styled-components-styled-component-from-existing-component",
        "matches": {
          "scc": true,
          "styled-components component from existing": true
        },
        "options": {}
      },
      {
        "content": "export const ${1} = styled(${2})`\n  ${3}\n`;",
        "doc": "Export styled-component from existing component",
        "grammar": "lsp",
        "label": "styled-components-export-styled-component-from-existing-component",
        "matches": {
          "exscc": true,
          "styled-components export component from existing": true
        },
        "options": {}
      },
      {
        "content": "import styled from 'styled-components';\n\nconst ${1} = styled.${2}`\n  ${3}\n`;\n\nexport default ${1};",
        "doc": "Styled-Components file",
        "grammar": "lsp",
        "label": "styled-components-styled-components-file",
        "matches": {
          "scf": true,
          "styled-components file": true
        },
        "options": {}
      },
      {
        "content": "<ThemeProvider theme={${1}}>\n  ${2}\n</ThemeProvider>",
        "doc": "ThemeProvider",
        "grammar": "lsp",
        "label": "styled-components-theme-provider",
        "matches": {
          "styled-components themeprovider": true,
          "themeprovider": true
        },
        "options": {}
      },
      {
        "content": "// Define what props.theme will look like\nconst theme = {\n  ${1}: '${2}'\n};",
        "doc": "styled-component theme",
        "grammar": "lsp",
        "label": "styled-components-styled-component-theme",
        "matches": {
          "sct": true,
          "styled-components theme": true
        },
        "options": {}
      },
      {
        "content": "const ${1} = styled.${2}.attrs({\n  ${3}: ${4}\n})`\n  ${5}\n`;",
        "doc": "Styled-Component with attributes",
        "grammar": "lsp",
        "label": "styled-components-styled-component-with-attributes",
        "matches": {
          "scattrs": true,
          "styled-components component with attributes": true
        },
        "options": {}
      },
      {
        "content": "export const ${1} = styled.${2}.attrs({\n  ${3}: ${4}\n})`\n  ${5}\n`;",
        "doc": "Export styled-component with attributes",
        "grammar": "lsp",
        "label": "styled-components-export-styled-component-with-attributes",
        "matches": {
          "exscattrs": true,
          "styled-components export component with attributes": true
        },
        "options": {}
      }
    ],
    "stylus": [
      {
        "content": "!important",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "!": true
        },
        "options": {}
      },
      {
        "content": "align-content ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac": true
        },
        "options": {}
      },
      {
        "content": "align-content start",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:s": true
        },
        "options": {}
      },
      {
        "content": "align-content end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:e": true
        },
        "options": {}
      },
      {
        "content": "align-content center",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:c": true
        },
        "options": {}
      },
      {
        "content": "align-content flex-start",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:fs": true
        },
        "options": {}
      },
      {
        "content": "align-content flex-end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:fe": true
        },
        "options": {}
      },
      {
        "content": "align-content space-between",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:sb": true
        },
        "options": {}
      },
      {
        "content": "align-content space-around",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:sa": true
        },
        "options": {}
      },
      {
        "content": "align-content space-evenly",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:se": true
        },
        "options": {}
      },
      {
        "content": "align-content stretch",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:st": true
        },
        "options": {}
      },
      {
        "content": "align-content baseline",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:b": true
        },
        "options": {}
      },
      {
        "content": "align-content first baseline",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:fb": true
        },
        "options": {}
      },
      {
        "content": "align-content last baseline",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ac:lb": true
        },
        "options": {}
      },
      {
        "content": "align-items ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ai": true
        },
        "options": {}
      },
      {
        "content": "align-items start",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ai:s": true
        },
        "options": {}
      },
      {
        "content": "align-items end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ai:e": true
        },
        "options": {}
      },
      {
        "content": "align-items center",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ai:c": true
        },
        "options": {}
      },
      {
        "content": "align-items flex-start",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ai:fs": true
        },
        "options": {}
      },
      {
        "content": "align-items flex-end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ai:fe": true
        },
        "options": {}
      },
      {
        "content": "align-items stretch",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ai:st": true
        },
        "options": {}
      },
      {
        "content": "align-items baseline",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ai:b": true
        },
        "options": {}
      },
      {
        "content": "align-items first baseline",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ai:fb": true
        },
        "options": {}
      },
      {
        "content": "align-items last baseline",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ai:lb": true
        },
        "options": {}
      },
      {
        "content": "align-self ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as": true
        },
        "options": {}
      },
      {
        "content": "align-self start",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as:s": true
        },
        "options": {}
      },
      {
        "content": "align-self end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as:e": true
        },
        "options": {}
      },
      {
        "content": "align-self center",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as:c": true
        },
        "options": {}
      },
      {
        "content": "align-self stretch",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as:st": true
        },
        "options": {}
      },
      {
        "content": "align-self flex-start",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as:fs": true
        },
        "options": {}
      },
      {
        "content": "align-self flex-end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as:fe": true
        },
        "options": {}
      },
      {
        "content": "align-self baseline",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as:b": true
        },
        "options": {}
      },
      {
        "content": "align-self first baseline",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as:fb": true
        },
        "options": {}
      },
      {
        "content": "align-self last baseline",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "as:lb": true
        },
        "options": {}
      },
      {
        "content": "-moz-border-image url(${1}) ${2:0} ${3:0} ${4:0} ${5:0} ${6:stretch} ${0:stretch}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdi:m+": true
        },
        "options": {}
      },
      {
        "content": "-moz-border-image ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdi:m": true
        },
        "options": {}
      },
      {
        "content": "-moz-border-radius ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdrz:m": true
        },
        "options": {}
      },
      {
        "content": "-moz-box-shadow ${1:0} ${2:0} ${3:0} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bxsh:m+": true
        },
        "options": {}
      },
      {
        "content": "-moz-box-shadow ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bxsh:m": true
        },
        "options": {}
      },
      {
        "content": "-webkit-border-image url(${1}) ${2:0} ${3:0} ${4:0} ${5:0} ${6:stretch} ${0:stretch}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdi:w+": true
        },
        "options": {}
      },
      {
        "content": "-webkit-border-image ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdi:w": true
        },
        "options": {}
      },
      {
        "content": "-webkit-border-radius ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdrz:w": true
        },
        "options": {}
      },
      {
        "content": "-webkit-box-shadow ${1:0} ${2:0} ${3:0} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bxsh:w+": true
        },
        "options": {}
      },
      {
        "content": "-webkit-box-shadow ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bxsh:w": true
        },
        "options": {}
      },
      {
        "content": "@font-face ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@f": true
        },
        "options": {}
      },
      {
        "content": "@import '${0}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@i": true
        },
        "options": {}
      },
      {
        "content": "@require '${0}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@r": true
        },
        "options": {}
      },
      {
        "content": "@media ${1:screen}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@m": true
        },
        "options": {}
      },
      {
        "content": "@media screen and (min-width: ${0}px)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@msmw": true
        },
        "options": {}
      },
      {
        "content": "@extend .${1}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "@ext": true
        },
        "options": {}
      },
      {
        "content": "background ${1} url(${2}) ${3:0} ${4:0} ${0:no-repeat}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bg+": true
        },
        "options": {}
      },
      {
        "content": "background-attachment ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bga": true
        },
        "options": {}
      },
      {
        "content": "background-attachment fixed",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bga:f": true
        },
        "options": {}
      },
      {
        "content": "background-attachment scroll",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bga:s": true
        },
        "options": {}
      },
      {
        "content": "background-break ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgbk": true
        },
        "options": {}
      },
      {
        "content": "background-break bounding-box",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgbk:bb": true
        },
        "options": {}
      },
      {
        "content": "background-break continuous",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgbk:c": true
        },
        "options": {}
      },
      {
        "content": "background-break each-box",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgbk:eb": true
        },
        "options": {}
      },
      {
        "content": "background-clip ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgcp": true
        },
        "options": {}
      },
      {
        "content": "background-clip border-box",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgcp:bb": true
        },
        "options": {}
      },
      {
        "content": "background-clip content-box",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgcp:cb": true
        },
        "options": {}
      },
      {
        "content": "background-clip no-clip",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgcp:nc": true
        },
        "options": {}
      },
      {
        "content": "background-clip padding-box",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgcp:pb": true
        },
        "options": {}
      },
      {
        "content": "background-color ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgc": true
        },
        "options": {}
      },
      {
        "content": "background-color transparent",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgc:t": true
        },
        "options": {}
      },
      {
        "content": "background-image url(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgi": true
        },
        "options": {}
      },
      {
        "content": "background-image none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgi:n": true
        },
        "options": {}
      },
      {
        "content": "background-origin ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgo": true
        },
        "options": {}
      },
      {
        "content": "background-origin border-box",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgo:bb": true
        },
        "options": {}
      },
      {
        "content": "background-origin content-box",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgo:cb": true
        },
        "options": {}
      },
      {
        "content": "background-origin padding-box",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgo:pb": true
        },
        "options": {}
      },
      {
        "content": "background-position-x ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgpx": true
        },
        "options": {}
      },
      {
        "content": "background-position-y ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgpy": true
        },
        "options": {}
      },
      {
        "content": "background-position ${1:0} ${0:0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgp": true
        },
        "options": {}
      },
      {
        "content": "background-repeat ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgr": true
        },
        "options": {}
      },
      {
        "content": "background-repeat no-repeat",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgr:n": true
        },
        "options": {}
      },
      {
        "content": "background-repeat repeat-x",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgr:x": true
        },
        "options": {}
      },
      {
        "content": "background-repeat repeat-y",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgr:y": true
        },
        "options": {}
      },
      {
        "content": "background-repeat repeat",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgr:r": true
        },
        "options": {}
      },
      {
        "content": "background-size ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgz": true
        },
        "options": {}
      },
      {
        "content": "background-size auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgz:a": true
        },
        "options": {}
      },
      {
        "content": "background-size contain",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgz:ct": true
        },
        "options": {}
      },
      {
        "content": "background-size cover",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bgz:cv": true
        },
        "options": {}
      },
      {
        "content": "background ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bg": true
        },
        "options": {}
      },
      {
        "content": "filter progid:DXImageTransform.Microsoft.AlphaImageLoader(src='${1}',sizingMethod='${0:crop}')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bg:ie": true
        },
        "options": {}
      },
      {
        "content": "background none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bg:n": true
        },
        "options": {}
      },
      {
        "content": "border ${1:1px} ${2:solid} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bd+": true
        },
        "options": {}
      },
      {
        "content": "border-bottom ${1:1px} ${2:solid} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdb+": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-color ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbc": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-image url(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbi": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-image none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbi:n": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-left-image url(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbli": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-left-image continue",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbli:c": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-left-image none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbli:n": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-left-radius ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdblrz": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-right-image url(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbri": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-right-image continue",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbri:c": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-right-image none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbri:n": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-right-radius ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbrrz": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-style ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbs": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-style none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbs:n": true
        },
        "options": {}
      },
      {
        "content": "border-bottom-width ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbw": true
        },
        "options": {}
      },
      {
        "content": "border-bottom ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdb": true
        },
        "options": {}
      },
      {
        "content": "border-bottom none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdb:n": true
        },
        "options": {}
      },
      {
        "content": "border-break ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbk": true
        },
        "options": {}
      },
      {
        "content": "border-break close",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdbk:c": true
        },
        "options": {}
      },
      {
        "content": "border-collapse ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdcl": true
        },
        "options": {}
      },
      {
        "content": "border-collapse collapse",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdcl:c": true
        },
        "options": {}
      },
      {
        "content": "border-collapse separate",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdcl:s": true
        },
        "options": {}
      },
      {
        "content": "border-color ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdc": true
        },
        "options": {}
      },
      {
        "content": "border-corner-image url(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdci": true
        },
        "options": {}
      },
      {
        "content": "border-corner-image continue",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdci:c": true
        },
        "options": {}
      },
      {
        "content": "border-corner-image none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdci:n": true
        },
        "options": {}
      },
      {
        "content": "border-fit ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdf": true
        },
        "options": {}
      },
      {
        "content": "border-fit clip",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdf:c": true
        },
        "options": {}
      },
      {
        "content": "border-fit overwrite",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdf:of": true
        },
        "options": {}
      },
      {
        "content": "border-fit overwrite",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdf:ow": true
        },
        "options": {}
      },
      {
        "content": "border-fit repeat",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdf:r": true
        },
        "options": {}
      },
      {
        "content": "border-fit scale",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdf:sc": true
        },
        "options": {}
      },
      {
        "content": "border-fit space",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdf:sp": true
        },
        "options": {}
      },
      {
        "content": "border-fit stretch",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdf:st": true
        },
        "options": {}
      },
      {
        "content": "border-image url(${1}) ${2:0} ${3:0} ${4:0} ${5:0} ${6:stretch} ${0:stretch}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdi": true
        },
        "options": {}
      },
      {
        "content": "border-image none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdi:n": true
        },
        "options": {}
      },
      {
        "content": "border-left ${1:1px} ${2:solid} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdl+": true
        },
        "options": {}
      },
      {
        "content": "border-left-color ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdlc": true
        },
        "options": {}
      },
      {
        "content": "border-left-image url(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdli": true
        },
        "options": {}
      },
      {
        "content": "border-left-image none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdli:n": true
        },
        "options": {}
      },
      {
        "content": "border-left-style ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdls": true
        },
        "options": {}
      },
      {
        "content": "border-left-style none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdls:n": true
        },
        "options": {}
      },
      {
        "content": "border-left-width ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdlw": true
        },
        "options": {}
      },
      {
        "content": "border-left ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdl": true
        },
        "options": {}
      },
      {
        "content": "border-left none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdl:n": true
        },
        "options": {}
      },
      {
        "content": "border-length ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdlt": true
        },
        "options": {}
      },
      {
        "content": "border-length auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdlt:a": true
        },
        "options": {}
      },
      {
        "content": "border-radius ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdrz": true
        },
        "options": {}
      },
      {
        "content": "border-right ${1:1px} ${2:solid} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdr+": true
        },
        "options": {}
      },
      {
        "content": "border-right-color ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdrc": true
        },
        "options": {}
      },
      {
        "content": "border-right-image url(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdri": true
        },
        "options": {}
      },
      {
        "content": "border-right-image none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdri:n": true
        },
        "options": {}
      },
      {
        "content": "border-right-style ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdrs": true
        },
        "options": {}
      },
      {
        "content": "border-right-style none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdrs:n": true
        },
        "options": {}
      },
      {
        "content": "border-right-width ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdrw": true
        },
        "options": {}
      },
      {
        "content": "border-right ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdr": true
        },
        "options": {}
      },
      {
        "content": "border-right none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdr:n": true
        },
        "options": {}
      },
      {
        "content": "border-spacing ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdsp": true
        },
        "options": {}
      },
      {
        "content": "border-style ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds": true
        },
        "options": {}
      },
      {
        "content": "border-style dashed",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:ds": true
        },
        "options": {}
      },
      {
        "content": "border-style dot-dash",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:dtds": true
        },
        "options": {}
      },
      {
        "content": "border-style dot-dot-dash",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:dtdtds": true
        },
        "options": {}
      },
      {
        "content": "border-style dotted",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:dt": true
        },
        "options": {}
      },
      {
        "content": "border-style double",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:db": true
        },
        "options": {}
      },
      {
        "content": "border-style groove",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:g": true
        },
        "options": {}
      },
      {
        "content": "border-style hidden",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:h": true
        },
        "options": {}
      },
      {
        "content": "border-style inset",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:i": true
        },
        "options": {}
      },
      {
        "content": "border-style none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:n": true
        },
        "options": {}
      },
      {
        "content": "border-style outset",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:o": true
        },
        "options": {}
      },
      {
        "content": "border-style ridge",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:r": true
        },
        "options": {}
      },
      {
        "content": "border-style solid",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:s": true
        },
        "options": {}
      },
      {
        "content": "border-style wave",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bds:w": true
        },
        "options": {}
      },
      {
        "content": "border-top ${1:1px} ${2:solid} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdt+": true
        },
        "options": {}
      },
      {
        "content": "border-top-color ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdtc": true
        },
        "options": {}
      },
      {
        "content": "border-top-image url(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdti": true
        },
        "options": {}
      },
      {
        "content": "border-top-image none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdti:n": true
        },
        "options": {}
      },
      {
        "content": "border-top-left-image url(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdtli": true
        },
        "options": {}
      },
      {
        "content": "border-corner-image continue",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdtli:c": true
        },
        "options": {}
      },
      {
        "content": "border-corner-image none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdtli:n": true
        },
        "options": {}
      },
      {
        "content": "border-top-left-radius ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdtlrz": true
        },
        "options": {}
      },
      {
        "content": "border-top-right-image url(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdtri": true
        },
        "options": {}
      },
      {
        "content": "border-top-right-image continue",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdtri:c": true
        },
        "options": {}
      },
      {
        "content": "border-top-right-image none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdtri:n": true
        },
        "options": {}
      },
      {
        "content": "border-top-right-radius ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdtrrz": true
        },
        "options": {}
      },
      {
        "content": "border-top-style ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdts": true
        },
        "options": {}
      },
      {
        "content": "border-top-style none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdts:n": true
        },
        "options": {}
      },
      {
        "content": "border-top-width ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdtw": true
        },
        "options": {}
      },
      {
        "content": "border-top ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdt": true
        },
        "options": {}
      },
      {
        "content": "border-top none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdt:n": true
        },
        "options": {}
      },
      {
        "content": "border-width ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bdw": true
        },
        "options": {}
      },
      {
        "content": "border ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bd": true
        },
        "options": {}
      },
      {
        "content": "border none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bd:n": true
        },
        "options": {}
      },
      {
        "content": "bottom ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "b": true
        },
        "options": {}
      },
      {
        "content": "bottom auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "b:a": true
        },
        "options": {}
      },
      {
        "content": "box-shadow ${1:0} ${2:0} ${3:0} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bxsh+": true
        },
        "options": {}
      },
      {
        "content": "box-shadow ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bxsh": true
        },
        "options": {}
      },
      {
        "content": "box-shadow none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bxsh:n": true
        },
        "options": {}
      },
      {
        "content": "box-sizing ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bxz": true
        },
        "options": {}
      },
      {
        "content": "box-sizing border-box",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bxz:bb": true
        },
        "options": {}
      },
      {
        "content": "box-sizing content-box",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bxz:cb": true
        },
        "options": {}
      },
      {
        "content": "caption-side ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cps": true
        },
        "options": {}
      },
      {
        "content": "caption-side bottom",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cps:b": true
        },
        "options": {}
      },
      {
        "content": "caption-side top",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cps:t": true
        },
        "options": {}
      },
      {
        "content": "clear ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cl": true
        },
        "options": {}
      },
      {
        "content": "clear both",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cl:b": true
        },
        "options": {}
      },
      {
        "content": "clear left",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cl:l": true
        },
        "options": {}
      },
      {
        "content": "clear none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cl:n": true
        },
        "options": {}
      },
      {
        "content": "clear right",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cl:r": true
        },
        "options": {}
      },
      {
        "content": "clip ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cp": true
        },
        "options": {}
      },
      {
        "content": "clip auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cp:a": true
        },
        "options": {}
      },
      {
        "content": "clip rect(${1:0} ${2:0} ${3:0} ${0:0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cp:r": true
        },
        "options": {}
      },
      {
        "content": "color ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "c": true
        },
        "options": {}
      },
      {
        "content": "content ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ct": true
        },
        "options": {}
      },
      {
        "content": "content attr(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ct:a": true
        },
        "options": {}
      },
      {
        "content": "content close-quote",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ct:cq": true
        },
        "options": {}
      },
      {
        "content": "content counter(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ct:c": true
        },
        "options": {}
      },
      {
        "content": "content counters(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ct:cs": true
        },
        "options": {}
      },
      {
        "content": "content no-close-quote",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ct:ncq": true
        },
        "options": {}
      },
      {
        "content": "content no-open-quote",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ct:noq": true
        },
        "options": {}
      },
      {
        "content": "content normal",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ct:n": true
        },
        "options": {}
      },
      {
        "content": "content open-quote",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ct:oq": true
        },
        "options": {}
      },
      {
        "content": "counter-increment ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "coi": true
        },
        "options": {}
      },
      {
        "content": "counter-reset ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cor": true
        },
        "options": {}
      },
      {
        "content": "cursor ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cur": true
        },
        "options": {}
      },
      {
        "content": "cursor auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cur:a": true
        },
        "options": {}
      },
      {
        "content": "cursor crosshair",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cur:c": true
        },
        "options": {}
      },
      {
        "content": "cursor default",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cur:d": true
        },
        "options": {}
      },
      {
        "content": "cursor hand",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cur:ha": true
        },
        "options": {}
      },
      {
        "content": "cursor help",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cur:he": true
        },
        "options": {}
      },
      {
        "content": "cursor move",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cur:m": true
        },
        "options": {}
      },
      {
        "content": "cursor pointer",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cur:p": true
        },
        "options": {}
      },
      {
        "content": "cursor text",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cur:t": true
        },
        "options": {}
      },
      {
        "content": "display ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d": true
        },
        "options": {}
      },
      {
        "content": "display -moz-inline-box",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:mib": true
        },
        "options": {}
      },
      {
        "content": "display -moz-inline-stack",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:mis": true
        },
        "options": {}
      },
      {
        "content": "display block",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:b": true
        },
        "options": {}
      },
      {
        "content": "display compact",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:cp": true
        },
        "options": {}
      },
      {
        "content": "display grid",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:g": true
        },
        "options": {}
      },
      {
        "content": "display flex",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:f": true
        },
        "options": {}
      },
      {
        "content": "display inline-block",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:ib": true
        },
        "options": {}
      },
      {
        "content": "display inline-table",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:itb": true
        },
        "options": {}
      },
      {
        "content": "display inline",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:i": true
        },
        "options": {}
      },
      {
        "content": "display list-item",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:li": true
        },
        "options": {}
      },
      {
        "content": "display none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:n": true
        },
        "options": {}
      },
      {
        "content": "display run-in",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:ri": true
        },
        "options": {}
      },
      {
        "content": "display table-caption",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:tbcp": true
        },
        "options": {}
      },
      {
        "content": "display table-cell",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:tbc": true
        },
        "options": {}
      },
      {
        "content": "display table-column-group",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:tbclg": true
        },
        "options": {}
      },
      {
        "content": "display table-column",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:tbcl": true
        },
        "options": {}
      },
      {
        "content": "display table-footer-group",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:tbfg": true
        },
        "options": {}
      },
      {
        "content": "display table-header-group",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:tbhg": true
        },
        "options": {}
      },
      {
        "content": "display table-row-group",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:tbrg": true
        },
        "options": {}
      },
      {
        "content": "display table-row",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:tbr": true
        },
        "options": {}
      },
      {
        "content": "display table",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "d:tb": true
        },
        "options": {}
      },
      {
        "content": "empty-cells ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ec": true
        },
        "options": {}
      },
      {
        "content": "empty-cells hide",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ec:h": true
        },
        "options": {}
      },
      {
        "content": "empty-cells show",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ec:s": true
        },
        "options": {}
      },
      {
        "content": "expression()",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "exp": true
        },
        "options": {}
      },
      {
        "content": "float ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fl": true
        },
        "options": {}
      },
      {
        "content": "float left",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fl:l": true
        },
        "options": {}
      },
      {
        "content": "float none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fl:n": true
        },
        "options": {}
      },
      {
        "content": "float right",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fl:r": true
        },
        "options": {}
      },
      {
        "content": "font ${1:1em} ${2:Arial},${0:sans-serif}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "f+": true
        },
        "options": {}
      },
      {
        "content": "font-effect ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fef": true
        },
        "options": {}
      },
      {
        "content": "font-effect emboss",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fef:eb": true
        },
        "options": {}
      },
      {
        "content": "font-effect engrave",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fef:eg": true
        },
        "options": {}
      },
      {
        "content": "font-effect none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fef:n": true
        },
        "options": {}
      },
      {
        "content": "font-effect outline",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fef:o": true
        },
        "options": {}
      },
      {
        "content": "font-emphasize-position ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "femp": true
        },
        "options": {}
      },
      {
        "content": "font-emphasize-position after",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "femp:a": true
        },
        "options": {}
      },
      {
        "content": "font-emphasize-position before",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "femp:b": true
        },
        "options": {}
      },
      {
        "content": "font-emphasize-style ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fems": true
        },
        "options": {}
      },
      {
        "content": "font-emphasize-style accent",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fems:ac": true
        },
        "options": {}
      },
      {
        "content": "font-emphasize-style circle",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fems:c": true
        },
        "options": {}
      },
      {
        "content": "font-emphasize-style disc",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fems:ds": true
        },
        "options": {}
      },
      {
        "content": "font-emphasize-style dot",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fems:dt": true
        },
        "options": {}
      },
      {
        "content": "font-emphasize-style none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fems:n": true
        },
        "options": {}
      },
      {
        "content": "font-emphasize ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fem": true
        },
        "options": {}
      },
      {
        "content": "font-family ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ff": true
        },
        "options": {}
      },
      {
        "content": "font-family ${0:'Monotype Corsiva','Comic Sans MS'},cursive",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ff:c": true
        },
        "options": {}
      },
      {
        "content": "font-family ${0:Capitals,Impact},fantasy",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ff:f": true
        },
        "options": {}
      },
      {
        "content": "font-family ${0:Monaco,'Courier New'},monospace",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ff:m": true
        },
        "options": {}
      },
      {
        "content": "font-family ${0:Helvetica,Arial},sans-serif",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ff:ss": true
        },
        "options": {}
      },
      {
        "content": "font-family ${0:Georgia,'Times New Roman'},serif",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ff:s": true
        },
        "options": {}
      },
      {
        "content": "font-size-adjust ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fza": true
        },
        "options": {}
      },
      {
        "content": "font-size-adjust none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fza:n": true
        },
        "options": {}
      },
      {
        "content": "font-size ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fz": true
        },
        "options": {}
      },
      {
        "content": "font-smooth ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fsm": true
        },
        "options": {}
      },
      {
        "content": "font-smooth always",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fsm:aw": true
        },
        "options": {}
      },
      {
        "content": "font-smooth auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fsm:a": true
        },
        "options": {}
      },
      {
        "content": "font-smooth never",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fsm:n": true
        },
        "options": {}
      },
      {
        "content": "font-stretch ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fst": true
        },
        "options": {}
      },
      {
        "content": "font-stretch condensed",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fst:c": true
        },
        "options": {}
      },
      {
        "content": "font-stretch expanded",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fst:e": true
        },
        "options": {}
      },
      {
        "content": "font-stretch extra-condensed",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fst:ec": true
        },
        "options": {}
      },
      {
        "content": "font-stretch extra-expanded",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fst:ee": true
        },
        "options": {}
      },
      {
        "content": "font-stretch normal",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fst:n": true
        },
        "options": {}
      },
      {
        "content": "font-stretch semi-condensed",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fst:sc": true
        },
        "options": {}
      },
      {
        "content": "font-stretch semi-expanded",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fst:se": true
        },
        "options": {}
      },
      {
        "content": "font-stretch ultra-condensed",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fst:uc": true
        },
        "options": {}
      },
      {
        "content": "font-stretch ultra-expanded",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fst:ue": true
        },
        "options": {}
      },
      {
        "content": "font-style ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fs": true
        },
        "options": {}
      },
      {
        "content": "font-style italic",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fs:i": true
        },
        "options": {}
      },
      {
        "content": "font-style normal",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fs:n": true
        },
        "options": {}
      },
      {
        "content": "font-style oblique",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fs:o": true
        },
        "options": {}
      },
      {
        "content": "font-variant ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fv": true
        },
        "options": {}
      },
      {
        "content": "font-variant normal",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fv:n": true
        },
        "options": {}
      },
      {
        "content": "font-variant small-caps",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fv:sc": true
        },
        "options": {}
      },
      {
        "content": "font-weight ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fw": true
        },
        "options": {}
      },
      {
        "content": "font-weight bold",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fw:b": true
        },
        "options": {}
      },
      {
        "content": "font-weight bolder",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fw:br": true
        },
        "options": {}
      },
      {
        "content": "font-weight lighter",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fw:lr": true
        },
        "options": {}
      },
      {
        "content": "font-weight normal",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fw:n": true
        },
        "options": {}
      },
      {
        "content": "font ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "f": true
        },
        "options": {}
      },
      {
        "content": "grid ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "g": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-flow ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gaf": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-flow ${1:row} ${0:dense}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gaf+": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-flow row",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gaf:r": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-flow column",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gaf:c": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-flow dense",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gaf:d": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-flow row dense",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gaf:rd": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-flow column dense",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gaf:cd": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-rows ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gar": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-rows auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gar:a": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-rows max-content",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gar:mac": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-rows min-content",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gar:mic": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-columns ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gac": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-columns auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gac:a": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-columns max-content",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gac:mac": true
        },
        "options": {}
      },
      {
        "content": "grid-auto-columns min-content",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gac:mic": true
        },
        "options": {}
      },
      {
        "content": "grid-template ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gt": true
        },
        "options": {}
      },
      {
        "content": "grid-template ${1} / ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gt+": true
        },
        "options": {}
      },
      {
        "content": "grid-template-rows ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gtr": true
        },
        "options": {}
      },
      {
        "content": "grid-template-columns ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gtc": true
        },
        "options": {}
      },
      {
        "content": "grid-template-areas ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gta": true
        },
        "options": {}
      },
      {
        "content": "grid-gap ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gg": true
        },
        "options": {}
      },
      {
        "content": "grid-gap ${1} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gg+": true
        },
        "options": {}
      },
      {
        "content": "grid-gap 0",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gg:0": true
        },
        "options": {}
      },
      {
        "content": "grid-row-gap ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "grg": true
        },
        "options": {}
      },
      {
        "content": "grid-row-gap 0",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "grg:0": true
        },
        "options": {}
      },
      {
        "content": "grid-column-gap ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gcg": true
        },
        "options": {}
      },
      {
        "content": "grid-column-gap 0",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gcg:0": true
        },
        "options": {}
      },
      {
        "content": "grid-row ${1} / ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gr": true
        },
        "options": {}
      },
      {
        "content": "grid-row-start ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "grs": true
        },
        "options": {}
      },
      {
        "content": "grid-row-end ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gre": true
        },
        "options": {}
      },
      {
        "content": "grid-column ${1} / ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gc": true
        },
        "options": {}
      },
      {
        "content": "grid-column-start ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gcs": true
        },
        "options": {}
      },
      {
        "content": "grid-column-end ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gce": true
        },
        "options": {}
      },
      {
        "content": "height ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "h": true
        },
        "options": {}
      },
      {
        "content": "height auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "h:a": true
        },
        "options": {}
      },
      {
        "content": "left ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "l": true
        },
        "options": {}
      },
      {
        "content": "left auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "l:a": true
        },
        "options": {}
      },
      {
        "content": "letter-spacing ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lts": true
        },
        "options": {}
      },
      {
        "content": "line-height ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lh": true
        },
        "options": {}
      },
      {
        "content": "list-style-image url(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lisi": true
        },
        "options": {}
      },
      {
        "content": "list-style-image none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lisi:n": true
        },
        "options": {}
      },
      {
        "content": "list-style-position ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lisp": true
        },
        "options": {}
      },
      {
        "content": "list-style-position inside",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lisp:i": true
        },
        "options": {}
      },
      {
        "content": "list-style-position outside",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lisp:o": true
        },
        "options": {}
      },
      {
        "content": "list-style-type ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list": true
        },
        "options": {}
      },
      {
        "content": "list-style-type circle",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list:c": true
        },
        "options": {}
      },
      {
        "content": "list-style-type decimal-leading-zero",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list:dclz": true
        },
        "options": {}
      },
      {
        "content": "list-style-type decimal",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list:dc": true
        },
        "options": {}
      },
      {
        "content": "list-style-type disc",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list:d": true
        },
        "options": {}
      },
      {
        "content": "list-style-type lower-roman",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list:lr": true
        },
        "options": {}
      },
      {
        "content": "list-style-type none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list:n": true
        },
        "options": {}
      },
      {
        "content": "list-style-type square",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list:s": true
        },
        "options": {}
      },
      {
        "content": "list-style-type upper-roman",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "list:ur": true
        },
        "options": {}
      },
      {
        "content": "list-style ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lis": true
        },
        "options": {}
      },
      {
        "content": "list-style none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lis:n": true
        },
        "options": {}
      },
      {
        "content": "margin-bottom ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mb": true
        },
        "options": {}
      },
      {
        "content": "margin-bottom auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mb:a": true
        },
        "options": {}
      },
      {
        "content": "margin-left ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ml": true
        },
        "options": {}
      },
      {
        "content": "margin-left auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ml:a": true
        },
        "options": {}
      },
      {
        "content": "margin-right ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mr": true
        },
        "options": {}
      },
      {
        "content": "margin-right auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mr:a": true
        },
        "options": {}
      },
      {
        "content": "margin-top ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mt": true
        },
        "options": {}
      },
      {
        "content": "margin-top auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mt:a": true
        },
        "options": {}
      },
      {
        "content": "margin ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "m": true
        },
        "options": {}
      },
      {
        "content": "margin ${1:0} ${2:0} ${3:0} ${0:0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "m:4": true
        },
        "options": {}
      },
      {
        "content": "margin ${1:0} ${2:0} ${0:0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "m:3": true
        },
        "options": {}
      },
      {
        "content": "margin ${1:0} ${0:0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "m:2": true
        },
        "options": {}
      },
      {
        "content": "margin 0",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "m:0": true
        },
        "options": {}
      },
      {
        "content": "margin auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "m:a": true
        },
        "options": {}
      },
      {
        "content": "max-height ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mah": true
        },
        "options": {}
      },
      {
        "content": "max-height none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mah:n": true
        },
        "options": {}
      },
      {
        "content": "max-width ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "maw": true
        },
        "options": {}
      },
      {
        "content": "max-width none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "maw:n": true
        },
        "options": {}
      },
      {
        "content": "min-height ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mih": true
        },
        "options": {}
      },
      {
        "content": "min-width ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "miw": true
        },
        "options": {}
      },
      {
        "content": "opacity ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "op": true
        },
        "options": {}
      },
      {
        "content": "filter progid:DXImageTransform.Microsoft.Alpha(Opacity=${0:100})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "op:ie": true
        },
        "options": {}
      },
      {
        "content": "-ms-filter 'progid:DXImageTransform.Microsoft.Alpha(Opacity=${0:100})'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "op:ms": true
        },
        "options": {}
      },
      {
        "content": "orphans ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "orp": true
        },
        "options": {}
      },
      {
        "content": "outline ${1:1px} ${2:solid} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "o+": true
        },
        "options": {}
      },
      {
        "content": "outline-color ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "oc": true
        },
        "options": {}
      },
      {
        "content": "outline-color invert",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "oc:i": true
        },
        "options": {}
      },
      {
        "content": "outline-offset ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "oo": true
        },
        "options": {}
      },
      {
        "content": "outline-style ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "os": true
        },
        "options": {}
      },
      {
        "content": "outline-width ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ow": true
        },
        "options": {}
      },
      {
        "content": "outline ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "o": true
        },
        "options": {}
      },
      {
        "content": "outline none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "o:n": true
        },
        "options": {}
      },
      {
        "content": "overflow-style ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovs": true
        },
        "options": {}
      },
      {
        "content": "overflow-style auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovs:a": true
        },
        "options": {}
      },
      {
        "content": "overflow-style marquee",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovs:mq": true
        },
        "options": {}
      },
      {
        "content": "overflow-style move",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovs:mv": true
        },
        "options": {}
      },
      {
        "content": "overflow-style panner",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovs:p": true
        },
        "options": {}
      },
      {
        "content": "overflow-style scrollbar",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovs:s": true
        },
        "options": {}
      },
      {
        "content": "overflow-x ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovx": true
        },
        "options": {}
      },
      {
        "content": "overflow-x auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovx:a": true
        },
        "options": {}
      },
      {
        "content": "overflow-x hidden",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovx:h": true
        },
        "options": {}
      },
      {
        "content": "overflow-x scroll",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovx:s": true
        },
        "options": {}
      },
      {
        "content": "overflow-x visible",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovx:v": true
        },
        "options": {}
      },
      {
        "content": "overflow-y ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovy": true
        },
        "options": {}
      },
      {
        "content": "overflow-y auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovy:a": true
        },
        "options": {}
      },
      {
        "content": "overflow-y hidden",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovy:h": true
        },
        "options": {}
      },
      {
        "content": "overflow-y scroll",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovy:s": true
        },
        "options": {}
      },
      {
        "content": "overflow-y visible",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ovy:v": true
        },
        "options": {}
      },
      {
        "content": "overflow ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ov": true
        },
        "options": {}
      },
      {
        "content": "overflow auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ov:a": true
        },
        "options": {}
      },
      {
        "content": "overflow hidden",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ov:h": true
        },
        "options": {}
      },
      {
        "content": "overflow scroll",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ov:s": true
        },
        "options": {}
      },
      {
        "content": "overflow visible",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ov:v": true
        },
        "options": {}
      },
      {
        "content": "padding-bottom ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pb": true
        },
        "options": {}
      },
      {
        "content": "padding-left ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pl": true
        },
        "options": {}
      },
      {
        "content": "padding-right ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pr": true
        },
        "options": {}
      },
      {
        "content": "padding-top ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pt": true
        },
        "options": {}
      },
      {
        "content": "padding ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p": true
        },
        "options": {}
      },
      {
        "content": "padding ${1:0} ${2:0} ${3:0} ${0:0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p:4": true
        },
        "options": {}
      },
      {
        "content": "padding ${1:0} ${2:0} ${0:0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p:3": true
        },
        "options": {}
      },
      {
        "content": "padding ${1:0} ${0:0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p:2": true
        },
        "options": {}
      },
      {
        "content": "padding 0",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "p:0": true
        },
        "options": {}
      },
      {
        "content": "place-content ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc": true
        },
        "options": {}
      },
      {
        "content": "place-content ${1} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc+": true
        },
        "options": {}
      },
      {
        "content": "place-content start",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc:s": true
        },
        "options": {}
      },
      {
        "content": "place-content end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc:e": true
        },
        "options": {}
      },
      {
        "content": "place-content center",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc:c": true
        },
        "options": {}
      },
      {
        "content": "place-content flex-start",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc:fs": true
        },
        "options": {}
      },
      {
        "content": "place-content flex-end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc:fe": true
        },
        "options": {}
      },
      {
        "content": "place-content space-between",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc:sb": true
        },
        "options": {}
      },
      {
        "content": "place-content space-around",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc:sa": true
        },
        "options": {}
      },
      {
        "content": "place-content space-evenly",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc:se": true
        },
        "options": {}
      },
      {
        "content": "place-content stretch",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pc:st": true
        },
        "options": {}
      },
      {
        "content": "page-break-after ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgba": true
        },
        "options": {}
      },
      {
        "content": "page-break-after always",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgba:aw": true
        },
        "options": {}
      },
      {
        "content": "page-break-after auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgba:a": true
        },
        "options": {}
      },
      {
        "content": "page-break-after left",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgba:l": true
        },
        "options": {}
      },
      {
        "content": "page-break-after right",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgba:r": true
        },
        "options": {}
      },
      {
        "content": "page-break-before ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgbb": true
        },
        "options": {}
      },
      {
        "content": "page-break-before always",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgbb:aw": true
        },
        "options": {}
      },
      {
        "content": "page-break-before auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgbb:a": true
        },
        "options": {}
      },
      {
        "content": "page-break-before left",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgbb:l": true
        },
        "options": {}
      },
      {
        "content": "page-break-before right",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgbb:r": true
        },
        "options": {}
      },
      {
        "content": "page-break-inside ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgbi": true
        },
        "options": {}
      },
      {
        "content": "page-break-inside auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgbi:a": true
        },
        "options": {}
      },
      {
        "content": "page-break-inside avoid",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pgbi:av": true
        },
        "options": {}
      },
      {
        "content": "place-items ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pi": true
        },
        "options": {}
      },
      {
        "content": "place-items ${1:stretch} ${0:stretch}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pi+": true
        },
        "options": {}
      },
      {
        "content": "place-items start",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pi:s": true
        },
        "options": {}
      },
      {
        "content": "place-items end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pi:e": true
        },
        "options": {}
      },
      {
        "content": "place-items center",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pi:c": true
        },
        "options": {}
      },
      {
        "content": "place-items stretch",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pi:st": true
        },
        "options": {}
      },
      {
        "content": "position ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pos": true
        },
        "options": {}
      },
      {
        "content": "position absolute",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pos:a": true
        },
        "options": {}
      },
      {
        "content": "position fixed",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pos:f": true
        },
        "options": {}
      },
      {
        "content": "position relative",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pos:r": true
        },
        "options": {}
      },
      {
        "content": "position static",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pos:s": true
        },
        "options": {}
      },
      {
        "content": "place-self ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ps": true
        },
        "options": {}
      },
      {
        "content": "place-self ${1:stretch} ${0:stretch}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ps+": true
        },
        "options": {}
      },
      {
        "content": "place-self start",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ps:s": true
        },
        "options": {}
      },
      {
        "content": "place-self end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ps:e": true
        },
        "options": {}
      },
      {
        "content": "place-self center",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ps:c": true
        },
        "options": {}
      },
      {
        "content": "place-self stretch",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ps:st": true
        },
        "options": {}
      },
      {
        "content": "quotes ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "q": true
        },
        "options": {}
      },
      {
        "content": "quotes '\\201C' '\\201D' '\\2018' '\\2019'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "q:en": true
        },
        "options": {}
      },
      {
        "content": "quotes none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "q:n": true
        },
        "options": {}
      },
      {
        "content": "quotes '\\00AB' '\\00BB' '\\201E' '\\201C'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "q:ru": true
        },
        "options": {}
      },
      {
        "content": "resize ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rz": true
        },
        "options": {}
      },
      {
        "content": "resize both",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rz:b": true
        },
        "options": {}
      },
      {
        "content": "resize horizontal",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rz:h": true
        },
        "options": {}
      },
      {
        "content": "resize none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rz:n": true
        },
        "options": {}
      },
      {
        "content": "resize vertical",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rz:v": true
        },
        "options": {}
      },
      {
        "content": "right ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "r": true
        },
        "options": {}
      },
      {
        "content": "right auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "r:a": true
        },
        "options": {}
      },
      {
        "content": "table-layout ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tbl": true
        },
        "options": {}
      },
      {
        "content": "table-layout auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tbl:a": true
        },
        "options": {}
      },
      {
        "content": "table-layout fixed",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tbl:f": true
        },
        "options": {}
      },
      {
        "content": "text-align-last ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tal": true
        },
        "options": {}
      },
      {
        "content": "text-align-last auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tal:a": true
        },
        "options": {}
      },
      {
        "content": "text-align-last center",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tal:c": true
        },
        "options": {}
      },
      {
        "content": "text-align-last left",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tal:l": true
        },
        "options": {}
      },
      {
        "content": "text-align-last right",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tal:r": true
        },
        "options": {}
      },
      {
        "content": "text-align ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ta": true
        },
        "options": {}
      },
      {
        "content": "text-align center",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ta:c": true
        },
        "options": {}
      },
      {
        "content": "text-align left",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ta:l": true
        },
        "options": {}
      },
      {
        "content": "text-align right",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ta:r": true
        },
        "options": {}
      },
      {
        "content": "text-decoration ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "td": true
        },
        "options": {}
      },
      {
        "content": "text-decoration line-through",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "td:l": true
        },
        "options": {}
      },
      {
        "content": "text-decoration none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "td:n": true
        },
        "options": {}
      },
      {
        "content": "text-decoration overline",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "td:o": true
        },
        "options": {}
      },
      {
        "content": "text-decoration underline",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "td:u": true
        },
        "options": {}
      },
      {
        "content": "text-emphasis ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "te": true
        },
        "options": {}
      },
      {
        "content": "text-emphasis accent",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "te:ac": true
        },
        "options": {}
      },
      {
        "content": "text-emphasis after",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "te:a": true
        },
        "options": {}
      },
      {
        "content": "text-emphasis before",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "te:b": true
        },
        "options": {}
      },
      {
        "content": "text-emphasis circle",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "te:c": true
        },
        "options": {}
      },
      {
        "content": "text-emphasis disc",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "te:ds": true
        },
        "options": {}
      },
      {
        "content": "text-emphasis dot",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "te:dt": true
        },
        "options": {}
      },
      {
        "content": "text-emphasis none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "te:n": true
        },
        "options": {}
      },
      {
        "content": "text-height ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "th": true
        },
        "options": {}
      },
      {
        "content": "text-height auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "th:a": true
        },
        "options": {}
      },
      {
        "content": "text-height font-size",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "th:f": true
        },
        "options": {}
      },
      {
        "content": "text-height max-size",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "th:m": true
        },
        "options": {}
      },
      {
        "content": "text-height text-size",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "th:t": true
        },
        "options": {}
      },
      {
        "content": "text-indent ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ti": true
        },
        "options": {}
      },
      {
        "content": "text-indent -9999px",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ti:-": true
        },
        "options": {}
      },
      {
        "content": "text-justify ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tj": true
        },
        "options": {}
      },
      {
        "content": "text-justify auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tj:a": true
        },
        "options": {}
      },
      {
        "content": "text-justify distribute",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tj:d": true
        },
        "options": {}
      },
      {
        "content": "text-justify inter-cluster",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tj:ic": true
        },
        "options": {}
      },
      {
        "content": "text-justify inter-ideograph",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tj:ii": true
        },
        "options": {}
      },
      {
        "content": "text-justify inter-word",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tj:iw": true
        },
        "options": {}
      },
      {
        "content": "text-justify kashida",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tj:k": true
        },
        "options": {}
      },
      {
        "content": "text-justify tibetan",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tj:t": true
        },
        "options": {}
      },
      {
        "content": "text-outline ${1:0} ${2:0} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "to+": true
        },
        "options": {}
      },
      {
        "content": "text-outline ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "to": true
        },
        "options": {}
      },
      {
        "content": "text-outline none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "to:n": true
        },
        "options": {}
      },
      {
        "content": "text-replace ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tr": true
        },
        "options": {}
      },
      {
        "content": "text-replace none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tr:n": true
        },
        "options": {}
      },
      {
        "content": "text-shadow ${1:0} ${2:0} ${3:0} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tsh+": true
        },
        "options": {}
      },
      {
        "content": "text-shadow ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tsh": true
        },
        "options": {}
      },
      {
        "content": "text-shadow none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tsh:n": true
        },
        "options": {}
      },
      {
        "content": "text-transform ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tt": true
        },
        "options": {}
      },
      {
        "content": "text-transform capitalize",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tt:c": true
        },
        "options": {}
      },
      {
        "content": "text-transform lowercase",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tt:l": true
        },
        "options": {}
      },
      {
        "content": "text-transform none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tt:n": true
        },
        "options": {}
      },
      {
        "content": "text-transform uppercase",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tt:u": true
        },
        "options": {}
      },
      {
        "content": "text-wrap ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tw": true
        },
        "options": {}
      },
      {
        "content": "text-wrap none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tw:no": true
        },
        "options": {}
      },
      {
        "content": "text-wrap normal",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tw:n": true
        },
        "options": {}
      },
      {
        "content": "text-wrap suppress",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tw:s": true
        },
        "options": {}
      },
      {
        "content": "text-wrap unrestricted",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tw:u": true
        },
        "options": {}
      },
      {
        "content": "top ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "t": true
        },
        "options": {}
      },
      {
        "content": "top auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "t:a": true
        },
        "options": {}
      },
      {
        "content": "vertical-align ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "va": true
        },
        "options": {}
      },
      {
        "content": "vertical-align baseline",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "va:bl": true
        },
        "options": {}
      },
      {
        "content": "vertical-align bottom",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "va:b": true
        },
        "options": {}
      },
      {
        "content": "vertical-align middle",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "va:m": true
        },
        "options": {}
      },
      {
        "content": "vertical-align sub",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "va:sub": true
        },
        "options": {}
      },
      {
        "content": "vertical-align super",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "va:sup": true
        },
        "options": {}
      },
      {
        "content": "vertical-align text-bottom",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "va:tb": true
        },
        "options": {}
      },
      {
        "content": "vertical-align text-top",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "va:tt": true
        },
        "options": {}
      },
      {
        "content": "vertical-align top",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "va:t": true
        },
        "options": {}
      },
      {
        "content": "visibility ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "v": true
        },
        "options": {}
      },
      {
        "content": "visibility collapse",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "v:c": true
        },
        "options": {}
      },
      {
        "content": "visibility hidden",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "v:h": true
        },
        "options": {}
      },
      {
        "content": "visibility visible",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "v:v": true
        },
        "options": {}
      },
      {
        "content": "white-space-collapse ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whsc": true
        },
        "options": {}
      },
      {
        "content": "white-space-collapse break-all",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whsc:ba": true
        },
        "options": {}
      },
      {
        "content": "white-space-collapse break-strict",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whsc:bs": true
        },
        "options": {}
      },
      {
        "content": "white-space-collapse keep-all",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whsc:k": true
        },
        "options": {}
      },
      {
        "content": "white-space-collapse loose",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whsc:l": true
        },
        "options": {}
      },
      {
        "content": "white-space-collapse normal",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whsc:n": true
        },
        "options": {}
      },
      {
        "content": "white-space ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whs": true
        },
        "options": {}
      },
      {
        "content": "white-space normal",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whs:n": true
        },
        "options": {}
      },
      {
        "content": "white-space nowrap",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whs:nw": true
        },
        "options": {}
      },
      {
        "content": "white-space pre-line",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whs:pl": true
        },
        "options": {}
      },
      {
        "content": "white-space pre-wrap",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whs:pw": true
        },
        "options": {}
      },
      {
        "content": "white-space pre",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "whs:p": true
        },
        "options": {}
      },
      {
        "content": "widows ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wid": true
        },
        "options": {}
      },
      {
        "content": "width ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "w": true
        },
        "options": {}
      },
      {
        "content": "width auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "w:a": true
        },
        "options": {}
      },
      {
        "content": "word-break ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wob": true
        },
        "options": {}
      },
      {
        "content": "word-break break-all",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wob:ba": true
        },
        "options": {}
      },
      {
        "content": "word-break break-strict",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wob:bs": true
        },
        "options": {}
      },
      {
        "content": "word-break keep-all",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wob:k": true
        },
        "options": {}
      },
      {
        "content": "word-break loose",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wob:l": true
        },
        "options": {}
      },
      {
        "content": "word-break normal",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wob:n": true
        },
        "options": {}
      },
      {
        "content": "word-spacing ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wos": true
        },
        "options": {}
      },
      {
        "content": "word-wrap ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wow": true
        },
        "options": {}
      },
      {
        "content": "word-wrap none",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wow:no": true
        },
        "options": {}
      },
      {
        "content": "word-wrap normal",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wow:n": true
        },
        "options": {}
      },
      {
        "content": "word-wrap suppress",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wow:s": true
        },
        "options": {}
      },
      {
        "content": "word-wrap unrestricted",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wow:u": true
        },
        "options": {}
      },
      {
        "content": "z-index ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "z": true
        },
        "options": {}
      },
      {
        "content": "z-index auto",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "z:a": true
        },
        "options": {}
      },
      {
        "content": "zoom 1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "zoo": true
        },
        "options": {}
      },
      {
        "content": ":hover",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":h": true
        },
        "options": {}
      },
      {
        "content": ":first-child",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":fc": true
        },
        "options": {}
      },
      {
        "content": ":last-child",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":lc": true
        },
        "options": {}
      },
      {
        "content": ":nth-child(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":nc": true
        },
        "options": {}
      },
      {
        "content": ":nth-last-child(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":nlc": true
        },
        "options": {}
      },
      {
        "content": ":only-child",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":oc": true
        },
        "options": {}
      },
      {
        "content": ":after",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":a": true
        },
        "options": {}
      },
      {
        "content": ":before",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ":b": true
        },
        "options": {}
      },
      {
        "content": "::after",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "::a": true
        },
        "options": {}
      },
      {
        "content": "::before",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "::b": true
        },
        "options": {}
      },
      {
        "content": "if ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "${1}(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mix": true
        },
        "options": {}
      },
      {
        "content": "for ${1:i} in ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "@keyframes ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "keyf": true
        },
        "options": {}
      },
      {
        "content": "justify-content ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc": true
        },
        "options": {}
      },
      {
        "content": "justify-content start",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc:s": true
        },
        "options": {}
      },
      {
        "content": "justify-content end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc:e": true
        },
        "options": {}
      },
      {
        "content": "justify-content center",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc:c": true
        },
        "options": {}
      },
      {
        "content": "justify-content flex-start",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc:fs": true
        },
        "options": {}
      },
      {
        "content": "justify-content flex-end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc:fe": true
        },
        "options": {}
      },
      {
        "content": "justify-content space-between",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc:sb": true
        },
        "options": {}
      },
      {
        "content": "justify-content space-around",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc:sa": true
        },
        "options": {}
      },
      {
        "content": "justify-content space-evenly",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc:se": true
        },
        "options": {}
      },
      {
        "content": "justify-content space-evenly",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc:st": true
        },
        "options": {}
      },
      {
        "content": "justify-content left",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc:l": true
        },
        "options": {}
      },
      {
        "content": "justify-content right",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "jc:r": true
        },
        "options": {}
      },
      {
        "content": "justify-items ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ji": true
        },
        "options": {}
      },
      {
        "content": "justify-items start",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ji:s": true
        },
        "options": {}
      },
      {
        "content": "justify-items end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ji:e": true
        },
        "options": {}
      },
      {
        "content": "justify-items center",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ji:c": true
        },
        "options": {}
      },
      {
        "content": "justify-items stretch",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ji:st": true
        },
        "options": {}
      },
      {
        "content": "justify-self ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "js": true
        },
        "options": {}
      },
      {
        "content": "justify-self start",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "js:s": true
        },
        "options": {}
      },
      {
        "content": "justify-self end",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "js:e": true
        },
        "options": {}
      },
      {
        "content": "justify-self center",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "js:c": true
        },
        "options": {}
      },
      {
        "content": "justify-self stretch",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "js:st": true
        },
        "options": {}
      }
    ],
    "supercollider": [
      {
        "content": "(\n\t${0}\n)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "b": true
        },
        "options": {}
      },
      {
        "content": "if (${1}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "if (${1}) {\n\t${2}\n} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "for (${1:1}, ${2:10}) { |i|\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "SynthDef(\\\\${1:synthName}, {${2}\n\t${0}\n}).add;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sdef": true
        },
        "options": {}
      },
      {
        "content": "for (${1:1}, ${2:10}) {${3: |i}|}\n\t$0\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "SynthDef(\\\\${1:synthName}, {${2: |${3:x}|}\n\t$0\n}).add;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sdef": true
        },
        "options": {}
      }
    ],
    "svelte": [
      {
        "content": "<script>\n\t${1:// your script goes here}\n</script>\n\n<style>\n\t${2:/* your styles go here */}\n</style>\n\n${3:<!-- markup (zero or more items) goes here -->}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-component-format",
        "matches": {
          "svcomponent": true,
          "svelte component template": true
        },
        "options": {}
      },
      {
        "content": "<script>\n\t${1:// your script goes here}\n</script>",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-script-tag",
        "matches": {
          "svelte script": true,
          "svscript": true
        },
        "options": {}
      },
      {
        "content": "<script context=\"module\">\n\t${1:// your script goes here}\n</script>",
        "doc": "add a script with context=\"module\" to your svelte file",
        "grammar": "lsp",
        "label": "svelte-script-context",
        "matches": {
          "svelte script context": true,
          "svscriptc": true
        },
        "options": {}
      },
      {
        "content": "<style>\n\t${1:/* your styles go here */}\n</style>",
        "doc": "add styles to your svelte file",
        "grammar": "lsp",
        "label": "svelte-style-tag",
        "matches": {
          "svelte style": true,
          "svstyle": true
        },
        "options": {}
      },
      {
        "content": "{${1:expression}}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-expression",
        "matches": {
          "svelte expression": true,
          "svexp": true
        },
        "options": {}
      },
      {
        "content": "{@html ${1:expression}}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-expression-html",
        "matches": {
          "svelte expression html": true,
          "svexphtml": true
        },
        "options": {}
      },
      {
        "content": "{@debug ${1:var1}${2:,var2}}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-expression-debug",
        "matches": {
          "svelte expression debug": true,
          "svexpdebug": true
        },
        "options": {}
      },
      {
        "content": "{#if ${1:condition}}\n\t${2: <!-- content here -->}\n{/if}",
        "doc": "if block",
        "grammar": "lsp",
        "label": "svelte-if-block",
        "matches": {
          "svelte if-block": true,
          "svif": true
        },
        "options": {}
      },
      {
        "content": "{#if ${1:condition}}\n\t${2: <!-- content here -->}\n{:else}\n\t${3: <!-- else content here -->}\n{/if}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-if-else-block",
        "matches": {
          "svelte if else": true,
          "svif-else": true
        },
        "options": {}
      },
      {
        "content": "{:else}\n\t${1: <!-- else content here -->}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-else-block",
        "matches": {
          "svelse": true,
          "svelte else": true
        },
        "options": {}
      },
      {
        "content": "{#if ${1:condition}}\n\t${2: <!-- content here -->}\n{:else if ${3: otherCondition}}\n\t${4: <!-- else if content here -->}\n{:else}\n\t${5: <!-- else content here -->}\n{/if}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-if-else-if-block",
        "matches": {
          "svelte if else if": true,
          "svif-else-if": true
        },
        "options": {}
      },
      {
        "content": "{:else if ${1: otherCondition}}\n\t${2: <!-- else if content here -->}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-else-if-block",
        "matches": {
          "svelse-if": true,
          "svelte else if": true
        },
        "options": {}
      },
      {
        "content": "{#each ${1:items} as ${2:item}}\n\t${3: <!-- content here -->}\n{/each}",
        "doc": "each block",
        "grammar": "lsp",
        "label": "svelte-each-block",
        "matches": {
          "sveach": true,
          "svelte each": true
        },
        "options": {}
      },
      {
        "content": "{#each ${1:items} as ${2:item}}\n\t${3: <!-- content here -->}\n{:else}\n\t${4: <!-- empty list -->}\n{/each}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-each-else-block",
        "matches": {
          "sveach-else": true,
          "svelte each else": true
        },
        "options": {}
      },
      {
        "content": "{#each ${1:items} as ${2:item}, ${3:i}}\n\t${4: <!-- content here -->}\n{/each}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-each-index-block",
        "matches": {
          "sveach-index": true,
          "svelte each index": true
        },
        "options": {}
      },
      {
        "content": "{#each ${1:items} as ${2:item}, (${3:key})}\n\t${4: <!-- content here -->}\n{/each}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-each-key-block",
        "matches": {
          "sveach-key": true,
          "svelte each key": true
        },
        "options": {}
      },
      {
        "content": "{#each ${1:items} as ${2:item}, i (${3:key})}\n\t${4: <!-- content here -->}\n{/each}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-each-index-key-block",
        "matches": {
          "sveach-i-k": true,
          "svelte each index key": true
        },
        "options": {}
      },
      {
        "content": "{#await ${1:promise}}\n\t${2: <!-- content when promise is pending -->}\n{:then ${3:value}}\n\t${4: <!-- content when promise was fulfilled -->}\n{/await}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-await-then-block",
        "matches": {
          "svawait": true,
          "svelte await then": true
        },
        "options": {}
      },
      {
        "content": "{:then ${1:value}}\n\t${2: <!-- content when promise was fulfilled -->}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-then-block",
        "matches": {
          "svelte then": true,
          "svthen": true
        },
        "options": {}
      },
      {
        "content": "{#await ${1:promise} then ${2:value}}\n\t${3: <!-- content when promise was fulfilled -->}\n{/await}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-await-short-block",
        "matches": {
          "svawait-short": true,
          "svelte await short": true
        },
        "options": {}
      },
      {
        "content": "{#await ${1:promise}}\n\t${2: <!-- content when promise is pending -->}\n{:then ${3:value}}\n\t${4: <!-- content when promise was fulfilled -->}\n{:catch error}\n\t${5: <!-- content when promise was rejected -->}\n{/await}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-await-catch-block",
        "matches": {
          "svawait-catch": true,
          "svelte await catch": true
        },
        "options": {}
      },
      {
        "content": "{:catch error}\n\t<!-- promise was rejected -->",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-catch-block",
        "matches": {
          "svcatch": true,
          "svelte catch": true
        },
        "options": {}
      },
      {
        "content": "on:${1:eventname}={${2:handler}}",
        "doc": "on event",
        "grammar": "lsp",
        "label": "svelte-on-event",
        "matches": {
          "svelte on event": true,
          "svon": true
        },
        "options": {}
      },
      {
        "content": "on:${1:eventname}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-on-event-forward",
        "matches": {
          "svelte on event foward": true,
          "svon-foward": true
        },
        "options": {}
      },
      {
        "content": "on:${1:eventname}|${2|preventDefault,stopPropagation,passive,capture,once|}={${3:handler}}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-on-event-modifiers",
        "matches": {
          "svelte on event modifiers": true,
          "svon-modifiers": true
        },
        "options": {}
      },
      {
        "content": "on:${1:click}=\"{() => ${2:count += 1}}\"",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-on-event-inline",
        "matches": {
          "svelte on event inline": true,
          "svon-inline": true
        },
        "options": {}
      },
      {
        "content": "|${1|preventDefault,stopPropagation,passive,capture,once|}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-modifiers",
        "matches": {
          "svelte modifier": true,
          "svmodifier": true
        },
        "options": {}
      },
      {
        "content": "bind:${1:property}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-bind",
        "matches": {
          "svbind-simple": true,
          "svelte bind": true
        },
        "options": {}
      },
      {
        "content": "bind:${1:property}={${2:variable}}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-bind-property",
        "matches": {
          "svbind-property": true,
          "svelte bind property": true
        },
        "options": {}
      },
      {
        "content": "<video\nsrc={${1:clip}}\nbind:${2:duration}\nbind:${3:buffered}\nbind:${4:seekable}\nbind:${5:played}\nbind:${6:currentTime}\nbind:${7:paused}\nbind:${8:volume}\n></video>",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-bind-video",
        "matches": {
          "svbind-video": true,
          "svelte bind video": true
        },
        "options": {}
      },
      {
        "content": "bind:${1|clientWidth,clientHeight,offsetWidth,offsetHeight|}={${2:variable}}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-bind-block-level",
        "matches": {
          "svbind-level": true,
          "svelte bind level": true
        },
        "options": {}
      },
      {
        "content": "bind:group={${1:variable}}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-bind-group",
        "matches": {
          "svbind-group": true,
          "svelte bind group": true
        },
        "options": {}
      },
      {
        "content": "bind:this={${1:dom_node}}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-bind-this",
        "matches": {
          "svbind-this": true,
          "svelte bind this": true
        },
        "options": {}
      },
      {
        "content": "class:${1:name}={${2:condition}}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-class",
        "matches": {
          "svcl": true,
          "svelte class": true
        },
        "options": {}
      },
      {
        "content": "class:${1:name}}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-class-short",
        "matches": {
          "svcls": true,
          "svelte class short": true
        },
        "options": {}
      },
      {
        "content": "use:action",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-use",
        "matches": {
          "svelte use": true,
          "svu": true
        },
        "options": {}
      },
      {
        "content": "use:action={${1:parameters}}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-use-parameters",
        "matches": {
          "svelte use parameters": true,
          "svupar": true
        },
        "options": {}
      },
      {
        "content": "${1|transition,in,out|}:${2:name}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-transition",
        "matches": {
          "svelte transition": true,
          "svt": true
        },
        "options": {}
      },
      {
        "content": "${1|transition,in,out|}:${2:name}={${3:params}}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-transition-params",
        "matches": {
          "svelte transition params": true,
          "svtp": true
        },
        "options": {}
      },
      {
        "content": "on:${1|introstart,introend,outrostart,outroend|}=\"{() => status = '${1|introstart,introend,outrostart,outroend|}'}\"",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-transition-events",
        "matches": {
          "svelte transition events": true,
          "svte": true
        },
        "options": {}
      },
      {
        "content": "${1|transition,in,out|}:${2:name}|${3:local}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-transition-local",
        "matches": {
          "svelte transition local": true,
          "svtl": true
        },
        "options": {}
      },
      {
        "content": "${1|transition,in,out|}:${2:name}|${3:local}={${4:params}}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-transition-all",
        "matches": {
          "svelte transition all": true,
          "svta": true
        },
        "options": {}
      },
      {
        "content": "animate:${1:name}={${2:params}}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-animate",
        "matches": {
          "sva": true,
          "svelte animate": true
        },
        "options": {}
      },
      {
        "content": "<slot>${1:<!-- optional fallback -->}</slot>",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-slot",
        "matches": {
          "svelte slot": true,
          "svsl": true
        },
        "options": {}
      },
      {
        "content": "<slot name=\"${1:x}\">${2:<!-- optional fallback -->}</slot>",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-slot-name",
        "matches": {
          "svelte slot name": true,
          "svsn": true
        },
        "options": {}
      },
      {
        "content": "<slot ${1:prop}={${2:value}}>${3:<!-- optional fallback -->}</slot>",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-slot-prop",
        "matches": {
          "svelte slot prop": true,
          "svsp": true
        },
        "options": {}
      },
      {
        "content": "<svelte:self />",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-self",
        "matches": {
          "svelte self": true,
          "svse": true
        },
        "options": {}
      },
      {
        "content": "<svelte:self ${1:prop}={${2:value}} />",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-self-prop",
        "matches": {
          "svelte self prop": true,
          "svsep": true
        },
        "options": {}
      },
      {
        "content": "<svelte:component this={${1:component}} />",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-component",
        "matches": {
          "svc": true,
          "svelte component": true
        },
        "options": {}
      },
      {
        "content": "<svelte:window />",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-window",
        "matches": {
          "svelte window": true,
          "svw": true
        },
        "options": {}
      },
      {
        "content": "bind:${1|innerWidth,innerHeight,outerWidth,outerHeight,scrollX,scrollY,online|}={${2:variable}}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-window-bind",
        "matches": {
          "svelte window bind": true,
          "svwb": true
        },
        "options": {}
      },
      {
        "content": "<svelte:body />",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-body",
        "matches": {
          "svb": true,
          "svelte body": true
        },
        "options": {}
      },
      {
        "content": "<svelte:head>\n\t${1:<!-- head content -->}\n</svelte:head>",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-head",
        "matches": {
          "svelte head": true,
          "svh": true
        },
        "options": {}
      },
      {
        "content": "<svelte:options ${1|immutable,accessors,namespace,tag|}={${2:value}}/>",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-options",
        "matches": {
          "svelte options": true,
          "svop": true
        },
        "options": {}
      },
      {
        "content": "const component = new ${1:App}({\n\ttarget: ${2|target,document.body|},\n\tprops: ${3:props},\n\tanchor: ${4:anchor},\n\thydrate: ${5|false,true|},\n\tintro: ${5|false,true|}\n})",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-create-component",
        "matches": {
          "svcreate-component": true,
          "svelte create component": true
        },
        "options": {}
      },
      {
        "content": "function ${1:foo}(node) {\n\t// the node has been mounted in the DOM\n\treturn {\n\t\tdestroy() {\n\t\t\t// the node has been removed from the DOM\n\t\t}\n\t};\n}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-action",
        "matches": {
          "svaction": true,
          "svelte action": true
        },
        "options": {}
      },
      {
        "content": "function ${1:foo}(node, ${2:parameters}) {\n\t// the node has been mounted in the DOM\n\treturn {\n\t\tdestroy() {\n\t\t\t// the node has been removed from the DOM\n\t\t}\n\t};\n}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-action-parameters",
        "matches": {
          "svactionp": true,
          "svelte action parameters": true
        },
        "options": {}
      },
      {
        "content": "function ${1:foo}(node, ${2:parameters}) {\n\t// the node has been mounted in the DOM\n\treturn {\n\t\tupdate(${2:parameters}) {\n\t\t\t// the value of `${2:parameters}` has changed\n\t\t}\n\t\tdestroy() {\n\t\t\t// the node has been removed from the DOM\n\t\t}\n\t};\n}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-action-update",
        "matches": {
          "svactionu": true,
          "svelte action update": true
        },
        "options": {}
      },
      {
        "content": "onMount(() => {\n\t${1:// content here}\n});",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-on-mount",
        "matches": {
          "svelte lifecycle mount": true,
          "svlfm": true
        },
        "options": {}
      },
      {
        "content": "beforeUpdate(() => {\n\t${1:// content here}\n});",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-before-update",
        "matches": {
          "svelte lifecycle before update": true,
          "svlfbu": true
        },
        "options": {}
      },
      {
        "content": "afterUpdate(() => {\n\t${1:// content here}\n});",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-after-update",
        "matches": {
          "svelte lifecycle-after-update": true,
          "svlfap": true
        },
        "options": {}
      },
      {
        "content": "onDestroy(() => {\n\t${1:// content here}\n});",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-on-destroy",
        "matches": {
          "svelte lifecycle destroy": true,
          "svlfd": true
        },
        "options": {}
      },
      {
        "content": "await tick()",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-tick",
        "matches": {
          "sv-tick": true,
          "svelte tick": true
        },
        "options": {}
      },
      {
        "content": "setContext(${1:key}, ${2:context})",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-set-context",
        "matches": {
          "sv-content": true,
          "svelte set content": true
        },
        "options": {}
      },
      {
        "content": "getContext(${1:key})",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-get-context",
        "matches": {
          "svelte get content": true,
          "svgetc": true
        },
        "options": {}
      },
      {
        "content": "const dispatch = createEventDispatcher();",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-dispatch",
        "matches": {
          "svdp": true,
          "svelte dispatch": true
        },
        "options": {}
      },
      {
        "content": "dispatch(${1:key},${2:data})",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-dispatch-event",
        "matches": {
          "svdpe": true,
          "svelte dispatch event": true
        },
        "options": {}
      },
      {
        "content": "const ${1:store} = writable(${2:initialValue});",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-writeable",
        "matches": {
          "svelte writeable": true,
          "svw": true
        },
        "options": {}
      },
      {
        "content": "const ${1:store} = writable(${2:initialValue}, () => {\n\t${3:console.log('got a subscriber');}\n\treturn () => ${4:console.log('no more subscribers');}\n});",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-writeable-set",
        "matches": {
          "svelte writeable set": true,
          "svwt": true
        },
        "options": {}
      },
      {
        "content": "const ${1:store} = readable(${2:initialValue}, () => {\n\t${3:console.log('got a subscriber');}\n\treturn () => ${4:console.log('no more subscribers');}\n});",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-readable",
        "matches": {
          "svelte readable": true,
          "svr": true
        },
        "options": {}
      },
      {
        "content": "const ${1:value} = get(${2:store});",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-store-get",
        "matches": {
          "svelte store-get-value": true,
          "svstoregm": true
        },
        "options": {}
      },
      {
        "content": "${1:component}.$set(${2: params});",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-component-set",
        "matches": {
          "svcoms": true,
          "svelte component set": true
        },
        "options": {}
      },
      {
        "content": "${1:component}.$on(${2:eventname}, ${3:handler});",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-component-on",
        "matches": {
          "svcomon": true,
          "svelte component on": true
        },
        "options": {}
      },
      {
        "content": "${1:component}.$destroy();",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-component-destroy",
        "matches": {
          "svcomd": true,
          "svelte component destroy": true
        },
        "options": {}
      },
      {
        "content": "const { head, html, css } = ${1:App}.render({\n\tprops: ${3:props},\n})",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-render-component",
        "matches": {
          "svelte render component": true,
          "svrcom": true
        },
        "options": {}
      },
      {
        "content": "const ${1:store} = tweened(${2:value}, ${3:options});",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-tweened",
        "matches": {
          "svelte tweened": true,
          "svtw": true
        },
        "options": {}
      },
      {
        "content": "const ${1:store} = spring(${2:value}, ${3:options});",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-spring",
        "matches": {
          "svelte spring": true,
          "svsp": true
        },
        "options": {}
      },
      {
        "content": "require('svelte/register');\nconst ${1:App} = require('${2:./App.svelte}').default;",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-register",
        "matches": {
          "svelte register": true,
          "svreg": true
        },
        "options": {}
      },
      {
        "content": "import { Route, Router } from 'svelte-routing'",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-routing-import",
        "matches": {
          "svelte import routing": true,
          "svroute": true
        },
        "options": {}
      },
      {
        "content": ":global(${1:body}) {\n\t/* this will apply to <body> */\n\t${2:/* your styles go here */}\n}",
        "doc": "",
        "grammar": "lsp",
        "label": "svelte-global-style",
        "matches": {
          "svelte global style": true,
          "svsglobal": true
        },
        "options": {}
      }
    ],
    "swift": [
      {
        "content": "struct ${1:name} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "struct": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "class ${1:name} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "class": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "enum ${1:name} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "enum": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "case ${1:pattern}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "protocol ${1:name} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "protocol": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "var ${1:name}: ${2:Int}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "var": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "let ${1:name}: ${2:Int}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "let": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "extension ${1:Int} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "extension": true
        },
        "options": {}
      },
      {
        "content": "func ${1:name}(${2:#:arguments}) -> ${3:Int}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "func name(...) -> Type { ... }",
        "matches": {
          "func": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "func ${1:name}(${2:#:arguments})${0}",
        "doc": "",
        "grammar": "snu",
        "label": "func name(...) { ... }",
        "matches": {
          "void": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "for var ${1:i = 0}; ${2:i < j}; ${3:i++} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "for ${1:item} in ${2:collection} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "iter": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "while ${1:false} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "while": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "repeat {\n    ${0:TARGET}\n} while ${1:false}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "repeat": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "if ${1:false} {\n    ${0:TARGET}\n}${9}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "else if ${1:false} {\n    ${0:TARGET}\n}${9}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "elif": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "else {\n    ${0:TARGET}\n}${9}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "else": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "if ${1:let} ${2:name} = ${3:expression} else {\n    ${0:TARGET}\n}${9}",
        "doc": "",
        "grammar": "snu",
        "label": "if let/case ... { ... }",
        "matches": {
          "optional": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "guard let ${1} = ${2} else {\n    ${0:TARGET}\n}\n${9}",
        "doc": "",
        "grammar": "snu",
        "label": "guard let ... else { ... }",
        "matches": {
          "guard": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "switch ${1:expression} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "switch": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "do {\n    ${0:TARGET}\n}${9}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "do": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "catch${1:#:pattern} {\n    ${0:TARGET}\n}${9}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "catch": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "defer {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "defer": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "import ${1:module}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "import": true
        },
        "options": {}
      },
      {
        "content": "subscript(${1:index: Int}) -> ${2:Int} {\n    ${0:TARGET}\n}\n${9}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "subscript": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "init${1:#:?}(${2:#:arguments}) {\n    ${0:TARGET}\n}\n${9}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "init": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "deinit {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "deinit": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "{ ${1:#capture}(${2:#:arguments}) -> ${3:Void} in\n    ${0:TARGET}\n}\n${9}",
        "doc": "",
        "grammar": "snu",
        "label": "{ (...) -> Type in ... }",
        "matches": {
          "closure": true
        },
        "options": {
          "word": true
        }
      }
    ],
    "systemverilog": [
      {
        "content": "always_comb begin\n    ${1:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "always_comb",
        "matches": {
          "alc": true
        },
        "options": {}
      },
      {
        "content": "always @(posedge ${1:clk} iff !${2:rst} or posedge $2) begin\n    if (${2}) begin\n        ${3:TARGET}\n    end else begin\n    end\nend",
        "doc": "",
        "grammar": "snu",
        "label": "always_ff @()",
        "matches": {
          "alf": true
        },
        "options": {}
      },
      {
        "content": "always_latch begin\n    if (${1:enable}) begin\n        ${2:TARGET}\n    end\nend",
        "doc": "",
        "grammar": "snu",
        "label": "always_latch",
        "matches": {
          "all": true
        },
        "options": {}
      },
      {
        "content": "logic${1:#: nbit} ${2:reg}_r, $2_w;${3:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "logic [] _r, _w;",
        "matches": {
          "rw": true
        },
        "options": {}
      },
      {
        "content": "typedef struct packed {\n    ${2:TARGET}\n} ${1:name} ;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "struct": true
        },
        "options": {}
      },
      {
        "content": "typedef enum {${2:TARGET}} ${1:name};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "enum": true
        },
        "options": {}
      },
      {
        "content": "for (int ${1:i} = ${2}; $1 < ${3}; ${4:do what}) begin\n    ${5:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "unique case (${1}) begin\n    ${2:'b0}: begin\n        ${3}\n    end\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case_parallel": true
        },
        "options": {}
      },
      {
        "content": "priority case (${1}) begin\n    ${2:'b0}: begin\n        ${3}\n    end\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case_full": true
        },
        "options": {}
      },
      {
        "content": "foreach (${1}) begin\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forea": true
        },
        "options": {}
      },
      {
        "content": "do begin\n\t${0}\nend while (${1});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dowh": true
        },
        "options": {}
      },
      {
        "content": "always_comb begin ${1:: statement_label}\n\t${0}\nend $1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "alc": true
        },
        "options": {}
      },
      {
        "content": "always_ff @(posedge ${1:clk}) begin ${2:: statement_label}\n\t${0}\nend $2",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "alff": true
        },
        "options": {}
      },
      {
        "content": "always_latch begin ${1:: statement_label}\n\t${0}\nend $1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "all": true
        },
        "options": {}
      },
      {
        "content": "class ${1:class_name};\n\t// data or class properties\n\t${0}\n\t// initialization\n\tfunction new();\n\tendfunction : new\nendclass : $1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cl": true
        },
        "options": {}
      },
      {
        "content": "typedef struct {\n\t${0}\n} ${1:name_t};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "types": true
        },
        "options": {}
      },
      {
        "content": "program ${1:program_name} ();\n\t${0}\nendprogram : $1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prog": true
        },
        "options": {}
      },
      {
        "content": "interface ${1:program_name} ();\n\t// nets\n\t${0}\n\t// clocking\n\t// modports\nendinterface : $1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "intf": true
        },
        "options": {}
      },
      {
        "content": "clocking ${1:clocking_name} @(${2:posedge} ${3:clk});\n\t${0}\nendclocking : $1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "clock": true
        },
        "options": {}
      },
      {
        "content": "covergroup ${1:group_name} @(${2:posedge} ${3:clk});\n\t${0}\nendgroup : $1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cg": true
        },
        "options": {}
      },
      {
        "content": "package ${1:package_name};\n\t${0}\nendpackage : $1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pkg": true
        },
        "options": {}
      }
    ],
    "tcl": [
      {
        "content": "#!/usr/bin/env tclsh",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#!": true
        },
        "options": {}
      },
      {
        "content": "proc ${1:function_name} {${2:args}} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pro": true
        },
        "options": {}
      },
      {
        "content": "${1:expr}? ${2:true} : ${0:false}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "xif": true
        },
        "options": {}
      },
      {
        "content": "if {${1}} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "if {${1}} {\n\t${2}\n} else {\n\t${0:# else...}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "elseif {${1}} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eif": true
        },
        "options": {}
      },
      {
        "content": "if {${1}} {\n\t${2}\n} elseif {${3}} {\n\t${4:# elsif...}\n} else {\n\t${0:# else...}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifee": true
        },
        "options": {}
      },
      {
        "content": "if { [catch {${1:#do something...}} ${2:err}] } {\n\t${0:# handle failure...}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ifc": true
        },
        "options": {}
      },
      {
        "content": "catch {${1}} ${2:err} ${0:options}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "catch": true
        },
        "options": {}
      },
      {
        "content": "while {${1}} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh": true
        },
        "options": {}
      },
      {
        "content": "for {set ${2:var} 0} {$$2 < ${1:count}} {${3:incr} $2} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "foreach ${1:x} {${2:#list}} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fore": true
        },
        "options": {}
      },
      {
        "content": "after ${1:ms} ${0:#do something}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "af": true
        },
        "options": {}
      },
      {
        "content": "after cancel ${0:id or script}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "afc": true
        },
        "options": {}
      },
      {
        "content": "after idle ${0:script}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "afi": true
        },
        "options": {}
      },
      {
        "content": "after info ${0:id}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "afin": true
        },
        "options": {}
      },
      {
        "content": "expr {${0:#expression here}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "exp": true
        },
        "options": {}
      },
      {
        "content": "switch ${1:var} {\n\t${3:pattern 1} {\n\t\t${0:#do something}\n\t}\n\tdefault {\n\t\t${2:#do something}\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sw": true
        },
        "options": {}
      },
      {
        "content": "${1:pattern} {\n\t${2:#do something}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ca": true
        },
        "options": {}
      },
      {
        "content": "namespace eval ${1:path} {${0:#script...}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ns": true
        },
        "options": {}
      },
      {
        "content": "namespace current",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nsc": true
        },
        "options": {}
      },
      {
        "content": "for {${1:set i 0}} {${2:\\$i < \\$n}} {${3:incr i}} {\n\t$4\n}\n",
        "doc": "",
        "grammar": "snu",
        "label": "for... (for)",
        "matches": {
          "for": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "foreach ${1:var} ${2:\\$list} {\n\t$3\n}\n",
        "doc": "",
        "grammar": "snu",
        "label": "foreach... (foreach)",
        "matches": {
          "foreach": true
        },
        "options": {}
      },
      {
        "content": "if {${1:condition}} {\n\t$2\n}\n",
        "doc": "",
        "grammar": "snu",
        "label": "if... (if)",
        "matches": {
          "if": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "proc ${1:name} {${2:args}} \\\n{\n\t$3\n}\n",
        "doc": "",
        "grammar": "snu",
        "label": "proc... (proc)",
        "matches": {
          "proc": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "switch ${1:-exact} -- ${2:\\$var} {\n\t${3:match} {\n\t\t$4\n\t}\n\tdefault {$5}\n}\n",
        "doc": "",
        "grammar": "snu",
        "label": "switch... (switch)",
        "matches": {
          "switch": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "while {${1:condition}} {\n\t$2\n}\n",
        "doc": "",
        "grammar": "snu",
        "label": "while... (while)",
        "matches": {
          "while": true
        },
        "options": {
          "b": true
        }
      }
    ],
    "tex": [
      {
        "content": "\\documentclass[${1}]{${2:article}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\documentclass": true,
          "documentclass": true
        },
        "options": {}
      },
      {
        "content": "$${1:#:expression}$${2}",
        "doc": "",
        "grammar": "snu",
        "label": "$ expression $",
        "matches": {
          "$": true,
          "mathexpression": true
        },
        "options": {}
      },
      {
        "content": "$$${1:#:expression}$$${2}",
        "doc": "",
        "grammar": "snu",
        "label": "$$ expression $$",
        "matches": {
          "$$": true,
          "mathenva": true
        },
        "options": {}
      },
      {
        "content": "\\[${1:#:expression}\\]${2}",
        "doc": "",
        "grammar": "snu",
        "label": "\\[ expression \\]",
        "matches": {
          "\\[": true,
          "mathenvb": true
        },
        "options": {}
      },
      {
        "content": "\\begin{${1:#:type}}\n\t${2:TARGET}\n\\end{$1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin": true,
          "begin": true
        },
        "options": {}
      },
      {
        "content": "\\begin{list}\n\t${1:TARGET}\n\\end{list}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{list} \\list": true,
          "list": true
        },
        "options": {}
      },
      {
        "content": "\\begin{quotation}\n\t${1:TARGET}\n\\end{quotation}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{quotation} \\quotation": true,
          "quotation": true
        },
        "options": {}
      },
      {
        "content": "\\begin{description}\n\t\\item[${1}] ${0}\n\\end{description}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{description} \\description desc": true,
          "description": true
        },
        "options": {}
      },
      {
        "content": "\\item[${1}] ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "itd": true,
          "item[ \\item[": true
        },
        "options": {}
      },
      {
        "content": "\\item ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "it": true,
          "item \\item": true
        },
        "options": {}
      },
      {
        "content": "\\begin{sloppypar}\n\t${1:TARGET}\n\\end{sloppypar}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{sloppypar} \\sloppypar": true,
          "sloppypar": true
        },
        "options": {}
      },
      {
        "content": "\\begin{enumerate}\n\t\\item ${1:TARGET}\n\\end{enumerate}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{enumerate} \\enumerate enum": true,
          "enumerate": true
        },
        "options": {}
      },
      {
        "content": "\\begin{theindex}\n\t${1:TARGET}\n\\end{theindex}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{theindex} \\theindex": true,
          "theindex": true
        },
        "options": {}
      },
      {
        "content": "\\begin{itemize}\n\t\\item ${1:TARGET}\n\\end{itemize}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{itemize} \\itemize": true,
          "itemize": true
        },
        "options": {}
      },
      {
        "content": "\\begin{titlepage}\n\t${1:TARGET}\n\\end{titlepage}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{titlepage} \\titlepage": true,
          "titlepage": true
        },
        "options": {}
      },
      {
        "content": "\\begin{verbatim}\n\t${1:TARGET}\n\\end{verbatim}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{verbatim} verb \\verbatim": true,
          "verbatim": true
        },
        "options": {}
      },
      {
        "content": "\\begin{verbatimtab}[${1:8}]\n\t${2:TARGET}\n\\end{verbatim}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{verbatimtab} \\verbatimtab": true,
          "verbatimtab": true
        },
        "options": {}
      },
      {
        "content": "\\begin{trivlist}\n\t${1:TARGET}\n\\end{trivlist}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{trivlist} \\trivlist": true,
          "trivlist": true
        },
        "options": {}
      },
      {
        "content": "\\begin{verse}\n\t${1:TARGET}\n\\end{verse}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{verse} \\verse": true,
          "verse": true
        },
        "options": {}
      },
      {
        "content": "\\begin{table}[${1}]\n\t\\centering\n\t\\caption{${2}}\n\t\\label{${3}}\n\t\\begin{tabular}{${4}}\n\t\t${5}\n\t\\end{tabular}\n\\end{table}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{table} \\table": true,
          "table": true
        },
        "options": {}
      },
      {
        "content": "\\begin{thebibliography}\n\t${1:TARGET}\n\\end{thebibliography}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{thebibliography} \\thebibliography": true,
          "thebibliography": true
        },
        "options": {}
      },
      {
        "content": "\\begin{tabbing}\n\t${1:TARGET}\n\\end{tabbing}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{tabbing} \\tabbing": true,
          "tabbing": true
        },
        "options": {}
      },
      {
        "content": "\\begin{note}\n\t${1:TARGET}\n\\end{note}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{note} \\note": true,
          "note": true
        },
        "options": {}
      },
      {
        "content": "\\begin{tabular}{${1}}\n\t${2:TARGET}\n\\end{tabular}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{tabular} \\tabular": true,
          "tabular": true
        },
        "options": {}
      },
      {
        "content": "\\begin{overlay}\n\t${1:TARGET}\n\\end{overlay}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{overlay} \\overlay": true,
          "overlay": true
        },
        "options": {}
      },
      {
        "content": "\\begin{array}{${1}}\n\t${2:TARGET}\n\\end{array}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{array} \\array": true,
          "array": true
        },
        "options": {}
      },
      {
        "content": "\\begin{cases}{${1}}\n\t${2:TARGET}\n\\end{cases}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{cases} \\cases": true,
          "cases": true
        },
        "options": {}
      },
      {
        "content": "\\begin{slide}\n\t${1:TARGET}\n\\end{slide}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{slide} \\slide": true,
          "slide": true
        },
        "options": {}
      },
      {
        "content": "\\begin{displaymath}\n\t${1:TARGET}\n\\end{displaymath}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{displaymath} \\displaymath": true,
          "displaymath": true
        },
        "options": {}
      },
      {
        "content": "\\begin{abstract}\n\t${1:TARGET}\n\\end{abstract}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{abstract} \\abstract": true,
          "abstract": true
        },
        "options": {}
      },
      {
        "content": "\\begin{align}\n\t${1:TARGET}\n\\end{align}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{align} \\align": true,
          "align": true
        },
        "options": {}
      },
      {
        "content": "\\begin{align*}\n\t${1:TARGET}\n\\end{align*}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{align*} \\align*": true,
          "align*": true
        },
        "options": {}
      },
      {
        "content": "\\begin{aligned}\n        ${1:TARGET}\n\\end{aligned}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{aligned} \\aligned": true,
          "aligned": true
        },
        "options": {}
      },
      {
        "content": "\\begin{eqnarray}\n\t${1:TARGET}\n\\end{eqnarray}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{eqnarray} \\eqnarray": true,
          "eqnarray": true
        },
        "options": {}
      },
      {
        "content": "\\begin{eqnarray*}\n\t${1:TARGET}\n\\end{eqnarray*}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{eqnarray*} \\eqnarray*": true,
          "eqnarray*": true
        },
        "options": {}
      },
      {
        "content": "\\begin{equation}\n\t${1:TARGET}\n\\end{equation}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{equation} \\equation": true,
          "equation": true
        },
        "options": {}
      },
      {
        "content": "\\begin{equation*}\n\t${1:TARGET}\n\\end{equation*}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{equation*} \\equation*": true,
          "equation*": true
        },
        "options": {}
      },
      {
        "content": "\\begin{center}\n\t${1:TARGET}\n\\end{center}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{center} \\center": true,
          "center": true
        },
        "options": {}
      },
      {
        "content": "\\begin{document}\n\t${1:TARGET}\n\\end{document}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{document} \\document": true,
          "document": true
        },
        "options": {}
      },
      {
        "content": "\\begin{filecontents}\n\t${1:TARGET}\n\\end{filecontents}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{filecontents} \\filecontents": true,
          "filecontents": true
        },
        "options": {}
      },
      {
        "content": "\\begin{lrbox}\n\t${1:TARGET}\n\\end{lrbox}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{lrbox} \\lrbox": true,
          "lrbox": true
        },
        "options": {}
      },
      {
        "content": "\\begin{flushleft}\n\t${1:TARGET}\n\\end{flushleft}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{flushleft} \\flushleft": true,
          "flushleft": true
        },
        "options": {}
      },
      {
        "content": "\\begin{flushright}\n\t${1:TARGET}\n\\end{flushright}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{flushright} \\flushright": true,
          "flushright": true
        },
        "options": {}
      },
      {
        "content": "\\begin{minipage}{${1:0.45}\\linewidth}\n\t${2:TARGET}\n\\end{minipage}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{minipage} \\minipage": true,
          "minipage": true
        },
        "options": {}
      },
      {
        "content": "\\begin{picture}\n\t${1:TARGET}\n\\end{picture}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{picture} \\picture": true,
          "picture": true
        },
        "options": {}
      },
      {
        "content": "\\begin{math}\n\t${1:TARGET}\n\\end{math}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{math} \\math": true,
          "math": true
        },
        "options": {}
      },
      {
        "content": "\\begin{quote}\n\t${1:TARGET}\n\\end{quote}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{quote} \\quote": true,
          "quote": true
        },
        "options": {}
      },
      {
        "content": "\\begin{matrix}\n\t${1:TARGET}\n\\end{matrix}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{matrix} \\matrix": true,
          "matrix": true
        },
        "options": {}
      },
      {
        "content": "\\begin{bmatrix}\n\t${1:TARGET}\n\\end{bmatrix}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{bmatrix} \\bmatrix": true,
          "bmatrix": true
        },
        "options": {}
      },
      {
        "content": "\\begin{pmatrix}\n\t${1:TARGET}\n\\end{pmatrix}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\pegin{bmatrix} \\pmatrix": true,
          "pmatrix": true
        },
        "options": {}
      },
      {
        "content": "\\begin{vmatrix}\n\t${1:TARGET}\n\\end{vmatrix}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{vmatrix} \\vmatrix": true,
          "vmatrix": true
        },
        "options": {}
      },
      {
        "content": "\\begin{Bmatrix}\n\t${1:TARGET}\n\\end{Bmatrix}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Bmatrix": true,
          "\\begin{Bmatrix} \\Bmatrix": true
        },
        "options": {}
      },
      {
        "content": "\\begin{Vmatrix}\n\t${1:TARGET}\n\\end{Vmatrix}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "Vmatrix": true,
          "\\begin{Vmatrix} \\Vmatrix": true
        },
        "options": {}
      },
      {
        "content": "\\part{${1}}\n${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\part": true,
          "part \\part{": true
        },
        "options": {}
      },
      {
        "content": "\\chapter{${1}}\n${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\chapter": true,
          "chapter \\chapter{": true
        },
        "options": {}
      },
      {
        "content": "\\section{${1}}\n${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\section": true,
          "section \\section{": true
        },
        "options": {}
      },
      {
        "content": "\\subsection{${1}}\n${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\subsection": true,
          "subsection \\subsection{": true
        },
        "options": {}
      },
      {
        "content": "\\subsubsection{${1}}\n${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\subsubsection": true,
          "subsubsection \\subsubsection{": true
        },
        "options": {}
      },
      {
        "content": "\\paragraph{${1}}\n${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\paragraph": true,
          "paragraph \\paragraph{": true
        },
        "options": {}
      },
      {
        "content": "\\subparagraph{${1}}\n${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\subparagraph": true,
          "subparagraph \\subparagraph{": true
        },
        "options": {}
      },
      {
        "content": "\\frac{${1}}{${2}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\frac": true,
          "frac \\frac{": true
        },
        "options": {}
      },
      {
        "content": "\\left${1:(} ${3:#:body} \\right${2:)}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "\\left \\right",
        "matches": {
          "\\left": true,
          "left": true
        },
        "options": {}
      },
      {
        "content": "\\begin{bfseries}\n\t${1:TARGET}\n\\end{bfseries}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{bfseries} \\bfseries": true,
          "bfseries": true
        },
        "options": {}
      },
      {
        "content": "\\begin{mdseries}\n\t${1:TARGET}\n\\end{mdseries}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{mdseries} \\mdseries": true,
          "mdseries": true
        },
        "options": {}
      },
      {
        "content": "\\begin{ttfamily}\n\t${1:TARGET}\n\\end{ttfamily}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{ttfamily} \\ttfamily": true,
          "ttfamily": true
        },
        "options": {}
      },
      {
        "content": "\\begin{sffamily}\n\t${1:TARGET}\n\\end{sffamily}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{sffamily} \\sffamily": true,
          "sffamily": true
        },
        "options": {}
      },
      {
        "content": "\\begin{rmfamily}\n\t${1:TARGET}\n\\end{rmfamily}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{rmfamily} \\rmfamily": true,
          "rmfamily": true
        },
        "options": {}
      },
      {
        "content": "\\begin{upshape}\n\t${1:TARGET}\n\\end{upshape}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{upshape} \\upshape": true,
          "upshape": true
        },
        "options": {}
      },
      {
        "content": "\\begin{slshape}\n\t${1:TARGET}\n\\end{slshape}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{slshape} \\slshape": true,
          "slshape": true
        },
        "options": {}
      },
      {
        "content": "\\begin{scshape}\n\t${1:TARGET}\n\\end{scshape}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{scshape} \\scshape": true,
          "scshape": true
        },
        "options": {}
      },
      {
        "content": "\\begin{itshape}\n\t${1:TARGET}\n\\end{itshape}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{itshape} \\itshape": true,
          "itshape": true
        },
        "options": {}
      },
      {
        "content": "\\textbf{${1:TARGET}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\textbf": true,
          "textbf \\textbf{": true
        },
        "options": {}
      },
      {
        "content": "\\textmd{${1:TARGET}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\textmd": true,
          "textmd \\textmd{": true
        },
        "options": {}
      },
      {
        "content": "\\texttt{${1:TARGET}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\texttt": true,
          "texttt \\texttt{": true
        },
        "options": {}
      },
      {
        "content": "\\textsf{${1:TARGET}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\textsf": true,
          "textsf \\textsf{": true
        },
        "options": {}
      },
      {
        "content": "\\textrm{${1:TARGET}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\textrm": true,
          "textrm \\textrm{": true
        },
        "options": {}
      },
      {
        "content": "\\textup{${1:TARGET}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\textup": true,
          "textup \\textup{": true
        },
        "options": {}
      },
      {
        "content": "\\textsl{${1:TARGET}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\textsl": true,
          "textsl \\textsl{": true
        },
        "options": {}
      },
      {
        "content": "\\textsc{${1:TARGET}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\textsc": true,
          "textsc \\textsc{": true
        },
        "options": {}
      },
      {
        "content": "\\textit{${1:TARGET}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\textit": true,
          "textit \\textit{": true
        },
        "options": {}
      },
      {
        "content": "\\begin{frame}{${1:#:frametitle}}\n\t${2:TARGET}\n\\end{frame}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{frame} \\frame": true,
          "frame": true
        },
        "options": {}
      },
      {
        "content": "\\begin{block}{${1:#:title}}\n\t${2:TARGET}\n\\end{block}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{block}": true,
          "block": true
        },
        "options": {}
      },
      {
        "content": "\\begin{exampleblock}{${1:#:title}}\n\t${2:TARGET}\n\\end{exampleblock}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{exampleblock}": true,
          "exampleblock": true
        },
        "options": {}
      },
      {
        "content": "\\begin{alertblock}{${1:#:title}}\n\t${2:TARGET}\n\\end{alertblock}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{alertblock}": true,
          "alertblock": true
        },
        "options": {}
      },
      {
        "content": "\\begin{columns}\n\t\\begin{column}{${1:#:width}${2:\\\\\\textwidth}}\n\t\t${0:#:body}\n\t\\end{column}\n\\end{columns}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{columns} \\columns": true,
          "columns": true
        },
        "options": {}
      },
      {
        "content": "\\begin{column}{${1:#:width}${2:\\\\\\textwidth}}\n\t${0:#:body}\n\\end{column}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{column} \\column": true,
          "column": true
        },
        "options": {}
      },
      {
        "content": "\\begin{figure}[${1}]\n\t\\centering\n\t\\begin{tikzpicture}[${2}]\n\t\t${3:TARGET}\n\t\\end{tikzpicture}\n\t\\caption{${4}}\n\t\\label{${5}}\n\\end{figure}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "figuretikz": true,
          "tikzfig": true
        },
        "options": {}
      },
      {
        "content": "\\begin{tikzpicture}[${1}]\n\t${2:TARGET}\n\\end{tikzpicture}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{tikzpicture}": true,
          "tikzpicture": true
        },
        "options": {}
      },
      {
        "content": "\\begin{scope}[${1}]\n\t${2:TARGET}\n\\end{scope}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\begin{scope}": true,
          "scope": true
        },
        "options": {}
      },
      {
        "content": "\\path[${1}] ${2};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\path": true,
          "path": true
        },
        "options": {}
      },
      {
        "content": "\\draw[${1}] ${2};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\draw": true,
          "draw": true
        },
        "options": {}
      },
      {
        "content": "\\fill[${1}] ${2};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\fill": true,
          "fill": true
        },
        "options": {}
      },
      {
        "content": "\\filldraw[${1}] ${2};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\filldraw": true,
          "filldraw": true
        },
        "options": {}
      },
      {
        "content": "\\shade[${1}] ${2};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\shade": true,
          "shade": true
        },
        "options": {}
      },
      {
        "content": "\\coordinate[${1}](${2:name}) ${3};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\coordinate": true,
          "coordinate": true
        },
        "options": {}
      },
      {
        "content": "\\node[${1}](${2:name}) ${3};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\node": true,
          "node": true
        },
        "options": {}
      },
      {
        "content": "\\addbibresource{${1:resource}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\addbibresource": true,
          "addbibresource": true
        },
        "options": {}
      },
      {
        "content": "\\cite{${1}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\cite": true,
          "cite": true
        },
        "options": {}
      },
      {
        "content": "\\nocite{${1}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\nocite": true,
          "nocite": true
        },
        "options": {}
      },
      {
        "content": "\\supercite{${1}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\supercite": true,
          "supercite": true
        },
        "options": {}
      },
      {
        "content": "\\autocite{${1}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\autocite": true,
          "autocite": true
        },
        "options": {}
      },
      {
        "content": "\\fullcite{${1}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\fullcite": true,
          "fullcite": true
        },
        "options": {}
      },
      {
        "content": "\\ref{${1}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\ref": true,
          "ref": true
        },
        "options": {}
      },
      {
        "content": "\\label{${1}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\label": true,
          "label": true
        },
        "options": {}
      },
      {
        "content": "\\\\documentclass{${1:class}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dcl \\documentclass{}": true
        },
        "options": {}
      },
      {
        "content": "\\\\documentclass[${1:options}]{${2:class}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dclo \\documentclass[]{}": true
        },
        "options": {}
      },
      {
        "content": "\\\\newcommand{\\\\${1:cmd}}[${2:opt}]{${3:realcmd}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nc \\newcommand": true
        },
        "options": {}
      },
      {
        "content": "\\\\usepackage[${1:options}]{${2:package}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "up \\usepackage": true
        },
        "options": {}
      },
      {
        "content": "\\\\newunicodechar{${1}}{${2:\\\\ensuremath}${3:tex-substitute}}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nuc \\newunicodechar": true
        },
        "options": {}
      },
      {
        "content": "\\\\DeclareMathOperator{${1}}{${2}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dmo \\DeclareMathOperator": true
        },
        "options": {}
      },
      {
        "content": "\\\\begin{${1:env}}\n\t${0:${VISUAL}}\n\\\\end{$1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "begin \\begin{} ... \\end{} block": true
        },
        "options": {}
      },
      {
        "content": "\\\\maketitle",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mkt maketitle": true
        },
        "options": {}
      },
      {
        "content": "\\\\begin{${1:tabular}}{${2:c}}\n\t${0:${VISUAL}}\n\\\\end{$1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tab tabular (or arbitrary) environment": true
        },
        "options": {}
      },
      {
        "content": "\\\\begin[${1:author}]{${2:thm}}\n\t${0:${VISUAL}}\n\\\\end{$2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "thm thm (or arbitrary) environment with optional argument": true
        },
        "options": {}
      },
      {
        "content": "\\\\begin{center}\n\t${0:${VISUAL}}\n\\\\end{center}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "center center environment": true
        },
        "options": {}
      },
      {
        "content": "\\\\begin{align${1:ed}}\n\t\\\\label{eq:${2}}\n\t${0:${VISUAL}}\n\\\\end{align$1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ali align(ed) environment": true
        },
        "options": {}
      },
      {
        "content": "\\\\begin{gather${1:ed}}\n\t${0:${VISUAL}}\n\\\\end{gather$1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "gat gather(ed) environment": true
        },
        "options": {}
      },
      {
        "content": "\\\\begin{equation}\n\t${0:${VISUAL}}\n\\\\end{equation}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eq equation environment": true
        },
        "options": {}
      },
      {
        "content": "\\\\begin{equation}\n\t\\\\label{eq:${2}}\n${0:${VISUAL}}\n\\\\end{equation}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eql Labeled equation environment": true
        },
        "options": {}
      },
      {
        "content": "\\\\begin{equation*}\n\t${0:${VISUAL}}\n\\\\end{equation*}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eq* unnumbered equation environment": true
        },
        "options": {}
      },
      {
        "content": "\\\\[\n\t${0:${VISUAL}}\n\\\\]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\ unnumbered equation: \\[ ... \\]": true
        },
        "options": {}
      },
      {
        "content": "\\\\begin{eqnarray}\n\t${0:${VISUAL}}\n\\\\end{eqnarray}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eqnarray eqnarray environment": true
        },
        "options": {}
      },
      {
        "content": "\\\\label{${1:eq:}${2:fig:}${3:tab:}${0}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lab \\label": true
        },
        "options": {}
      },
      {
        "content": "\\\\begin{enumerate}\n\t\\\\item ${0}\n\\\\end{enumerate}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "enum enumerate environment": true
        },
        "options": {}
      },
      {
        "content": "\\\\begin{enumerate}[(a)]\n\t\\\\item ${0}\n\\\\end{enumerate}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "enuma enumerate environment": true
        },
        "options": {}
      },
      {
        "content": "\\\\begin{enumerate}[(i)]\n\t\\\\item ${0}\n\\\\end{enumerate}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "enumi enumerate environment": true
        },
        "options": {}
      },
      {
        "content": "\\\\begin{itemize}\n\t\\\\item ${0}\n\\\\end{itemize}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "item itemize environment": true
        },
        "options": {}
      },
      {
        "content": "\\\\item ${1:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "it \\item": true
        },
        "options": {}
      },
      {
        "content": "\\\\begin{description}\n\t\\\\item[${1}] ${0}\n\\\\end{description}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "desc description environment": true
        },
        "options": {}
      },
      {
        "content": "\\\\item ${1}\n\t${0:]i}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "]i \\item (recursive)": true
        },
        "options": {}
      },
      {
        "content": "\\\\begin{${1:p/b/v/V/B/small}matrix}\n\t${0:${VISUAL}}\n\\\\end{$1matrix}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "mat smart matrix environment": true
        },
        "options": {}
      },
      {
        "content": "\\\\begin{cases}\n\t${1:equation}, &\\\\text{ if }${2:case}\\\\\n\t${0:${VISUAL}}\n\\\\end{cases}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cas cases environment": true
        },
        "options": {}
      },
      {
        "content": "\\\\begin{split}\n\t${0:${VISUAL}}\n\\\\end{split}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "spl split environment": true
        },
        "options": {}
      },
      {
        "content": "\\\\part{${1:part name}} % (fold)%\n\\\\label{prt:${2:$1}}\n${0}\n% part $2 (end)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "part document \\part": true
        },
        "options": {}
      },
      {
        "content": "\\\\chapter{${1:chapter name}}%\n\\\\label{cha:${2:$1}}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cha \\chapter": true
        },
        "options": {}
      },
      {
        "content": "\\\\section{${1:section name}}%\n\\\\label{sec:${2:$1}}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sec \\section": true
        },
        "options": {}
      },
      {
        "content": "\\\\section*{${1:section name}}%\n\\\\label{sec:${2:$1}}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sec* \\section*": true
        },
        "options": {}
      },
      {
        "content": "\\\\subsection{${1:subsection name}}%\n\\\\label{sub:${2:$1}}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sub \\subsection": true
        },
        "options": {}
      },
      {
        "content": "\\\\subsection*{${1:subsection name}}%\n\\\\label{sub:${2:$1}}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sub* \\subsection*": true
        },
        "options": {}
      },
      {
        "content": "\\\\subsubsection{${1:subsubsection name}}%\n\\\\label{ssub:${2:$1}}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ssub \\subsubsection": true
        },
        "options": {}
      },
      {
        "content": "\\\\subsubsection*{${1:subsubsection name}}%\n\\\\label{ssub:${2:$1}}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ssub* \\subsubsection*": true
        },
        "options": {}
      },
      {
        "content": "\\\\paragraph{${1:paragraph name}}%\n\\\\label{par:${2:$1}}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "par \\paragraph": true
        },
        "options": {}
      },
      {
        "content": "\\\\subparagraph{${1:subparagraph name}}%\n\\\\label{subp:${2:$1}}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "subp \\subparagraph": true
        },
        "options": {}
      },
      {
        "content": "\\\\noindent\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ni \\noindent": true
        },
        "options": {}
      },
      {
        "content": "\\\\item[${1:description}] ${0:item}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "itd description \\item": true
        },
        "options": {}
      },
      {
        "content": "${1:Figure}~\\\\ref{${2:fig:}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "figure reference to a figure": true
        },
        "options": {}
      },
      {
        "content": "${1:Table}~\\\\ref{${2:tab:}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "table reference to a table": true
        },
        "options": {}
      },
      {
        "content": "${1:Listing}~\\\\ref{${2:list}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "listing reference to a listing": true
        },
        "options": {}
      },
      {
        "content": "${1:Section}~\\\\ref{sec:${2}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "section reference to a section": true
        },
        "options": {}
      },
      {
        "content": "${1:page}~\\\\pageref{${2}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "page reference to a page": true
        },
        "options": {}
      },
      {
        "content": "\\\\index{${1:index}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "index \\index": true
        },
        "options": {}
      },
      {
        "content": "\\\\citen{${1}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "citen \\citen": true
        },
        "options": {}
      },
      {
        "content": "\\\\citep{${1}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "citep \\citep": true
        },
        "options": {}
      },
      {
        "content": "\\\\citet{${1}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "citet \\citet": true
        },
        "options": {}
      },
      {
        "content": "\\\\cite[${1}]{${2}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cite \\cite[]{}": true
        },
        "options": {}
      },
      {
        "content": "\\\\citeauthor{${1}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "citea \\citeauthor": true
        },
        "options": {}
      },
      {
        "content": "\\\\citeyear{${1}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "citey \\citeyear": true
        },
        "options": {}
      },
      {
        "content": "\\\\footcite[${1}]{${2}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fcite \\footcite[]{}": true
        },
        "options": {}
      },
      {
        "content": "\\\\begin{figure}\n\\\\begin{center}\n\t\\\\includegraphics[scale=${1}]{Figures/${2}}\n\\\\end{center}\n\\\\caption{${3}}\n\\\\label{fig:${4}}\n\\\\end{figure}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fig figure environment (includegraphics)": true
        },
        "options": {}
      },
      {
        "content": "\\\\begin{figure}[htpb]\n\\\\begin{center}\n\\\\begin{tikzpicture}[scale=${1:1}, transform shape]\n\t${2}\n\\\\end{tikzpicture}\n\\\\end{center}\n\\\\caption{${3}}%\n\\\\label{fig:${4}}\n\\\\end{figure}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tikz figure environment (tikzpicture)": true
        },
        "options": {}
      },
      {
        "content": "\\\\begin{subfigure}[${1}]{${2:\\\\textwidth}}\n\\\\begin{center}\n\t${3}\n\\\\end{center}\n\\\\caption{${4}}\n\\\\label{fig:${5}}\n\\\\end{subfigure}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "subfig subfigure environment": true
        },
        "options": {}
      },
      {
        "content": "\\\\begin{equation}\n\\\\begin{tikzcd}\n\t${1}\n\\\\end{tikzcd}\n\\\\end{equation}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tikzcd tikzcd environment in equation": true
        },
        "options": {}
      },
      {
        "content": "\\\\begin{equation*}\n\\\\begin{tikzcd}\n\t${1}\n\\\\end{tikzcd}\n\\\\end{equation*}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tikzcd* tikzcd environment in equation*": true
        },
        "options": {}
      },
      {
        "content": "\\\\stackrel{${1:above}}{${2:below}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "stackrel \\stackrel{}{}": true
        },
        "options": {}
      },
      {
        "content": "\\\\frac{${1:num}}{${2:denom}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "frac \\frac{}{}": true
        },
        "options": {}
      },
      {
        "content": "\\\\sum^{${1:n}}_{${2:i=1}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sum \\sum^{}_{}": true
        },
        "options": {}
      },
      {
        "content": "\\\\lim_{${1:n \\\\to \\\\infty}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lim \\lim_{}": true
        },
        "options": {}
      },
      {
        "content": "\\\\begin{frame}[${1:t}]\n\t\\frametitle{${2:title}}\n\t\\framesubtitle{${3:subtitle}}\n\t${0:${VISUAL}}\n\\\\end{frame}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "frame frame environment": true
        },
        "options": {}
      },
      {
        "content": "\\\\begin{block}{${1:title}}\n\t${0:${VISUAL}}\n\\\\end{block}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "block block environment": true
        },
        "options": {}
      },
      {
        "content": "\\\\begin{alertblock}{${1:title}}\n\t${0:${VISUAL}}\n\\\\end{alertblock}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "alertblock alertblock environment": true
        },
        "options": {}
      },
      {
        "content": "\\\\begin{exampleblock}{${1:title}}\n\t${0:${VISUAL}}\n\\\\end{exampleblock}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "example exampleblock environment": true
        },
        "options": {}
      },
      {
        "content": "\\\\begin{columns}\n\t\\\\begin{column}{0.5\\\\textwidth}\n\t\t${1}\n\t\\\\end{column}\n\t\\\\begin{column}{0.5\\\\textwidth}\n\t\t${0}\n\t\\\\end{column}\n\\\\end{columns}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "col2 two-column environment": true
        },
        "options": {}
      },
      {
        "content": "\\\\begin{multicols}{2}\n\t${1}\n\t\\columnbreak\n\t${0}\n\\\\end{multicols}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "multicol2 two-column environment with multicol": true
        },
        "options": {}
      },
      {
        "content": "\\\\{ ${0} \\\\}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\{ \\{ \\}": true
        },
        "options": {}
      },
      {
        "content": "\\\\left${1} ${0:${VISUAL}} \\\\right$1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lr left right": true
        },
        "options": {}
      },
      {
        "content": "\\\\left( ${0:${VISUAL}} \\\\right)",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lr( left( right)": true
        },
        "options": {}
      },
      {
        "content": "\\\\left| ${0:${VISUAL}} \\\\right|",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lr| left| right|": true
        },
        "options": {}
      },
      {
        "content": "\\\\left\\\\{ ${0:${VISUAL}} \\\\right\\\\}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lr{ left\\{ right\\}": true
        },
        "options": {}
      },
      {
        "content": "\\\\left[ ${0:${VISUAL}} \\\\right]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lr[ left[ right]": true
        },
        "options": {}
      },
      {
        "content": "\\\\langle ${0:${VISUAL}} \\\\rangle",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lra langle rangle": true
        },
        "options": {}
      },
      {
        "content": "\\\\begin{listing}[language=${1:language}]\n\t${0:${VISUAL}}\n\\\\end{listing}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lst": true
        },
        "options": {}
      },
      {
        "content": "\\\\lstinline|${1}| ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lsi": true
        },
        "options": {}
      },
      {
        "content": "\\\\url{${1}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "url": true
        },
        "options": {}
      },
      {
        "content": "\\\\href{${1}}{${2}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "href": true
        },
        "options": {}
      },
      {
        "content": "\\\\frac{d}{dt} {$1} {$0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ddt time derivative": true
        },
        "options": {}
      },
      {
        "content": "\\\\lim_{{$1}} {{$2}} {$0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lim limit": true
        },
        "options": {}
      },
      {
        "content": "\\\\frac{\\\\partial {$1}}{\\partial {$2}} {$0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pdv partial derivation": true
        },
        "options": {}
      },
      {
        "content": "\\\\frac{\\partial^2 {$1}}{\\partial {$2} \\partial {$3}} {$0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ppdv second partial derivation": true
        },
        "options": {}
      },
      {
        "content": "\\\\frac{d {$1}}{d {$2}} {$0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dv derivative": true
        },
        "options": {}
      },
      {
        "content": "\\\\sum_{{$1}} {$0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "summ summation": true
        },
        "options": {}
      },
      {
        "content": "\\\\dot{{$1}} {$0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dot dot": true
        },
        "options": {}
      },
      {
        "content": "\\\\ddot{{$1}} {$0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ddot ddot": true
        },
        "options": {}
      },
      {
        "content": "\\\\vec{{$1}} {$0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vec vector": true
        },
        "options": {}
      },
      {
        "content": "\\\\times {$0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "\\x cross product": true
        },
        "options": {}
      },
      {
        "content": "\\\\cdot {$0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          ". dot product": true
        },
        "options": {}
      },
      {
        "content": "\\\\int_{{$1}}^{{$2}} {$3} \\: d{$4} {$5}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "int integral": true
        },
        "options": {}
      },
      {
        "content": "\\\\rightarrow {$0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ra rightarrow": true
        },
        "options": {}
      },
      {
        "content": "\\\\longrightarrow {$0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lra longrightarrow": true
        },
        "options": {}
      }
    ],
    "texmath": [
      {
        "content": "\\begin{equation*}\n\t${0:${VISUAL}}\n\\end{equation*}",
        "doc": "",
        "grammar": "snu",
        "label": "Equation without a number",
        "matches": {
          "eqnn": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "\\begin{align}\n\t${0:${VISUAL}}\n\\end{align}",
        "doc": "",
        "grammar": "snu",
        "label": "Align",
        "matches": {
          "al": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "\\begin{align*}\n\t${0:${VISUAL}}\n\\end{align*}",
        "doc": "",
        "grammar": "snu",
        "label": "Align without a number",
        "matches": {
          "alnn": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "\\begin{eqnarray}\n\t${1:${VISUAL}} & ${2:${VISUAL}} & ${0:${VISUAL}}\n\\end{eqnarray}",
        "doc": "",
        "grammar": "snu",
        "label": "Equation array",
        "matches": {
          "eqa": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "\\begin{eqnarray*}\n\t${1:${VISUAL}} & ${2:${VISUAL}} & ${0:${VISUAL}}\n\\end{eqnarray*}",
        "doc": "",
        "grammar": "snu",
        "label": "Equation array without a number",
        "matches": {
          "eqann": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "\\dv[${1:${VISUAL}}]{${2}}{${3}}",
        "doc": "",
        "grammar": "snu",
        "label": "Derivative",
        "matches": {
          "dv": true
        },
        "options": {
          "w": true
        }
      },
      {
        "content": "\\pdv[${1:${VISUAL}}]{${2}}{${3}}",
        "doc": "",
        "grammar": "snu",
        "label": "Partial Derivative",
        "matches": {
          "pdv": true
        },
        "options": {
          "w": true
        }
      },
      {
        "content": "\\SI{${1:${VISUAL}}}{${2}}",
        "doc": "",
        "grammar": "snu",
        "label": "SI-Unit",
        "matches": {
          "SI": true
        },
        "options": {
          "w": true
        }
      }
    ],
    "textile": [
      {
        "content": "---\ntitle: ${1:title}\nlayout: post\ndate: ${2:date} ${0:hour:minute:second} -05:00\n---",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "header": true
        },
        "options": {}
      },
      {
        "content": "!${1:url}(${2:title}):${0:link}!",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "img": true
        },
        "options": {}
      },
      {
        "content": "|${1}|",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "|": true
        },
        "options": {}
      },
      {
        "content": "\"${1:link text}\":${0:url}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "link": true
        },
        "options": {}
      },
      {
        "content": "(${1:Expand acronym})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "(": true
        },
        "options": {}
      },
      {
        "content": "[${1:ref number}] ${0}\nfn$1. ${2:footnote}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fn": true
        },
        "options": {}
      }
    ],
    "toml": [],
    "ts-snippets": [
      {
        "content": "import React, { Component } from 'react'\n\ninterface Props {\n\t\n}\ninterface State {\n\t\n}\n\nexport default class ${1:${TM_FILENAME_BASE}} extends Component<Props, State> {\n\tstate = {}\n\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n",
        "doc": "Creates a React component class with ES7 module system and TypeScript interfaces",
        "grammar": "lsp",
        "label": "typeScriptReactClassComponent",
        "matches": {
          "tsrcc": true
        },
        "options": {}
      },
      {
        "content": "import React, { Component } from 'react'\n\ninterface Props {\n\t\n}\ninterface State {\n\t\n}\n\nclass ${1:${TM_FILENAME_BASE}} extends Component<Props, State> {\n\tstate = {}\n\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "Creates a React component class with ES7 module system and TypeScript interfaces",
        "grammar": "lsp",
        "label": "typeScriptReactClassExportComponent",
        "matches": {
          "tsrce": true
        },
        "options": {}
      },
      {
        "content": "import React, { ReactElement } from 'react'\n\ninterface Props {\n\t\n}\n\nfunction ${1:${TM_FILENAME_BASE}}({}: Props): ReactElement {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "Creates a React Functional Component with ES7 module system and TypeScript interface",
        "grammar": "lsp",
        "label": "typeScriptReactFunctionalExportComponent",
        "matches": {
          "tsrfce": true
        },
        "options": {}
      },
      {
        "content": "import React, { ReactElement } from 'react'\n\ninterface Props {\n\t\n}\n\nexport default function ${1:${TM_FILENAME_BASE}}({}: Props): ReactElement {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n",
        "doc": "Creates a React Functional Component with ES7 module system and TypeScript interface",
        "grammar": "lsp",
        "label": "typeScriptReactFunctionalComponent",
        "matches": {
          "tsrfc": true
        },
        "options": {}
      },
      {
        "content": "import React from 'react'\n\ninterface Props {\n\t\n}\n\nconst ${1:${TM_FILENAME_BASE}} = (props: Props) => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "Creates a React Arrow Function Component with ES7 module system and TypeScript interface",
        "grammar": "lsp",
        "label": "typeScriptReactArrowFunctionExportComponent",
        "matches": {
          "tsrafce": true
        },
        "options": {}
      },
      {
        "content": "import React from 'react'\n\ninterface Props {\n\t\n}\n\nexport const ${1:${TM_FILENAME_BASE}} = (props: Props) => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n",
        "doc": "Creates a React Arrow Function Component with ES7 module system and TypeScript interface",
        "grammar": "lsp",
        "label": "typeScriptReactArrowFunctionComponent",
        "matches": {
          "tsrafc": true
        },
        "options": {}
      },
      {
        "content": "import React, { PureComponent } from 'react'\n\ninterface Props {\n\t\n}\n\nexport default class ${1:${TM_FILENAME_BASE}} extends PureComponent<Props> {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n",
        "doc": "Creates a React pure component class with ES7 module system and TypeScript interface",
        "grammar": "lsp",
        "label": "typeScriptReactClassPureComponent",
        "matches": {
          "tsrpc": true
        },
        "options": {}
      },
      {
        "content": "import React, { PureComponent } from 'react'\n\ninterface Props {\n\t\n}\n\nclass ${1:${TM_FILENAME_BASE}} extends PureComponent<Props> {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "Creates a React pure component class with ES7 module system and TypeScript interface",
        "grammar": "lsp",
        "label": "typeScriptReactClassExportPureComponent",
        "matches": {
          "tsrpce": true
        },
        "options": {}
      },
      {
        "content": "import React, { memo } from 'react'\n\ninterface Props {\n\t\n}\n\nexport default memo(function ${1:${TM_FILENAME_BASE}}({}: Props) {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n})\n",
        "doc": "Creates a React Memo Function Component with ES7 module system and TypeScript interface",
        "grammar": "lsp",
        "label": "typeScriptReactFunctionMemoComponent",
        "matches": {
          "tsrmc": true
        },
        "options": {}
      },
      {
        "content": "import React, { Component } from 'react'\nimport { connect } from 'react-redux'\n\ninterface Props {\n\t\n}\ninterface State {\n\t\n}\n\nexport class ${1:${TM_FILENAME_BASE}} extends Component<Props, State> {\n\tstate = {}\n\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n\nconst mapStateToProps = (state) => ({\n\t\n})\n\nconst mapDispatchToProps = {\n\t\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(${1:${TM_FILENAME_BASE}})\n",
        "doc": "Creates a React component class with PropTypes with connected redux and ES7 module system and TypeScript interfaces",
        "grammar": "lsp",
        "label": "typeScriptReactClassCompomentRedux",
        "matches": {
          "tsrcredux": true
        },
        "options": {}
      },
      {
        "content": "import React from 'react'\nimport { View, Text } from 'react-native'\n\ninterface Props {\n\t\n}\n\nconst ${1:${TM_FILENAME_BASE}} = (props: Props) => {\n\treturn (\n\t\t<View>\n\t\t\t<Text>$0</Text>\n\t\t</View>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "Creates a React Native Arrow Function Component with ES7 module system and TypeScript interface",
        "grammar": "lsp",
        "label": "typescriptReactNativeArrowFunctionComponent",
        "matches": {
          "tsrnf": true
        },
        "options": {}
      },
      {
        "content": "import React from 'react'\nimport { View } from 'react-native'\n\ninterface ${1:${TM_FILENAME_BASE}}Props {\n\t\n}\n\nconst ${1:${TM_FILENAME_BASE}}: React.FunctionComponent<${1:${TM_FILENAME_BASE}}Props> = (props) => {\n\treturn (\n\t\t<View>\n\t\t\t$0\n\t\t</View>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "Creates a React Native Arrow Function Component with ES7 module system and named TypeScript interface",
        "grammar": "lsp",
        "label": "typescriptReactNativeArrowFunctionComponentNamedProps",
        "matches": {
          "tsrnfi": true
        },
        "options": {}
      },
      {
        "content": "import React from 'react'\nimport { StyleSheet, Text, View } from 'react-native'\n\ninterface Props {\n\t\n}\n\nconst ${1:${TM_FILENAME_BASE}} = (props: Props) => {\n\treturn (\n\t\t<View>\n\t\t\t<Text>$0</Text>\n\t\t</View>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n\nconst styles = StyleSheet.create({})\n",
        "doc": "Creates a React Native Arrow Function Component with ES7 module system, TypeScript interface and StyleSheet",
        "grammar": "lsp",
        "label": "typescriptReactNativeArrowFunctionComponentWithStyles",
        "matches": {
          "tsrnfs": true
        },
        "options": {}
      },
      {
        "content": "export interface ${1:${TM_FILENAME_BASE}} {$0}",
        "doc": "",
        "grammar": "lsp",
        "label": "Export interface",
        "matches": {
          "expint": true
        },
        "options": {}
      },
      {
        "content": "export type ${1:${TM_FILENAME_BASE}} = {$0}",
        "doc": "",
        "grammar": "lsp",
        "label": "Export type",
        "matches": {
          "exptp": true
        },
        "options": {}
      }
    ],
    "twig": [
      {
        "content": "{% autoescape ${1:#:strategy} %}\n\t${0:TARGET}\n{% autoescape %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% autoescape ... %} ... {% endautoescape %}",
        "matches": {
          "autoescape": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "{% block ${1:#:name} %}\n\t${0:TARGET}\n{% endblock %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% block ... %} ... {% endblock %}",
        "matches": {
          "bl": true,
          "block": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "<pre>\n\t{{ dump(${0:TARGET}) }}\n</pre>",
        "doc": "",
        "grammar": "snu",
        "label": "<pre> {{ dump(...) }} </pre>",
        "matches": {
          "dump": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "{% embed '${1:template}' %}\n\t{% block ${2} %}\n\t\t${0:TARGET}\n\t{% endblock %}\n{% endembed %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% embed ... %} ... {% endembed %}",
        "matches": {
          "embed": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "{% extends '${1:#:template}' %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% extends ... %}",
        "matches": {
          "ext": true,
          "extends": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "{% filter ${1} %}\n\t${0:TARGET}\n{% endfilter %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% filter ... %} ... {% endfilter %}",
        "matches": {
          "filter": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "{% flush %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% flush %}",
        "matches": {
          "flush": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "{% for ${1:#:value} in ${2:#:list} %}\n\t${0:TARGET}\n{% endfor %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% for ... in ... %} ... {% endfor %}",
        "matches": {
          "for": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "{% from '${1:#:module}' import ${2:#:macro} %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% from '...' import ... %}",
        "matches": {
          "from": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "{% if ${1} %}\n\t${0:TARGET}\n{% endif %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% if ... %} ... {% endif %}",
        "matches": {
          "if": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "{% elseif ${1} %}\n\t${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "{% elseif ... %} ...",
        "matches": {
          "elif": true,
          "elseif": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "{% else %}\n\t${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "{% else %} ...",
        "matches": {
          "else": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "{% import '${1:#:module}' as ${2:#:namespace} %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% import '...' as ... %}",
        "matches": {
          "import": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "{% include '${1:#:template}' %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% include '...' %}",
        "matches": {
          "include": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "{% include '${1:#:template}' with {${2:#:'key'}: ${2:#:'value'}} %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% include '...' %}",
        "matches": {
          "includewith": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "{% macro ${1:#:name}(${2:#:args}) %}\n\t${0:TARGET}\n{% endmacro %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% macro ...(...) %} ... {% endmacro %}",
        "matches": {
          "macro": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "{% sandbox %}\n\t${0:TARGET}\n{% endsandbox %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% sandbox %} ... {% endsandbox %}",
        "matches": {
          "sandbox": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "{% set ${1:#:var} = ${2:#:value} %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% set ... = ... %}",
        "matches": {
          "set": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "{% set ${1:#:var} %}\n\t${0:TARGET}\n{% endset %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% set ... %} ... {% endset %}",
        "matches": {
          "setblock": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "{% spaceless %}\n\t${0:TARGET}\n{% endspaceless %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% spaceless %} ... {% endspaceless %}",
        "matches": {
          "spaceless": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "{% use '${1:#:template}' %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% use '...' %}",
        "matches": {
          "use": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "{% verbatim %}\n\t${0:TARGET}\n{% endverbatim %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% verbatim %} ... {% endverbatim %}",
        "matches": {
          "verbatim": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "{# ${1:comment} #}",
        "doc": "",
        "grammar": "snu",
        "label": "{# ... #}",
        "matches": {
          "#": true,
          "comment": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "{% ${1:#:tag} %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% ... %}",
        "matches": {
          "%": true,
          "tag": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "{% ${1:#:tag} ${2:#:name} %}\n\t${0:TARGET}\n{% end$1 %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% ... %} ... {% end... %}",
        "matches": {
          "tagblock": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "{% apply ${1} %}\n\t${0}\n{% endapply %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "apply \"twig apply\"": true
        },
        "options": {}
      },
      {
        "content": "{% autoescape %}\n\t${0}\n{% endautoescape %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "autoescape \"twig autoescape\"": true
        },
        "options": {}
      },
      {
        "content": "{% endautoescape %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "endautoescape \"twig endautoescape\"": true
        },
        "options": {}
      },
      {
        "content": "{% block ${1} %}\n\t${0}\n{% endblock %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bl \"twig block\"": true
        },
        "options": {}
      },
      {
        "content": "{% block ${1} %}\n\t${0}\n{% endblock %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "block \"twig block\"": true
        },
        "options": {}
      },
      {
        "content": "{% endblock %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "endblock \"twig endblock\"": true
        },
        "options": {}
      },
      {
        "content": "{% cache %}\n\t${0}\n{% endcache %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "cache \"twig cache\"": true
        },
        "options": {}
      },
      {
        "content": "{% endcache %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "endcache \"twig endcache\"": true
        },
        "options": {}
      },
      {
        "content": "{% css %}\n\t${0}\n{% endcss %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "css \"twig css\"": true
        },
        "options": {}
      },
      {
        "content": "{% endcss %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "endcss \"twig endcss\"": true
        },
        "options": {}
      },
      {
        "content": "{% dd ${1} %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dd \"twig dd\"": true
        },
        "options": {}
      },
      {
        "content": "{% do ${1} %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "do \"twig do\"": true
        },
        "options": {}
      },
      {
        "content": "{% embed \"${1}\" %}\n\t${0}\n{% endembed %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "embed \"twig embed\"": true
        },
        "options": {}
      },
      {
        "content": "{% endembed %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "endembed \"twig endembed\"": true
        },
        "options": {}
      },
      {
        "content": "{% exit ${1} %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "exit \"twig exit\"": true
        },
        "options": {}
      },
      {
        "content": "{% extends \"${1}\" %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "extends \"twig extends\"": true
        },
        "options": {}
      },
      {
        "content": "{% extends \"${1}\" %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ext \"twig extends\"": true
        },
        "options": {}
      },
      {
        "content": "{% for ${1} in ${2} %}\n\t${0}\n{% endfor %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for \"twig for\"": true
        },
        "options": {}
      },
      {
        "content": "{% for ${1} in ${2} %}\n\t${3}\n{% else %}\n\t${0}\n{% endfor %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fore \"twig for else\"": true
        },
        "options": {}
      },
      {
        "content": "{% endfor %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "endfor \"twig endfor\"": true
        },
        "options": {}
      },
      {
        "content": "{% from \"${1}\" import ${2} %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "from \"twig from\"": true
        },
        "options": {}
      },
      {
        "content": "{% header \"${1}\" %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "header \"twig header\"": true
        },
        "options": {}
      },
      {
        "content": "{% hook \"${1}\" %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "hook \"twig hook\"": true
        },
        "options": {}
      },
      {
        "content": "{% html %}\n\t${0}\n{% endhtml %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "html \"twig html\"": true
        },
        "options": {}
      },
      {
        "content": "{% endhtml %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "endhtml \"twig endhtml\"": true
        },
        "options": {}
      },
      {
        "content": "{% if ${1} %}\n\t${0}\n{% endif %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if \"twig if\"": true
        },
        "options": {}
      },
      {
        "content": "{% if ${1} %}\n\t${2}\n{% else %}\n\t${0}\n{% endif %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife \"twig if else\"": true
        },
        "options": {}
      },
      {
        "content": "{% else %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "el \"twig else\"": true
        },
        "options": {}
      },
      {
        "content": "{% elseif ${1} %}\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eif \"twig elseif\"": true
        },
        "options": {}
      },
      {
        "content": "{% endif %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "endif \"twig endif\"": true
        },
        "options": {}
      },
      {
        "content": "{% import \"${1}\" as ${2} %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "import \"twig import\"": true
        },
        "options": {}
      },
      {
        "content": "{% include \"${1}\" %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "include \"twig include\"": true
        },
        "options": {}
      },
      {
        "content": "{% include \"${1}\" with ${2} %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "includewith \"twig include with parameters\"": true
        },
        "options": {}
      },
      {
        "content": "{% js %}\n\t${0}\n{% endjs %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "js \"twig js\"": true
        },
        "options": {}
      },
      {
        "content": "{% endjs %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "endjs \"twig endjs\"": true
        },
        "options": {}
      },
      {
        "content": "{% macro ${1}(${2}) %}\n\t${0}\n{% endmacro %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "macro \"twig macro\"": true
        },
        "options": {}
      },
      {
        "content": "{% endmacro %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "endmacro \"twig endmacro\"": true
        },
        "options": {}
      },
      {
        "content": "{% namespace \"${1}\" %}\n\t${0}\n{% endnamespace %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "namespace \"twig namespace\"": true
        },
        "options": {}
      },
      {
        "content": "{% endnamespace %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "endnamespace \"twig endnamespace\"": true
        },
        "options": {}
      },
      {
        "content": "{% nav ${1} in ${2} %}\n\t${0}\n{% endnav %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nav \"twig nav\"": true
        },
        "options": {}
      },
      {
        "content": "{% endnav %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "endnav \"twig endnav\"": true
        },
        "options": {}
      },
      {
        "content": "{% paginate ${1} as ${2} %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "paginate \"twig paginate\"": true
        },
        "options": {}
      },
      {
        "content": "{% redirect \"${1}\" %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "redirect \"twig redirect\"": true
        },
        "options": {}
      },
      {
        "content": "{% requireGuest %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "requireguest \"twig requireguest\"": true
        },
        "options": {}
      },
      {
        "content": "{% requireLogin %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "requirelogin \"twig requirelogin\"": true
        },
        "options": {}
      },
      {
        "content": "{% requirePermission \"${1}\" %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "requirepermission \"twig requirepermission\"": true
        },
        "options": {}
      },
      {
        "content": "{% set ${1} = ${2} %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "set \"twig set\"": true
        },
        "options": {}
      },
      {
        "content": "{% set ${1} %}\n\t${0}\n{% endset %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "setb \"twig set block\"": true
        },
        "options": {}
      },
      {
        "content": "{% endset %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "endset \"twig endset\"": true
        },
        "options": {}
      },
      {
        "content": "{% switch ${1} %}\n\t{% case \"${2}\" %}\n\t\t${0}\n\t{% default %}\n{% endswitch %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "switch \"twig switch\"": true
        },
        "options": {}
      },
      {
        "content": "{% case \"${1}\" %}\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case \"twig switch case\"": true
        },
        "options": {}
      },
      {
        "content": "{% default %}\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "default \"twig switch default\"": true
        },
        "options": {}
      },
      {
        "content": "{% endswitch %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "endswitch \"twig endswitch\"": true
        },
        "options": {}
      },
      {
        "content": "{% use \"${1}\" %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "use \"twig use\"": true
        },
        "options": {}
      },
      {
        "content": "{% verbatim %}\n\t${0}\n{% endverbatim %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "verbatim \"twig verbatim\"": true
        },
        "options": {}
      },
      {
        "content": "{% endverbatim %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "endverbatim \"twig endverbatim\"": true
        },
        "options": {}
      },
      {
        "content": "{% with %}\n\t${0}\n{% endwith %}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "with \"twig with\"": true
        },
        "options": {}
      },
      {
        "content": "{% endwith %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "endwith \"twig endwith\"": true
        },
        "options": {}
      },
      {
        "content": "<pre>\n\t{{ dump(${1}) }}\n</pre>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "dump \"twig dump\"": true
        },
        "options": {}
      },
      {
        "content": "{{ \"${1}\"|t }}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "translate \"twig translate\"": true
        },
        "options": {}
      }
    ],
    "typescript": [
      {
        "content": "import { Component, OnInit } from '@angular/core';\n\n@Component({\n\tselector: '${1:selector-name}',\n\ttemplateUrl: '${2:name}.component.html'\n})\n\nexport class ${3:Name}Component implements OnInit {\n\tconstructor() { }\n\n\tngOnInit() { }$0\n}",
        "doc": "Angular component",
        "grammar": "lsp",
        "label": "Angular Component",
        "matches": {
          "a-component": true
        },
        "options": {}
      },
      {
        "content": "import { Component, OnInit } from '@angular/core';\n\n@Component({\n\tselector: '${1:selector-name}',\n\ttemplate: `$0`\n})\n\nexport class ${2:Name}Component implements OnInit {\n\tconstructor() { }\n\n\tngOnInit() { }\n}",
        "doc": "Angular component with an inline template",
        "grammar": "lsp",
        "label": "Angular Component with Inline Template",
        "matches": {
          "a-component-inline": true
        },
        "options": {}
      },
      {
        "content": "import { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n\tname: '${1:selector-name}'\n})\n\nexport class ${2:Name}Pipe implements PipeTransform {\n\ttransform(value: any, ...args: any[]): any {\n\t\t$0\n\t}\n}",
        "doc": "Angular pipe",
        "grammar": "lsp",
        "label": "Angular Pipe",
        "matches": {
          "a-pipe": true
        },
        "options": {}
      },
      {
        "content": "import { Injectable } from '@angular/core';\n\n@Injectable({providedIn: ${1:'root'}})\nexport class ${2:ServiceName}Service {\n\tconstructor() { }\n\t$0\n}",
        "doc": "Angular Service with Injectable ProvidedIn Root",
        "grammar": "lsp",
        "label": "Angular Service",
        "matches": {
          "a-service": true
        },
        "options": {}
      },
      {
        "content": "{ path: '', pathMatch: 'full', redirectTo: '${1:path}' },$0",
        "doc": "Angular default route path",
        "grammar": "lsp",
        "label": "Angular Default Route Path",
        "matches": {
          "a-route-path-default": true
        },
        "options": {}
      },
      {
        "content": "{\n\tpath: '${1:path}', \n\tcomponent: ${2:Component},\n\tchildren: [\n\t\t{ path: '${3:childpath}', component: ${4:ChildComponent} }\n\t]\n},$0",
        "doc": "Angular route path with children",
        "grammar": "lsp",
        "label": "Angular Route Path with Children",
        "matches": {
          "a-route-path-with-children": true
        },
        "options": {}
      },
      {
        "content": "{ path: '**', component: ${1:PathNotFoundComponent} },$0",
        "doc": "Angular 404 route path",
        "grammar": "lsp",
        "label": "Angular 404 Route Path",
        "matches": {
          "a-route-path-404": true
        },
        "options": {}
      },
      {
        "content": "{ path: '${1:path}', component: ${2:Name}Component },$0",
        "doc": "Angular eager route path",
        "grammar": "lsp",
        "label": "Angular Eager Route Path",
        "matches": {
          "a-route-path-eager": true
        },
        "options": {}
      },
      {
        "content": "{\n\tpath: '${1:path}', \n\tloadChildren: () => import('${2:lazy-path}').then(m => m.${3:lazy-module})\n},$0",
        "doc": "Angular lazy route path",
        "grammar": "lsp",
        "label": "Angular Lazy Route Path",
        "matches": {
          "a-route-path-lazy": true
        },
        "options": {}
      },
      {
        "content": "this.route.paramMap\n\t.pipe(map(params => params.get('id')), tap(id => (this.id = +id)))\n\t.subscribe(id => {$1});\n$0",
        "doc": "Angular - subscribe to routing parameters",
        "grammar": "lsp",
        "label": "Routing Params - Subscribe",
        "matches": {
          "a-route-params-subscribe": true
        },
        "options": {}
      },
      {
        "content": "return this.httpClient.get('${1:url}');$0",
        "doc": "Angular HttpClient.get",
        "grammar": "lsp",
        "label": "HttpClient.get",
        "matches": {
          "a-httpclient-get": true
        },
        "options": {}
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\n@Injectable({providedIn: ${1:'root'}})\nexport class ${2:ServiceName}Service {\n\tconstructor(private httpClient: HttpClient) { }\n\t$0\n}",
        "doc": "Angular service with HttpClient",
        "grammar": "lsp",
        "label": "Angular HttpClient Service",
        "matches": {
          "a-service-httpclient": true
        },
        "options": {}
      },
      {
        "content": "import { HttpInterceptor, HttpHandler, HttpRequest, HttpEvent, HttpResponse } from '@angular/common/http';\nimport { Observable } from 'rxjs';\nimport { tap } from 'rxjs/operators';\n\n@Injectable()\nexport class LogInterceptor implements HttpInterceptor {\n\tconstructor() {}\n\n\tintercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n\t\tconst started = Date.now();\n\t\treturn next.handle(req).pipe(\n\t\t\ttap(event => {\n\t\t\t\tif (event instanceof HttpResponse) {\n\t\t\t\t\tconst elapsed = Date.now() - started;\n\t\t\t\t\tconsole.log(`Request for \\${req.urlWithParams} took \\${elapsed} ms.`);\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\t}\n}",
        "doc": "Angular HttpInterceptor for Logging HttpClient",
        "grammar": "lsp",
        "label": "Angular HttpInterceptor for Logging",
        "matches": {
          "a-http-interceptor-logging": true
        },
        "options": {}
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { HttpEvent, HttpInterceptor, HttpHandler, HttpRequest } from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class HeaderInterceptor implements HttpInterceptor {\n\tconstructor() {}\n\n\tintercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n\t\tconst headers = req.headers\n\t\t\t.set('Content-Type', 'application/json');\n\t\tconst authReq = req.clone({ headers });\n\t\treturn next.handle(authReq);\n\t}\n}",
        "doc": "Angular HttpInterceptor for headers HttpClient",
        "grammar": "lsp",
        "label": "Angular HttpInterceptor for Headers",
        "matches": {
          "a-http-interceptor-headers": true
        },
        "options": {}
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { HttpInterceptor, HttpEvent, HttpHandler, HttpRequest } from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class ${2:Your}Interceptor implements HttpInterceptor {\n\tintercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n\t\treturn next.handle(req);\n\t}\n}",
        "doc": "Empty Angular HttpInterceptor for HttpClient",
        "grammar": "lsp",
        "label": "Angular HttpInterceptor - Empty",
        "matches": {
          "a-http-interceptor": true
        },
        "options": {}
      },
      {
        "content": "@Output() ${1:eventName} = new EventEmitter<${2:eventType}>();",
        "doc": "Angular @Output event and emitter",
        "grammar": "lsp",
        "label": "Output Event",
        "matches": {
          "a-output-event": true
        },
        "options": {}
      },
      {
        "content": "this.${1:service}.${2:function}\n\t.subscribe(${3:arg} => this.${4:property} = ${3:arg});\n$0",
        "doc": "Angular observable subscribe",
        "grammar": "lsp",
        "label": "Subscribe",
        "matches": {
          "a-subscribe": true
        },
        "options": {}
      },
      {
        "content": "import { Component } from '@angular/core';\n\n@Component({\n\tselector: '${1:prefix-app}',\n\ttemplate: `\n\t\t<router-outlet></router-outlet>\n\t\t`\n})\nexport class ${2:App}Component { }\n$0",
        "doc": "Angular App root component",
        "grammar": "lsp",
        "label": "Angular Root Component",
        "matches": {
          "a-component-root": true
        },
        "options": {}
      },
      {
        "content": "import { NgModule } from '@angular/core';\nimport { BrowserModule  } from '@angular/platform-browser';\nimport { HttpModule } from '@angular/http';\n\nimport { ${1:App}Component } from './${1:app}.component';\n\n@NgModule({\n\timports: [\n\t\tBrowserModule,\n\t\tHttpModule,\n\t],\n\tdeclarations: [${1:App}Component],\n\tbootstrap: [${1:App}Component],\n})\nexport class ${1:App}Module { }\n$0",
        "doc": "Angular Root Module",
        "grammar": "lsp",
        "label": "Angular Root Module",
        "matches": {
          "a-module-root": true
        },
        "options": {}
      },
      {
        "content": "import { Routes } from '@angular/router';\n\nexport const routes: Routes = [${0}]",
        "doc": "Route definitions",
        "grammar": "lsp",
        "label": "Route definitions",
        "matches": {
          "a-routes": true
        },
        "options": {}
      },
      {
        "content": "import { NgModule } from '@angular/core';\n\nimport { ${1:Name}Component } from './${2:name}.component';\n\n@NgModule({\n\timports: [],\n\texports: [],\n\tdeclarations: [${1:Name}Component],\n\tproviders: [],\n})\nexport class ${1:Name}Module { }\n$0",
        "doc": "Angular Module",
        "grammar": "lsp",
        "label": "Angular Module",
        "matches": {
          "a-module": true
        },
        "options": {}
      },
      {
        "content": "import { Directive } from '@angular/core';\n\n@Directive({ selector: '[${1:selector-name}]' })\nexport class ${2:Name}Directive {\n\tconstructor() { }\n}",
        "doc": "Angular directive",
        "grammar": "lsp",
        "label": "Angular Directive",
        "matches": {
          "a-directive": true
        },
        "options": {}
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { ActivatedRouteSnapshot, CanActivate, RouterStateSnapshot } from '@angular/router';\n\n@Injectable({providedIn: ${1:'root'}})\nexport class ${2:Name}Guard implements CanActivate {\n\tconstructor() { }\n\n\tcanActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {\n\t\treturn true;$0\n\t}\n}",
        "doc": "Angular CanActivate guard",
        "grammar": "lsp",
        "label": "Angular CanActivate Guard",
        "matches": {
          "a-guard-can-activate": true
        },
        "options": {}
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { ActivatedRouteSnapshot, CanActivateChild, RouterStateSnapshot } from '@angular/router';\n\n@Injectable({providedIn: ${1:'root'}})\nexport class ${2:Name}Guard implements CanActivateChild {\n\tconstructor() { }\n\n\tcanActivateChild(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {\n\t\treturn true;$0\n\t}\n}",
        "doc": "Angular CanActivateChild guard",
        "grammar": "lsp",
        "label": "Angular CanActivateChild Guard",
        "matches": {
          "a-guard-can-activate-child": true
        },
        "options": {}
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { CanLoad, Route } from '@angular/router';\n\n@Injectable({providedIn: ${1:'root'}})\nexport class ${2:Name}Guard implements CanLoad {\n\tconstructor() { }\n\n\tcanLoad(route: Route) {\n\t\treturn true;$0\n\t}\n}",
        "doc": "Angular CanLoad guard",
        "grammar": "lsp",
        "label": "Angular CanLoad Guard",
        "matches": {
          "a-guard-can-load": true
        },
        "options": {}
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { ActivatedRouteSnapshot, CanDeactivate, RouterStateSnapshot } from '@angular/router';\nimport { Observable } from 'rxjs';\n\nimport { ${2:ComponentName}Component } from './${3:filename}.component';\n\n// Consider using this interface for all CanDeactivate guards,\n// and have your components implement this interface, too.\n//\n//   e.g. export class CanDeactivateGuard implements CanDeactivate<CanComponentDeactivate> {\n//\n// export interface CanComponentDeactivate {\n// canDeactivate: () => any;\n// }\n\n@Injectable({providedIn: ${4:'root'}})\nexport class ${1:Name}Guard implements CanDeactivate<${2:ComponentName}Component> {\n\tcanDeactivate(\n\t\tcomponent: ${2:ComponentName}Component,\n\t\tcurrentRoute: ActivatedRouteSnapshot, \n\t\tcurrentState: RouterStateSnapshot\n\t): Observable<boolean>|Promise<boolean>|boolean {\n\t\treturn false;$0\n\t}\n}",
        "doc": "Angular CanDeactivate guard",
        "grammar": "lsp",
        "label": "Angular CanDeactivate Guard",
        "matches": {
          "a-guard-can-deactivate": true
        },
        "options": {}
      },
      {
        "content": "import { PreloadingStrategy, Route } from '@angular/router';\nimport { Observable, of } from 'rxjs';\n\nexport class PreloadSelectedModulesList implements PreloadingStrategy {\n\tpreload(route: Route, load: Function): Observable<any> {\n\t\treturn route.data && route.data['${1:preload}'] ? load() : of(null);\n\t}\n}\n$0",
        "doc": "Angular opt-in preload strategy",
        "grammar": "lsp",
        "label": "Angular Opt-In Preload Strategy",
        "matches": {
          "a-preload-opt-in-strategy": true
        },
        "options": {}
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { PreloadingStrategy, Route } from '@angular/router';\nimport { Observable, EMPTY } from 'rxjs';\n\n// avoid typing issues for now\nexport declare var navigator;\n\n@Injectable({ providedIn: 'root' })\nexport class NetworkAwarePreloadStrategy implements PreloadingStrategy {\n\tpreload(route: Route, load: () => Observable<any>): Observable<any> {\n\t\treturn this.hasGoodConnection() ? load() : EMPTY;\n\t}\n\n\thasGoodConnection(): boolean {\n\t\tconst conn = navigator.connection;\n\t\tif (conn) {\n\t\t\tif (conn.saveData) {\n\t\t\t\treturn false; // save data mode is enabled, so dont preload\n\t\t\t}\n\t\t\tconst avoidTheseConnections = ['slow-2g', '2g' /* , '3g', '4g' */];\n\t\t\tconst effectiveType = conn.effectiveType || '';\n\t\t\tif (avoidTheseConnections.includes(effectiveType)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}",
        "doc": "Angular network aware preload strategy",
        "grammar": "lsp",
        "label": "Angular Network-Aware Preload Strategy",
        "matches": {
          "a-preload-network-strategy": true
        },
        "options": {}
      },
      {
        "content": "checkEvents() {\n\tthis.router.events.subscribe(event => {\n\t\tswitch (true) {\n\t\t\tcase event instanceof ${1:eventName}:\n\t\t\t\t$0\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t});\n}",
        "doc": "Angular Router Events",
        "grammar": "lsp",
        "label": "Angular Router Events",
        "matches": {
          "a-router-events": true
        },
        "options": {}
      },
      {
        "content": "constructor( @Optional() @SkipSelf() parentModule: ${1:ModuleName} {\n\tif (parentModule) {\n\t\tconst msg = `${1:ModuleName} has already been loaded. \n\t\t\tImport ${1:ModuleName} once, only, in the root AppModule.`;\n\t\tthrow new Error(msg);\n\t}\n}",
        "doc": "Angular Module SkipSelf constructor",
        "grammar": "lsp",
        "label": "Angular Module SkipSelf Constructor",
        "matches": {
          "a-ctor-skip-self": true
        },
        "options": {}
      },
      {
        "content": "import { ${1:Observable} } from 'rxjs';\n$0",
        "doc": "RxJs import",
        "grammar": "lsp",
        "label": "RxJs Import",
        "matches": {
          "a-rxjs-import": true
        },
        "options": {}
      },
      {
        "content": "import { ${1:map} } from 'rxjs/operators';\n$0",
        "doc": "RxJs import",
        "grammar": "lsp",
        "label": "RxJs Operator Import",
        "matches": {
          "a-rxjs-operator-import": true
        },
        "options": {}
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { Resolve, ActivatedRouteSnapshot } from '@angular/router';\nimport { Observable } from 'rxjs';\n\n@Injectable({ providedIn: ${1:'root'} })\nexport class ${2:YourResolver} implements Resolve<${3:ObjectToResolve}> {\n\tresolve(route: ActivatedRouteSnapshot): Observable<${3:ObjectToResolve}> | Promise<${3:ObjectToResolve}> | ${3:ObjectToResolve} {\n\t\treturn ${0};\n\t}\n}",
        "doc": "Angular Resolver",
        "grammar": "lsp",
        "label": "Angular Resolver",
        "matches": {
          "a-resolver": true
        },
        "options": {}
      },
      {
        "content": "import { NgModule } from '@angular/core';\nimport { EffectsModule } from '@ngrx/effects';\nimport { StoreModule } from '@ngrx/store';\nimport { StoreDevtoolsModule } from '@ngrx/store-devtools';\nimport { environment } from '../../environments/environment';\n\n@NgModule({\n  imports: [\n    StoreModule.forRoot({}),\n    EffectsModule.forRoot([]),\n    environment.production ? [] : StoreDevtoolsModule.instrument()\n  ]\n})\nexport class $1StoreModule {}",
        "doc": "NgRx Store Module",
        "grammar": "lsp",
        "label": "NgRx Store Module",
        "matches": {
          "a-ngrx-store-module": true
        },
        "options": {}
      },
      {
        "content": "export const ${1:action} = createAction('[${2:Source}] ${3:Event}');",
        "doc": "Creates an NgRx Action",
        "grammar": "lsp",
        "label": "NgRx Create Action",
        "matches": {
          "a-ngrx-create-action": true
        },
        "options": {}
      },
      {
        "content": "export const ${1:action} = createAction('[${2:Source}] ${3:Event}', props<{${4:key}: ${5:type}}>());",
        "doc": "Creates an NgRx Action with Props",
        "grammar": "lsp",
        "label": "NgRx Create Action w/ Props",
        "matches": {
          "a-ngrx-create-action-props": true
        },
        "options": {}
      },
      {
        "content": "const ${1:feature}Reducer = createReducer(\n\tinitialState,\n\ton($1Actions.action, state => ({ ...state, ${2:prop}: ${3:updatedValue} })),\n);\n\nexport function reducer(state: State | undefined, action: Action) {\n\treturn $1Reducer(state, action);\n}",
        "doc": "Creates an NgRx Reducer",
        "grammar": "lsp",
        "label": "NgRx Create Reducer",
        "matches": {
          "a-ngrx-create-reducer": true
        },
        "options": {}
      },
      {
        "content": "export const select${1:Feature}${2:Property} = createSelector(\n\tselect$1,\n\t(state: $1State) => state.${3:property}\n);",
        "doc": "Creates an NgRx Selector",
        "grammar": "lsp",
        "label": "NgRx Create Selector",
        "matches": {
          "a-ngrx-create-selector": true
        },
        "options": {}
      },
      {
        "content": "export const select${1:Feature}${2:Property} = createSelector(\n\tselect$1,\n\t(state: $1State, props) => ${3:selectLogic}\n);",
        "doc": "Creates an NgRx Selector using props",
        "grammar": "lsp",
        "label": "NgRx Create Selector w/ Props",
        "matches": {
          "a-ngrx-create-selector-props": true
        },
        "options": {}
      },
      {
        "content": "EntityDataModule.forRoot(${1:entityConfig}),",
        "doc": "Import NgRx Entity Data Module",
        "grammar": "lsp",
        "label": "NgRx Data Import Entity Data Module",
        "matches": {
          "a-ngrx-data-entity-data-module-import": true
        },
        "options": {}
      },
      {
        "content": "import { EntityMetadataMap } from '@ngrx/data';\n\nconst entityMetadata: EntityMetadataMap = {\n  ${1:Model1}: {},${0}\n};\n\nexport const entityConfig = {\n  entityMetadata\n};",
        "doc": "NgRx Data Entity Metadata",
        "grammar": "lsp",
        "label": "NgRx Data Entity Metadata",
        "matches": {
          "a-ngrx-data-entity-metadata": true
        },
        "options": {}
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport {\n  EntityCollectionServiceBase,\n  EntityCollectionServiceElementsFactory\n} from '@ngrx/data';\nimport { ${1:Model} } from '${2:../core}';\n\n@Injectable({ providedIn: ${3:'root'} })\nexport class ${1:Model}Service extends EntityCollectionServiceBase<${1:Model}> {\n  constructor(serviceElementsFactory: EntityCollectionServiceElementsFactory) {\n    super('${1:Model}', serviceElementsFactory);\n  }\n}",
        "doc": "NgRx Data Entity Collection Data Service",
        "grammar": "lsp",
        "label": "NgRx Data Entity Collection Data Service",
        "matches": {
          "a-ngrx-data-entity-collection-data-service": true
        },
        "options": {}
      },
      {
        "content": "${1:trackBy}(index: number, ${2:name}: ${3:model}): ${4:number} {\n  return ${2:name}${5:.id};$0\n}",
        "doc": "TrackBy Function",
        "grammar": "lsp",
        "label": "TrackBy Function",
        "matches": {
          "a-trackby": true
        },
        "options": {}
      },
      {
        "content": "var ${1:#:NAME}: ${2:#:TYPE} = ${0:#:TARGET};",
        "doc": "",
        "grammar": "snu",
        "label": "var NAME: TYPE = expr;",
        "matches": {
          "var-with-type": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "class ${1:#:NAME} {\n  constructor(${2:#:Args}) {\n    ${3:#:TARGET}\n  }\n  ${0:#:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "class NAME {...}",
        "matches": {
          "class": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "${1:#:NAME}(${2:#:Args}): ${3:#:TYPE} {\n  ${0:#:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "method": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "get ${1:#:NAME}(): ${2:#:TYPE} {\n  ${3:#:TARGET}\n}\nset $1(${4:value}: $2) {\n  ${0:#:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "accessor": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "static ${1:#:NAME}(${2:#:Args}) {\n  ${0:#:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "static f(){}",
        "matches": {
          "static": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "interface ${1:#:NAME} {\n  ${0:#:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "interface NAME {...}",
        "matches": {
          "interface": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "enum ${1:#:NAME} {\n  ${0:#:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "enum NAME {...}",
        "matches": {
          "enum": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "module ${1:#:NAME} {\n  ${0:#:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "module NAME {...}",
        "matches": {
          "module": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "namespace ${1:#:NAME} {\n  ${0:#:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "namespace NAME {...}",
        "matches": {
          "namespace": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "/// <reference path=\"${0:#:TARGET}\" />",
        "doc": "",
        "grammar": "snu",
        "label": "/// <reference path=\"...\" />",
        "matches": {
          "reference": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "(${1:#:Args}) => { ${0:#:TARGET} }",
        "doc": "",
        "grammar": "snu",
        "label": "() => {}",
        "matches": {
          "arrow-function": true,
          "function-arrow": true
        },
        "options": {
          "word": true
        }
      },
      {
        "content": "const ${1}: ${2:any} = ${3};\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tconst \"ts const\"": true
        },
        "options": {}
      },
      {
        "content": "let ${1}: ${2:any} = ${3};\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tlet \"ts let\"": true
        },
        "options": {}
      },
      {
        "content": "var ${1}: ${2:any} = ${3};\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tvar \"ts var\"": true
        },
        "options": {}
      },
      {
        "content": "${1}: ${0:any}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "+ \"ts create field\"": true
        },
        "options": {}
      },
      {
        "content": "#${1}: ${0:any}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#+ \"ts create private field using #\"": true
        },
        "options": {}
      },
      {
        "content": "public ${1}: ${0:any}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tpfi \"ts create public field\"": true
        },
        "options": {}
      },
      {
        "content": "private ${1}: ${0:any}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tprfi \"ts create private field\"": true
        },
        "options": {}
      },
      {
        "content": "protected ${1}: ${0:any}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tprofi \"ts create protected field\"": true
        },
        "options": {}
      },
      {
        "content": "interface ${1} {\n\t${2}: ${3:any};\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "int \"interface\"": true
        },
        "options": {}
      },
      {
        "content": "interface ${1} extends ${2} {\n\t${3}: ${4:any};\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "intx \"interface extends\"": true
        },
        "options": {}
      },
      {
        "content": "function ${1}(${2}): ${3:any} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tfun \"ts function\"": true
        },
        "options": {}
      },
      {
        "content": "public ${1}(${2}): ${3:any} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tpmet \"ts public method\"": true
        },
        "options": {}
      },
      {
        "content": "public static ${1}(${2}): ${3:any} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tpsmet \"ts public static method\"": true
        },
        "options": {}
      },
      {
        "content": "private ${1}(${2}): ${3:any} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tprmet \"ts private method\"": true
        },
        "options": {}
      },
      {
        "content": "protected ${1}(${2}): ${3:any} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tpromet \"ts protected method\"": true
        },
        "options": {}
      },
      {
        "content": "class ${1} {\n\t${2}\n\tconstructor(public ${3}: ${4: any}) {\n\t\t${5}\n\t}\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tcla \"ts class\"": true
        },
        "options": {}
      },
      {
        "content": "class ${1} extends ${2} {\n\t${3}\n\tconstructor(public ${4}: ${5: any}) {\n\t\t${6}\n\t}\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tclax \"ts class extends\"": true
        },
        "options": {}
      }
    ],
    "typescriptreact": [],
    "verilog": [
      {
        "content": "always @(${1:*})${2:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "always @()",
        "matches": {
          "al": true
        },
        "options": {}
      },
      {
        "content": "always @(posedge clk${1})${2:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "always @(posedge clk)",
        "matches": {
          "alclk": true
        },
        "options": {}
      },
      {
        "content": "begin\n    ${1:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "begin ... end",
        "matches": {
          "be": true,
          "beginend": true
        },
        "options": {}
      },
      {
        "content": "reg${1:#: nbit} ${2:reg}_r, $2_w;${3:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "reg [] _r, _w;",
        "matches": {
          "rw": true
        },
        "options": {}
      },
      {
        "content": "input${1:#: nbit} i_${2:name},",
        "doc": "",
        "grammar": "snu",
        "label": "input [] i_,",
        "matches": {
          "I": true
        },
        "options": {}
      },
      {
        "content": "output${1:#: nbit} o_${2:name},",
        "doc": "",
        "grammar": "snu",
        "label": "output [] o_,",
        "matches": {
          "O": true
        },
        "options": {}
      },
      {
        "content": "inout${1:#: nbit} io_${2:name},",
        "doc": "",
        "grammar": "snu",
        "label": "inout [] io_,",
        "matches": {
          "IO": true
        },
        "options": {}
      },
      {
        "content": "reg [${1}:${2:0}] ${3:name} [${4:0}:${5}];${6:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "reg [] name []",
        "matches": {
          "regm": true,
          "regmemory": true
        },
        "options": {}
      },
      {
        "content": "${1:reg}_r <= $1_w;${2:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "_r <= _w;",
        "matches": {
          "regseq": true
        },
        "options": {}
      },
      {
        "content": "${1:reg}_w = $1_r;${2:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "_w = _r",
        "matches": {
          "regkeep": true
        },
        "options": {}
      },
      {
        "content": "assign ${1:#:name} = ${2:#:val};${3:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "assign ... = ...",
        "matches": {
          "as": true,
          "assign": true
        },
        "options": {}
      },
      {
        "content": "parameter ${1:#:name} = ${2:#:val};${3:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "parameter ... = ...",
        "matches": {
          "pa": true,
          "parameter": true
        },
        "options": {}
      },
      {
        "content": "localparam ${1:#:name} = ${2:#:val};${3:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "localparam ... = ...",
        "matches": {
          "localparam": true,
          "lpa": true
        },
        "options": {}
      },
      {
        "content": "if (${1:#:condition})${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "if()",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "else${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "else",
        "matches": {
          "el": true,
          "else": true
        },
        "options": {}
      },
      {
        "content": "else if (${1:#:condition})${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "else if ()",
        "matches": {
          "elseif": true
        },
        "options": {}
      },
      {
        "content": "initial begin\n    ${0:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "initial begin ... end",
        "matches": {
          "init": true,
          "initial": true
        },
        "options": {}
      },
      {
        "content": "for (${1:i} = ${2}; $1 < ${3}; ${4:$1 = $1 + 1})${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "for () begin ... end",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "while (${1:#:condition})${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "while () begin ... end",
        "matches": {
          "while": true
        },
        "options": {}
      },
      {
        "content": "case (${1})\n    ${2:'b0}: begin\n        ${3}\n    end\n    default : begin\n        ${4}\n    end\nendcase",
        "doc": "",
        "grammar": "snu",
        "label": "case () ... endcase",
        "matches": {
          "case": true
        },
        "options": {}
      },
      {
        "content": "function${1:# nbit} ${1:func_name};\n    ${2:portlist};\n    begin\n        ${0:TARGET};\n    end\nendfunction",
        "doc": "",
        "grammar": "snu",
        "label": "function ... endfunction",
        "matches": {
          "func": true,
          "function": true
        },
        "options": {}
      },
      {
        "content": "(${1:#:condition}) ? ${2:#:a} : ${3:#:b}",
        "doc": "",
        "grammar": "snu",
        "label": "() ? a : b",
        "matches": {
          "ter": true,
          "ternary": true
        },
        "options": {}
      },
      {
        "content": "$display(\"${1}\", ${2});",
        "doc": "",
        "grammar": "snu",
        "label": "$display(\"...\", ...);",
        "matches": {
          "display": true
        },
        "options": {}
      },
      {
        "content": "$strobe(\"${1}\", ${2});",
        "doc": "",
        "grammar": "snu",
        "label": "$strobe(\"...\", ...);",
        "matches": {
          "strobe": true
        },
        "options": {}
      },
      {
        "content": "if (${1}) begin\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "if (${1}) begin\n\t${2}\nend\nelse begin\n\t${3}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "else if (${1}) begin\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eif": true
        },
        "options": {}
      },
      {
        "content": "else begin\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "el": true
        },
        "options": {}
      },
      {
        "content": "while (${1}) begin\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh": true
        },
        "options": {}
      },
      {
        "content": "repeat (${1}) begin\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "rep": true
        },
        "options": {}
      },
      {
        "content": "case (${1:/* variable */})\n\t${2:/* value */}: begin\n\t\t${3}\n\tend\n\tdefault: begin\n\t\t${4}\n\tend\nendcase",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case": true
        },
        "options": {}
      },
      {
        "content": "casez (${1:/* variable */})\n\t${2:/* value */}: begin\n\t\t${3}\n\tend\n\tdefault: begin\n\t\t${4}\n\tend\nendcase",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "casez": true
        },
        "options": {}
      },
      {
        "content": "always @(${1:/* sensitive list */}) begin\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "al": true
        },
        "options": {}
      },
      {
        "content": "for (int ${2:i} = 0; $2 < ${1:count}; $2${3:++}) begin\n\t${4}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "forever begin\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forev": true
        },
        "options": {}
      },
      {
        "content": "function ${1:void} ${2:name}(${3});\n\t${0}\nendfunction: $2",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fun": true
        },
        "options": {}
      },
      {
        "content": "task ${1:name}(${2});\n\t${0}\nendtask: $1",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "task": true
        },
        "options": {}
      },
      {
        "content": "initial begin\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ini": true
        },
        "options": {}
      },
      {
        "content": "typedef enum ${2:logic[15:0]}\n{\n\t${3:REG = 16'h0000}\n} ${1:my_dest_t};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "tde": true
        },
        "options": {}
      }
    ],
    "vhdl": [
      {
        "content": "library ${1}\nuse $1.${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "lib": true
        },
        "options": {}
      },
      {
        "content": "library IEEE;\nuse IEEE.std_logic_1164.ALL;\nuse IEEE.numeric_std.ALL;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "libs": true
        },
        "options": {}
      },
      {
        "content": "library UNISIM;\nuse UNISIM.VCOMPONENTS.ALL;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "libx": true
        },
        "options": {}
      },
      {
        "content": "signal ${1} : std_logic;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "st": true
        },
        "options": {}
      },
      {
        "content": "signal ${1} : std_logic_vector (${2} downto 0);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "sv": true
        },
        "options": {}
      },
      {
        "content": "${1} : in std_logic;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ist": true
        },
        "options": {}
      },
      {
        "content": "${1} : in std_logic_vector (${2} downto 0);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "isv": true
        },
        "options": {}
      },
      {
        "content": "${1} : out std_logic;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ost": true
        },
        "options": {}
      },
      {
        "content": "${1} : out std_logic_vector (${2} downto 0);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "osv": true
        },
        "options": {}
      },
      {
        "content": "signal ${1} : unsigned (${2} downto 0);",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "un": true
        },
        "options": {}
      },
      {
        "content": "process (${1})\nbegin\n\t${2}\nend process;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pr": true
        },
        "options": {}
      },
      {
        "content": "process (${1:clk})\nbegin\n\tif rising_edge ($1) then\n\t\t${2}\n\tend if;\nend process;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prc": true
        },
        "options": {}
      },
      {
        "content": "process (${1:clk}, ${2:nrst})\nbegin\n\tif ($2 = '${3:0}') then\n\t\t${4}\n\telsif rising_edge($1) then\n\t\t${5}\n\tend if;\nend process;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "prcr": true
        },
        "options": {}
      },
      {
        "content": "process (${1:all})\nbegin\n\t${2}\nend process;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "pra": true
        },
        "options": {}
      },
      {
        "content": "if ${1} then\n\t${2}\nend if;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "if ${1} then\n\t${2}\nelse\n\t${3}\nend if;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "else\n\t${1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "el": true
        },
        "options": {}
      },
      {
        "content": "elsif ${1} then\n\t${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eif": true
        },
        "options": {}
      },
      {
        "content": "case ${1} is\n\t${2}\nend case;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ca": true
        },
        "options": {}
      },
      {
        "content": "when ${1} =>\n\t${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh": true
        },
        "options": {}
      },
      {
        "content": "for ${1:i} in ${2} ${3:to} ${4} loop\n\t${5}\nend loop;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "while ${1} loop\n\t${2}\nend loop;",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh": true
        },
        "options": {}
      },
      {
        "content": "(others => '${1:0}');",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "oth": true
        },
        "options": {}
      }
    ],
    "vim": [
      {
        "content": "if ${1:#:condition}\n  ${0:TARGET}\nendif",
        "doc": "",
        "grammar": "snu",
        "label": "if endif",
        "matches": {
          "if": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "elseif ${1:#:condition}\n    ${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "elseif": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "if ${1:#:condition}\n  ${2:TARGET}\nelse\n  ${3}\nendif",
        "doc": "",
        "grammar": "snu",
        "label": "if else endif",
        "matches": {
          "ifelse": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "for ${1:#:var} in ${2:#:list}\n  ${0:TARGET}\nendfor",
        "doc": "",
        "grammar": "snu",
        "label": "for in endfor",
        "matches": {
          "for": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "while ${1:#:condition}\n  ${0:TARGET}\nendwhile",
        "doc": "",
        "grammar": "snu",
        "label": "while endwhile",
        "matches": {
          "while": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "function! ${1:#:func_name}(${2}) abort\n  ${0:TARGET}\nendfunction",
        "doc": "",
        "grammar": "snu",
        "label": "func endfunc",
        "matches": {
          "func": true,
          "function": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "try\n  ${1:TARGET}\ncatch /${2:#:pattern}/\n  ${3}\nendtry",
        "doc": "",
        "grammar": "snu",
        "label": "try endtry",
        "matches": {
          "try": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "try\n  ${1:TARGET}\nfinally\n  ${2}\nendtry",
        "doc": "",
        "grammar": "snu",
        "label": "try ... finally ... endtry",
        "matches": {
          "tryf": true,
          "tryfinally": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "catch ${1:/${2:#:pattern: empty, E484, Vim(cmdname):{errmsg\\\\}\\}/}",
        "doc": "",
        "grammar": "snu",
        "label": "catch /pattern/",
        "matches": {
          "catch": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "echomsg string(${1:TARGET})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "echomsg": true,
          "log": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "command! ${1:#:command_name} call ${2:#:func_name}",
        "doc": "",
        "grammar": "snu",
        "label": "command call function",
        "matches": {
          "command": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "function! ${1:#:func_name}(arglead, cmdline, cursorpos) abort\n  return filter(${2:#:list}, 'stridx(v:val, a:arglead) == 0')\nendfunction",
        "doc": "",
        "grammar": "snu",
        "label": "customlist complete function",
        "matches": {
          "customlist": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "augroup ${1:#:augroup_name}\n  autocmd!\n  autocmd ${2:#:event}\naugroup END",
        "doc": "",
        "grammar": "snu",
        "label": "augroup with autocmds",
        "matches": {
          "augroup": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "redir => ${1:#:var}\n\t${2::TARGET}\nredir END",
        "doc": "",
        "grammar": "snu",
        "label": "redir => var",
        "matches": {
          "redir": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "let s:hooks = neobundle#get_hooks('${1}')\nfunction! s:hooks.on_source(bundle) abort\n  ${0}\nendfunction\nunlet s:hooks",
        "doc": "",
        "grammar": "snu",
        "label": "neobundle hooks",
        "matches": {
          "bundle_hooks": true
        },
        "options": {}
      },
      {
        "content": "if exists('g:loaded_${1}')\n  finish\nendif\n${0}\nlet g:loaded_$1 = 1",
        "doc": "",
        "grammar": "snu",
        "label": "if exists('g:loaded_{plugin-name}')",
        "matches": {
          "g:loaded": true,
          "loaded": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "\" vim: ${0:foldmethod=marker}",
        "doc": "",
        "grammar": "snu",
        "label": "\" vim: {modeline}",
        "matches": {
          "modeline": true
        },
        "options": {}
      },
      {
        "content": "if !exists('b:undo_ftplugin')\n  let b:undo_ftplugin = ''\nendif\n${1}\nlet b:undo_ftplugin .= '\n\\ | setlocal ${2:#:option_name1< option_name2<...}\n\\'",
        "doc": "",
        "grammar": "snu",
        "label": "if !exists('b:undo_ftplugin')",
        "matches": {
          "b:undo_ftplugin": true,
          "undo_ftplugin": true
        },
        "options": {}
      },
      {
        "content": "python << EOF\n${0}\nEOF",
        "doc": "",
        "grammar": "snu",
        "label": "python <<EOF | EOF",
        "matches": {
          "py": true,
          "python": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "python3 << EOF\n${0}\nEOF",
        "doc": "",
        "grammar": "snu",
        "label": "python3 <<EOF | EOF",
        "matches": {
          "py3": true,
          "python3": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "lua << EOF\n${0}\nEOF",
        "doc": "",
        "grammar": "snu",
        "label": "lua <<EOF | EOF",
        "matches": {
          "lua": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "let pos_save = getpos('.')\ntry\n  ${0}\nfinally\n  call setpos('.', pos_save)\nendtry",
        "doc": "",
        "grammar": "snu",
        "label": "use pos save",
        "matches": {
          "save_pos": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "let save_reg_$1 = getreg('${1}')\nlet save_regtype_$1 = getregtype('$1')\ntry\n  ${0}\nfinally\n  call setreg('$1', save_reg_$1, save_regtype_$1)\nendtry",
        "doc": "",
        "grammar": "snu",
        "label": "use register save",
        "matches": {
          "save_register": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "let $1_save = &${1}\nlet &$1 = ${2}\ntry\n  ${0}\nfinally\n  let &$1 = $1_save\nendtry",
        "doc": "",
        "grammar": "snu",
        "label": "use option save",
        "matches": {
          "save_option": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "echomsg string([${0:TARGET}])",
        "doc": "",
        "grammar": "snu",
        "label": "debug-echomsg",
        "matches": {
          "p": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "v:version > ${1} || (v:version == $1 && has('patch${2}'))",
        "doc": "",
        "grammar": "snu",
        "label": "vim-version-check",
        "matches": {
          "version": true
        },
        "options": {}
      },
      {
        "content": "has('patch-${1}')",
        "doc": "",
        "grammar": "snu",
        "label": "vim-version-check-new",
        "matches": {
          "version_new": true
        },
        "options": {}
      },
      {
        "content": "try\n\t${1:${VISUAL}}\ncatch ${2}\n\t${0}\nendtry",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "t try ... catch statement": true
        },
        "options": {}
      },
      {
        "content": "for ${1} in ${2}\n\t${0:${VISUAL}}\nendfor",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for for ... in loop": true
        },
        "options": {}
      },
      {
        "content": "for [${1},${2}] in items(${3})\n\t${0}\n\tunlet $1 $2\nendfor",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "forkv for [key, value] in loop": true
        },
        "options": {}
      },
      {
        "content": "while ${1}\n\t${0:${VISUAL}}\nendw",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh while loop": true
        },
        "options": {}
      },
      {
        "content": "if ${1}\n\t${0:${VISUAL}}\nendif",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if if statement": true
        },
        "options": {}
      },
      {
        "content": "if ${1}\n\t${2:${VISUAL}}\nelse\n\t${0}\nendif",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife if ... else statement": true
        },
        "options": {}
      },
      {
        "content": "augroup ${1:AU_NAME}\n\tautocmd!\n\tautocmd ${2:BufRead,BufNewFile} ${3:*.ext,*.ext3|<buffer[=N]>} ${0}\naugroup END",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "au augroup ... autocmd block": true
        },
        "options": {}
      },
      {
        "content": "augroup ${1:AU_NAME}\n\tautocmd!\n\t${0:${VISUAL}}\naugroup END",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "auv augroupvisual ... autocmd block with visual placeholder": true
        },
        "options": {}
      },
      {
        "content": "Plugin '${0}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "bun Vundle.vim Plugin definition": true
        },
        "options": {}
      },
      {
        "content": "Plug '${0}'",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "plug vim-plug Plugin definition": true
        },
        "options": {}
      },
      {
        "content": "Plug '${1}', { 'do': '${0}' }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "plugdo vim-plug Plugin definition with { 'do': '' }": true
        },
        "options": {}
      },
      {
        "content": "Plug '${1}', { 'on': '${0}' }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "plugon vim-plug Plugin definition with { 'on': '' }": true
        },
        "options": {}
      },
      {
        "content": "Plug '${1}', { 'for': '${0}' }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "plugfor vim-plug Plugin definition with { 'for': '' }": true
        },
        "options": {}
      },
      {
        "content": "Plug '${1}', { 'branch': '${0}' }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "plugbr vim-plug Plugin definition with { 'branch': '' }": true
        },
        "options": {}
      },
      {
        "content": "Plug '${1}', { 'tag': '${0}' }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "plugtag vim-plug Plugin definition with { 'tag': '' }": true
        },
        "options": {}
      },
      {
        "content": "let ${1:variable} = ${0: value}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "let": true
        },
        "options": {}
      },
      {
        "content": "set ${1:setting};",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "se": true
        },
        "options": {}
      },
      {
        "content": "set ${1:setting} = ${0:value}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "set": true
        },
        "options": {}
      },
      {
        "content": "nnoremap ${1} ${2}<CR>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "nn": true
        },
        "options": {}
      },
      {
        "content": "noremap ${1} ${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "no": true
        },
        "options": {}
      },
      {
        "content": "vmap ${1} ${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vm": true
        },
        "options": {}
      },
      {
        "content": "imap ${1} ${2}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "im": true
        },
        "options": {}
      },
      {
        "content": "execute ${1}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "exe": true
        },
        "options": {}
      },
      {
        "content": "if !exists(\"g:${1:MyUltraImportantVar}\")\n\tlet g:$1 = ${2:\"${3:<tab>}\"}\nendif",
        "doc": "",
        "grammar": "snu",
        "label": "Global / configuration variable",
        "matches": {
          "gvar": true
        },
        "options": {
          "b": true
        }
      },
      {
        "content": "fun ${1:function_name}($2)\n\t${3:\" code}\nendf",
        "doc": "",
        "grammar": "snu",
        "label": "function",
        "matches": {
          "f": true
        },
        "options": {
          "b": true
        }
      }
    ],
    "vimshell": [
      {
        "content": "ls",
        "doc": "",
        "grammar": "snu",
        "label": "=> ls?",
        "matches": {
          "sl": true
        },
        "options": {}
      }
    ],
    "vimspec": [
      {
        "content": "function! s:suite.${1}()\n  ${2:TARGET}\n  call s:assert.equal(${3:expected}, ${4:actual})\nendfunction",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "suite": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "call themis#log(${TARGET})",
        "doc": "",
        "grammar": "snu",
        "label": "p",
        "matches": {
          "themis#log (This is an undocumented function)": true
        },
        "options": {
          "head": true
        }
      }
    ],
    "vimwiki": [
      {
        "content": "*${1}*${2}",
        "doc": "",
        "grammar": "snu",
        "label": "*text*",
        "matches": {
          "bold": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "~~${1}~~${2}",
        "doc": "",
        "grammar": "snu",
        "label": "~~scratch~~",
        "matches": {
          "scratch": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "_${1}_${2}",
        "doc": "",
        "grammar": "snu",
        "label": "_italic_",
        "matches": {
          "italic": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": ",,${1},,${2}",
        "doc": "",
        "grammar": "snu",
        "label": ",,sub,,",
        "matches": {
          "sub": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "^${1}^${2}",
        "doc": "",
        "grammar": "snu",
        "label": "^upper^",
        "matches": {
          "upper": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "{{local:${1:image_path}}}${2}",
        "doc": "",
        "grammar": "snu",
        "label": "{{<image path>}}",
        "matches": {
          "image_local": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "{{http://${1:image_url}}}${2}",
        "doc": "",
        "grammar": "snu",
        "label": "{{<image url>}}",
        "matches": {
          "image": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "|${1:title}|${2:title}|\n|---|---|\n|${3:value}|${4:value}${5:TARGET}|",
        "doc": "",
        "grammar": "snu",
        "label": "table template",
        "matches": {
          "table": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "term:: ${1:definintion}",
        "doc": "",
        "grammar": "snu",
        "label": "definition",
        "matches": {
          "definintion": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": ":${1:tag}:${3}",
        "doc": "",
        "grammar": "snu",
        "label": ":tag1:tag2:",
        "matches": {
          "tag": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "{{{\n${0:TARGET}\n}}}",
        "doc": "",
        "grammar": "snu",
        "label": "{{{<code>}}}",
        "matches": {
          "code": true
        },
        "options": {
          "head": true
        }
      }
    ],
    "vital": [
      {
        "content": "vital#${1:#:plugin_name}#new()",
        "doc": "",
        "grammar": "snu",
        "label": "vital#...#new()",
        "matches": {
          "vital_new_without_let": true
        },
        "options": {}
      },
      {
        "content": "let ${1:s:V} = vital#${2:#:plugin_name}#new()",
        "doc": "",
        "grammar": "snu",
        "label": "let s:V = vital#...#new()",
        "matches": {
          "vital_new": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "${1:s:V}.import('${2:#:module_name}')",
        "doc": "",
        "grammar": "snu",
        "label": "s:V.import('...')",
        "matches": {
          "vital_import_without_let": true
        },
        "options": {}
      },
      {
        "content": "let ${1:s:M} = ${2:s:V}.import('${3:#:module_name}')",
        "doc": "",
        "grammar": "snu",
        "label": "let s:M = s:V.import('...')",
        "matches": {
          "vital_import": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "${1:s:V}.load('${2:#:module_name}')",
        "doc": "",
        "grammar": "snu",
        "label": "s:V.load('...')",
        "matches": {
          "vital_load_without_call": true
        },
        "options": {}
      },
      {
        "content": "call ${1:s:V}.load('${2:#:module_name}')",
        "doc": "",
        "grammar": "snu",
        "label": "call s:V.load('...')",
        "matches": {
          "vital_load": true
        },
        "options": {
          "head": true
        }
      }
    ],
    "vue": [
      {
        "content": "<template>\n\t<${1:div}$2>\n\t\t$0\n\t</${1:div}>\n</template>",
        "doc": "template element",
        "grammar": "lsp",
        "label": "vue-template",
        "matches": {
          "template": true,
          "vue template": true
        },
        "options": {}
      },
      {
        "content": "v-text=\"${1:msg}\"",
        "doc": "Expects: string. Updates the elements textContent.",
        "grammar": "lsp",
        "label": "vue-v-text",
        "matches": {
          "vtext": true,
          "vue v-text": true
        },
        "options": {}
      },
      {
        "content": "v-html=\"${1:html}\"",
        "doc": "Expects: string. Updates the elements innerHTML.",
        "grammar": "lsp",
        "label": "vue-v-html",
        "matches": {
          "vhtml": true,
          "vue v-html": true
        },
        "options": {}
      },
      {
        "content": "v-show=\"${1:condition}\"",
        "doc": "Expects: any",
        "grammar": "lsp",
        "label": "vue-v-show",
        "matches": {
          "vshow": true,
          "vue v-show": true
        },
        "options": {}
      },
      {
        "content": "v-if=\"${1:condition}\"",
        "doc": "Expects: any",
        "grammar": "lsp",
        "label": "vue-v-if",
        "matches": {
          "vif": true,
          "vue v-if": true
        },
        "options": {}
      },
      {
        "content": "v-else",
        "doc": "Does not expect expression. previous sibling element must have v-if or v-else-if.",
        "grammar": "lsp",
        "label": "vue-v-else",
        "matches": {
          "velse": true,
          "vue v-else": true
        },
        "options": {}
      },
      {
        "content": "v-else-if=\"${1:condition}\"",
        "doc": "Expects: any. previous sibling element must have v-if or v-else-if.",
        "grammar": "lsp",
        "label": "vue-v-else-if",
        "matches": {
          "velseif": true,
          "vue v-else-if": true
        },
        "options": {}
      },
      {
        "content": "v-for=\"${1:item} in ${2:items}\"",
        "doc": "Expects: Array | Object | number | string",
        "grammar": "lsp",
        "label": "vue-v-for-without-key",
        "matches": {
          "vforwithoutkey": true,
          "vue v-for-without-key": true
        },
        "options": {}
      },
      {
        "content": "v-for=\"(${1:item}, ${2:index}) in ${3:items}\" :key=\"${4:index}\"",
        "doc": "Expects: Array | Object | number | string",
        "grammar": "lsp",
        "label": "vue-v-for",
        "matches": {
          "vfor": true,
          "vue v-for": true
        },
        "options": {}
      },
      {
        "content": "v-on:${1:event}=\"${2:handle}\"",
        "doc": "Expects: Function | Inline Statement",
        "grammar": "lsp",
        "label": "vue-v-on",
        "matches": {
          "von": true,
          "vue v-on": true
        },
        "options": {}
      },
      {
        "content": "v-bind$1=\"${2}\"",
        "doc": "Expects: any (with argument) | Object (without argument)",
        "grammar": "lsp",
        "label": "vue-v-bind",
        "matches": {
          "vbind": true,
          "vue v-bind": true
        },
        "options": {}
      },
      {
        "content": "v-model=\"${1:something}\"",
        "doc": "Expects: varies based on value of form inputs element or output of components",
        "grammar": "lsp",
        "label": "vue-v-model",
        "matches": {
          "vmodel": true,
          "vue v-model": true
        },
        "options": {}
      },
      {
        "content": "v-pre",
        "doc": "Does not expect expression",
        "grammar": "lsp",
        "label": "vue-v-pre",
        "matches": {
          "vpre": true,
          "vue v-pre": true
        },
        "options": {}
      },
      {
        "content": "v-cloak",
        "doc": "Does not expect expression",
        "grammar": "lsp",
        "label": "vue-v-cloak",
        "matches": {
          "vcloak": true,
          "vue v-cloak": true
        },
        "options": {}
      },
      {
        "content": "v-once",
        "doc": "Does not expect expression",
        "grammar": "lsp",
        "label": "vue-v-once",
        "matches": {
          "vonce": true,
          "vue v-once": true
        },
        "options": {}
      },
      {
        "content": ":key=\"${1:key}\"",
        "doc": "Expects: string. Children of the same common parent must have unique keys. Duplicate keys will cause render errors.",
        "grammar": "lsp",
        "label": "vue-key",
        "matches": {
          "key": true,
          "vue key": true
        },
        "options": {}
      },
      {
        "content": "ref=\"${1:reference}\"$0",
        "doc": "Expects: string. ref is used to register a reference to an element or a child component. The reference will be registered under the parent components $refs object. If used on a plain DOM element, the reference will be that element; if used on a child component, the reference will be component instance.",
        "grammar": "lsp",
        "label": "vue-ref",
        "matches": {
          "ref": true,
          "vue ref": true
        },
        "options": {}
      },
      {
        "content": "slot=\"$1\"$0",
        "doc": "slot=''. Expects: string. Used on content inserted into child components to indicate which named slot the content belongs to.",
        "grammar": "lsp",
        "label": "vue-slota",
        "matches": {
          "slota": true,
          "vue slota": true
        },
        "options": {}
      },
      {
        "content": "<slot$1>$2</slot>$0",
        "doc": "<slot></slot>. Expects: string. Used on content inserted into child components to indicate which named slot the content belongs to.",
        "grammar": "lsp",
        "label": "vue-slote",
        "matches": {
          "slote": true,
          "vue slote": true
        },
        "options": {}
      },
      {
        "content": "slot-scope=\"$1\"$0",
        "doc": "Used to denote an element or component as a scoped slot. The attributes value should be a valid JavaScript expression that can appear in the argument position of a function signature. This means in supported environments you can also use ES2015 destructuring in the expression. Serves as a replacement for scope in 2.5.0+.",
        "grammar": "lsp",
        "label": "vue-slotscope",
        "matches": {
          "slotscope": true,
          "vue slotscope": true
        },
        "options": {}
      },
      {
        "content": "scope=\"${1:this api replaced by slot-scope in 2.5.0+}\"$0",
        "doc": "Used to denote a <template> element as a scoped slot, which is replaced by `slot-scope` in 2.5.0+.",
        "grammar": "lsp",
        "label": "vue-scope",
        "matches": {
          "scope": true,
          "vue scope": true
        },
        "options": {}
      },
      {
        "content": "<component :is=\"${1:componentId}\"></component>$0",
        "doc": "component element",
        "grammar": "lsp",
        "label": "vue-component",
        "matches": {
          "component": true,
          "vue component": true
        },
        "options": {}
      },
      {
        "content": "<keep-alive$1>\n$2\n</keep-alive>$0",
        "doc": "keep-alive element",
        "grammar": "lsp",
        "label": "vue-keep-alive",
        "matches": {
          "keepalive": true,
          "vue keep-alive": true
        },
        "options": {}
      },
      {
        "content": "<transition$1>\n$2\n</transition>$0",
        "doc": "transition element",
        "grammar": "lsp",
        "label": "vue-transition",
        "matches": {
          "transition": true,
          "vue transition": true
        },
        "options": {}
      },
      {
        "content": "<transition-group$1>\n$2\n</transition-group>",
        "doc": "transition-group element",
        "grammar": "lsp",
        "label": "vue-transition-group",
        "matches": {
          "transitiongroup": true,
          "vue transition-group": true
        },
        "options": {}
      },
      {
        "content": "enter-class=\"$1\"$0",
        "doc": "enter-class=''. Expects: string.",
        "grammar": "lsp",
        "label": "vue-enter-class",
        "matches": {
          "enterclass": true,
          "vue enter-class": true
        },
        "options": {}
      },
      {
        "content": "leave-class=\"$1\"$0",
        "doc": "leave-class=''. Expects: string.",
        "grammar": "lsp",
        "label": "vue-leave-class",
        "matches": {
          "leaveclass": true,
          "vue leave-class": true
        },
        "options": {}
      },
      {
        "content": "appear-class=\"$1\"$0",
        "doc": "appear-class=''. Expects: string.",
        "grammar": "lsp",
        "label": "vue-appear-class",
        "matches": {
          "appearclass": true,
          "vue appear-class": true
        },
        "options": {}
      },
      {
        "content": "enter-to-class=\"$1\"$0",
        "doc": "enter-to-class=''. Expects: string.",
        "grammar": "lsp",
        "label": "vue-enter-to-class",
        "matches": {
          "entertoclass": true,
          "vue enter-to-class": true
        },
        "options": {}
      },
      {
        "content": "leave-to-class=\"$1\"$0",
        "doc": "leave-to-class=''. Expects: string.",
        "grammar": "lsp",
        "label": "vue-leave-to-class",
        "matches": {
          "leavetoclass": true,
          "vue leave-to-class": true
        },
        "options": {}
      },
      {
        "content": "appear-to-class=\"$1\"$0",
        "doc": "appear-to-class=''. Expects: string.",
        "grammar": "lsp",
        "label": "vue-appear-to-class",
        "matches": {
          "appeartoclass": true,
          "vue appear-to-class": true
        },
        "options": {}
      },
      {
        "content": "enter-active-class=\"$1\"$0",
        "doc": "enter-active-class=''. Expects: string.",
        "grammar": "lsp",
        "label": "vue-enter-active-class",
        "matches": {
          "enteractiveclass": true,
          "vue enter-active-class": true
        },
        "options": {}
      },
      {
        "content": "leave-active-class=\"$1\"$0",
        "doc": "leave-active-class=''. Expects: string.",
        "grammar": "lsp",
        "label": "vue-leave-active-class",
        "matches": {
          "leaveactiveclass": true,
          "vue leave-active-class": true
        },
        "options": {}
      },
      {
        "content": "appear-active-class=\"$1\"$0",
        "doc": "appear-active-class=''. Expects: string.",
        "grammar": "lsp",
        "label": "vue-appear-active-class",
        "matches": {
          "appearactiveclass": true,
          "vue appear-active-class": true
        },
        "options": {}
      },
      {
        "content": "@before-enter=\"$1\"$0",
        "doc": "@before-enter=''",
        "grammar": "lsp",
        "label": "vue-before-enter",
        "matches": {
          "beforeenterevent": true,
          "vue before-enter": true
        },
        "options": {}
      },
      {
        "content": "@before-leave=\"$1\"$0",
        "doc": "@before-leave=''",
        "grammar": "lsp",
        "label": "vue-before-leave",
        "matches": {
          "beforeleaveevent": true,
          "vue before-leave": true
        },
        "options": {}
      },
      {
        "content": "@before-appear=\"$1\"$0",
        "doc": "@before-appear=''",
        "grammar": "lsp",
        "label": "vue-before-appear",
        "matches": {
          "beforeappearevent": true,
          "vue before-appear": true
        },
        "options": {}
      },
      {
        "content": "@enter=\"$1\"$0",
        "doc": "@enter=''",
        "grammar": "lsp",
        "label": "vue-enter",
        "matches": {
          "enterevent": true,
          "vue enter": true
        },
        "options": {}
      },
      {
        "content": "@leave=\"$1\"$0",
        "doc": "@leave=''",
        "grammar": "lsp",
        "label": "vue-leave",
        "matches": {
          "leaveevent": true,
          "vue leave": true
        },
        "options": {}
      },
      {
        "content": "@appear=\"$1\"$0",
        "doc": "@appear=''",
        "grammar": "lsp",
        "label": "vue-appear",
        "matches": {
          "appearevent": true,
          "vue appear": true
        },
        "options": {}
      },
      {
        "content": "@after-enter=\"$1\"$0",
        "doc": "@after-enter=''",
        "grammar": "lsp",
        "label": "vue-after-enter",
        "matches": {
          "afterenterevent": true,
          "vue after-enter": true
        },
        "options": {}
      },
      {
        "content": "@after-leave=\"$1\"$0",
        "doc": "@after-leave=''",
        "grammar": "lsp",
        "label": "vue-after-leave",
        "matches": {
          "afterleaveevent": true,
          "vue after-leave": true
        },
        "options": {}
      },
      {
        "content": "@after-appear=\"$1\"$0",
        "doc": "@after-appear=''",
        "grammar": "lsp",
        "label": "vue-after-appear",
        "matches": {
          "afterappearevent": true,
          "vue after-appear": true
        },
        "options": {}
      },
      {
        "content": "@enter-cancelled=\"$1\"$0",
        "doc": "@enter-cancelled=''",
        "grammar": "lsp",
        "label": "vue-enter-cancelled",
        "matches": {
          "entercancelledevent": true,
          "vue enter-cancelled": true
        },
        "options": {}
      },
      {
        "content": "@leave-cancelled=\"$1\"$0",
        "doc": "@leave-cancelled='' (v-show only)",
        "grammar": "lsp",
        "label": "vue-leave-cancelled",
        "matches": {
          "leavecancelledevent": true,
          "vue leave-cancelled": true
        },
        "options": {}
      },
      {
        "content": "@appear-cancelled=\"$1\"$0",
        "doc": "@appear-cancelled=''",
        "grammar": "lsp",
        "label": "vue-appear-cancelled",
        "matches": {
          "appearcancelledevent": true,
          "vue appear-cancelled": true
        },
        "options": {}
      },
      {
        "content": "<router-link $1>$2</router-link>$0",
        "doc": "router-link element",
        "grammar": "lsp",
        "label": "vue-routerlink",
        "matches": {
          "routerlink": true,
          "vue routerlink": true
        },
        "options": {}
      },
      {
        "content": "<router-link to=\"$1\">$2</router-link>$0",
        "doc": "<router-link to=''></router-link>. router-link element",
        "grammar": "lsp",
        "label": "vue-routerlinkto",
        "matches": {
          "routerlinkto": true,
          "vue routerlinkto": true
        },
        "options": {}
      },
      {
        "content": "to=\"$1\"$0",
        "doc": "to=''",
        "grammar": "lsp",
        "label": "vue-to",
        "matches": {
          "to": true,
          "vue to": true
        },
        "options": {}
      },
      {
        "content": "tag=\"$1\"$0",
        "doc": "tag=''",
        "grammar": "lsp",
        "label": "vue-tag",
        "matches": {
          "tag": true,
          "vue tag": true
        },
        "options": {}
      },
      {
        "content": "<router-view>$1</router-view>$0",
        "doc": "router-view element",
        "grammar": "lsp",
        "label": "vue-routerview",
        "matches": {
          "routerview": true,
          "vue routerview": true
        },
        "options": {}
      },
      {
        "content": "data() {\n\treturn {\n\t\t${1:key}: ${2:value}\n\t}\n},",
        "doc": "Vue Component Data",
        "grammar": "lsp",
        "label": "vue-data",
        "matches": {
          "vdata": true,
          "vue data": true
        },
        "options": {}
      },
      {
        "content": "methods: {\n\t${1:name}() {\n\t\t${0}\n\t}\n},",
        "doc": "vue method",
        "grammar": "lsp",
        "label": "vue-methods",
        "matches": {
          "vmethod": true,
          "vue methods": true
        },
        "options": {}
      },
      {
        "content": "computed: {\n\t${1:name}() {\n\t\treturn this.${2:data} ${0}\n\t}\n},",
        "doc": "computed value",
        "grammar": "lsp",
        "label": "vue-computed",
        "matches": {
          "vcomputed": true,
          "vue computed": true
        },
        "options": {}
      },
      {
        "content": "beforeCreate () {\n\t${0};\n},",
        "doc": "beforeCreate lifecycle method",
        "grammar": "lsp",
        "label": "vue-lifecycle-beforecreate",
        "matches": {
          "vbeforecreate": true,
          "vue lifecycle beforecreate": true
        },
        "options": {}
      },
      {
        "content": "created () {\n\t${0};\n},",
        "doc": "created lifecycle method",
        "grammar": "lsp",
        "label": "vue-lifecycle-created",
        "matches": {
          "vcreated": true,
          "vue lifecycle created": true
        },
        "options": {}
      },
      {
        "content": "beforeMount () {\n\t${0};\n},",
        "doc": "beforeMount lifecycle method",
        "grammar": "lsp",
        "label": "vue-lifecycle-beforemount",
        "matches": {
          "vbeforemount": true,
          "vue lifecycle beforemount": true
        },
        "options": {}
      },
      {
        "content": "mounted () {\n\t${0};\n},",
        "doc": "mounted lifecycle method",
        "grammar": "lsp",
        "label": "vue-lifecycle-mounted",
        "matches": {
          "vmounted": true,
          "vue lifecycle mounted": true
        },
        "options": {}
      },
      {
        "content": "beforeUpdate () {\n\t${0};\n},",
        "doc": "beforeUpdate lifecycle method",
        "grammar": "lsp",
        "label": "vue-lifecycle-beforeupdate",
        "matches": {
          "vbeforeupdate": true,
          "vue lifecycle beforeupdate": true
        },
        "options": {}
      },
      {
        "content": "updated () {\n\t${0};\n},",
        "doc": "updated lifecycle method",
        "grammar": "lsp",
        "label": "vue-lifecycle-updated",
        "matches": {
          "vue lifecycle updated": true,
          "vupdated": true
        },
        "options": {}
      },
      {
        "content": "beforeDestroy () {\n\t${0};\n},",
        "doc": "beforeDestroy lifecycle method",
        "grammar": "lsp",
        "label": "vue-lifecycle-beforedestroy",
        "matches": {
          "vbeforedestroy": true,
          "vue lifecycle beforedestroy": true
        },
        "options": {}
      },
      {
        "content": "destroyed () {\n\t${0};\n},",
        "doc": "destroyed lifecycle method",
        "grammar": "lsp",
        "label": "vue-lifecycle-destroyed",
        "matches": {
          "vdestroyed": true,
          "vue lifecycle destroyed": true
        },
        "options": {}
      },
      {
        "content": "watch: {\n\t${1:data}(${2:newValue}, ${3:oldValue}) {\n\t\t${0}\n\t}\n},",
        "doc": "vue watcher",
        "grammar": "lsp",
        "label": "vue-watchers",
        "matches": {
          "vue watchers": true,
          "vwatcher": true
        },
        "options": {}
      },
      {
        "content": "watch: {\n\t${1:data}: {\n\t\timmediate: ${2:true},\n\t\tdeep: ${3:true},\n\t\thandler(${4:newValue}, ${5:oldValue}) {\n\t\t\t${0}\n\t\t}\n\t}\n},",
        "doc": "vue watcher with options",
        "grammar": "lsp",
        "label": "vue-watchers-with-options",
        "matches": {
          "vue watchers with options": true,
          "vwatcher-options": true
        },
        "options": {}
      },
      {
        "content": "props: {\n\t${1:propName}: {\n\t\ttype: ${2:Number},\n\t\tdefault: ${0}\n\t},\n},",
        "doc": "Vue Props with Default",
        "grammar": "lsp",
        "label": "vue-props-with-default",
        "matches": {
          "vprops": true,
          "vue props with default": true
        },
        "options": {}
      },
      {
        "content": "import ${1:New} from '@/components/${1:New}.vue';",
        "doc": "Import one component into another",
        "grammar": "lsp",
        "label": "vue-import-file",
        "matches": {
          "vimport": true,
          "vue import file": true
        },
        "options": {}
      },
      {
        "content": "components: {\n\t${1:New},\n},",
        "doc": "Import one component into another, within export statement",
        "grammar": "lsp",
        "label": "vue-import-into-the-component",
        "matches": {
          "vcomponents": true,
          "vue import into the component": true
        },
        "options": {}
      },
      {
        "content": "import ${1:Name} from '@/components/${1:Name}.vue'\n\nexport default {\n\tcomponents: {\n\t\t${1:Name}\n\t},\n}",
        "doc": "import a component and include it in export default",
        "grammar": "lsp",
        "label": "vue-import-export",
        "matches": {
          "vimport-export": true,
          "vue import export": true
        },
        "options": {}
      },
      {
        "content": "import { mapState } from 'vuex'\n\nexport default {\n\tcomputed: {\n\t\t...mapState([\n\t\t\t${1:'nameOfState'},\n\t\t])\n\t},\n}",
        "doc": "map getters inside a vue component",
        "grammar": "lsp",
        "label": "vue-mapstate",
        "matches": {
          "vmapstate": true,
          "vue mapstate": true
        },
        "options": {}
      },
      {
        "content": "import { mapGetters } from 'vuex'\n\nexport default {\n\tcomputed: {\n\t\t...mapGetters([\n\t\t\t${1:'nameOfGetter'},\n\t\t])\n\t},\n}",
        "doc": "mapgetters inside a vue component",
        "grammar": "lsp",
        "label": "vue-mapgetters",
        "matches": {
          "vmapgetters": true,
          "vue mapgetters": true
        },
        "options": {}
      },
      {
        "content": "import { mapMutations } from 'vuex'\n\nexport default {\n\tmethods: {\n\t\t...mapMutations([\n\t\t\t${1:'nameOfMutation'}, //also supports payload `this.nameOfMutation(amount)` \n\t\t])\n\t},\n}",
        "doc": "mapmutations inside a vue component",
        "grammar": "lsp",
        "label": "vue-mapmutations",
        "matches": {
          "vmapmutations": true,
          "vue mapmutations": true
        },
        "options": {}
      },
      {
        "content": "import { mapActions } from 'vuex'\n\nexport default {\n\tmethods: {\n\t\t...mapActions([\n\t\t\t${1:'nameOfAction'}, //also supports payload `this.nameOfAction(amount)` \n\t\t])\n\t},\n}",
        "doc": "mapactions inside a vue component",
        "grammar": "lsp",
        "label": "vue-mapactions",
        "matches": {
          "vmapactions": true,
          "vue mapactions": true
        },
        "options": {}
      },
      {
        "content": "filters: {\n\t${1:fnName}: function(${2:value}) {\n\t\treturn ${2:value}${0};\n\t}\n}",
        "doc": "vue filter",
        "grammar": "lsp",
        "label": "vue-filter",
        "matches": {
          "vfilter": true,
          "vue filter": true
        },
        "options": {}
      },
      {
        "content": "const ${1:mixinName} = {\n\tmounted() {\n\t\tconsole.log('hello from mixin!')\n\t},\n}",
        "doc": "vue mixin",
        "grammar": "lsp",
        "label": "vue-mixin",
        "matches": {
          "vmixin": true,
          "vue mixin": true
        },
        "options": {}
      },
      {
        "content": "mixins: [${1:mixinName}],",
        "doc": "vue use mixin",
        "grammar": "lsp",
        "label": "vue-use-mixin",
        "matches": {
          "vmixin-use": true,
          "vue use mixin": true
        },
        "options": {}
      },
      {
        "content": "Vue.directive('${1:directiveName}', {\n\tbind(el, binding, vnode) {\n\t\tel.style.${2:arg} = binding.value.${2:arg};\n\t}\n});",
        "doc": "vue custom directive",
        "grammar": "lsp",
        "label": "vue-custom-directive",
        "matches": {
          "vc-direct": true,
          "vue custom directive": true
        },
        "options": {}
      },
      {
        "content": "import { ${1:libName} } from '${1:libName}'",
        "doc": "import a library",
        "grammar": "lsp",
        "label": "vue-import-library",
        "matches": {
          "vimport-lib": true,
          "vue import library": true
        },
        "options": {}
      },
      {
        "content": "import { TimelineMax, ${1:Ease} } from 'gsap'",
        "doc": "component methods options that dispatch an action from vuex store.",
        "grammar": "lsp",
        "label": "vue-import-gsap",
        "matches": {
          "vimport-gsap": true,
          "vue import gsap": true
        },
        "options": {}
      },
      {
        "content": "beforeEnter(el) {\n\tconsole.log('beforeEnter');\n},\nenter(el, done) {\n\tconsole.log('enter');\n\tdone();\n},\nbeforeLeave(el) {\n\tconsole.log('beforeLeave');\n},\nleave(el, done) {\n\tconsole.log('leave');\n\tdone();\n},",
        "doc": "transition component js hooks",
        "grammar": "lsp",
        "label": "vue-transition-methods-with-javascript-hooks",
        "matches": {
          "vanimhook-js": true,
          "vue transition methods with javascript hooks": true
        },
        "options": {}
      },
      {
        "content": "${1:mutationName}() {\n\tthis.\\$store.commit('${1:mutationName}', ${2:payload})\n}",
        "doc": "commit to vuex store in methods for mutation",
        "grammar": "lsp",
        "label": "vue-commit-vuex-store-in-methods",
        "matches": {
          "vcommit": true,
          "vue commit vuex store in methods": true
        },
        "options": {}
      },
      {
        "content": "${1:actionName}() {\n\tthis.\\$store.dispatch('${1:actionName}', ${2:payload})\n}",
        "doc": "dispatch to vuex store in methods for action",
        "grammar": "lsp",
        "label": "vue-dispatch-vuex-store-in-methods",
        "matches": {
          "vdispatch": true,
          "vue dispatch vuex store in methods": true
        },
        "options": {}
      },
      {
        "content": "return ${1:this.num} += ${2:1}",
        "doc": "increment",
        "grammar": "lsp",
        "label": "vue-incrementer",
        "matches": {
          "vinc": true,
          "vue incrementer": true
        },
        "options": {}
      },
      {
        "content": "return ${1:this.num} -= ${2:1}",
        "doc": "decrement",
        "grammar": "lsp",
        "label": "vue-decrementer",
        "matches": {
          "vdec": true,
          "vue decrementer": true
        },
        "options": {}
      },
      {
        "content": "import Vue from 'vue'\nimport ${1:HelloWorld} from './components/${1:HelloWorld}'\n\ndescribe('${1:HelloWorld}.vue', () => {\n\tit('${2:should render correct contents}', () => {\n\t\tconst Constructor = Vue.extend(${1:HelloWorld})\n\t\tconst vm = new Constructor().$mount()\n\t\texpect(vm.$el.querySelector('.hello h1').textContent)\n\t\t\t.to.equal(${3:'Welcome to Your Vue.js App'})\n\t})\n})",
        "doc": "unit test component",
        "grammar": "lsp",
        "label": "vue-unit-test",
        "matches": {
          "vtest": true,
          "vue unit test": true
        },
        "options": {}
      },
      {
        "content": "module.exports = {\n\tcss: {\n\t\tloaderOptions: {\n\t\t\t${1:sass}: {\n\t\t\t\tdata: `${2:@import '@/styles/_variables.scss';}`\n\t\t\t}\n\t\t}\n\t}\n}",
        "doc": "vue.config.js",
        "grammar": "lsp",
        "label": "vue-vue-config-js-import",
        "matches": {
          "vconfig": true,
          "vue vue.config.js import": true
        },
        "options": {}
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script>\n\texport default {\n\t\t${0}\n\t}\n</script>\n\n<style lang=\"scss\" scoped>\n\n</style>",
        "doc": "Base for Vue File with SCSS",
        "grammar": "lsp",
        "label": "vue-single-file-component",
        "matches": {
          "vue base": true
        },
        "options": {}
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script>\n\texport default {\n\t\t${0}\n\t}\n</script>\n\n<style lang=\"postcss\" scoped>\n\n</style>",
        "doc": "Base for Vue File with PostCSS",
        "grammar": "lsp",
        "label": "vue-single-file-component-with-postcss",
        "matches": {
          "vue base postcss": true
        },
        "options": {}
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script>\n\texport default {\n\t\t${0}\n\t}\n</script>\n\n<style scoped>\n\n</style>",
        "doc": "Base for Vue File with CSS",
        "grammar": "lsp",
        "label": "vue-single-file-component-with-css",
        "matches": {
          "vue base css": true
        },
        "options": {}
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script lang=\"ts\">\n\timport Vue from 'vue'\n\n\texport default Vue.extend({\n\t\t${0}\n\t})\n</script>\n\n<style scoped>\n\n</style>",
        "doc": "Base for Vue File with Typescript",
        "grammar": "lsp",
        "label": "vue-single-file-component-with-typescript",
        "matches": {
          "vue base ts": true
        },
        "options": {}
      },
      {
        "content": "const ${1:name} = reactive({\n\t${2:count}: ${3:0}\n})",
        "doc": "Set reactive property - Vue Composition API",
        "grammar": "lsp",
        "label": "vue-v3reactive",
        "matches": {
          "vue v3 reactive": true
        },
        "options": {}
      },
      {
        "content": "const ${1:name} = computed(() => {\n\treturn ${2}\n})",
        "doc": "Set computed property - Vue Composition API",
        "grammar": "lsp",
        "label": "vue-v3computed",
        "matches": {
          "vue v3 computed": true
        },
        "options": {}
      },
      {
        "content": "watch(() => ${1:foo}, (newValue, oldValue) => {\n\t${2}\n})",
        "doc": "Requires watching a specific data source, and applies side effects in a separate callback function.",
        "grammar": "lsp",
        "label": "vue-v3watch",
        "matches": {
          "vue v3 watch": true
        },
        "options": {}
      },
      {
        "content": "watch([${1:foo}, ${2:bar}], ([new${1}, new${2}], [prev${1}, prev${2}]) => {\n\t${3}\n})",
        "doc": "Requires watching an array, and applies side effects in a separate callback function.",
        "grammar": "lsp",
        "label": "vue-v3watch-array",
        "matches": {
          "vue v3 watch-array": true
        },
        "options": {}
      },
      {
        "content": "watchEffect(() => {\n\t${1}\n})",
        "doc": "Run a function immediately while reactively tracking its dependencies, and re-run it whenever the dependencies have changed.",
        "grammar": "lsp",
        "label": "vue-v3watcheffect",
        "matches": {
          "vue v3 watcheffect": true
        },
        "options": {}
      },
      {
        "content": "const ${1:name} = ref(${2:initialValue})",
        "doc": "Takes an inner value and returns a reactive and mutable ref object.",
        "grammar": "lsp",
        "label": "vue-v3ref",
        "matches": {
          "vue v3ref": true
        },
        "options": {}
      },
      {
        "content": "import ${1|onBeforeMount,onMounted,onBeforeUpdate,onUpdated,onBeforeUnmount,onUnmounted,,onActivated,onDeactivated,onErrorCaptured,onRenderTracked,onRenderTriggered|} from '${2|vue,@vue/composition-api|}'",
        "doc": "Import Lifecycle hooks to use in file",
        "grammar": "lsp",
        "label": "vue-v3lifecyclehook-import",
        "matches": {
          "vue v3 importlifecyclehook ": true
        },
        "options": {}
      },
      {
        "content": "${1|onBeforeMount,onMounted,onBeforeUpdate,onUpdated,onBeforeUnmount,onUnmounted,,onActivated,onDeactivated,onErrorCaptured,onRenderTracked,onRenderTriggered|}(() => {${2}})",
        "doc": "Lifecycle hooks can be registered with directly imported `onXXX` functions:",
        "grammar": "lsp",
        "label": "vue-v3lifecyclehook",
        "matches": {
          "vue v3 lifecyclehook": true
        },
        "options": {}
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script>\nimport { ${0|ref,reactive,computed,readonly,watchEffect,watch|} } from '${1|vue,@vue/composition-api|}'\nexport default {\n\tsetup () {\n\t\t${2}\n\n\t\treturn {}\n\t}\n}\n</script>\n\n<style lang=\"scss\" scoped>\n\n</style>",
        "doc": "Base for Vue File Composition API with SCSS",
        "grammar": "lsp",
        "label": "vue-single-file-component-v3",
        "matches": {
          "vue v3 base": true
        },
        "options": {}
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script lang=\"ts\">\nimport Vue from 'vue'\n\nexport default Vue.extend({\n\tsetup () {\n\t\t${0}\n\n\t\treturn {}\n\t}\n})\n</script>\n\n<style scoped>\n\n</style>",
        "doc": "Base for Vue File Composition API - Typescript",
        "grammar": "lsp",
        "label": "vue-single-file-component-with-typescript-v3",
        "matches": {
          "vue v3 base ts": true
        },
        "options": {}
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script>\n\texport default {\n\t\t${0}\n\t}\n</script>\n\n<style lang=\"scss\" scoped>\n\n</style>",
        "doc": "Base for Vue File with SCSS",
        "grammar": "lsp",
        "label": "Vue Single File Component",
        "matches": {
          "vbase": true
        },
        "options": {}
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script>\n\texport default {\n\t\t${0}\n\t}\n</script>\n\n<style lang=\"sass\" scoped>\n\n</style>",
        "doc": "Base for Vue File with PostCSS",
        "grammar": "lsp",
        "label": "Vue Single File Component with SASS",
        "matches": {
          "vbase-sass": true
        },
        "options": {}
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script>\n\texport default {\n\t\t${0}\n\t}\n</script>\n\n<style lang=\"less\" scoped>\n\n</style>",
        "doc": "Base for Vue File with PostCSS",
        "grammar": "lsp",
        "label": "Vue Single File Component with LESS",
        "matches": {
          "vbase-less": true
        },
        "options": {}
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script>\n\texport default {\n\t\t${0}\n\t}\n</script>\n\n<style lang=\"postcss\" scoped>\n\n</style>",
        "doc": "Base for Vue File with PostCSS",
        "grammar": "lsp",
        "label": "Vue Single File Component with postcss",
        "matches": {
          "vbase-pcss": true
        },
        "options": {}
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script>\n\texport default {\n\t\t${0}\n\t}\n</script>\n\n<style scoped>\n\n</style>",
        "doc": "Base for Vue File with CSS",
        "grammar": "lsp",
        "label": "Vue Single File Component with Css",
        "matches": {
          "vbase-css": true
        },
        "options": {}
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script>\n\texport default {\n\t\t${0}\n\t}\n</script>\n\n<style lang=\"stylus\" scoped>\n\n</style>",
        "doc": "Base for Vue File with Stylus",
        "grammar": "lsp",
        "label": "Vue Single File Component with Stylus",
        "matches": {
          "vbase-styl": true
        },
        "options": {}
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script lang=\"ts\">\n\timport Vue from 'vue'\n\n\texport default Vue.extend({\n\t\t${0}\n\t})\n</script>\n\n<style scoped>\n\n</style>",
        "doc": "Base for Vue File with Typescript",
        "grammar": "lsp",
        "label": "Vue Single File Component with Typescript",
        "matches": {
          "vbase-ts": true
        },
        "options": {}
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script>\n\texport default {\n\t\t${0}\n\t}\n</script>",
        "doc": "Base for Vue File with no styles",
        "grammar": "lsp",
        "label": "Vue Single File Component with No Style",
        "matches": {
          "vbase-ns": true
        },
        "options": {}
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script>\nexport default {\n\tsetup () {\n\t\t${0}\n\n\t\treturn {}\n\t}\n}\n</script>\n\n<style lang=\"scss\" scoped>\n\n</style>",
        "doc": "Base for Vue File Composition API with SCSS",
        "grammar": "lsp",
        "label": "Vue Single File Component Composition API",
        "matches": {
          "vbase-3": true
        },
        "options": {}
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script setup>\n\n</script>\n\n<style lang=\"scss\" scoped>\n\n</style>",
        "doc": "Base for Vue File Setup Composition API with SCSS",
        "grammar": "lsp",
        "label": "Vue Single File Component Setup Composition API",
        "matches": {
          "vbase-3-setup": true
        },
        "options": {}
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script>\nimport { reactive, toRefs } from '@vue/composition-api'\n\nexport default {\n\tsetup () {\n\t\tconst state = reactive({\n\t\t\t${0:count}: ${1:0},\n\t\t})\n\t\n\t\treturn {\n\t\t\t...toRefs(state),\n\t\t}\n\t}\n}\n</script>\n\n<style lang=\"scss\" scoped>\n\n</style>",
        "doc": "Base for Vue File Composition API with SCSS",
        "grammar": "lsp",
        "label": "Vue Single File Component Composition API Reactive",
        "matches": {
          "vbase-3-reactive": true
        },
        "options": {}
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n\tsetup () {\n\t\t${0}\n\n\t\treturn {}\n\t}\n})\n</script>\n\n<style scoped>\n\n</style>",
        "doc": "Base for Vue File Composition API - Typescript",
        "grammar": "lsp",
        "label": "Vue Single File Component Composition API with Typescript",
        "matches": {
          "vbase-3-ts": true
        },
        "options": {}
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script setup lang=\"ts\">\n\n</script>\n\n<style scoped>\n\n</style>",
        "doc": "Base for Vue File Setup Composition API - Typescript",
        "grammar": "lsp",
        "label": "Vue Single File Component Setup Composition API with Typescript",
        "matches": {
          "vbase-3-ts-setup": true
        },
        "options": {}
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script lang=\"ts\">\n\timport { Component, Vue } from 'vue-property-decorator';\n\n\t@Component\n\texport default class ${0} extends Vue {\n\t\t\n\t}\n</script>\n\n<style scoped>\n\n</style>",
        "doc": "Base for Vue File with Class based Typescript format",
        "grammar": "lsp",
        "label": "Vue Single File Component with Class based Typescript format",
        "matches": {
          "vbase-ts-class": true
        },
        "options": {}
      },
      {
        "content": "<template>\n  ${0}\n</template>\n<script>\nexport default {\n}\n</script>\n<style>\n</style>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <template> <script> and <style>",
        "matches": {
          "scaffold": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "<template>\n  ${0}\n</template>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <template> with html",
        "matches": {
          "template_with_html": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "<template lang=\"pug\">\n  ${0}\n</template>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <template> with pug",
        "matches": {
          "template_with_pug": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "<script>\nexport default {\n  ${0}\n}\n</script>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <script> with JavaScript",
        "matches": {
          "script_with_JavaScript": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "<script lang=\"ts\">\nimport Vue from 'vue'\nexport default Vue.extend({\n  ${0}\n})\n</script>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <script> with TypeScript",
        "matches": {
          "script_with_TypeScript": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "<style>\n${0}\n</style>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <style> with CSS",
        "matches": {
          "style_with_CSS": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "<style scoped>\n${0}\n</style>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <style> with CSS scoped",
        "matches": {
          "style_with_CSS_scoped": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "<style lang=\"scss\">\n${0}\n</style>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <style> with scss",
        "matches": {
          "style_with_scss": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "<style lang=\"scss\" scoped>\n${0}\n</style>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <style> with scss scoped",
        "matches": {
          "style_with_scss_scoped": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "<style lang=\"less\">\n${0}\n</style>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <style> with less",
        "matches": {
          "style_with_less": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "<style lang=\"less\" scoped>\n${0}\n</style>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <style> with less scoped",
        "matches": {
          "style_with_less_scoped": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "<style lang=\"sass\">\n${0}\n</style>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <style> with sass",
        "matches": {
          "style_with_sass": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "<style lang=\"sass\" scoped>\n${0}\n</style>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <style> with sass scoped",
        "matches": {
          "style_with_sass_scoped": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "<style lang=\"postcss\">\n${0}\n</style>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <style> with postcss",
        "matches": {
          "style_with_postcss": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "<style lang=\"postcss\" scoped>\n${0}\n</style>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <style> with postcss scoped",
        "matches": {
          "style_with_postcss_scoped": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "<style lang=\"stylus\">\n${0}\n</style>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <style> with stylus",
        "matches": {
          "style_with_stylus": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "<style lang=\"stylus\" scoped>\n${0}\n</style>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <style> with stylus scoped",
        "matches": {
          "style_with_stylus_scoped": true
        },
        "options": {
          "head": true
        }
      },
      {
        "content": "<slot></slot>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "slot": true
        },
        "options": {}
      },
      {
        "content": "<template></template>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "template": true
        },
        "options": {}
      },
      {
        "content": "<transition></transition>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "transition": true
        },
        "options": {}
      },
      {
        "content": "<template>\n\t<div>\n\t</div>\n</template>\n<script>\n\texport default{\n\t\t${0}\n\t}\n</script>\n<style scoped>\n</style>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vbase": true
        },
        "options": {}
      },
      {
        "content": "import ${1:Name} from './components/$1.vue';\nexport default {\n\tcomponents: {\n\t\t$1\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vimport:c": true
        },
        "options": {}
      },
      {
        "content": "actions: {\n\t${1:updateValue}({commit}, ${2:payload}) {\n\t\tcommit($1, $2);\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vactions": true
        },
        "options": {}
      },
      {
        "content": "<transition\n  @before-enter=\"beforeEnter\"\n  @enter=\"enter\"\n  @after-enter=\"afterEnter\"\n  @enter-cancelled=\"enterCancelled\"\n  @before-Leave=\"beforeLeave\"\n  @leave=\"leave\"\n  @after-leave=\"afterLeave\"\n  @leave-cancelled=\"leaveCancelled\"\n  :css=\"false\">\n </transition>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vanim:js:el": true
        },
        "options": {}
      },
      {
        "content": "methods: {\n\tbeforeEnter(el) {\n\t\tconsole.log('beforeEnter');\n\t},\n\tenter(el, done) {\n\t\tconsole.log('enter');\n\t\tdone();\n\t},\n\tafterEnter(el) {\n\t\tconsole.log('afterEnter');\n\t},\n\tenterCancelled(el, done) {\n\t\tconsole.log('enterCancelled');\n\t},\n\tbeforeLeave(el) {\n\t\tconsole.log('beforeLeave');\n\t},\n\tleave(el, done) {\n\t\tconsole.log('leave');\n\t\tdone();\n\t},\n\tafterLeave(el) {\n\t\tconsole.log('afterLeave');\n\t},\n\tleaveCancelled(el, done) {\n\t\tconsole.log('leaveCancelled');\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vanim:js:method": true
        },
        "options": {}
      },
      {
        "content": "@click=\"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vcl": true
        },
        "options": {}
      },
      {
        "content": "data() {\n\treturn {\n\t\t${1:key}: ${2:value}\n\t};\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vdata": true
        },
        "options": {}
      },
      {
        "content": "filters: {\n\t${1:fnName}: function(${2:value}) {\n\t\treturn;\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vfilter": true
        },
        "options": {}
      },
      {
        "content": "<div v-for=\"${1:item} in ${2:items}\" :key=\"$1.id\">\n\t{{ $1 }}\n</div>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vfor": true
        },
        "options": {}
      },
      {
        "content": "getters: {\n\t${1:value}: state => {\n\t\treturn state.$1;\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vgetters": true
        },
        "options": {}
      },
      {
        "content": "import ${1:New} from './components/$1.vue';",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vimport": true
        },
        "options": {}
      },
      {
        "content": "<keep-alive>\n\t<component :is=\"\">\n\t\t<p>default</p>\n\t</component>\n</keep-alive>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vkeep": true
        },
        "options": {}
      },
      {
        "content": "const ${1:mixinName} = {\n\tmounted() {\n\t\tconsole.log('hello from mixin!')\n\t},\n}\nconst ${2:Component} = Vue.extend({\n\tmixins: [$1]\n})",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vmixin": true
        },
        "options": {}
      },
      {
        "content": "mutations: {\n\t${1:updateValue}(state, ${3:payload}) => {\n\t\tstate.${2:value} = $3;\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vmutations": true
        },
        "options": {}
      },
      {
        "content": "${1:propName}: {\n  type: ${2:Number},\n  default: ${0}\n},",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vprops:d": true
        },
        "options": {}
      },
      {
        "content": "${1:propName}: {\n\ttype: ${2:Number}\n},",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vprops": true
        },
        "options": {}
      },
      {
        "content": "import Vue from 'vue';\nimport Vuex from 'vuex';\nVue.use(Vuex);\nexport const store = new Vuex.Store({\n\tstate: {\n\t\t${1:key}: ${2:value}\n\t}\n});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "vstore": true
        },
        "options": {}
      },
      {
        "content": "$t('$1')",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "trans": true
        },
        "options": {}
      },
      {
        "content": "$t('$1', { $2: $3 })",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "transc": true
        },
        "options": {}
      }
    ],
    "vue-pug": [
      {
        "content": "${1:div}(v-for=\"${2:item} in ${2:item}s\" :key=\"${2:item}.id\")\n\t| {{ ${2:item} }}",
        "doc": "vfor statement",
        "grammar": "lsp",
        "label": "Vue v-for",
        "matches": {
          "vfor": true
        },
        "options": {}
      },
      {
        "content": "input(v-model=\"${1:data}\" type=\"text\")",
        "doc": "v-model directive",
        "grammar": "lsp",
        "label": "Vue v-model Directive",
        "matches": {
          "vmodel": true
        },
        "options": {}
      },
      {
        "content": "input(v-model.number=\"${1:numData}\" type=\"number\" step=\"1\")",
        "doc": "v-model directive number input",
        "grammar": "lsp",
        "label": "Vue v-model Number Directive",
        "matches": {
          "vmodel-num": true
        },
        "options": {}
      },
      {
        "content": "@click=\"${1:handler}(${2:arg}, $event)\"",
        "doc": "v-on click handler with arguments",
        "grammar": "lsp",
        "label": "Vue v-on Shortcut Directive",
        "matches": {
          "von": true
        },
        "options": {}
      },
      {
        "content": "${1:component}(:${1:propName}=\"${0}\")",
        "doc": "component element with props",
        "grammar": "lsp",
        "label": "Vue Component with Props Binding",
        "matches": {
          "vel-props": true
        },
        "options": {}
      },
      {
        "content": "img(:src=\"'/path/to/images/' + ${1:fileName}\" alt=\"${2:altText}\")",
        "doc": "image source binding",
        "grammar": "lsp",
        "label": "Vue Image Source Binding",
        "matches": {
          "vsrc": true
        },
        "options": {}
      },
      {
        "content": "${1:div}(:style=\"{ fontSize: ${2:data} + 'px' }\")",
        "doc": "vue inline style binding",
        "grammar": "lsp",
        "label": "Vue Style Binding",
        "matches": {
          "vstyle": true
        },
        "options": {}
      },
      {
        "content": "${1:div}(:style=\"[${2:styleObjectA}, ${3:styleObjectB]}\")",
        "doc": "vue inline style binding, objects",
        "grammar": "lsp",
        "label": "Vue Style Binding Object",
        "matches": {
          "vstyle-obj": true
        },
        "options": {}
      },
      {
        "content": "${1:div}(:class=\"{ ${2:className}: ${3:data} }\")",
        "doc": "vue class binding",
        "grammar": "lsp",
        "label": "Vue Class Binding",
        "matches": {
          "vclass": true
        },
        "options": {}
      },
      {
        "content": "${1:div}(:class=\"[${2:classNameA}, ${3:classNameB}]\")",
        "doc": "vue class binding",
        "grammar": "lsp",
        "label": "Vue Class Binding Object",
        "matches": {
          "vclass-obj": true
        },
        "options": {}
      },
      {
        "content": "${1:div}(:class=\"[${2:classNameA}, {${3:classNameB} : ${4:condition}}]\")",
        "doc": "vue multiple conditional class bindings",
        "grammar": "lsp",
        "label": "Vue Multiple Conditional Class Bindings",
        "matches": {
          "vclass-obj-mult": true
        },
        "options": {}
      },
      {
        "content": "transition(\n\tmode=\"out-in\"\n\t@before-enter=\"beforeEnter\"\n\t@enter=\"enter\"\n\n\t@before-leave=\"beforeLeave\"\n\t@leave=\"leave\"\n\t:css=\"false\"\n)",
        "doc": "transition component js hooks",
        "grammar": "lsp",
        "label": "Vue Transition Component with JavaScript Hooks",
        "matches": {
          "vanim": true
        },
        "options": {}
      },
      {
        "content": "nuxt-link(to=\"/${1:page}\") ${1:page}",
        "doc": "nuxt routing link",
        "grammar": "lsp",
        "label": "Vue Nuxt Routing Link",
        "matches": {
          "vnuxtl": true
        },
        "options": {}
      },
      {
        "content": "@change=\"$emit('change', $event.target.value)\"",
        "doc": "Vue Emit from Child Component",
        "grammar": "lsp",
        "label": "Vue Emit from Child",
        "matches": {
          "vemit-child": true
        },
        "options": {}
      },
      {
        "content": "@change=\"${1:foo} = $event\"",
        "doc": "Vue Emit to Parent Component",
        "grammar": "lsp",
        "label": "Vue Emit to Parent",
        "matches": {
          "vemit-parent": true
        },
        "options": {}
      }
    ],
    "vue-script": [
      {
        "content": "data() {\n\treturn {\n\t\t${1:key}: ${2:value}\n\t}\n},",
        "doc": "Vue Component Data",
        "grammar": "lsp",
        "label": "Vue Data",
        "matches": {
          "vdata": true
        },
        "options": {}
      },
      {
        "content": "methods: {\n\t${1:name}() {\n\t\t${0}\n\t}\n},",
        "doc": "vue method",
        "grammar": "lsp",
        "label": "Vue Methods",
        "matches": {
          "vmethod": true
        },
        "options": {}
      },
      {
        "content": "computed: {\n\t${1:name}() {\n\t\treturn this.${2:data} ${0}\n\t}\n},",
        "doc": "computed value",
        "grammar": "lsp",
        "label": "Vue Computed",
        "matches": {
          "vcomputed": true
        },
        "options": {}
      },
      {
        "content": "beforeCreate () {\n\t${0};\n},",
        "doc": "beforeCreate lifecycle method",
        "grammar": "lsp",
        "label": "Vue Lifecycle beforeCreate",
        "matches": {
          "vbeforecreate": true
        },
        "options": {}
      },
      {
        "content": "created () {\n\t${0};\n},",
        "doc": "created lifecycle method",
        "grammar": "lsp",
        "label": "Vue Lifecycle created",
        "matches": {
          "vcreated": true
        },
        "options": {}
      },
      {
        "content": "beforeMount () {\n\t${0};\n},",
        "doc": "beforeMount lifecycle method",
        "grammar": "lsp",
        "label": "Vue Lifecycle beforeMount",
        "matches": {
          "vbeforemount": true
        },
        "options": {}
      },
      {
        "content": "mounted () {\n\t${0};\n},",
        "doc": "mounted lifecycle method",
        "grammar": "lsp",
        "label": "Vue Lifecycle mounted",
        "matches": {
          "vmounted": true
        },
        "options": {}
      },
      {
        "content": "beforeUpdate () {\n\t${0};\n},",
        "doc": "beforeUpdate lifecycle method",
        "grammar": "lsp",
        "label": "Vue Lifecycle beforeUpdate",
        "matches": {
          "vbeforeupdate": true
        },
        "options": {}
      },
      {
        "content": "updated () {\n\t${0};\n},",
        "doc": "updated lifecycle method",
        "grammar": "lsp",
        "label": "Vue Lifecycle updated",
        "matches": {
          "vupdated": true
        },
        "options": {}
      },
      {
        "content": "beforeDestroy () {\n\t${0};\n},",
        "doc": "beforeDestroy lifecycle method",
        "grammar": "lsp",
        "label": "Vue Lifecycle beforeDestroy",
        "matches": {
          "vbeforedestroy": true
        },
        "options": {}
      },
      {
        "content": "destroyed () {\n\t${0};\n},",
        "doc": "destroyed lifecycle method",
        "grammar": "lsp",
        "label": "Vue Lifecycle destroyed",
        "matches": {
          "vdestroyed": true
        },
        "options": {}
      },
      {
        "content": "watch: {\n\t${1:data}(${2:newValue}, ${3:oldValue}) {\n\t\t${0}\n\t}\n},",
        "doc": "vue watcher",
        "grammar": "lsp",
        "label": "Vue Watchers",
        "matches": {
          "vwatcher": true
        },
        "options": {}
      },
      {
        "content": "watch: {\n\t${1:data}: {\n\t\timmediate: ${2:true},\n\t\tdeep: ${3:true},\n\t\thandler(${4:newValue}, ${5:oldValue}) {\n\t\t\t${0}\n\t\t}\n\t}\n},",
        "doc": "vue watcher with options",
        "grammar": "lsp",
        "label": "Vue Watchers with Options",
        "matches": {
          "vwatcher-options": true
        },
        "options": {}
      },
      {
        "content": "props: {\n\t${1:propName}: {\n\t\ttype: ${2:Number},\n\t\tdefault: ${0}\n\t},\n},",
        "doc": "Vue Props with Default",
        "grammar": "lsp",
        "label": "Vue Props with Default",
        "matches": {
          "vprops": true
        },
        "options": {}
      },
      {
        "content": "import ${1:New} from '@/components/${1:New}.vue';",
        "doc": "Import one component into another",
        "grammar": "lsp",
        "label": "Vue Import File",
        "matches": {
          "vimport": true
        },
        "options": {}
      },
      {
        "content": "components: {\n\t${1:New},\n},",
        "doc": "Import one component into another, within export statement",
        "grammar": "lsp",
        "label": "Vue Import into the Component",
        "matches": {
          "vcomponents": true
        },
        "options": {}
      },
      {
        "content": "import ${1:Name} from '@/components/${1:Name}.vue';\n\nexport default {\n\tcomponents: {\n\t\t${1:Name}\n\t},\n};",
        "doc": "import a component and include it in export default",
        "grammar": "lsp",
        "label": "Vue Import Export",
        "matches": {
          "vimport-export": true
        },
        "options": {}
      },
      {
        "content": "${1:New} = () => import('@/components/${1:New}.vue')",
        "doc": "Import component that should be lazy loaded",
        "grammar": "lsp",
        "label": "Vue Import Component Dynamically",
        "matches": {
          "vimport-dynamic": true
        },
        "options": {}
      },
      {
        "content": "import { mapState } from 'vuex';\n\nexport default {\n\tcomputed: {\n\t\t...mapState([\n\t\t\t${1:'nameOfState'},\n\t\t])\n\t},\n};",
        "doc": "map getters inside a vue component",
        "grammar": "lsp",
        "label": "Vue MapState",
        "matches": {
          "vmapstate": true
        },
        "options": {}
      },
      {
        "content": "import { mapGetters } from 'vuex';\n\nexport default {\n\tcomputed: {\n\t\t...mapGetters([\n\t\t\t${1:'nameOfGetter'},\n\t\t])\n\t},\n};",
        "doc": "mapgetters inside a vue component",
        "grammar": "lsp",
        "label": "Vue MapGetters",
        "matches": {
          "vmapgetters": true
        },
        "options": {}
      },
      {
        "content": "import { mapMutations } from 'vuex';\n\nexport default {\n\tmethods: {\n\t\t...mapMutations([\n\t\t\t${1:'nameOfMutation'}, //also supports payload `this.nameOfMutation(amount)` \n\t\t])\n\t},\n};",
        "doc": "mapmutations inside a vue component",
        "grammar": "lsp",
        "label": "Vue MapMutations",
        "matches": {
          "vmapmutations": true
        },
        "options": {}
      },
      {
        "content": "import { mapActions } from 'vuex';\n\nexport default {\n\tmethods: {\n\t\t...mapActions([\n\t\t\t${1:'nameOfAction'}, //also supports payload `this.nameOfAction(amount)` \n\t\t])\n\t},\n};",
        "doc": "mapactions inside a vue component",
        "grammar": "lsp",
        "label": "Vue MapActions",
        "matches": {
          "vmapactions": true
        },
        "options": {}
      },
      {
        "content": "filters: {\n\t${1:fnName}: function(${2:value}) {\n\t\treturn ${2:value}${0};\n\t}\n}",
        "doc": "vue filter",
        "grammar": "lsp",
        "label": "Vue Filter",
        "matches": {
          "vfilter": true
        },
        "options": {}
      },
      {
        "content": "const ${1:mixinName} = {\n\tmounted() {\n\t\tconsole.log('hello from mixin!');\n\t},\n};",
        "doc": "vue mixin",
        "grammar": "lsp",
        "label": "Vue Mixin",
        "matches": {
          "vmixin": true
        },
        "options": {}
      },
      {
        "content": "mixins: [${1:mixinName}],",
        "doc": "vue use mixin",
        "grammar": "lsp",
        "label": "Vue Use Mixin",
        "matches": {
          "vmixin-use": true
        },
        "options": {}
      },
      {
        "content": "Vue.directive('${1:directiveName}', {\n\tbind(el, binding, vnode) {\n\t\tel.style.${2:arg} = binding.value.${2:arg};\n\t}\n});",
        "doc": "vue custom directive",
        "grammar": "lsp",
        "label": "Vue Custom Directive",
        "matches": {
          "vc-direct": true
        },
        "options": {}
      },
      {
        "content": "import { ${1:libName} } from '${1:libName}';",
        "doc": "import a library",
        "grammar": "lsp",
        "label": "Vue Import Library",
        "matches": {
          "vimport-lib": true
        },
        "options": {}
      },
      {
        "content": "import gsap from 'gsap';",
        "doc": "import gsap library",
        "grammar": "lsp",
        "label": "Vue Import GSAP",
        "matches": {
          "vimport-gsap": true
        },
        "options": {}
      },
      {
        "content": "beforeEnter(el) {\n\tconsole.log('beforeEnter');\n},\nenter(el, done) {\n\tconsole.log('enter');\n\tdone();\n},\nbeforeLeave(el) {\n\tconsole.log('beforeLeave');\n},\nleave(el, done) {\n\tconsole.log('leave');\n\tdone();\n},",
        "doc": "transition component js hooks",
        "grammar": "lsp",
        "label": "Vue Transition Methods with JavaScript Hooks",
        "matches": {
          "vanimhook-js": true
        },
        "options": {}
      },
      {
        "content": "${1:mutationName}() {\n\tthis.\\$store.commit('${1:mutationName}', ${2:payload});\n}",
        "doc": "commit to vuex store in methods for mutation",
        "grammar": "lsp",
        "label": "Vue Commit Vuex Store in Methods",
        "matches": {
          "vcommit": true
        },
        "options": {}
      },
      {
        "content": "${1:actionName}() {\n\tthis.\\$store.dispatch('${1:actionName}', ${2:payload});\n}",
        "doc": "dispatch to vuex store in methods for action",
        "grammar": "lsp",
        "label": "Vue Dispatch Vuex Store in Methods",
        "matches": {
          "vdispatch": true
        },
        "options": {}
      },
      {
        "content": "import Vue from 'vue';\nimport ${1:HelloWorld} from './components/${1:HelloWorld}';\n\ndescribe('${1:HelloWorld}.vue', () => {\n\tit('${2:should render correct contents}', () => {\n\t\tconst Constructor = Vue.extend(${1:HelloWorld});\n\t\tconst vm = new Constructor().$mount();\n\t\texpect(vm.$el.querySelector('.hello h1').textContent)\n\t\t\t.to.equal(${3:'Welcome to Your Vue.js App'});\n\t});\n});",
        "doc": "unit test component",
        "grammar": "lsp",
        "label": "Unit Test",
        "matches": {
          "vtest": true
        },
        "options": {}
      },
      {
        "content": "module.exports = {\n\tcss: {\n\t\tloaderOptions: {\n\t\t\t${1:sass}: {\n\t\t\t\tdata: `${2:@import '@/styles/_variables.scss';}`\n\t\t\t}\n\t\t}\n\t}\n}",
        "doc": "vue.config.js",
        "grammar": "lsp",
        "label": "Vue.config.js Import",
        "matches": {
          "vconfig": true
        },
        "options": {}
      },
      {
        "content": "const ${1:name} = reactive({\n\t${2:count}: ${3:0}\n})",
        "doc": "Vue Composition api - reactive",
        "grammar": "lsp",
        "label": "Vue Composition API - Reactive",
        "matches": {
          "v3reactive": true
        },
        "options": {}
      },
      {
        "content": "const ${1:name} = computed(() => {\n\treturn ${2}\n})",
        "doc": "Vue Composition api - computed",
        "grammar": "lsp",
        "label": "Vue Composition API - Computed",
        "matches": {
          "v3computed": true
        },
        "options": {}
      },
      {
        "content": "watch(() => ${1:foo}, (newValue, oldValue) => {\n\t${2}\n})",
        "doc": "Vue Composition api - watcher single source",
        "grammar": "lsp",
        "label": "Vue Composition API - watch - single source",
        "matches": {
          "v3watch": true
        },
        "options": {}
      },
      {
        "content": "watch([${1:foo}, ${2:bar}], ([new${1}, new${2}], [prev${1}, prev${2}]) => {\n\t${3}\n})",
        "doc": "Vue Composition api - watch as array",
        "grammar": "lsp",
        "label": "Vue Composition API - watch - array",
        "matches": {
          "v3watch-array": true
        },
        "options": {}
      },
      {
        "content": "watchEffect(() => {\n\t${1}\n})",
        "doc": "Vue Composition api - watchEffect",
        "grammar": "lsp",
        "label": "Vue Composition API - watchEffect",
        "matches": {
          "v3watcheffect": true
        },
        "options": {}
      },
      {
        "content": "const ${1:name} = ref(${2:initialValue})",
        "doc": "Vue Ref",
        "grammar": "lsp",
        "label": "Vue Composition API - Vue ref",
        "matches": {
          "v3ref": true
        },
        "options": {}
      },
      {
        "content": "onMounted(() => {${1}})",
        "doc": "Vue Mounted Lifecycle hook",
        "grammar": "lsp",
        "label": "Vue Lifecycle Hooks - onMounted",
        "matches": {
          "v3onmounted": true
        },
        "options": {}
      },
      {
        "content": "onBeforeMount(() => {${1}})",
        "doc": "Vue onBeforeMount Lifecycle hook",
        "grammar": "lsp",
        "label": "Vue Lifecycle Hooks - onBeforeMount",
        "matches": {
          "v3onbeforemount": true
        },
        "options": {}
      },
      {
        "content": "onBeforeUpdate(() => {${1}})",
        "doc": "Vue onBeforeUpdate Lifecycle hook",
        "grammar": "lsp",
        "label": "Vue Lifecycle Hooks - onBeforeUpdate",
        "matches": {
          "v3onbeforeupdate": true
        },
        "options": {}
      },
      {
        "content": "onUpdated(() => {${1}})",
        "doc": "Vue onUpdated Lifecycle hook",
        "grammar": "lsp",
        "label": "Vue Lifecycle Hooks - onUpdated",
        "matches": {
          "v3onupdated": true
        },
        "options": {}
      },
      {
        "content": "onErrorCaptured(() => {${1}})",
        "doc": "Vue onErrorCaptured Lifecycle hook",
        "grammar": "lsp",
        "label": "Vue Lifecycle Hooks - onErrorCaptured",
        "matches": {
          "v3onerrorcaptured": true
        },
        "options": {}
      },
      {
        "content": "onUnmounted(() => {${1}})",
        "doc": "(destroyed) Vue onUnmounted Lifecycle hook",
        "grammar": "lsp",
        "label": "Vue Lifecycle Hooks - onUnmounted",
        "matches": {
          "v3onunmounted": true
        },
        "options": {}
      },
      {
        "content": "onBeforeUnmount(() => {${1}})",
        "doc": "(beforeDestroy) Vue onBeforeUnmount Lifecycle hook",
        "grammar": "lsp",
        "label": "Vue Lifecycle Hooks - onBeforeUnmount",
        "matches": {
          "v3onbeforeunmount": true
        },
        "options": {}
      },
      {
        "content": "import Vue from 'vue'\nimport ${1:VueCompositionApi} from '${2:@vue/composition-api}'\n\nVue.use(${1:VueCompositionApi})",
        "doc": "Import a plugin to main.js or plugins file",
        "grammar": "lsp",
        "label": "Plugin import",
        "matches": {
          "vplugin": true
        },
        "options": {}
      },
      {
        "content": "import { reactive, toRefs } from '@vue/composition-api'\n\nexport default {\n\tsetup () {\n\t\tconst state = reactive({\n\t\t\t${0:count}: ${1:0},\n\t\t})\n\t\n\t\treturn {\n\t\t\t...toRefs(state),\n\t\t}\n\t}\n}",
        "doc": "Vue Composition API Script with Reactive",
        "grammar": "lsp",
        "label": "Vue Composition API Reactive Script",
        "matches": {
          "v3reactive-setup": true
        },
        "options": {}
      },
      {
        "content": "import { ${0:component} } from '@/composables/${0:component}.js'\n\nexport default {\n\tsetup () {\n\t\tconst { ${1:name} } = ${0:component}()\n\t\n\t\treturn {\n\t\t\t${1:name}\n\t\t}\n\t}\n}",
        "doc": "Use Composition API within Options API",
        "grammar": "lsp",
        "label": "Use Composition API within Options API",
        "matches": {
          "v3useinoptions": true
        },
        "options": {}
      }
    ],
    "vue-script-router": [
      {
        "content": "import Vue from 'vue';\nimport VueRouter from 'vue-router';\n\nVue.use(VueRouter);\n\nexport const router = new VueRouter({\n\tbase: '/',\n\tmode: 'history',\n\troutes: [\n\t\t{ path: '/path', component: component }\n\t]\n});",
        "doc": "Base for Vue Router",
        "grammar": "lsp",
        "label": "Vue Router",
        "matches": {
          "vrouter": true
        },
        "options": {}
      },
      {
        "content": "scrollBehavior(to, from, savedPosition) {\n\tif(savedPosition) {\n\t\treturn savedPosition;\n\t} else {\n\t\treturn { x: 0, y: 0 };\n\t}\n},",
        "doc": "Vue Router scrollBehavior",
        "grammar": "lsp",
        "label": "Vue Router scrollBehavior",
        "matches": {
          "vscrollbehavior": true
        },
        "options": {}
      },
      {
        "content": "router.beforeEach((to, from, next) => {\n\t${1:next();}\n});",
        "doc": "Vue Router global guards beforeEach",
        "grammar": "lsp",
        "label": "Vue Router beforeEach",
        "matches": {
          "vbeforeeach": true
        },
        "options": {}
      },
      {
        "content": "router.beforeResolve((to, from, next) => {\n\t${1:next();}\n});",
        "doc": "Vue Router global guards beforeResolve",
        "grammar": "lsp",
        "label": "Vue Router beforeResolve",
        "matches": {
          "vbeforeresolve": true
        },
        "options": {}
      },
      {
        "content": "router.afterEach((to, from) => {\n\t\n});",
        "doc": "Vue Router global guards afterEach",
        "grammar": "lsp",
        "label": "Vue Router afterEach",
        "matches": {
          "vaftereach": true
        },
        "options": {}
      },
      {
        "content": "beforeEnter(to, from, next) {\n\t${1:next();}\n},",
        "doc": "Vue Router per-route guard beforeEnter",
        "grammar": "lsp",
        "label": "Vue Router beforeEnter",
        "matches": {
          "vbeforeenter": true
        },
        "options": {}
      },
      {
        "content": "beforeRouteEnter(to, from, next) {\n\tnext(vm => {${1:}});\n},",
        "doc": "Vue Router component guards beforeRouteEnter",
        "grammar": "lsp",
        "label": "Vue Router beforeRouteEnter",
        "matches": {
          "vbeforerouteenter": true
        },
        "options": {}
      },
      {
        "content": "beforeRouteUpdate(to, from, next) {\n\t${1:next();}\n},",
        "doc": "Vue Router component guards beforeRouteUpdate",
        "grammar": "lsp",
        "label": "Vue Router beforeRouteUpdate",
        "matches": {
          "vbeforerouteupdate": true
        },
        "options": {}
      },
      {
        "content": "beforeRouteLeave(to, from, next) {\n\t${1:next();}\n},",
        "doc": "Vue Router component guards beforeRouteLeave",
        "grammar": "lsp",
        "label": "Vue Router beforeRouteLeave",
        "matches": {
          "vbeforerouteleave": true
        },
        "options": {}
      },
      {
        "content": "{\n\tpath: '${1:pathName}',\n\tname: '${2:routeName}',\n\tcomponent: () => import('./${3:pathToComponent}'),\n},",
        "doc": "Vue Router route with per route code-splitting",
        "grammar": "lsp",
        "label": "Vue Router Route",
        "matches": {
          "vroute-named": true
        },
        "options": {}
      }
    ],
    "vue-script-vuex": [
      {
        "content": "import Vue from 'vue';\nimport Vuex from 'vuex';\n\nVue.use(Vuex);\n\nexport const store = new Vuex.Store({\n\tstate: {\n\t\t${1:key}: ${2:value}\n\t}\n});",
        "doc": "Base for Vuex store",
        "grammar": "lsp",
        "label": "Vuex Store",
        "matches": {
          "vstore": true
        },
        "options": {}
      },
      {
        "content": "getters: {\n\t${1:value}: state => {\n\t\treturn state.${1:value};\n\t}\n}",
        "doc": "vuex getter",
        "grammar": "lsp",
        "label": "Vuex Getters",
        "matches": {
          "vgetter": true
        },
        "options": {}
      },
      {
        "content": "mutations: {\n\t${1:updateValue}(state, ${3:payload}) {\n\t\tstate.${2:value} = ${3:payload};\n\t}\n}",
        "doc": "vuex mutation",
        "grammar": "lsp",
        "label": "Vuex Mutation",
        "matches": {
          "vmutation": true
        },
        "options": {}
      },
      {
        "content": "actions: {\n\t${1:updateValue}({commit}, ${2:payload}) {\n\t\tcommit('${1:updateValue}', ${2:payload});\n\t}\n}",
        "doc": "vuex action",
        "grammar": "lsp",
        "label": "Vuex Action",
        "matches": {
          "vaction": true
        },
        "options": {}
      },
      {
        "content": "import { store } from './store/index';",
        "doc": "import vuex store into main.js",
        "grammar": "lsp",
        "label": "Vue Import Vuex Store",
        "matches": {
          "vstore-import": true
        },
        "options": {}
      },
      {
        "content": "export default {\n\tstate: {\n\t\tvalue: 'my value'\n\t},\n\tgetters: {\n\t\tvalue: state => {\n\t\t\treturn state.value;\n\t\t}\n\t},\n\tmutations: {\n\t\tupdateValue(state, payload) {\n\t\t\tstate.value = payload;\n\t\t}\n\t},\n\tactions: {\n\t\tupdateValue({commit}, payload) {\n\t\t\tcommit('updateValue', payload);\n\t\t}\n\t}\n};",
        "doc": "vuex module",
        "grammar": "lsp",
        "label": "Vuex Module",
        "matches": {
          "vmodule": true
        },
        "options": {}
      },
      {
        "content": "export const state = () => ({\n\tvalue: 'myvalue'\n})\n\nexport const getters = {\n\tgetterValue: state => {\n\t\treturn state.value\n\t}\n}\n\nexport const mutations = {\n\tupdateValue: (state, payload) => {\n\t\tstate.value = payload\n\t}\n}\n\nexport const actions = {\n\tupdateActionValue({ commit }) {\n\t\tcommit('updateValue', payload)\n\t}\n}",
        "doc": "vuex store 2",
        "grammar": "lsp",
        "label": "Vuex Store 2",
        "matches": {
          "vstore2": true
        },
        "options": {}
      }
    ],
    "vue-template": [
      {
        "content": "<${1:div} v-for=\"${2:item} in ${2:item}s\" :key=\"${2:item}.id\">\n\t{{ ${2:item} }}\n</${1:div}>",
        "doc": "vfor statement",
        "grammar": "lsp",
        "label": "Vue v-for",
        "matches": {
          "vfor": true
        },
        "options": {}
      },
      {
        "content": "<input v-model=\"${1:data}\" type=\"text\" />",
        "doc": "v-model directive",
        "grammar": "lsp",
        "label": "Vue v-model Directive",
        "matches": {
          "vmodel": true
        },
        "options": {}
      },
      {
        "content": "<input v-model.number=\"${1:numData}\" type=\"number\" step=\"1\" />",
        "doc": "v-model directive number input",
        "grammar": "lsp",
        "label": "Vue v-model Number Directive",
        "matches": {
          "vmodel-num": true
        },
        "options": {}
      },
      {
        "content": "@click=\"${1:handler}(${2:arg}, $event)\"",
        "doc": "v-on click handler with arguments",
        "grammar": "lsp",
        "label": "Vue v-on Shortcut Directive",
        "matches": {
          "von": true
        },
        "options": {}
      },
      {
        "content": "<${1:component} :${1:propName}=\"${0}\"></${1:component}>",
        "doc": "component element with props",
        "grammar": "lsp",
        "label": "Vue Component with Props Binding",
        "matches": {
          "vel-props": true
        },
        "options": {}
      },
      {
        "content": "<template v-slot:${0:name}>${1:defaultcontent}</template>",
        "doc": "named slot",
        "grammar": "lsp",
        "label": "Vue Named Slot",
        "matches": {
          "vslot-named": true
        },
        "options": {}
      },
      {
        "content": "<img :src=\"'/path/to/images/' + ${1:fileName}\" alt=\"${2:altText}\"/>",
        "doc": "image source binding",
        "grammar": "lsp",
        "label": "Vue Image Source Binding",
        "matches": {
          "vsrc": true
        },
        "options": {}
      },
      {
        "content": "<${1:div} :style=\"{ fontSize: ${2:data} + 'px' }\"></${1:div}>",
        "doc": "vue inline style binding",
        "grammar": "lsp",
        "label": "Vue Style Binding",
        "matches": {
          "vstyle": true
        },
        "options": {}
      },
      {
        "content": "<${1:div} :style=\"[${2:styleObjectA}, ${3:styleObjectB]}\"></${1:div}>",
        "doc": "vue inline style binding, objects",
        "grammar": "lsp",
        "label": "Vue Style Binding Object",
        "matches": {
          "vstyle-obj": true
        },
        "options": {}
      },
      {
        "content": "<${1:div} :class=\"{ ${2:className}: ${3:data} }\"></${1:div}>",
        "doc": "vue class binding",
        "grammar": "lsp",
        "label": "Vue Class Binding",
        "matches": {
          "vclass": true
        },
        "options": {}
      },
      {
        "content": "<${1:div} :class=\"[${2:classNameA}, ${3:classNameB}]\"></${1:div}>",
        "doc": "vue class binding",
        "grammar": "lsp",
        "label": "Vue Class Binding Object",
        "matches": {
          "vclass-obj": true
        },
        "options": {}
      },
      {
        "content": "<${1:div} :class=\"[${2:classNameA}, {${3:classNameB} : ${4:condition}}]\"></${1:div}>",
        "doc": "vue multiple conditional class bindings",
        "grammar": "lsp",
        "label": "Vue Multiple Conditional Class Bindings",
        "matches": {
          "vclass-obj-mult": true
        },
        "options": {}
      },
      {
        "content": "@change=\"$emit('change', $event.target.value)\"",
        "doc": "Vue Emit from Child Component",
        "grammar": "lsp",
        "label": "Vue Emit from Child",
        "matches": {
          "vemit-child": true
        },
        "options": {}
      },
      {
        "content": "@change=\"${1:foo} = $event\"",
        "doc": "Vue Emit to Parent Component",
        "grammar": "lsp",
        "label": "Vue Emit to Parent",
        "matches": {
          "vemit-parent": true
        },
        "options": {}
      },
      {
        "content": "<transition\n\tmode=\"out-in\"\n\t@before-enter=\"beforeEnter\"\n\t@enter=\"enter\"\n\n\t@before-leave=\"beforeLeave\"\n\t@leave=\"leave\"\n\t:css=\"false\">\n\n</transition>",
        "doc": "transition component js hooks",
        "grammar": "lsp",
        "label": "Vue Transition Component with JavaScript Hooks",
        "matches": {
          "vanim": true
        },
        "options": {}
      },
      {
        "content": "<nuxt-link to=\"/${1:page}\">${1:page}</nuxt-link>",
        "doc": "nuxt routing link",
        "grammar": "lsp",
        "label": "Vue Nuxt Routing Link",
        "matches": {
          "vnuxtl": true
        },
        "options": {}
      },
      {
        "content": "<router-link :to=\"{name: '${1:name}'}\">${2:LinkTitle}</router-link>",
        "doc": "Named routing link",
        "grammar": "lsp",
        "label": "Vue Named Routing Link",
        "matches": {
          "vroutename": true
        },
        "options": {}
      },
      {
        "content": "<router-link :to=\"{name: '${1:name}', params:{${2:id}: '${3:value}'} }\">${4:LinkTitle}</router-link>",
        "doc": "Named routing link w/ params",
        "grammar": "lsp",
        "label": "Vue Named Routing Link with Params",
        "matches": {
          "vroutenameparam": true
        },
        "options": {}
      },
      {
        "content": "<router-link to=\"${1:path}\">${2:LinkTitle}</router-link>",
        "doc": "Path routing link",
        "grammar": "lsp",
        "label": "Vue Path Routing Link",
        "matches": {
          "vroutepath": true
        },
        "options": {}
      }
    ],
    "vuex": [
      {
        "content": "import Vue from 'vue';\nimport Vuex from 'vuex';\n\nVue.use(Vuex);\n\nexport const store = new Vuex.Store({\n\tstate: {\n\t\t${1:key}: ${2:value}\n\t}\n});",
        "doc": "Base for Vuex store",
        "grammar": "lsp",
        "label": "vuex-store",
        "matches": {
          "vstore": true,
          "vuex store": true
        },
        "options": {}
      },
      {
        "content": "getters: {\n\t${1:value}: state => {\n\t\treturn state.${1:value};\n\t}\n}",
        "doc": "vuex getter",
        "grammar": "lsp",
        "label": "vuex-getters",
        "matches": {
          "vgetter": true,
          "vuex getters": true
        },
        "options": {}
      },
      {
        "content": "mutations: {\n\t${1:updateValue}(state, ${3:payload}) {\n\t\tstate.${2:value} = ${3:payload};\n\t}\n}",
        "doc": "vuex mutation",
        "grammar": "lsp",
        "label": "vuex-mutation",
        "matches": {
          "vmutation": true,
          "vuex mutation": true
        },
        "options": {}
      },
      {
        "content": "actions: {\n\t${1:updateValue}({commit}, ${2:payload}) {\n\t\tcommit('${1:updateValue}', ${2:payload});\n\t}\n}",
        "doc": "vuex action",
        "grammar": "lsp",
        "label": "vuex-action",
        "matches": {
          "vaction": true,
          "vuex action": true
        },
        "options": {}
      },
      {
        "content": "import { store } from './store/index';",
        "doc": "import vuex store into main.js",
        "grammar": "lsp",
        "label": "vuex-import-store",
        "matches": {
          "vstore-import": true,
          "vuex import store": true
        },
        "options": {}
      },
      {
        "content": "export default {\n\tstate: {\n\t\tvalue: 'my value'\n\t},\n\tgetters: {\n\t\tvalue: state => {\n\t\t\treturn state.value;\n\t\t}\n\t},\n\tmutations: {\n\t\tupdateValue(state, payload) {\n\t\t\tstate.value = payload;\n\t\t}\n\t},\n\tactions: {\n\t\tupdateValue({commit}, payload) {\n\t\t\tcommit('updateValue', payload);\n\t\t}\n\t}\n};",
        "doc": "vuex module",
        "grammar": "lsp",
        "label": "vuex-module",
        "matches": {
          "vmodule": true,
          "vuex module": true
        },
        "options": {}
      },
      {
        "content": "export const state = () => ({\n\tvalue: 'myvalue'\n})\n\nexport const getters = {\n\tgetterValue: state => {\n\t\treturn state.value\n\t}\n}\n\nexport const mutations = {\n\tupdateValue: (state, payload) => {\n\t\tstate.value = payload\n\t}\n}\n\nexport const actions = {\n\tupdateActionValue({ commit }) {\n\t\tcommit('updateValue', payload)\n\t}\n}",
        "doc": "vuex store 2",
        "grammar": "lsp",
        "label": "vuex-store-2",
        "matches": {
          "vstore2": true,
          "vuex store 2": true
        },
        "options": {}
      }
    ],
    "xhtml": [
      {
        "content": "<html xmlns=\"http://www.w3.org/1999/xhtml\">\n    ${1:TARGET}\n</html>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "xhtml": true
        },
        "options": {}
      }
    ],
    "xml": [
      {
        "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "xml": true
        },
        "options": {}
      },
      {
        "content": "<${1:}>\n\t${2}\n</$1>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "t": true
        },
        "options": {}
      },
      {
        "content": "<${1:}>${2}</$1>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ti": true
        },
        "options": {}
      },
      {
        "content": "<?xml version=\"1.0\"?>\n",
        "doc": "",
        "grammar": "snu",
        "label": "XML declaration",
        "matches": {
          "xml": true
        },
        "options": {
          "b": true
        }
      }
    ],
    "xslt": [
      {
        "content": "<xsl:apply-templates select=\"${1:*}\">\n\t<xsl:with-param name=\"${2:param}\">${3}</xsl:with-param>${4}\n</xsl:apply-templates>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "apply-templates with-param": true
        },
        "options": {}
      },
      {
        "content": "<xsl:apply-templates select=\"${1:*}\">\n\t<xsl:sort select=\"${2:node}\" order=\"${3:ascending}\" data-type=\"${4:text}\">${5}\n</xsl:apply-templates>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "apply-templates sort-by": true
        },
        "options": {}
      },
      {
        "content": "<xsl:apply-templates select=\"${1:*}\" />",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "apply-templates plain": true
        },
        "options": {}
      },
      {
        "content": "<xsl:attribute name=\"${1:name}\">${2}</xsl:attribute>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "attribute blank": true
        },
        "options": {}
      },
      {
        "content": "<xsl:attribute name=\"${1:name}\">\n\t<xsl:value-of select=\"${2:*}\" />\n</xsl:attribute>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "attribute value-of": true
        },
        "options": {}
      },
      {
        "content": "<xsl:call-template name=\"${1:template}\" />",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "call-template": true
        },
        "options": {}
      },
      {
        "content": "<xsl:call-template name=\"${1:template}\">\n\t<xsl:with-param name=\"${2:param}\">${3}</xsl:with-param>${4}\n</xsl:call-template>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "call-template with-param": true
        },
        "options": {}
      },
      {
        "content": "<xsl:choose>\n\t<xsl:when test=\"${1:value}\">\n\t\t${2}\n\t</xsl:when>\n</xsl:choose>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "choose": true
        },
        "options": {}
      },
      {
        "content": "<xsl:copy-of select=\"${1:*}\" />",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "copy-of": true
        },
        "options": {}
      },
      {
        "content": "<xsl:for-each select=\"${1:*}\">${2}\n</xsl:for-each>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for-each": true
        },
        "options": {}
      },
      {
        "content": "<xsl:if test=\"${1:test}\">${2}\n</xsl:if>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "<xsl:import href=\"${1:stylesheet}\" />",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "import": true
        },
        "options": {}
      },
      {
        "content": "<xsl:include href=\"${1:stylesheet}\" />",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "include": true
        },
        "options": {}
      },
      {
        "content": "<xsl:otherwise>${0}\n</xsl:otherwise>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "otherwise": true
        },
        "options": {}
      },
      {
        "content": "<xsl:param name=\"${1:name}\">${2}\n</xsl:param>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "param": true
        },
        "options": {}
      },
      {
        "content": "<xsl:stylesheet version=\"1.0\"\nxmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">${0}\n</xsl:stylesheet>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "stylesheet": true
        },
        "options": {}
      },
      {
        "content": "<xsl:template match=\"${1:*}\">${0}\n</xsl:template>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "template": true
        },
        "options": {}
      },
      {
        "content": "<xsl:template name=\"${1:name}\">${0}\n</xsl:template>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "template named": true
        },
        "options": {}
      },
      {
        "content": "<xsl:text>${0}</xsl:text>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "text": true
        },
        "options": {}
      },
      {
        "content": "<xsl:value-of select=\"${1:*}\" />",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "value-of": true
        },
        "options": {}
      },
      {
        "content": "<xsl:variable name=\"${1:name}\">${0}\n</xsl:variable>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "variable blank": true
        },
        "options": {}
      },
      {
        "content": "<xsl:variable select=\"${1:*}\" />",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "variable select": true
        },
        "options": {}
      },
      {
        "content": "<xsl:when test=\"${1:test}\">${0}\n</xsl:when>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "when": true
        },
        "options": {}
      },
      {
        "content": "<xsl:with-param name=\"${1:name}\">${0}</xsl:with-param>",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "with-param": true
        },
        "options": {}
      },
      {
        "content": "<xsl:with-param name=\"${1:name}\" select=\"${0:*}\" />",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "with-param select": true
        },
        "options": {}
      }
    ],
    "yii": [
      {
        "content": "Yii::app()->session['${0}'];",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yse": true
        },
        "options": {}
      },
      {
        "content": "$this->renderDynamic('${0:callback}');",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yrd": true
        },
        "options": {}
      },
      {
        "content": "Yii::app()->cache->set('${1:key}', ${2:value}, ${3:expire}, new C${4:}CacheDependency(${0}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ycas": true
        },
        "options": {}
      },
      {
        "content": "Yii::app()->cache->add('${1:key}', ${2:value}, ${3:expire}, new C${4}CacheDependency(${0}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ycad": true
        },
        "options": {}
      },
      {
        "content": "Yii::app()->clientScript->registerCssFile('${0:file}');",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yregcf": true
        },
        "options": {}
      },
      {
        "content": "Yii::app()->request->requestType",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yreqtype": true
        },
        "options": {}
      },
      {
        "content": "Yii::app()->request->isAjaxRequest",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yisajax": true
        },
        "options": {}
      },
      {
        "content": "Yii::t('${1:category}', '${2:message}',array(${0}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yt": true
        },
        "options": {}
      },
      {
        "content": "Yii::app()->clientScript->registerCss('${1:id}', '${0}');",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yregc": true
        },
        "options": {}
      },
      {
        "content": "Yii::log('${1:msg}', '${0:info}');",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ylog": true
        },
        "options": {}
      },
      {
        "content": "YYii::app()->request->userHostAddress",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yuserip": true
        },
        "options": {}
      },
      {
        "content": "Yii::app()->clientScript->registerScriptFile('${1:scriptUrl}', CClientScript::POS_${0:END});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yregsf": true
        },
        "options": {}
      },
      {
        "content": "$this->widget('CLinkPager', array('pages'=>$pages,'header'=>'${0}'}))",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ylinkpager": true
        },
        "options": {}
      },
      {
        "content": "CJSON::encode(${0:text});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yjec": true
        },
        "options": {}
      },
      {
        "content": "$dataProvider = new CActiveDataProvider('${1}', array(\n  'criteria' => array(\n\t\t'condition' => '${2}',\n\t\t'order' => '${3}',\n\t\t'with' => array('${4}')\n\t),\n//'pagination' => false,\n\t'pagination' => array(\n\t\t'pageSize'=>${5},\n\t),\n));\n${0}\n// $dataProvider->getData() will return a list of Post objects",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yadp": true
        },
        "options": {}
      },
      {
        "content": "$this->renderDynamic('${1:callback}', array('${2:key}'=>${0:value}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yrdi": true
        },
        "options": {}
      },
      {
        "content": "Yii::app()->clientScript->registerScript('${1:id}', '${2}', CClientScript::POS_${0:READY});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yregs": true
        },
        "options": {}
      },
      {
        "content": "Yii::app()->cache->flush();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ycaf": true
        },
        "options": {}
      },
      {
        "content": "Yii::app()->request->cookies['${0}']",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yco": true
        },
        "options": {}
      },
      {
        "content": "Yii::app()->user->",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yuser": true
        },
        "options": {}
      },
      {
        "content": "$this->refresh();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yrf": true
        },
        "options": {}
      },
      {
        "content": "Yii::import('${0}');",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yimp": true
        },
        "options": {}
      },
      {
        "content": "Yii::trace('${0:msg}');",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ytrace": true
        },
        "options": {}
      },
      {
        "content": "Yii::app()->params['${0}']",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ypar": true
        },
        "options": {}
      },
      {
        "content": "Yii::app()->request->isPostRequest",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yispost": true
        },
        "options": {}
      },
      {
        "content": "if(Yii::app()->request->isAjaxRequest == TRUE)\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yifisajax": true
        },
        "options": {}
      },
      {
        "content": "Yii::app()->cache->delete('${0:key}');",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ydelcache": true
        },
        "options": {}
      },
      {
        "content": "$this->render('${1:view}',array('${2:key}'=>${0:value}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yr": true
        },
        "options": {}
      },
      {
        "content": "$this->redirect(array('${1:controller}/${0:action}'));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yre": true
        },
        "options": {}
      },
      {
        "content": "Yii::app()->cache->get('${0:key}');",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ycag": true
        },
        "options": {}
      },
      {
        "content": "$this->renderText('${0}');",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yrt": true
        },
        "options": {}
      },
      {
        "content": "$this->renderPartial('${1:view}',array('${2:key}'=>${0:value}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yrp": true
        },
        "options": {}
      },
      {
        "content": "${1:ModelName}::model()->count(${2:condition}, array('${3:key}'=>${0:value}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ycountm": true
        },
        "options": {}
      },
      {
        "content": "${1:ModelName}::model()->countBySql(${2:sql},array('${3:key}'=>${0:value}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ycountbs": true
        },
        "options": {}
      },
      {
        "content": "${1:ModelName}::model()->updateAll(${2:array('attributes')}, ${3:condition},array('${4:key}'=>${0:value}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yupdatea": true
        },
        "options": {}
      },
      {
        "content": "${1:ModelName}::model()->updateByPk(${2:pk}, ${3:array('attributes')}, ${4:condition},array('${5:key}'=>${0:value}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yupdatebp": true
        },
        "options": {}
      },
      {
        "content": "${1:ModelName}::model()->deleteAll(${2:condition},array('${3:key}'=>${0:value}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ydela": true
        },
        "options": {}
      },
      {
        "content": "${1:ModelName}::model()->deleteByPk(${2:pk}, ${3:condition}, array('${4:key}'=>${0:value}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ydelbp": true
        },
        "options": {}
      },
      {
        "content": "${1:ModelName}::model()->find(${2:condition},array('${3:key}'=>${0:value}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yfind": true
        },
        "options": {}
      },
      {
        "content": "${1:ModelName}::model()->findAll(${2:condition},array('${3:key}'=>${0:value}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yfinda": true
        },
        "options": {}
      },
      {
        "content": "${1:ModelName}::model()->findByPk(${2:pk}, ${3:condition}, array('${4:key}'=>${0:value}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yfindbp": true
        },
        "options": {}
      },
      {
        "content": "${1:ModelName}::model()->findAllByPk(${2:pk}, ${3:condition},array('${4:key}'=>${0:value}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yfindabp": true
        },
        "options": {}
      },
      {
        "content": "${1:ModelName}::model()->findBySql(${2:sql}, array('${3:key}'=>${0:value}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yfindbs": true
        },
        "options": {}
      },
      {
        "content": "${1:ModelName}::model()->findAllByAttributes(array('${2:attributeName}'=>${3:attributeValue}), ${4:condition}, array('${5:key}'=>${0:value}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yfindaba": true
        },
        "options": {}
      },
      {
        "content": "${1:ModelName}::model()->exists(${2:condition}, array('${3:key}'=>${0:value}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yexists": true
        },
        "options": {}
      },
      {
        "content": "<?php\nclass ${1:ModelName} extends ${2:CActiveRecord}\n{\n\t/**\n\t * Returns the static model of the specified AR class.\n\t * @return CActiveRecord the static model class\n\t */\n\tpublic static function model($className=__CLASS__)\n\t{\n\t\treturn parent::model($className);\n\t}\n\t/**\n\t * @return string the associated database table name\n\t */\n\tpublic function tableName()\n\t{\n\t\treturn '${0:table_name}';\n\t}\n\t/**\n\t * @return array validation rules for model attributes.\n\t */\n\tpublic function rules()\n\t{\n\t\treturn array(\n\t\t);\n\t}\n\t/**\n\t * @return array relational rules.\n\t */\n\tpublic function relations()\n\t{\n\t\treturn array(\n\t\t);\n\t}\n\t/**\n\t * @return array customized attribute labels (name=&gt;label)\n\t */\n\tpublic function attributeLabels()\n\t{\n\t\treturn array(\n\t\t);\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ymodel": true
        },
        "options": {}
      },
      {
        "content": "<?php\n/**\n * ${1:}\n */\nclass ${2:Site}Controller extends ${3:CController}\n{\n\t  public function action${4:Index}()\n\t  {\n\t      ${0}\n\t  }\n\t// -----------------------------------------------------------\n\t// Uncomment the following methods and override them if needed\n\t/*\n\tpublic function filters()\n\t{\n\t\t// return the filter configuration for this controller, e.g.:\n\t\treturn array(\n\t\t\t'inlineFilterName',\n\t\t\tarray(\n\t\t\t\t'class'=>'path.to.FilterClass',\n\t\t\t\t'propertyName'=>'propertyValue',\n\t\t\t),\n\t\t);\n\t}\n\tpublic function actions()\n\t{\n\t\t// return external action classes, e.g.:\n\t\treturn array(\n\t\t\t'action1'=>'path.to.ActionClass',\n\t\t\t'action2'=>array(\n\t\t\t\t'class'=>'path.to.AnotherActionClass',\n\t\t\t\t'propertyName'=>'propertyValue',\n\t\t\t),\n\t\t);\n\t}\n\t*/\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ycontroller": true
        },
        "options": {}
      },
      {
        "content": "public function action${1:Index}(${2:params})\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yact": true
        },
        "options": {}
      }
    ],
    "yii-chtml": [
      {
        "content": "echo CHtml::radioButton('${1:name}', ${2:false},array(${3:optionName}=>${0:optionValue} );",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhrb": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::asset('${0:path}');",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhass": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::activeLabelEx(${1:model}, '${2:attribute}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhale": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::encodeArray(array(${0}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yheca": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::normalizeUrl(array('${0}'));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhnurl": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::submitButton('${1:label}',array('${2:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhsb": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::linkButton('${1:lable}',array('${2:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhlinkb": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::activeTextArea(${1:model}, '${2:attribute}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhata": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::ajaxButton('${1:label}', '${2:url}',array('${3:ajaxOptionName}'=>${4:ajaxOptionValue}),array('${5:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhajb": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::activeId(${1:model}, '${0:attribute}');",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhai": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::activeCheckBox(${1:model}, '${2:attribute}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhacb": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::activeHiddenField(${1:model}, '${2:attribute}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhahf": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::encode(${0:text});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhec": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::metaTag('${1:content}', '${2:name}', '${3:httpEquiv}',array('${4:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhmtag": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::dropDownList('${1:name}', '${2:select}', array(${3}),array('${4:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhddl": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::listBox('${1:name}', '${2:select}',array(${3}),array('${4:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhlb": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::script('${0:test}');",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhjs": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::ajax(array(${0}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhaj": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::textField('${1:name}', '${2:value}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhtf": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::activePasswordField(${1:model}, '${2:attribute}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhapf": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::listData(array(${1}),'${2:valueField}', '${3:textField}','${0:groupField}');",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhld": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::mailto('${1:text}', '${2:email}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhmt": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::image('${1:src}', '${2:alt}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhimg": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::activeListBox(${1:model}, '${2:attribute}', array(${3}),array('${4:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhalb": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::activeFileField(${1:model}, '${2:attribute}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhaff": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::closeTag('${0:tag}');",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhct": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::activeInputField('${1:type}', ${2:model}, '${3:attribute}',array('${4:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhaif": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::scriptFile('${0:url}');",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhjsf": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::radioButtonList('${1:name}', ${2:select}, array(${3}),array('${4:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhrbl": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::cssFile('${1:url}','${0:media}');",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhcssf": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::error(${1:model}, '${0:attribute}');",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yherr": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::passwordField('${1:name}', '${2:value}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhpf": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::hiddenField('${1:name}', '${2:value}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhhf": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::cdata(${0:text});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhc": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::link('${1:text}',array(${2}),array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhlink": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::errorSummary(${1:model},'${2:headerHtml}','${0:footerHtml}');",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yherrs": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::tag('${1:tag}',array('${2:optionName}'=>${3:optionValue}),${4:false},${0:true});",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yht": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::ajaxLink('${1:label}', '${2:url}',array('${3:ajaxOptionName}'=>${4:ajaxOptionValue}),array('${5:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhajl": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::label('${1:label}', '${2:for}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhlabel": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::activeName(${1:model}, '${0:attribute}');",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhan": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::statefulForm(array('${1}'), '${2:post}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhsform": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::fileField('${1:name}', '${2:value}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhff": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::activeTextField(${1:model}, '${2:attribute}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhatf": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::css('${1:test}','${0:media}');",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhcss": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::imageButton('${1:src}',array('${2:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhimgb": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::ajaxSubmitButton('${1:label}', '${2:url}',array('${3:ajaxOptionName}'=>${4:ajaxOptionValue}),array('${5:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhajsb": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::button('${1:label}',array('${2:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhb": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::listOptions('${1:selection}', array(${2}), array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhlo": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::activeCheckBoxList(${1:model}, '${2:attribute}', array(${3}),array('${4:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhacbl": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::openTag('${1:tag}', array('${2:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhot": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::checkBox('${1:name}', ${2:false}, array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhcb": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::textArea('${1:name}', '${2:value}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhta": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::linkTag('${1:relation}', '${2:type}', '${3:href}', '${4:media}',array('${5:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhlinkt": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::resetButton('${1:label}',array('${2:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhrsb": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::activeRadioButtonList(${1:model}, '${2:attribute}', array(${3}),array('${4:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yharbl": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::checkBoxList('${1:name}', ${2:select}, array(${3}),array('${4:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhcbl": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::form(array('${1}'), '${2:post}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhform": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::beginForm(array('${1}'), '${2:post}',array('${3:optionName}'=>${4:optionValue}));\n${0}\necho CHtml::endForm();",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhbeform": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::activeDropDownList(${1:model}, '${2:attribute}', array(${3}),array('${4:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhaddl": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::activeRadioButton(${1:model}, '${2:attribute}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yharb": true
        },
        "options": {}
      },
      {
        "content": "echo CHtml::activeLabel(${1:model}, '${2:attribute}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "yhal": true
        },
        "options": {}
      }
    ],
    "yup": [
      {
        "content": "yup.reach()",
        "doc": "yup.reach(schema: Schema, path: string, value?: object, context?: object): Schema\n\nFor nested schemas yup.reach will retrieve a nested schema based on the provided path.For nested schemas that need to resolve dynamically, you can provide a value and optionally\na context object.let schema = object().shape({\n  nested: object().shape({\n    arr: array().of(object().shape({ num: number().max(4) }))\n  })\n});\n\nreach(schema, \"nested.arr.num\");\nreach(schema, \"nested.arr[].num\");\nreach(schema, \"nested.arr[1].num\");\nreach(schema, 'nested[\"arr\"][1].num');\n",
        "grammar": "lsp",
        "label": "yup-reach",
        "matches": {
          "yup reach": true
        },
        "options": {}
      },
      {
        "content": "yup.addMethod()",
        "doc": "yup.addMethod(schemaType: Schema, name: string, method: ()=> Schema): void\n\nAdds a new method to the core schema types. A friendlier convenience method for schemaType.prototype[name] = method.yup.addMethod(yup.date, \"format\", function(formats, parseStrict) {\n  return this.transform(function(value, originalValue) {\n    if (this.isType(value)) return value;\n\n    value = Moment(originalValue, formats, parseStrict);\n\n    return value.isValid() ? value.toDate() : new Date(\"\");\n  });\n});\n",
        "grammar": "lsp",
        "label": "yup-add-method",
        "matches": {
          "yup addmethod": true
        },
        "options": {}
      },
      {
        "content": "yup.ref()",
        "doc": "yup.ref(path: string, options: { contextPrefix: string }): Ref\n\nCreates a reference to another sibling or sibling descendant field. Refs are resolved\nat validation/cast time and supported where specified. Refs are evaluated in the proper order so that\nthe ref value is resolved before the field using the ref (be careful of circular dependencies!).let schema = object({\n  baz: ref(\"foo.bar\"),\n  foo: object({\n    bar: string()\n  }),\n  x: ref(\"$x\")\n});\n\nschema.cast({ foo: { bar: \"boom\" } }, { context: { x: 5 } });\n// => { baz: 'boom',  x: 5, foo: { bar: 'boom' } }\n",
        "grammar": "lsp",
        "label": "yup-ref",
        "matches": {
          "yup ref": true
        },
        "options": {}
      },
      {
        "content": "yup.lazy()",
        "doc": "yup.lazy((value: any) => Schema): Lazy\n\nCreates a schema that is evaluated at validation/cast time. Useful for creating\nrecursive schema like Trees, for polymorphic fields and arrays.CAUTION! When defining parent-child recursive object schema, you want to reset the default()\nto undefined on the child otherwise the object will infinitely nest itself when you cast it!.let node = object({\n  id: number(),\n  child: yup.lazy(() => node.default(undefined))\n});\n\nlet renderable = yup.lazy(value => {\n  switch (typeof value) {\n    case \"number\":\n      return number();\n    case \"string\":\n      return string();\n    default:\n      return mixed();\n  }\n});\n\nlet renderables = array().of(renderable);\n",
        "grammar": "lsp",
        "label": "yup-lazy",
        "matches": {
          "yup lazy": true
        },
        "options": {}
      },
      {
        "content": "mixed.clone()",
        "doc": "mixed.clone(): Schema\n\nCreates a deep copy of the schema. Clone is used internally to return a new schema with every schema state change.",
        "grammar": "lsp",
        "label": "mixed-clone",
        "matches": {
          "yup mixed clone": true
        },
        "options": {}
      },
      {
        "content": "mixed.label()",
        "doc": "mixed.label(label: string): Schema\n\nOverrides the key name which is used in error messages.",
        "grammar": "lsp",
        "label": "mixed-label",
        "matches": {
          "yup mixed label": true
        },
        "options": {}
      },
      {
        "content": "mixed.meta()",
        "doc": "mixed.meta(metadata: object): Schema\n\nAdds to a metadata object, useful for storing data with a schema, that doesn't belong\nthe cast object itself.",
        "grammar": "lsp",
        "label": "mixed-meta",
        "matches": {
          "yup mixed meta": true
        },
        "options": {}
      },
      {
        "content": "mixed.describe()",
        "doc": "mixed.describe(): SchemaDescription\n\nCollects schema details (like meta, labels, and active tests) into a serializable\ndescription object.SchemaDescription {\n  type: string,\n  label: string,\n  meta: object,\n  tests: Array<{ name: string, params: object }>\n}\n",
        "grammar": "lsp",
        "label": "mixed-describe",
        "matches": {
          "yup mixed describe": true
        },
        "options": {}
      },
      {
        "content": "mixed.concat()",
        "doc": "mixed.concat(schema: Schema)\n\nCreates a new instance of the schema by combining two schemas. Only schemas of the same type can be concatenated.",
        "grammar": "lsp",
        "label": "mixed-concat",
        "matches": {
          "yup mixed concat": true
        },
        "options": {}
      },
      {
        "content": "mixed.validate()",
        "doc": "mixed.validate(value: any, options?: object): Promise<any, ValidationError>\n\nReturns the value (a cast value if isStrict is false) if the value is valid, and returns the errors otherwise.\nThis method is asynchronous and returns a Promise object, that is fulfilled with the value, or rejected\nwith a ValidationError.The options argument is an object hash containing any schema options you may want to override\n(or specify for the first time).Options = {\n  strict: boolean = false;\n  abortEarly: boolean = true;\n  stripUnknown: boolean = false;\n  recursive: boolean = true;\n  context?: object;\n}\n\nstrict: only validate the input, and skip and coercion or transformation\nabortEarly: return from validation methods on the first error rather\nthan after all validations run.\nstripUnknown: remove unspecified keys from objects.\nrecursive: when false validations will not descend into nested schema\n(relevant for objects or arrays).\ncontext: any context needed for validating schema conditions (see: when())\nschema.validate({ name: \"jimmy\", age: 24 }).then(function(value) {\n  value; // => { name: 'jimmy',age: 24 }\n});\n\nschema.validate({ name: \"jimmy\", age: \"hi\" }).catch(function(err) {\n  err.name; // => 'ValidationError'\n  err.errors; // => ['age must be a number']\n});\n",
        "grammar": "lsp",
        "label": "mixed-validate",
        "matches": {
          "yup mixed validate": true
        },
        "options": {}
      },
      {
        "content": "mixed.validateSync()",
        "doc": "mixed.validateSync(value: any, options?: object): any\n\nRuns validatations synchronously if possible and returns the resulting value,\nor throws a ValidationError. Accepts all the same options as validate.Synchronous validation only works if there are no configured async tests, e.g tests that return a Promise.\nFor instance this will work:let schema = number().test(\n  \"is-42\",\n  \"this isn't the number i want\",\n  value => value != 42\n);\n\nschema.validateSync(23); // throws ValidationError\nhowever this will not:let schema = number().test(\"is-42\", \"this isn't the number i want\", value =>\n  Promise.resolve(value != 42)\n);\n\nschema.validateSync(42); // throws Error\n",
        "grammar": "lsp",
        "label": "mixed-validate-sync",
        "matches": {
          "yup mixed validatesync": true
        },
        "options": {}
      },
      {
        "content": "mixed.validateAt()",
        "doc": "mixed.validateAt(path: string, value: any, options?: object): Promise<any, ValidationError>\n\nValidate a deeply nested path within the schema. Similar to how reach works,\nbut uses the resulting schema as the subject for validation.\nNote! The value here is the root value relative to the starting schema, not the value at the nested path.\nlet schema = object({\n  foo: array().of(\n    object({\n      loose: boolean(),\n      bar: string().when(\"loose\", {\n        is: true,\n        otherwise: s => s.strict()\n      })\n    })\n  )\n});\n\nlet rootValue = {\n  foo: [{ bar: 1 }, { bar: 1, loose: true }]\n};\n\nawait schema.validateAt(\"foo[0].bar\", rootValue); // => ValidationError: must be a string\n\nawait schema.validateAt(\"foo[1].bar\", rootValue); // => '1'\n",
        "grammar": "lsp",
        "label": "mixed-validate-at",
        "matches": {
          "yup mixed validateat": true
        },
        "options": {}
      },
      {
        "content": "mixed.validateSyncAt()",
        "doc": "mixed.validateSyncAt(path: string, value: any, options?: object): any\n\nSame as validateAt but synchronous.",
        "grammar": "lsp",
        "label": "mixed-validate-sync-at",
        "matches": {
          "yup mixed validatesyncat": true
        },
        "options": {}
      },
      {
        "content": "mixed.isValid()",
        "doc": "mixed.isValid(value: any, options?: object): Promise<boolean>\n\nReturns true when the passed in value matches the schema. isValid\nis asynchronous and returns a Promise object.Takes the same options as validate().",
        "grammar": "lsp",
        "label": "mixed-is-valid",
        "matches": {
          "yup mixed isvalid": true
        },
        "options": {}
      },
      {
        "content": "mixed.isValidSync()",
        "doc": "mixed.isValidSync(value: any, options?: object): boolean\n\nSynchronously returns true when the passed in value matches the schema.Takes the same options as validateSync() and has the same caveats around async tests.",
        "grammar": "lsp",
        "label": "mixed-is-valid-sync",
        "matches": {
          "yup mixed isvalidsync": true
        },
        "options": {}
      },
      {
        "content": "mixed.cast()",
        "doc": "mixed.cast(value: any, options = {}): any\n\nAttempts to coerce the passed in value to a value that matches the schema. For example: '5' will\ncast to 5 when using the number() type. Failed casts generally return null, but may also\nreturn results like NaN and unexpected strings.options parameter can be an object containing context. (For more info on context see mixed.validate)",
        "grammar": "lsp",
        "label": "mixed-cast",
        "matches": {
          "yup mixed cast": true
        },
        "options": {}
      },
      {
        "content": "mixed.isType()",
        "doc": "mixed.isType(value: any): boolean\n\nRuns a type check against the passed in value. It returns true if it matches,\nit does not cast the value. When nullable() is set null is considered a valid value of the type.\nYou should use isType for all Schema type checks.",
        "grammar": "lsp",
        "label": "mixed-is-type",
        "matches": {
          "yup mixed istype": true
        },
        "options": {}
      },
      {
        "content": "mixed.strict()",
        "doc": "mixed.strict(isStrict: boolean = false): Schema\n\nSets the strict option to true. Strict schemas skip coercion and transformation attempts,\nvalidating the value \"as is\".",
        "grammar": "lsp",
        "label": "mixed-strict",
        "matches": {
          "yup mixed strict": true
        },
        "options": {}
      },
      {
        "content": "mixed.strip()",
        "doc": "mixed.strip(stripField: boolean = true): Schema\n\nMarks a schema to be removed from an output object. Only works as a nested schema.let schema = object({\n  useThis: number(),\n  notThis: string().strip()\n});\n\nschema.cast({ notThis: \"foo\", useThis: 4 }); // => { useThis: 4 }\n",
        "grammar": "lsp",
        "label": "mixed-strip",
        "matches": {
          "yup mixed strip": true
        },
        "options": {}
      },
      {
        "content": "mixed.withMutation()",
        "doc": "mixed.withMutation(builder: (current: Schema) => void): void\n\nFirst the legally required Rich Hickey quote:\nIf a tree falls in the woods, does it make a sound?\nIf a pure function mutates some local data in order to produce an immutable return value, is that ok?\nwithMutation allows you to mutate the schema in place, instead of the default behavior which clones before each change.\nGenerally this isn't necessary since the vast majority of schema changes happen during the initial\ndeclaration, and only happen once over the lifetime of the schema, so performance isn't an issue.\nHowever certain mutations do occur at cast/validation time, (such as conditional schema using when()), or\nwhen instantiating a schema object.object()\n  .shape({ key: string() })\n  .withMutation(schema => {\n    return arrayOfObjectTests.forEach(test => {\n      schema.test(test);\n    });\n  });\n",
        "grammar": "lsp",
        "label": "mixed-with-mutation",
        "matches": {
          "yup mixed withmutation": true
        },
        "options": {}
      },
      {
        "content": "mixed.default()",
        "doc": "mixed.default(): Any\n\nCalling default with no arguments will return the current default value",
        "grammar": "lsp",
        "label": "mixed-default",
        "matches": {
          "yup mixed default": true
        },
        "options": {}
      },
      {
        "content": "mixed.nullable()",
        "doc": "mixed.nullable(isNullable: boolean = true): Schema\n\nIndicates that null is a valid value for the schema. Without nullable()\nnull is treated as a different type and will fail isType() checks.",
        "grammar": "lsp",
        "label": "mixed-nullable",
        "matches": {
          "yup mixed nullable": true
        },
        "options": {}
      },
      {
        "content": "mixed.required()",
        "doc": "mixed.required(message?: string | function): Schema\n\nMark the schema as required. All field values apart from undefined and null meet this requirement.",
        "grammar": "lsp",
        "label": "mixed-required",
        "matches": {
          "yup mixed required": true
        },
        "options": {}
      },
      {
        "content": "mixed.notRequired()",
        "doc": "mixed.notRequired(): Schema\n\nMark the schema as not required. Passing undefined as value will not fail validation.",
        "grammar": "lsp",
        "label": "mixed-not-required",
        "matches": {
          "yup mixed notrequired": true
        },
        "options": {}
      },
      {
        "content": "mixed.typeError()",
        "doc": "mixed.typeError(message: string): Schema\n\nDefine an error message for failed type checks. The ${value} and ${type} interpolation can\nbe used in the message argument.",
        "grammar": "lsp",
        "label": "mixed-type-error",
        "matches": {
          "yup mixed typeerror": true
        },
        "options": {}
      },
      {
        "content": "mixed.oneOf()",
        "doc": "mixed.oneOf(arrayOfValues: Array<any>, message?: string | function): Schema Alias: equals\n\nWhitelist a set of values. Values added are automatically removed from any blacklist if they are in it.\nThe ${values} interpolation can be used in the message argument.Note that undefined does not fail this validator, even when undefined is not included in arrayOfValues.\nIf you don't want undefined to be a valid value, you can use mixed.required.let schema = yup.mixed().oneOf([\"jimmy\", 42]);\n\nawait schema.isValid(42); // => true\nawait schema.isValid(\"jimmy\"); // => true\nawait schema.isValid(new Date()); // => false\n",
        "grammar": "lsp",
        "label": "mixed-one-of",
        "matches": {
          "yup mixed oneof": true
        },
        "options": {}
      },
      {
        "content": "mixed.notOneOf()",
        "doc": "mixed.notOneOf(arrayOfValues: Array<any>, message?: string | function)\n\nBlacklist a set of values. Values added are automatically removed from any whitelist if they are in it.\nThe ${values} interpolation can be used in the message argument.let schema = yup.mixed().notOneOf([\"jimmy\", 42]);\n\nawait schema.isValid(42); // => false\nawait schema.isValid(new Date()); // => true\n",
        "grammar": "lsp",
        "label": "mixed-not-one-of",
        "matches": {
          "yup mixed notoneof": true
        },
        "options": {}
      },
      {
        "content": "mixed.when()",
        "doc": "mixed.when(keys: string | Array<string>, builder: object | (value, schema)=> Schema): Schema\n\nAdjust the schema based on a sibling or sibling children fields. You can provide an object\nliteral where the key is is value or a matcher function, then provides the true schema and/or\notherwise for the failure condition.is conditions are strictly compared (===) if you want to use a different form of equality you\ncan provide a function like: is: (value) => value == true.Like joi you can also prefix properties with $ to specify a property that is dependent\non context passed in by validate() or isValid. when conditions are additive.let schema = object({\n  isBig: boolean(),\n  count: number()\n    .when(\"isBig\", {\n      is: true, // alternatively: (val) => val == true\n      then: yup.number().min(5),\n      otherwise: yup.number().min(0)\n    })\n    .when(\"$other\", (other, schema) => (other === 4 ? schema.max(6) : schema))\n});\n\nawait schema.validate(value, { context: { other: 4 } });\nYou can also specify more than one dependent key, in which case each value will be spread as an argument.let schema = object({\n  isSpecial: boolean(),\n  isBig: boolean(),\n  count: number().when([\"isBig\", \"isSpecial\"], {\n    is: true, // alternatively: (isBig, isSpecial) => isBig && isSpecial\n    then: yup.number().min(5),\n    otherwise: yup.number().min(0)\n  })\n});\n\nawait schema.validate({\n  isBig: true,\n  isSpecial: true,\n  count: 10\n});\nAlternatively you can provide a function that returns a schema\n(called with the value of the key and the current schema).let schema = yup.object({\n  isBig: yup.boolean(),\n  count: yup.number().when(\"isBig\", (isBig, schema) => {\n    return isBig ? schema.min(5) : schema.min(0);\n  })\n});\n\nawait schema.validate({ isBig: false, count: 4 });\n",
        "grammar": "lsp",
        "label": "mixed-when",
        "matches": {
          "yup mixed when": true
        },
        "options": {}
      },
      {
        "content": "mixed.test()",
        "doc": "mixed.test(options: object): Schema\n\nAlternative test(..) signature. options is an object containing some of the following options:Options = {\n  // unique name identifying the test\n  name: string;\n  // test function, determines schema validity\n  test: (value: any) => boolean;\n  // the validation error message\n  message: string;\n  // values passed to message for interpolation\n  params: ?object;\n  // mark the test as exclusive, meaning only one of the same can be active at once\n  exclusive: boolean = false;\n}\nIn the case of mixing exclusive and non-exclusive tests the following logic is used.\nIf a non-exclusive test is added to a schema with an exclusive test of the same name\nthe exclusive test is removed and further tests of the same name will be stacked.If an exclusive test is added to a schema with non-exclusive tests of the same name\nthe previous tests are removed and further tests of the same name will replace each other.let max = 64;\nlet schema = yup.mixed().test({\n  name: \"max\",\n  exclusive: true,\n  params: { max },\n  message: \"${path} must be less than ${max} characters\",\n  test: value => value == null || value.length <= max\n});\n",
        "grammar": "lsp",
        "label": "mixed-test",
        "matches": {
          "yup mixed test": true
        },
        "options": {}
      },
      {
        "content": "mixed.transform()",
        "doc": "mixed.transform((currentValue: any, originalValue: any) => any): Schema\n\nAdds a transformation to the transform chain. Transformations are central to the casting process,\ndefault transforms for each type coerce values to the specific type (as verified by isType()).\ntransforms are run before validations and only applied when strict is true. Some types have built in transformations.Transformations are useful for arbitrarily altering how the object is cast, however, you should take care\nnot to mutate the passed in value. Transforms are run sequentially so each value represents the\ncurrent state of the cast, you can use the originalValue param if you need to work on the raw initial value.let schema = string().transform(function(value, originalvalue) {\n  return this.isType(value) && value !== null ? value.toUpperCase() : value;\n});\n\nschema.cast(\"jimmy\"); // => 'JIMMY'\nEach types will handle basic coercion of values to the proper type for you, but occasionally\nyou may want to adjust or refine the default behavior. For example, if you wanted to use a different\ndate parsing strategy than the default one you could do that with a transform.module.exports = function(formats = \"MMM dd, yyyy\") {\n  return date().transform(function(value, originalvalue) {\n    // check to see if the previous transform already parsed the date\n    if (this.isType(value)) return value;\n\n    // the default coercion failed so lets try it with Moment.js instead\n    value = Moment(originalValue, formats);\n\n    // if its valid return the date object, otherwise return an `InvalidDate`\n    return value.isValid() ? value.toDate() : new Date(\"\");\n  });\n};\nstringDefine a string schema. Supports all the same methods as mixed.let schema = yup.string();\n\nawait schema.isValid(\"hello\"); // => true\nBy default, the cast logic of string is to call toString on the value if it exists.\nempty values are not coerced (use ensure() to coerce empty values to empty strings).Failed casts return the input value.",
        "grammar": "lsp",
        "label": "mixed-transform",
        "matches": {
          "yup mixed transform": true
        },
        "options": {}
      },
      {
        "content": "string.required()",
        "doc": "string.required(message?: string | function): Schema\n\nThe same as the mixed() schema required, except that empty strings are also considered 'missing' values.",
        "grammar": "lsp",
        "label": "string-required",
        "matches": {
          "yup string required": true
        },
        "options": {}
      },
      {
        "content": "string.length()",
        "doc": "string.length(limit: number | Ref, message?: string | function): Schema\n\nSet a required length for the string value. The ${length} interpolation can be used in the message argument",
        "grammar": "lsp",
        "label": "string-length",
        "matches": {
          "yup string length": true
        },
        "options": {}
      },
      {
        "content": "string.min()",
        "doc": "string.min(limit: number | Ref, message?: string | function): Schema\n\nSet a minimum length limit for the string value. The ${min} interpolation can be used in the message argument",
        "grammar": "lsp",
        "label": "string-min",
        "matches": {
          "yup string min": true
        },
        "options": {}
      },
      {
        "content": "string.max()",
        "doc": "string.max(limit: number | Ref, message?: string | function): Schema\n\nSet a maximum length limit for the string value. The ${max} interpolation can be used in the message argument",
        "grammar": "lsp",
        "label": "string-max",
        "matches": {
          "yup string max": true
        },
        "options": {}
      },
      {
        "content": "string.matches()",
        "doc": "string.matches(regex: Regex, options: { message: string, excludeEmptyString: bool }): Schema\n\nAn alternate signature for string.matches with an options object. excludeEmptyString, when true,\nshort circuits the regex test when the value is an empty stringlet schema = string().matches(/(hi|bye)/, { excludeEmptyString: true });\n\nawait schema.isValid(\"\"); // => true\n",
        "grammar": "lsp",
        "label": "string-matches",
        "matches": {
          "yup string matches": true
        },
        "options": {}
      },
      {
        "content": "string.email()",
        "doc": "string.email(message?: string | function): Schema\n\nValidates the value as an email address via a regex.",
        "grammar": "lsp",
        "label": "string-email",
        "matches": {
          "yup string email": true
        },
        "options": {}
      },
      {
        "content": "string.url()",
        "doc": "string.url(message?: string | function): Schema\n\nValidates the value as a valid URL via a regex.",
        "grammar": "lsp",
        "label": "string-url",
        "matches": {
          "yup string url": true
        },
        "options": {}
      },
      {
        "content": "string.ensure()",
        "doc": "string.ensure(): Schema\n\nTransforms undefined and null values to an empty string along with\nsetting the default to an empty string.",
        "grammar": "lsp",
        "label": "string-ensure",
        "matches": {
          "yup string ensure": true
        },
        "options": {}
      },
      {
        "content": "string.trim()",
        "doc": "string.trim(message?: string | function): Schema\n\nTransforms string values by removing leading and trailing whitespace. If\nstrict() is set it will only validate that the value is trimmed.",
        "grammar": "lsp",
        "label": "string-trim",
        "matches": {
          "yup string trim": true
        },
        "options": {}
      },
      {
        "content": "string.lowercase()",
        "doc": "string.lowercase(message?: string | function): Schema\n\nTransforms the string value to lowercase. If strict() is set it\nwill only validate that the value is lowercase.",
        "grammar": "lsp",
        "label": "string-lowercase",
        "matches": {
          "yup string lowercase": true
        },
        "options": {}
      },
      {
        "content": "string.uppercase()",
        "doc": "string.uppercase(message?: string | function): Schema\n\nTransforms the string value to uppercase. If strict() is set it\nwill only validate that the value is uppercase.numberDefine a number schema. Supports all the same methods as mixed.let schema = yup.number();\n\nawait schema.isValid(10); // => true\nThe default cast logic of number is: parseFloat.Failed casts return NaN.",
        "grammar": "lsp",
        "label": "string-uppercase",
        "matches": {
          "yup string uppercase": true
        },
        "options": {}
      },
      {
        "content": "number.min()",
        "doc": "number.min(limit: number | Ref, message?: string | function): Schema\n\nSet the minimum value allowed. The ${min} interpolation can be used in the\nmessage argument.",
        "grammar": "lsp",
        "label": "number-min",
        "matches": {
          "yup number min": true
        },
        "options": {}
      },
      {
        "content": "number.max()",
        "doc": "number.max(limit: number | Ref, message?: string | function): Schema\n\nSet the maximum value allowed. The ${max} interpolation can be used in the\nmessage argument.",
        "grammar": "lsp",
        "label": "number-max",
        "matches": {
          "yup number max": true
        },
        "options": {}
      },
      {
        "content": "number.lessThan()",
        "doc": "number.lessThan(max: number | Ref, message?: string | function): Schema\n\nValue must be less than max. The ${less} interpolation can be used in the\nmessage argument.",
        "grammar": "lsp",
        "label": "number-less-than",
        "matches": {
          "yup number lessthan": true
        },
        "options": {}
      },
      {
        "content": "number.moreThan()",
        "doc": "number.moreThan(min: number | Ref, message?: string | function): Schema\n\nValue must be strictly greater than min. The ${more} interpolation can be used in the\nmessage argument.",
        "grammar": "lsp",
        "label": "number-more-than",
        "matches": {
          "yup number morethan": true
        },
        "options": {}
      },
      {
        "content": "number.positive()",
        "doc": "number.positive(message?: string | function): Schema\n\nValue must be a positive number.",
        "grammar": "lsp",
        "label": "number-positive",
        "matches": {
          "yup number positive": true
        },
        "options": {}
      },
      {
        "content": "number.negative()",
        "doc": "number.negative(message?: string | function): Schema\n\nValue must be a negative number.",
        "grammar": "lsp",
        "label": "number-negative",
        "matches": {
          "yup number negative": true
        },
        "options": {}
      },
      {
        "content": "number.integer()",
        "doc": "number.integer(message?: string | function): Schema\n\nValidates that a number is an integer.",
        "grammar": "lsp",
        "label": "number-integer",
        "matches": {
          "yup number integer": true
        },
        "options": {}
      },
      {
        "content": "number.truncate()",
        "doc": "number.truncate(): Schema\n\nTransformation that coerces the value to an integer by stripping off the digits\nto the right of the decimal point.",
        "grammar": "lsp",
        "label": "number-truncate",
        "matches": {
          "yup number truncate": true
        },
        "options": {}
      },
      {
        "content": "number.round()",
        "doc": "number.round(type: 'floor' | 'ceil' | 'trunc' | 'round' = 'round'): Schema\n\nAdjusts the value via the specified method of Math (defaults to 'round').booleanDefine a boolean schema. Supports all the same methods as mixed.let schema = yup.boolean();\n\nawait schema.isValid(true); // => true\ndateDefine a Date schema. By default ISO date strings will parse correctly,\nfor more robust parsing options see the extending schema types at the end of the readme.\nSupports all the same methods as mixed.let schema = yup.date();\n\nawait schema.isValid(new Date()); // => true\nThe default cast logic of date is pass the value to the Date constructor, failing that, it will attempt\nto parse the date as an ISO date string.Failed casts return an invalid Date.",
        "grammar": "lsp",
        "label": "number-round",
        "matches": {
          "yup number round": true
        },
        "options": {}
      },
      {
        "content": "date.min()",
        "doc": "date.min(limit: Date | string | Ref, message?: string | function): Schema\n\nSet the minimum date allowed. When a string is provided it will attempt to cast to a date first\nand use the result as the limit.",
        "grammar": "lsp",
        "label": "date-min",
        "matches": {
          "yup date min": true
        },
        "options": {}
      },
      {
        "content": "date.max()",
        "doc": "date.max(limit: Date | string | Ref, message?: string | function): Schema\n\nSet the maximum date allowed, When a string is provided it will attempt to cast to a date first\nand use the result as the limit.arrayDefine an array schema. Arrays can be typed or not, When specifying the element type, cast and isValid\nwill apply to the elements as well. Options passed into isValid are passed also passed to child schemas.\nSupports all the same methods as mixed.let schema = yup.array().of(yup.number().min(2));\n\nawait schema.isValid([2, 3]); // => true\nawait schema.isValid([1, -24]); // => false\n\nschema.cast([\"2\", \"3\"]); // => [2, 3]\nYou can also pass a subtype schema to the array constructor as a convenience.array().of(yup.number());\n// or\narray(yup.number());\nThe default cast behavior for array is: JSON.parseFailed casts return: null;",
        "grammar": "lsp",
        "label": "date-max",
        "matches": {
          "yup date max": true
        },
        "options": {}
      },
      {
        "content": "array.of()",
        "doc": "array.of(type: Schema): Schema\n\nSpecify the schema of array elements. of() is optional and when omitted the array schema will\nnot validate its contents.",
        "grammar": "lsp",
        "label": "array-of",
        "matches": {
          "yup array of": true
        },
        "options": {}
      },
      {
        "content": "array.required()",
        "doc": "array.required(message?: string | function): Schema\n\nThe same as the mixed() schema required, except that empty arrays are also considered 'missing' values.",
        "grammar": "lsp",
        "label": "array-required",
        "matches": {
          "yup array required": true
        },
        "options": {}
      },
      {
        "content": "array.min()",
        "doc": "array.min(limit: number | Ref, message?: string | function): Schema\n\nSet a minimum length limit for the array. The ${min} interpolation can be used in the message argument.",
        "grammar": "lsp",
        "label": "array-min",
        "matches": {
          "yup array min": true
        },
        "options": {}
      },
      {
        "content": "array.max()",
        "doc": "array.max(limit: number | Ref, message?: string | function): Schema\n\nSet a maximum length limit for the array. The ${max} interpolation can be used in the message argument.",
        "grammar": "lsp",
        "label": "array-max",
        "matches": {
          "yup array max": true
        },
        "options": {}
      },
      {
        "content": "array.ensure()",
        "doc": "array.ensure(): Schema\n\nEnsures that the value is an array, by setting the default to [] and transforming null and undefined\nvalues to an empty array as well. Any non-empty, non-array value will be wrapped in an array.array()\n  .ensure()\n  .cast(null); // => []\narray()\n  .ensure()\n  .cast(1); // => [1]\narray()\n  .ensure()\n  .cast([1]); // => [1]\n",
        "grammar": "lsp",
        "label": "array-ensure",
        "matches": {
          "yup array ensure": true
        },
        "options": {}
      },
      {
        "content": "array.compact()",
        "doc": "array.compact(rejector: (value) => boolean): Schema\n\nRemoves falsey values from the array. Providing a rejecter function lets you specify the rejection criteria yourself.array()\n  .compact()\n  .cast([\"\", 1, 0, 4, false, null]); // => [1, 4]\n\narray()\n  .compact(function(v) {\n    return v == null;\n  })\n  .cast([\"\", 1, 0, 4, false, null]); // => ['', 1, 0, 4, false]\nobjectDefine an object schema. Options passed into isValid are also passed to child schemas.\nSupports all the same methods as mixed.yup.object().shape({\n  name: string().required(),\n  age: number()\n    .required()\n    .positive()\n    .integer(),\n  email: string().email(),\n  website: string().url()\n});\nYou can also pass a shape to the object constructor as a convenience.object().shape({\n  num: number()\n});\n// or\nobject({\n  num: number()\n});\nThe default cast behavior for object is: JSON.parseFailed casts return: null;",
        "grammar": "lsp",
        "label": "array-compact",
        "matches": {
          "yup array compact": true
        },
        "options": {}
      },
      {
        "content": "object.shape()",
        "doc": "object.shape(fields: object, noSortEdges?: Array<[string, string]>): Schema\n\nDefine the keys of the object and the schemas for said keys.Note that you can chain shape method, which acts like object extends, for example:object({\n  a: string(),\n  b: number()\n}).shape({\n  b: string(),\n  c: number()\n});\nwould be exactly the same as:object({\n  a: string(),\n  b: string(),\n  c: number()\n});\n",
        "grammar": "lsp",
        "label": "object-shape",
        "matches": {
          "yup object shape": true
        },
        "options": {}
      },
      {
        "content": "object.from()",
        "doc": "object.from(fromKey: string, toKey: string, alias: boolean = false): Schema\n\nTransforms the specified key to a new key. If alias is true then the old key will be left.let schema = object({\n  myProp: mixed(),\n  Other: mixed()\n})\n  .from(\"prop\", \"myProp\")\n  .from(\"other\", \"Other\", true);\n\nschema.cast({ prop: 5, other: 6 }); // => { myProp: 5, other: 6, Other: 6 }\n",
        "grammar": "lsp",
        "label": "object-from",
        "matches": {
          "yup object from": true
        },
        "options": {}
      },
      {
        "content": "object.noUnknown()",
        "doc": "object.noUnknown(onlyKnownKeys: boolean = true, message?: string | function): Schema\n\nValidate that the object value only contains keys specified in shape, pass false as the first\nargument to disable the check. Restricting keys to known, also enables stripUnknown option, when not in strict mode.",
        "grammar": "lsp",
        "label": "object-no-unknown",
        "matches": {
          "yup object nounknown": true
        },
        "options": {}
      },
      {
        "content": "object.camelCase()",
        "doc": "object.camelCase(): Schema\n\nTransforms all object keys to camelCase",
        "grammar": "lsp",
        "label": "object-camel-case",
        "matches": {
          "yup object camelcase": true
        },
        "options": {}
      },
      {
        "content": "object.constantCase()",
        "doc": "object.constantCase(): Schema\n\nTransforms all object keys to CONSTANT_CASE.Extending Schema TypesThe simplest way to extend an existing type is just to cache a configured schema and use that through your application.let yup = require(\"yup\");\nlet parseFormats = [\"MMM dd, yyy\"];\nlet invalidDate = new Date(\"\");\n\nmodule.exports = yup.date().transform(function(value, originalValue) {\n  if (this.isType(value)) return value;\n  // the default coercion transform failed so lets try it with Moment instead\n  value = Moment(originalValue, parseFormats);\n  return value.isValid() ? value.toDate() : invalidDate;\n});\nAlternatively, each schema is a normal JavaScript constructor function that you can mutate or delegate to\nusing the normal patterns. Generally you should not inherit from mixed unless you know what you are doing,\nbetter to think of it as an abstract class. The other types are fair game though.You should keep in mind some basic guidelines when extending schemas\nnever mutate an existing schema, always clone() and then mutate the new one before returning it.\nBuilt-in methods like test and transform take care of this for you, so you can safely use them (see below) without worrying\ntransforms should never mutate the value passed in, and should return an invalid object when one exists\n(NaN, InvalidDate, etc) instead of null for bad values.\nby the time validations run the value is guaranteed to be the correct type, however if nullable is\nset then null is a valid value for that type, so don't assume that a property or method exists on the value.\nAdjust core Typeslet invalidDate = new Date(\"\");\n\nfunction parseDateFromFormats(formats, parseStrict) {\n  return this.transform(function(value, originalValue) {\n    if (this.isType(value)) return value;\n\n    value = Moment(originalValue, formats, parseStrict);\n\n    return value.isValid() ? value.toDate() : invalidDate;\n  });\n}\n\n// `addMethod` doesn't do anything special it's\n// equivalent to: yup.date.prototype.format = parseDateFromFormats\nyup.addMethod(yup.date, \"format\", parseDateFromFormats);\nCreating new TypesYup schema use the common constructor pattern for modeling inheritance. You can use any\nutility or pattern that works with that pattern. The below demonstrates using the es6 class\nsyntax since its less verbose, but you absolutely aren't required to use it.let DateSchema = yup.date;\nlet invalidDate = new Date(\"\"); // our failed to coerce value\n\nclass MomentDateSchemaType extends DateSchema {\n  constructor() {\n    super();\n    this._validFormats = [];\n\n    this.withMutation(() => {\n      this.transform(function(value, originalvalue) {\n        if (this.isType(value))\n          // we have a valid value\n          return value;\n        return Moment(originalValue, this._validFormats, true);\n      });\n    });\n  }\n\n  _typeCheck(value) {\n    return (\n      super._typeCheck(value) || (moment.isMoment(value) && value.isValid())\n    );\n  }\n\n  format(formats) {\n    if (!formats) throw new Error(\"must enter a valid format\");\n    let next = this.clone();\n    next._validFormats = {}.concat(formats);\n  }\n}\n\nlet schema = new MomentDateSchemaType();\n\nschema.format(\"YYYY-MM-DD\").cast(\"It is 2012-05-25\"); // => Fri May 25 2012 00:00:00 GMT-0400 (Eastern Daylight Time)\nTypeScript SupportIf you are using TypeScript installing the Yup typings is recommendednpm install -D @types/yup\nYou can now infer a TypeScript type alias using the exported InferType. Given the following Yup schema:import * as yup from 'yup';\n\nconst personSchema = yup.object({\n  firstName: yup\n    .string(),\n  nickName: yup\n    .string()\n    .nullable(),\n  gender: yup\n    .mixed<'male' | 'female' | 'other'>()\n    .oneOf(['male', 'female', 'other']),\n  email: yup\n    .string()\n    .nullable()\n    .notRequired()\n    .email(),\n  birthDate: yup\n    .date()\n    .nullable()\n    .notRequired()\n    .min(new Date(1900, 0, 1)),\n});\nYou can derive the TypeScript type as follows:type Person = yup.InferType<typeof personSchema>;\nWhich is equivalent to the following TypeScript type alias:type Person = {\n  firstName: string;\n  nickName: string | null;\n  gender: \"male\" | \"female\" | \"other\";\n  email?: string | null | undefined;\n  birthDate?: Date | null | undefined;\n}\nMaking the following objects valid both for TypeScript and Yup validation:const minimalPerson: Person = {\n    firstName: \"Matt\",\n    nickName: null,\n    gender: \"male\"\n};\n\nconst fullPerson: Person = {\n    firstName: \"Matt\",\n    nickName: \"The Hammer\",\n    gender: \"male\",\n    email: \"matt@the-hammer.com\",\n    birthDate: new Date(1976, 9, 5)\n};\n",
        "grammar": "lsp",
        "label": "object-constant-case",
        "matches": {
          "yup object constantcase": true
        },
        "options": {}
      }
    ],
    "zsh": [
      {
        "content": "#!/bin/zsh",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "#!": true
        },
        "options": {}
      },
      {
        "content": "if ${1:condition}; then\n\t${0:${VISUAL}}\nfi",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "if": true
        },
        "options": {}
      },
      {
        "content": "if ${1:condition}; then\n\t${2:${VISUAL}}\nelse\n\t${0:# statements}\nfi",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ife": true
        },
        "options": {}
      },
      {
        "content": "elif ${1:condition}; then\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "eif": true
        },
        "options": {}
      },
      {
        "content": "for (( ${2:i} = 0; $2 < ${1:count}; $2++ )); do\n\t${0:${VISUAL}}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "for": true
        },
        "options": {}
      },
      {
        "content": "for ${1:needle} in ${2:haystack}; do\n\t${0:${VISUAL}}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fori": true
        },
        "options": {}
      },
      {
        "content": "for ${1:item} in ${2:list}; do\n\t${0:${VISUAL}}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fore": true
        },
        "options": {}
      },
      {
        "content": "while ${1:condition}; do\n\t${0:${VISUAL}}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "wh": true
        },
        "options": {}
      },
      {
        "content": "until ${1:condition}; do\n\t${0:${VISUAL}}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "until": true
        },
        "options": {}
      },
      {
        "content": "repeat ${1:integer}; do\n\t${0:${VISUAL}}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "repeat": true
        },
        "options": {}
      },
      {
        "content": "case ${1:word} in\n\t${2:pattern})\n\t\t${0};;\nesac",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "case": true
        },
        "options": {}
      },
      {
        "content": "select ${1:answer} in ${2:choices}; do\n\t${0:${VISUAL}}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "select": true
        },
        "options": {}
      },
      {
        "content": "( ${0:#statements} )",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "(": true
        },
        "options": {}
      },
      {
        "content": "{ ${0:#statements} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "{": true
        },
        "options": {}
      },
      {
        "content": "[[ ${0:test} ]]",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "[": true
        },
        "options": {}
      },
      {
        "content": "{ ${1:try} } always { ${0:always} }",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "always": true
        },
        "options": {}
      },
      {
        "content": "${1:function_name}() {\n\t${0:# function_body}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "fun": true
        },
        "options": {}
      },
      {
        "content": "function ${1:function_name}() {\n\t${0:# function_body}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "",
        "matches": {
          "ffun": true
        },
        "options": {}
      },
      {
        "content": "#!/usr/bin/env zsh\n$0",
        "doc": "",
        "grammar": "snu",
        "label": "#!/usr/bin/env zsh",
        "matches": {
          "#!": true
        },
        "options": {
          "b": true
        }
      }
    ]
  }
}