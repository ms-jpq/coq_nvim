{
  "extends": {
    "Gemfile": [],
    "_": [],
    "actionscript": [],
    "ada": [],
    "all": [],
    "alpaca": [],
    "angular": [],
    "angular_coffee": [],
    "apache": [],
    "applescript": [],
    "arduino": [],
    "asciidoc": [],
    "asciidoctor": [
      "asciidoc"
    ],
    "asm": [],
    "autoit": [],
    "awk": [],
    "axios": [],
    "base": [],
    "beancount": [],
    "bib": [],
    "bindzone": [],
    "blade": [
      "html"
    ],
    "c": [],
    "chef": [],
    "classnames": [],
    "clojure": [],
    "cmake": [],
    "codeigniter": [],
    "coffee": [],
    "coffee-jasmine": [
      "coffee"
    ],
    "coffee-react": [
      "coffee"
    ],
    "cpp": [
      "c"
    ],
    "crystal": [],
    "cs": [],
    "css": [],
    "cuda": [
      "cpp"
    ],
    "cypress": [],
    "d": [
      "c"
    ],
    "dart": [],
    "dart-flutter": [],
    "diff": [],
    "django": [],
    "dockerfile": [],
    "dosini": [],
    "dotenv": [],
    "dotenv-safe": [],
    "eelixir": [
      "html"
    ],
    "ejs": [],
    "elixir": [],
    "elm": [],
    "erlang": [],
    "eruby": [
      "html"
    ],
    "falcon": [],
    "fortran": [],
    "framer-motion": [],
    "freemarker": [
      "html"
    ],
    "fsharp": [],
    "gatsby": [],
    "gatsby-image": [],
    "gitcommit": [],
    "gnuplot": [],
    "go": [],
    "graphql-request": [],
    "groovy": [],
    "haml": [],
    "handlebars": [],
    "haskell": [],
    "helm": [],
    "help": [],
    "html": [],
    "html_minimal": [],
    "htmldjango": [
      "html"
    ],
    "htmljinja": [
      "jinja2",
      "html"
    ],
    "htmltornado": [],
    "idris": [],
    "ignore": [],
    "jade": [],
    "java": [],
    "javascript": [],
    "javascript-angular": [],
    "javascript-bemjson": [],
    "javascript-d3": [],
    "javascript-ember": [],
    "javascript-jasmine": [],
    "javascript-jasmine-arrow": [],
    "javascript-jquery": [],
    "javascript-jsdoc": [],
    "javascript-mocha": [],
    "javascript-node": [],
    "javascript-openui5": [],
    "javascript-react": [],
    "javascript-redux": [],
    "javascript-requirejs": [],
    "javascript.node": [],
    "javascript_react": [],
    "jenkins": [],
    "jest": [],
    "jinja": [
      "html"
    ],
    "jinja2": [],
    "jquery_coffee": [],
    "json": [],
    "jsonc": [],
    "jsp": [],
    "julia": [],
    "kotlin": [],
    "kp19pp": [],
    "laravel": [],
    "ledger": [],
    "lfe": [],
    "lhaskell": [
      "haskell"
    ],
    "liquid": [],
    "lodash": [],
    "lpc": [],
    "ls": [],
    "lua": [],
    "make": [],
    "mako": [],
    "markdown": [],
    "matlab": [],
    "mediawiki": [],
    "mkd": [
      "markdown"
    ],
    "moon": [],
    "mustache": [],
    "neosnippet": [],
    "next": [],
    "nim": [],
    "nuxt": [],
    "nuxt-config": [],
    "nuxt-script": [],
    "objc": [],
    "ocaml": [],
    "octave": [
      "matlab"
    ],
    "openfoam": [],
    "pandoc": [
      "markdown"
    ],
    "perl": [],
    "perl6": [],
    "phoenix": [],
    "php": [],
    "php-laravel": [],
    "php-phpspec": [],
    "php-symfony2": [],
    "plsql": [],
    "po": [],
    "processing": [],
    "progress": [],
    "prolog": [],
    "prop-types": [],
    "proto": [],
    "ps1": [],
    "puppet": [],
    "purescript": [],
    "python": [],
    "r": [],
    "r-snippets": [],
    "racket": [],
    "rails": [],
    "react": [],
    "react-helmet": [],
    "react-intersection-observer": [],
    "react-modal": [],
    "reason": [],
    "redux": [],
    "redux-thunk": [],
    "requirejs_coffee": [],
    "rmarkdown": [],
    "rmd": [],
    "rnoweb": [
      "tex",
      "r"
    ],
    "robot": [],
    "rst": [],
    "ruby": [],
    "rust": [],
    "sass": [],
    "scala": [],
    "scheme": [],
    "scss": [
      "css"
    ],
    "sh": [],
    "simplemvcf": [],
    "slim": [],
    "snippets": [],
    "snippets-ts": [],
    "soy": [
      "html"
    ],
    "sql": [],
    "sshconfig": [],
    "styled-components": [],
    "stylus": [],
    "supercollider": [],
    "svelte": [
      "css",
      "javascript",
      "html"
    ],
    "swift": [],
    "systemverilog": [
      "verilog"
    ],
    "tcl": [],
    "tex": [
      "texmath"
    ],
    "texmath": [],
    "textile": [],
    "toml": [],
    "ts-snippets": [],
    "twig": [],
    "typescript": [
      "javascript"
    ],
    "typescriptreact": [
      "typescript"
    ],
    "verilog": [],
    "vhdl": [],
    "vim": [],
    "vimshell": [],
    "vimspec": [
      "vim"
    ],
    "vimwiki": [],
    "vital": [],
    "vue": [
      "css",
      "javascript",
      "html"
    ],
    "vue-pug": [],
    "vue-script": [],
    "vue-script-router": [],
    "vue-script-vuex": [],
    "vue-template": [],
    "vuex": [],
    "xhtml": [
      "html"
    ],
    "xml": [],
    "xslt": [],
    "yii": [],
    "yii-chtml": [],
    "yup": [],
    "zsh": [
      "sh"
    ]
  },
  "snippets": {
    "Gemfile": [
      {
        "content": "source :rubygems",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "source-rubygems"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "gem '${1}', '${2} >= 1.0'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gem"
        ],
        "opts": [
          "head"
        ]
      }
    ],
    "_": [
      {
        "content": "`strftime(\"%d %b %Y\")`${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "date_english"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "`strftime(\"%Y-%m-%dT%H:%M:%S\")`${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "df",
          "datetime_iso8601"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "`strftime(\"%Y-%m-%d\")`${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dd",
          "date_iso8601"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "`strftime(\"%H:%M:%S\")`${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dt",
          "time_colon"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "Last Modified: `strftime(\"%Y-%m-%dT%H:%M:%S\")`${0}",
        "doc": "",
        "grammar": "snu",
        "label": "Last modified time",
        "matches": [
          "lmod",
          "lastmod"
        ],
        "opts": []
      },
      {
        "content": "`bufname('%') ==#'[Command Line]' ? expand('#') : expand('%')`${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fname",
          "filename"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "`substitute(bufname('%') ==#'[Command Line]' ? expand('#:p') : expand('%:p'), '//\\+', '/', 'g')`${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "path"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "`substitute(bufname('%') ==#'[Command Line]' ? expand('#:h') : expand('%:h'), '\\(//*\\|/*$\\)', '/', 'g')`${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rpath"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "`bufname('%') ==#'[Command Line]' ? expand('#:t:r:r:r') : expand('%:t:r:r:r')`${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bname",
          "basename"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "`substitute(bufname('%') ==#'[Command Line]' ? expand('#:t:r:r:r') : expand('%:t:r:r:r'), '\\%(^\\(.\\)\\|_\\(.\\)\\)', '\\u\\1\\u\\2', 'g')`${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "filename_upper_camel",
          "fnameuc"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "`substitute(bufname('%') ==#'[Command Line]' ? expand('#:t:r:r:r') : expand('%:t:r:r:r'), '\\%(_\\(.\\)\\)', '\\u\\1', 'g')`${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "filename_lower_camel",
          "fnamelc"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "Copyright `&enc[:2] == \"utf\" ? \"©\" : \"(c)\"` `strftime(\"%Y\")` ${1:`g:snips_author`}. All Rights Reserved.",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "c)"
        ],
        "opts": []
      },
      {
        "content": "`strftime(\"%Y-%m-%d\")`",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "date"
        ],
        "opts": []
      },
      {
        "content": "`strftime(\"%B %d, %Y\")`",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ddate"
        ],
        "opts": []
      },
      {
        "content": "`strftime(\"%Y-%m-%dT%H:%M:%S\")`",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "diso"
        ],
        "opts": []
      },
      {
        "content": "`strftime(\"%H:%M\")`",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "time"
        ],
        "opts": []
      },
      {
        "content": "`strftime(\"%Y-%m-%d %H:%M\")`",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "datetime"
        ],
        "opts": []
      },
      {
        "content": "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lorem"
        ],
        "opts": []
      },
      {
        "content": "${1:One line to give the program's name and a brief description.}\nCopyright `&enc[:2] == \"utf\" ? \"©\" : \"(c)\"` `strftime(\"%Y\")` ${2:`g:snips_author`}\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\nGNU General Public License for more details.\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, see <http://www.gnu.org/licenses/>.\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "GPL2"
        ],
        "opts": []
      },
      {
        "content": "${1:One line to give the program's name and a brief description.}\nCopyright `&enc[:2] == \"utf\" ? \"©\" : \"(c)\"` `strftime(\"%Y\")` ${2:`g:snips_author`}\nThis library is free software; you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published\nby the Free Software Foundation; either version 2.1 of the License, or\n(at your option) any later version.\nThis library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\nGNU Lesser General Public License for more details.\nYou should have received a copy of the GNU Lesser General Public License\nalong with this library; if not, see <http://www.gnu.org/licenses/>.\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "LGPL2"
        ],
        "opts": []
      },
      {
        "content": "${1:one line to give the program's name and a brief description.}\nCopyright `&enc[:2] == \"utf\" ? \"©\" : \"(c)\"` `strftime(\"%Y\")` ${2:`g:snips_author`}\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "GPL3"
        ],
        "opts": []
      },
      {
        "content": "${1:One line to give the program's name and a brief description.}\nCopyright `&enc[:2] == \"utf\" ? \"©\" : \"(c)\"` `strftime(\"%Y\")` ${2:`g:snips_author`}\nThis library is free software; you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published\nby the Free Software Foundation; either version 3 of the License, or\n(at your option) any later version.\nThis library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\nGNU Lesser General Public License for more details.\nYou should have received a copy of the GNU Lesser General Public License\nalong with this library; if not, see <http://www.gnu.org/licenses/>.\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "LGPL3"
        ],
        "opts": []
      },
      {
        "content": "${1:one line to give the program's name and a brief description.}\nCopyright `&enc[:2] == \"utf\" ? \"©\" : \"(c)\"` `strftime(\"%Y\")` ${2:`g:snips_author`}\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU Affero General Public License as\npublished by the Free Software Foundation, either version 3 of the\nLicense, or (at your option) any later version.\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Affero General Public License for more details.\nYou should have received a copy of the GNU Affero General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "AGPL3"
        ],
        "opts": []
      },
      {
        "content": "As a special exception, if other files instantiate generics from\nthis unit, or you link this unit with other files to produce an\nexecutable, this unit does not by itself cause the resulting\nexecutable to be covered by the GNU General Public License.\nThis exception does not however invalidate any other reasons why the\nexecutable file might be covered by the GNU Public License.\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "GMGPL linking exception"
        ],
        "opts": []
      },
      {
        "content": "${1:one line to give the program's name and a brief description}\nCopyright `&enc[:2] == \"utf\" ? \"©\" : \"(c)\"` `strftime(\"%Y\")` ${2:`g:snips_author`}\nAll rights reserved.\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\nnotice, this list of conditions and the following disclaimer in the\ndocumentation and/or other materials provided with the distribution.\nTHIS SOFTWARE IS PROVIDED BY $2 ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL $2 BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nThe views and conclusions contained in the software and documentation\nare those of the authors and should not be interpreted as representing\nofficial policies, either expressed or implied, of $2.\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "BSD2"
        ],
        "opts": []
      },
      {
        "content": "${1:one line to give the program's name and a brief description}\nCopyright `&enc[:2] == \"utf\" ? \"©\" : \"(c)\"` `strftime(\"%Y\")` ${2:`g:snips_author`}\nAll rights reserved.\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\nnotice, this list of conditions and the following disclaimer in the\ndocumentation and/or other materials provided with the distribution.\n3. Neither the name of the ${3:organization} nor the\nnames of its contributors may be used to endorse or promote products\nderived from this software without specific prior written permission.\nTHIS SOFTWARE IS PROVIDED BY $2 ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL $2 BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "BSD3"
        ],
        "opts": []
      },
      {
        "content": "${1:one line to give the program's name and a brief description}\nCopyright `&enc[:2] == \"utf\" ? \"©\" : \"(c)\"` `strftime(\"%Y\")` ${2:`g:snips_author`}\nAll rights reserved.\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\nnotice, this list of conditions and the following disclaimer in the\ndocumentation and/or other materials provided with the distribution.\n3. All advertising materials mentioning features or use of this software\nmust display the following acknowledgement:\nThis product includes software developed by the ${3:organization}.\n4. Neither the name of the $3 nor the\nnames of its contributors may be used to endorse or promote products\nderived from this software without specific prior written permission.\nTHIS SOFTWARE IS PROVIDED BY $2 ''AS IS'' AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL $2 BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "BSD4"
        ],
        "opts": []
      },
      {
        "content": "${1:one line to give the program's name and a brief description}\nCopyright `&enc[:2] == \"utf\" ? \"©\" : \"(c)\"` `strftime(\"%Y\")` ${2:`g:snips_author`}\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the \"Software\"),\nto deal in the Software without restriction, including without limitation\nthe rights to use, copy, modify, merge, publish, distribute, sublicense,\nand/or sell copies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\nDAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\nOR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "MIT"
        ],
        "opts": []
      },
      {
        "content": "${1:one line to give the program's name and a brief description}\nCopyright `strftime(\"%Y\")` ${2:`g:snips_author`}\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\thttp://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "APACHE"
        ],
        "opts": []
      },
      {
        "content": "${1:one line to give the program's name and a brief description}\nCopyright `strftime(\"%Y\")` ${2:`g:snips_author`}\nLicensed under the \"THE BEER-WARE LICENSE\" (Revision 42):\n$2 wrote this file. As long as you retain this notice you\ncan do whatever you want with this stuff. If we meet some day, and you think\nthis stuff is worth it, you can buy me a beer or coffee in return\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "BEERWARE"
        ],
        "opts": []
      },
      {
        "content": "\t\tDO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE\n\t\t\t\tVersion 2, December 2004\nCopyright `strftime(\"%Y\")` ${0:`g:snips_author`}\nEveryone is permitted to copy and distribute verbatim or modified\ncopies of this license document, and changing it is allowed as long\nas the name is changed.\n\t\tDO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE\nTERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n 0. You just DO WHAT THE FUCK YOU WANT TO.\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "WTFPL"
        ],
        "opts": []
      },
      {
        "content": "This Source Code Form is subject to the terms of the Mozilla Public\nLicense, v. 2.0. If a copy of the MPL was not distributed with this\nfile, You can obtain one at http://mozilla.org/MPL/2.0/.\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "MPL2"
        ],
        "opts": []
      },
      {
        "content": "${1:One line to give the program's name and a brief description.}\nCopyright `&enc[:2] == \"utf\" ? \"©\" : \"(c)\"` `strftime(\"%Y\")` ${2:`g:snips_author`}\nThis program  is free software: you can redistribute it and/or modify\nit under the terms of the GNU Affero General Public License as\npublished by the Free Software Foundation, either version 3 of the\nLicense, or (at your option) any later version.\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Affero General Public License for more details.\nYou should have received a copy of the GNU Affero General Public License\nalong with this program. If not, see <http://www.gnu.org/licenses/>.",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "AGPL"
        ],
        "opts": []
      },
      {
        "content": "${1:one line to give the program's name and a brief description}\nCopyright `&enc[:2] == \"utf\" ? \"©\" : \"(c)\"` `strftime(\"%Y\")`, ${2:`g:snips_author`}\nPermission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies.\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ISC"
        ],
        "opts": []
      }
    ],
    "actionscript": [
      {
        "content": "#endinitclip",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ec"
        ],
        "opts": []
      },
      {
        "content": "#include \"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "inc"
        ],
        "opts": []
      },
      {
        "content": "break;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "br"
        ],
        "opts": []
      },
      {
        "content": "call(${1:#:frame});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ca"
        ],
        "opts": []
      },
      {
        "content": "case ${1:#:expression} :\n\t${1:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "ce",
        "matches": [
          "case"
        ],
        "opts": []
      },
      {
        "content": "catch ($1) {\n\t$2\n}",
        "doc": "",
        "grammar": "snu",
        "label": "ch",
        "matches": [
          "catch"
        ],
        "opts": []
      },
      {
        "content": "class ${1:#:ClassName} {\n\tvar _${2};\n\tfunction ${1}(${2}){\n\t\t_${2} = ${2};${0}\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "class"
        ],
        "opts": []
      },
      {
        "content": "continue;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "co"
        ],
        "opts": []
      },
      {
        "content": "default :\n\t${1:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dt"
        ],
        "opts": []
      },
      {
        "content": "delete ${1};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "de"
        ],
        "opts": []
      },
      {
        "content": "do {\n\t${1:TARGET}\n} while (${2:#:condition});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "do"
        ],
        "opts": []
      },
      {
        "content": "duplicateMovieClip(${1:#:target}, ${2:#:newName}, ${3:#:depth});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dm"
        ],
        "opts": []
      },
      {
        "content": "else if (${1}) {\n\t${2:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ei"
        ],
        "opts": []
      },
      {
        "content": "for (var ${1} in ${2}){\n\t${3:TARGET}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "fi",
        "matches": [
          "fori"
        ],
        "opts": []
      },
      {
        "content": "for (var ${1} = 0; $1 < ${2}.length; $1++) {\n\t${0:TARGET}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "fr",
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "fscommand(${1:#:command}, ${2:#:paramaters});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fs"
        ],
        "opts": []
      },
      {
        "content": "function ${1}(${2}):${3}{\n\t${0:TARGET}\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fn"
        ],
        "opts": []
      },
      {
        "content": "getURL(${1});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gu"
        ],
        "opts": []
      },
      {
        "content": "gotoAndPlay(${1});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gp"
        ],
        "opts": []
      },
      {
        "content": "gotoAndStop(${1});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gs"
        ],
        "opts": []
      },
      {
        "content": "if (${1}) {\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "ifFrameLoaded (${1}) {\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "il"
        ],
        "opts": []
      },
      {
        "content": "import ${1};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ip"
        ],
        "opts": []
      },
      {
        "content": "interface ${1}{\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "it"
        ],
        "opts": []
      },
      {
        "content": "loadMovie(${1:url}, ${2:target}, ${3:method});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lm"
        ],
        "opts": []
      },
      {
        "content": "loadMovieNum(${1:url}, ${2:level}, ${3:method});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ln"
        ],
        "opts": []
      },
      {
        "content": "loadVariables(${1:url}, ${2:target}, ${3:method});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lv"
        ],
        "opts": []
      },
      {
        "content": "loadVariables(${1:url}, ${2:level}, ${3:method});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vn"
        ],
        "opts": []
      },
      {
        "content": "MovieClip",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mc"
        ],
        "opts": []
      },
      {
        "content": "nextFrame();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nf"
        ],
        "opts": []
      },
      {
        "content": "nextScene();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ns"
        ],
        "opts": []
      },
      {
        "content": "on (${1}) {\n\t${2}\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "on"
        ],
        "opts": []
      },
      {
        "content": "onClipEvent (${1}) {\n\t${0:TARGET}\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "oc"
        ],
        "opts": []
      },
      {
        "content": "play();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pl"
        ],
        "opts": []
      },
      {
        "content": "pravFrame();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pf"
        ],
        "opts": []
      },
      {
        "content": "prevScene();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ps"
        ],
        "opts": []
      },
      {
        "content": "print(${1:#:target}, ${2:#:type});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pr"
        ],
        "opts": []
      },
      {
        "content": "printAsBitmapNum(${1:#:level}, ${2:#:type});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bn"
        ],
        "opts": []
      },
      {
        "content": "printNum(${1:#:level}, ${2:#:type});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pn"
        ],
        "opts": []
      },
      {
        "content": "removeMovieClip(${1:#:target});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rm"
        ],
        "opts": []
      },
      {
        "content": "return ${1};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rt"
        ],
        "opts": []
      },
      {
        "content": "setProperty(${1:#:target}, ${2:#:property}, ${3:#:value});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sp"
        ],
        "opts": []
      },
      {
        "content": "set(${1:#:name}, ${2:#:value});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sv"
        ],
        "opts": []
      },
      {
        "content": "startDrag(${1:#:target}, ${2:#:lockcenter}, ${3:#:l}, ${4:#:t}, ${5:#:r}, ${6:#:b} );",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dr"
        ],
        "opts": []
      },
      {
        "content": "stop();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "st"
        ],
        "opts": []
      },
      {
        "content": "stopAllSounds();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ss"
        ],
        "opts": []
      },
      {
        "content": "stopDrag();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sd"
        ],
        "opts": []
      },
      {
        "content": "switch ( ${1:#:condition} ) {\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sw"
        ],
        "opts": []
      },
      {
        "content": "tellTarget( ${1:#:target} ) {\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tt"
        ],
        "opts": []
      },
      {
        "content": "throw ${1};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "th"
        ],
        "opts": []
      },
      {
        "content": "toggleHighQuality();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tq"
        ],
        "opts": []
      },
      {
        "content": "trace(${1:\"$0\"});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tr"
        ],
        "opts": []
      },
      {
        "content": "try {\n\t${0:TARGET}\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ty"
        ],
        "opts": []
      },
      {
        "content": "unloadMovie(${1:#:target});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "um"
        ],
        "opts": []
      },
      {
        "content": "unloadMovieNum(${1:#:level});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "un"
        ],
        "opts": []
      },
      {
        "content": "var ${1}:${2};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vr"
        ],
        "opts": []
      },
      {
        "content": "while (${1:#:condition}) {\n\t${0:TARGET}\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh"
        ],
        "opts": []
      },
      {
        "content": "with (${1:#:target});\n\t${0:TARGET}\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wt"
        ],
        "opts": []
      },
      {
        "content": "package {\n\timport flash.display.*;\n\timport flash.Events.*;\n\tpublic class Main extends Sprite {\n\t\tpublic function Main (\t) {\n\t\t\ttrace(\"start\");\n\t\t\tstage.scaleMode = StageScaleMode.NO_SCALE;\n\t\t\tstage.addEventListener(Event.RESIZE, resizeListener);\n\t\t}\n\t\tprivate function resizeListener (e:Event):void {\n\t\t\ttrace(\"The application window changed size!\");\n\t\t\ttrace(\"New width:  \" + stage.stageWidth);\n\t\t\ttrace(\"New height: \" + stage.stageHeight);\n\t\t}\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "main"
        ],
        "opts": []
      },
      {
        "content": "${1:public|internal} class ${2:name} ${0:extends } {\n\tpublic function $2 (\t) {\n\t\t(\"start\");\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "class"
        ],
        "opts": []
      },
      {
        "content": "package name {\n\t${1:public|internal|final} class ${2:name} ${0:extends } {\n\t\tprivate|public| static const FOO = \"abc\";\n\t\tprivate|public| static var BAR = \"abc\";\n\t\t// class initializer - no JIT !! one time setup\n\t\tif Cababilities.os == \"Linux|MacOS\" {\n\t\t\tFOO = \"other\";\n\t\t}\n\t\t// constructor:\n\t\tpublic function $2 (\t){\n\t\t\tsuper2();\n\t\t\ttrace(\"start\");\n\t\t}\n\t\tpublic function name (a, b...){\n\t\t\tsuper.name(..);\n\t\t\tlable:break\n\t\t}\n\t}\n}\nfunction A(){\n\t// A can only be accessed within this file\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "all"
        ],
        "opts": []
      },
      {
        "content": "switch(${1}){\n\tcase ${2}:\n\t\t${0}\n\tbreak;\n\tdefault:\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "switch"
        ],
        "opts": []
      },
      {
        "content": "case ${1}:\n\t${0}\nbreak;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case"
        ],
        "opts": []
      },
      {
        "content": "package ${1:package}{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "package"
        ],
        "opts": []
      },
      {
        "content": "while ${1:cond}{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh"
        ],
        "opts": []
      },
      {
        "content": "do {\n\t${0}\n} while (${1:cond})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "do"
        ],
        "opts": []
      },
      {
        "content": "for (${1:var} in ${2:object}){\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for enumerate names"
        ],
        "opts": []
      },
      {
        "content": "for each (${1:var} in ${2:object}){\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for enumerate values"
        ],
        "opts": []
      },
      {
        "content": "function get ${1:name} {\n\treturn ${2}\n}\nfunction set $1 (newValue) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "get_set"
        ],
        "opts": []
      },
      {
        "content": "interface name {\n\tfunction method(${1}):${0:returntype};\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "interface"
        ],
        "opts": []
      },
      {
        "content": "try {\n\t${1:${VISUAL}}\n} catch (error:ErrorType) {\n\t${2}\n} finally {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "try"
        ],
        "opts": []
      },
      {
        "content": "for (${2:i} = 0; $2 < ${1:count}; $2${3:++}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for for (..) {..}"
        ],
        "opts": []
      },
      {
        "content": "for (${1:i} = ${2:0}; ${3:$1 < 10}; $1${4:++}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forr"
        ],
        "opts": []
      },
      {
        "content": "if (${1:/* condition */}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "else {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "el"
        ],
        "opts": []
      },
      {
        "content": "${1:/* condition */} ? ${2:a} : ${0:b}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "t"
        ],
        "opts": []
      },
      {
        "content": "function ${1:function_name}(${2})${3}\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fun"
        ],
        "opts": []
      },
      {
        "content": "package\n{\n\timport org.flixel.*\n\tpublic class ${1:ClassName} extends ${2:FlxSprite}\n\t{\n\t\tpublic function $1(${3: X:Number, Y:Number}):void\n\t\t{\n\t\t\tsuper(X,Y);\n\t\t\t${4}\n\t\t}\n\t\toverride public function update():void\n\t\t{\n\t\t\tsuper.update();\n\t\t\t${0}\n\t\t}\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "FlxSprite"
        ],
        "opts": []
      }
    ],
    "ada": [
      {
        "content": "with ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": "with ...;...",
        "matches": [
          "with"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "package ${1} is\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": "package {NAME} is {...} end",
        "matches": [
          "package"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "package body ${1} is\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": "package body {NAME} is {...} end",
        "matches": [
          "package_body"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "entry ${1}(${2}) when ${3} is\nbegin\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": "entry {...} when",
        "matches": [
          "entry"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "task ${1} is\n\tentry ${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "task"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "task body ${1} is\n\t${2}\nbegin\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": "task body",
        "matches": [
          "task_body"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "accept ${1}(${2}) do\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "accept"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "protected type ${1}(${2}) is\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": "protected type",
        "matches": [
          "protected_type"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "protected body ${1} is\n\t${2}\nbegin\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": "protected body",
        "matches": [
          "protected_body"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "generic\n\ttype ${1} is ${2};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "generic type",
        "matches": [
          "generic"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "type ${1} is ${2};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "type"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "type ${1} is ${2}\n\twith Default_Value => ${3};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "type with default value",
        "matches": [
          "type_default"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "subtype ${1} is ${2};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "subtype"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "declare\n\t${1}\nbegin\n\t${0}\nend;",
        "doc": "",
        "grammar": "snu",
        "label": "declare block",
        "matches": [
          "declare"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "${1}:\ndeclare\n\t${2}\nbegin\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": "declare named block",
        "matches": [
          "declare_named"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "if ${1} then ${2} else ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "if expression",
        "matches": [
          "ife"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "case ${1} is\n\twhen ${2} => ${3},${0}",
        "doc": "",
        "grammar": "snu",
        "label": "case expression",
        "matches": [
          "case_expression"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "for all ${1} ${2:in} ${3} => ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "for all",
        "matches": [
          "for_all"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "for some ${1} ${2:in} ${3} => ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "for some",
        "matches": [
          "for_some"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "if ${1} then\n\t${0}\nend if;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "if ${1} then\n\t${2}\nelse\n\t${0}\nend if;",
        "doc": "",
        "grammar": "snu",
        "label": "if ... else",
        "matches": [
          "ifelse"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "else\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "else"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "elsif ${1} then\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "elseif",
          "ei"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "while ${1} loop\n\t${0}\nend loop;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "while",
          "w"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "${1}:\nwhile ${2} loop\n\t${0}\nend loop $1;",
        "doc": "",
        "grammar": "snu",
        "label": "named while",
        "matches": [
          "named_while"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "for ${1:I} in ${2} loop\n\t${0}\nend loop;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "for ${1} of ${2} loop\n\t${0}\nend loop;",
        "doc": "",
        "grammar": "snu",
        "label": "for each",
        "matches": [
          "for_each"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "${1}:\nfor ${2:I} in ${3} loop\n\t${0}\nend loop $1;",
        "doc": "",
        "grammar": "snu",
        "label": "named for",
        "matches": [
          "named_for"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "${1}:\nfor ${2} of ${3} loop\n\t${0}\nend loop $1;",
        "doc": "",
        "grammar": "snu",
        "label": "named for each",
        "matches": [
          "named_for_each"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "procedure ${1}(${2}) is\n\t${3}\nbegin\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "procedure"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "procedure ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "procedure declaration",
        "matches": [
          "procedure_declare"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "function ${1}(${2}) return ${3} is\n\t${4}\nbegin\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "function"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "function ${1} return ${2} is\n\t(${3});${0}",
        "doc": "",
        "grammar": "snu",
        "label": "expression function",
        "matches": [
          "function_expr"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "function ${1} return ${2};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "function declaration",
        "matches": [
          "function_declare"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "return ${1} do\n\t${0}\nend return;",
        "doc": "",
        "grammar": "snu",
        "label": "extended return",
        "matches": [
          "return"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "record\n\t${0}\nend record;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "record"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "case ${1} is\n\twhen ${2} => ${3};${0}\nend case;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "when ${1} => ${2};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "when"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "when others => ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": "when others",
        "matches": [
          "when_others"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "loop\n\t${0}\nend loop;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "loop"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "${1}:\nloop\n\t${0}\nend loop $1;",
        "doc": "",
        "grammar": "snu",
        "label": "named loop",
        "matches": [
          "named_loop"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "exit when ${1};\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "exit when",
        "matches": [
          "exit_when"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "Ada.Text_IO.Put(${1});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "Ada.Text_IO.Put",
        "matches": [
          "put"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "Ada.Text_IO.Put_Line(${1});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "Ada.Text_IO.Put_Line",
        "matches": [
          "put_line"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "Ada.Text_IO.Get(${1});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "Ada.Text_IO.Get",
        "matches": [
          "get"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "Ada.Text_IO.Get_Line(${1});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "Ada.Text_IO.Get_Line",
        "matches": [
          "get_line"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "Ada.Text_IO.New_Line(${1:1});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "Ada.Text_IO.New_Line",
        "matches": [
          "newline"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "with ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wi with"
        ],
        "opts": []
      },
      {
        "content": "package ${1} is\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pac package"
        ],
        "opts": []
      },
      {
        "content": "package body ${1} is\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pacb package body"
        ],
        "opts": []
      },
      {
        "content": "entry ${1}(${2}) when ${3} is\nbegin\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ent entry ... when"
        ],
        "opts": []
      },
      {
        "content": "task ${1} is\n\tentry ${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "task task"
        ],
        "opts": []
      },
      {
        "content": "task body ${1} is\n\t${2}\nbegin\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "taskb task body"
        ],
        "opts": []
      },
      {
        "content": "accept ${1}(${2}) do\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "acc accept"
        ],
        "opts": []
      },
      {
        "content": "protected type ${1}(${2}) is\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prot protected type"
        ],
        "opts": []
      },
      {
        "content": "protected body ${1} is\n\t${2}\nbegin\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prob protected body"
        ],
        "opts": []
      },
      {
        "content": "generic\n\ttype ${1} is ${2};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gen generic type"
        ],
        "opts": []
      },
      {
        "content": "type ${1} is ${2};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ty type"
        ],
        "opts": []
      },
      {
        "content": "type ${1} is ${2}\n\twith Default_Value => ${3};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tyd type with default value"
        ],
        "opts": []
      },
      {
        "content": "subtype ${1} is ${2};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "subty subtype"
        ],
        "opts": []
      },
      {
        "content": "declare\n\t${1}\nbegin\n\t${0}\nend;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dec declare block"
        ],
        "opts": []
      },
      {
        "content": "${1}:\ndeclare\n\t${2}\nbegin\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "decn declare named block"
        ],
        "opts": []
      },
      {
        "content": "if ${1} then ${2} else ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifex if expression"
        ],
        "opts": []
      },
      {
        "content": "case ${1} is\n\twhen ${2} => ${3},${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "casex case expression"
        ],
        "opts": []
      },
      {
        "content": "for all ${1} ${2:in} ${3} => ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fora for all"
        ],
        "opts": []
      },
      {
        "content": "for some ${1} ${2:in} ${3} => ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fors for some"
        ],
        "opts": []
      },
      {
        "content": "if ${1} then\n\t${0:${VISUAL}}\nend if;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if if"
        ],
        "opts": []
      },
      {
        "content": "if ${1} then\n\t${2:${VISUAL}}\nelse\n\t${0}\nend if;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife if ... else"
        ],
        "opts": []
      },
      {
        "content": "else\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "el else"
        ],
        "opts": []
      },
      {
        "content": "elsif ${1} then\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eif elsif"
        ],
        "opts": []
      },
      {
        "content": "while ${1} loop\n\t${0:${VISUAL}}\nend loop;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh while"
        ],
        "opts": []
      },
      {
        "content": "${1}:\nwhile ${2} loop\n\t${0:${VISUAL}}\nend loop $1;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nwh named while"
        ],
        "opts": []
      },
      {
        "content": "for ${1:I} in ${2} loop\n\t${0}\nend loop;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for for"
        ],
        "opts": []
      },
      {
        "content": "for ${1} of ${2} loop\n\t${0}\nend loop;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fore for each"
        ],
        "opts": []
      },
      {
        "content": "${1}:\nfor ${2:I} in ${3} loop\n\t${0}\nend loop $1;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nfor named for"
        ],
        "opts": []
      },
      {
        "content": "${1}:\nfor ${2} of ${3} loop\n\t${0}\nend loop $1;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nfore named for each"
        ],
        "opts": []
      },
      {
        "content": "procedure ${1}(${2}) is\n\t${3}\nbegin\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "proc procedure"
        ],
        "opts": []
      },
      {
        "content": "procedure ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "procd procedure declaration"
        ],
        "opts": []
      },
      {
        "content": "function ${1}(${2}) return ${3} is\n\t${4}\nbegin\n\t${0}\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fun function"
        ],
        "opts": []
      },
      {
        "content": "function ${1} return ${2} is\n\t(${3});${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fune expression function"
        ],
        "opts": []
      },
      {
        "content": "function ${1} return ${2};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fund function declaration"
        ],
        "opts": []
      },
      {
        "content": "return ${1} do\n\t${0}\nend return;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ret extended return"
        ],
        "opts": []
      },
      {
        "content": "record\n\t${0}\nend record;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rec record"
        ],
        "opts": []
      },
      {
        "content": "case ${1} is\n\twhen ${2} => ${3};${0}\nend case;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case case"
        ],
        "opts": []
      },
      {
        "content": "when ${1} => ${2};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whe when"
        ],
        "opts": []
      },
      {
        "content": "when others => ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wheo when others"
        ],
        "opts": []
      },
      {
        "content": "loop\n\t${0}\nend loop;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lo loop"
        ],
        "opts": []
      },
      {
        "content": "${1}:\nloop\n\t${0}\nend loop $1;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nlo named loop"
        ],
        "opts": []
      },
      {
        "content": "exit when ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ex exit when"
        ],
        "opts": []
      },
      {
        "content": "Ada.Text_IO.Put(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "put Ada.Text_IO.Put"
        ],
        "opts": []
      },
      {
        "content": "Ada.Text_IO.Put_Line(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "putl Ada.Text_IO.Put_Line"
        ],
        "opts": []
      },
      {
        "content": "Ada.Text_IO.Get(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "get Ada.Text_IO.Get"
        ],
        "opts": []
      },
      {
        "content": "Ada.Text_IO.Get_Line(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "getl Ada.Text_IO.Get_Line"
        ],
        "opts": []
      },
      {
        "content": "Ada.Text_IO.New_Line(${1:1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "newline Ada.Text_IO.New_Line"
        ],
        "opts": []
      }
    ],
    "all": [],
    "alpaca": [
      {
        "content": "module ${0:`expand('%:t:r')`}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mod"
        ],
        "opts": []
      },
      {
        "content": "import ${0:http}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "imp"
        ],
        "opts": []
      },
      {
        "content": "import type ${0:option.option}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "impt"
        ],
        "opts": []
      },
      {
        "content": "export ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "exp"
        ],
        "opts": []
      },
      {
        "content": "export ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "expt"
        ],
        "opts": []
      },
      {
        "content": "val ${1:fn} ${2}: fn ${3:'a} -> ${4:'a}\nlet $1 ${5} =\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fn"
        ],
        "opts": []
      },
      {
        "content": "match ${1} with\n| ${2} -> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mat"
        ],
        "opts": []
      },
      {
        "content": "| ${1} -> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "-"
        ],
        "opts": []
      },
      {
        "content": "let ${1} = ${2:${VISUAL}} in\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "let"
        ],
        "opts": []
      },
      {
        "content": "let ${1} =\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "letf"
        ],
        "opts": []
      },
      {
        "content": "type ${1:msg}\n\t= ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ty"
        ],
        "opts": []
      },
      {
        "content": "test \"${1}\" =\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "test"
        ],
        "opts": []
      },
      {
        "content": "{-| ${0}\n-}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doc"
        ],
        "opts": []
      },
      {
        "content": "|> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p"
        ],
        "opts": []
      },
      {
        "content": "assert.equal ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ae"
        ],
        "opts": []
      }
    ],
    "angular": [
      {
        "content": "# Client App\nFROM johnpapa/angular-cli as client-app\nLABEL authors=\"${1:John Papa}\"\nWORKDIR /usr/src/app\nCOPY [\"package.json\", \"npm-shrinkwrap.json*\", \"./\"]\nRUN npm install --silent\nCOPY . .\nRUN ng build --prod\n\n# Node server\nFROM ${2:node:12-alpine} as node-server\nWORKDIR /usr/src/app\nCOPY [\"package.json\", \"npm-shrinkwrap.json*\", \"./\"]\nRUN npm install --production --silent && mv node_modules ../\nCOPY ${3:server.js} .\nCOPY ${4:/server} /usr/src/app/server\n\n# Final image\nFROM ${2:node:12-alpine}\nWORKDIR /usr/src/app\nCOPY --from=node-server /usr/src /usr/src\nCOPY --from=client-app /usr/src/app/dist ./\nEXPOSE ${5:3000}\n# CMD [\"node\", \"server.js\"]\nCMD [\"npm\", \"start\"]\n$0",
        "doc": "Multi-stage Node and Angular Dockerfile",
        "grammar": "lsp",
        "label": "multi-stage-node-and-angular-dockerfile",
        "matches": [
          "angular multi-stage node and dockerfile",
          "docker-angular-node-multi-stage"
        ],
        "opts": []
      },
      {
        "content": "[class]=\"${1:expression}\"",
        "doc": "Angular [class] binding",
        "grammar": "lsp",
        "label": "class",
        "matches": [
          "a-class",
          "angular class"
        ],
        "opts": []
      },
      {
        "content": "[style.${1:property}]=\"${2:expression}\"",
        "doc": "Angular [style] binding",
        "grammar": "lsp",
        "label": "style",
        "matches": [
          "angular style",
          "a-style"
        ],
        "opts": []
      },
      {
        "content": "[ngClass]=\"{${1:cssClass}: ${2:expression}}\"",
        "doc": "Angular ngClass",
        "grammar": "lsp",
        "label": "ngclass",
        "matches": [
          "a-ngclass",
          "angular ng class"
        ],
        "opts": []
      },
      {
        "content": "*ngFor=\"let ${1:item} of ${2:list}\"${0}",
        "doc": "Angular *ngFor",
        "grammar": "lsp",
        "label": "ngfor",
        "matches": [
          "angular ng for",
          "a-ngfor"
        ],
        "opts": []
      },
      {
        "content": "*ngFor=\"let ${1:item} of ${2:list}; trackBy:${1:item}.id\"${0}",
        "doc": "Angular *ngFor with trackBy",
        "grammar": "lsp",
        "label": "ngfor-with-trackby",
        "matches": [
          "a-ngfor-trackby",
          "angular ng for with track by"
        ],
        "opts": []
      },
      {
        "content": "*ngFor=\"let ${1:item} of ${2:stream} | async as ${3:list}\"${0}",
        "doc": "Angular *ngForAsync",
        "grammar": "lsp",
        "label": "ngforasync",
        "matches": [
          "a-ngforasync",
          "angular ng for async"
        ],
        "opts": []
      },
      {
        "content": "<form (ngSubmit)=\"onSubmit()\" #${1:form}=\"ngForm\">\n</form>",
        "doc": "Form with ngSubmit and form attributes",
        "grammar": "lsp",
        "label": "ngform",
        "matches": [
          "angular ng form",
          "a-form"
        ],
        "opts": []
      },
      {
        "content": "formArrayName=\"${1:control}\"",
        "doc": "Angular formArrayName",
        "grammar": "lsp",
        "label": "ngformarrayname",
        "matches": [
          "angular ng form array name",
          "a-formarrayname"
        ],
        "opts": []
      },
      {
        "content": "formControlName=\"${1:control}\"",
        "doc": "Angular formControlName",
        "grammar": "lsp",
        "label": "ngformcontrolname",
        "matches": [
          "angular ng form control name",
          "a-formcontrolname"
        ],
        "opts": []
      },
      {
        "content": "[formGroup]=\"${1:form}\"",
        "doc": "Angular formGroup",
        "grammar": "lsp",
        "label": "ngformgroup",
        "matches": [
          "a-formgroup",
          "angular ng form group"
        ],
        "opts": []
      },
      {
        "content": "[formGroupName]=\"${1:name}\"",
        "doc": "Angular formGroupName",
        "grammar": "lsp",
        "label": "ngformgroupname",
        "matches": [
          "a-formgroupname",
          "angular ng form group name"
        ],
        "opts": []
      },
      {
        "content": "<button type=\"submit\" [disabled]=\"!${1:form}.form.valid\">\n\tSave\n</button>",
        "doc": "Angular form submit",
        "grammar": "lsp",
        "label": "ngformsubmit",
        "matches": [
          "angular ng form submit",
          "a-form-submit"
        ],
        "opts": []
      },
      {
        "content": "*ngIf=\"${1:expression}\"",
        "doc": "Angular *ngIf",
        "grammar": "lsp",
        "label": "ngif",
        "matches": [
          "angular ng if",
          "a-ngif"
        ],
        "opts": []
      },
      {
        "content": "*ngIf=\"${1:expression};else ${2:templateName}\"",
        "doc": "Angular *ngIfElse",
        "grammar": "lsp",
        "label": "ngifelse",
        "matches": [
          "angular ng if else",
          "a-ngifelse"
        ],
        "opts": []
      },
      {
        "content": "[(ngModel)]=\"${1:binding}\"",
        "doc": "Angular ngModel",
        "grammar": "lsp",
        "label": "ngmodel",
        "matches": [
          "angular ng model",
          "a-ngmodel"
        ],
        "opts": []
      },
      {
        "content": "[routerLink]=\"['/${1:routePath}']\" routerLinkActive=\"${2:router-link-active}\" $0",
        "doc": "Angular routerLink",
        "grammar": "lsp",
        "label": "ngrouterlink",
        "matches": [
          "a-routerlink",
          "angular ng router link"
        ],
        "opts": []
      },
      {
        "content": "[routerLink]=\"['${1:routePath}', ${2:routeParameterValue}]\"\nrouterLinkActive=\"${3:router-link-active}\"$0",
        "doc": "Angular routerLink with a route parameter",
        "grammar": "lsp",
        "label": "ngrouterlinkwithparameter",
        "matches": [
          "a-routerlink-param",
          "angular ng router link with parameter"
        ],
        "opts": []
      },
      {
        "content": "<select [(ngModel)]=\"${1:model}\">\n\t<option *ngFor=\"let ${2:item} of ${3:list}\" [value]=\"${2:item}\">{{${2:item}}}</option>\n</select>",
        "doc": "<select> control with ngModel",
        "grammar": "lsp",
        "label": "ngselect",
        "matches": [
          "angular ng select",
          "a-select"
        ],
        "opts": []
      },
      {
        "content": "[ngStyle]=\"{${1:style}: ${2:expression}}\"",
        "doc": "Angular ngStyle",
        "grammar": "lsp",
        "label": "ngstyle",
        "matches": [
          "angular ng style",
          "a-ngstyle"
        ],
        "opts": []
      },
      {
        "content": "<div [ngSwitch]=\"${1:conditionExpression}\">\n\t<div *ngSwitchCase=\"${2:expression}\">${3:output}</div>\n\t<div *ngSwitchDefault>${4:output2}</div>\n</div>",
        "doc": "Angular ngSwitch",
        "grammar": "lsp",
        "label": "ngswitch",
        "matches": [
          "angular ng switch",
          "a-ngswitch"
        ],
        "opts": []
      },
      {
        "content": "<pre>{{${1:model} | json}}</pre>$0",
        "doc": "Angular pre debug | json",
        "grammar": "lsp",
        "label": "pre-w-json",
        "matches": [
          "a-prej",
          "angular pre json"
        ],
        "opts": []
      },
      {
        "content": "<pre>{{${1:model} | async | json}}</pre>$0",
        "doc": "Angular pre debug | async | json",
        "grammar": "lsp",
        "label": "pre-w-async-json",
        "matches": [
          "a-preja",
          "angular pre async json"
        ],
        "opts": []
      },
      {
        "content": "<ng-container $0></ng-container>",
        "doc": "Angular ng-container",
        "grammar": "lsp",
        "label": "ng-container",
        "matches": [
          "a-ng-container",
          "angular ng-container"
        ],
        "opts": []
      },
      {
        "content": "<ng-template [ngTemplateOutlet]=\"${1:outlet}\" [ngOutletContext]=\"${2:context}\"></ng-template>",
        "doc": "Angular ng-template",
        "grammar": "lsp",
        "label": "ng-template",
        "matches": [
          "a-ng-template",
          "angular ng-template"
        ],
        "opts": []
      },
      {
        "content": "<ng-content select=\"${0:selector}\"></ng-content>",
        "doc": "Angular ng-content",
        "grammar": "lsp",
        "label": "ng-content",
        "matches": [
          "angular ng-content",
          "a-ng-content"
        ],
        "opts": []
      },
      {
        "content": "const express = require('express');\nconst app = express();\nconst port = process.env.PORT || ${1:port};\nconst www = process.env.WWW || '${2:./}';\napp.use(express.static(www));\nconsole.log(`serving \\${www}`);\napp.get('*', (req, res) => {\n\tres.sendFile(`index.html`, { root: www });\n});\napp.listen(port, () => console.log(`listening on http://localhost:\\${port}`));\n$0",
        "doc": "Node.js Express Server",
        "grammar": "lsp",
        "label": "node-js-express-server",
        "matches": [
          "ex-node-server-simple",
          "angular node express server"
        ],
        "opts": []
      },
      {
        "content": "import { Component, OnInit } from '@angular/core';\n\n@Component({\n\tselector: '${1:selector-name}',\n\ttemplateUrl: '${2:name}.component.html'\n})\n\nexport class ${3:Name}Component implements OnInit {\n\tconstructor() { }\n\n\tngOnInit() { }$0\n}",
        "doc": "Angular component",
        "grammar": "lsp",
        "label": "angular-component",
        "matches": [
          "a-component",
          "angular component"
        ],
        "opts": []
      },
      {
        "content": "import { Component, OnInit } from '@angular/core';\n\n@Component({\n\tselector: '${1:selector-name}',\n\ttemplate: `$0`\n})\n\nexport class ${2:Name}Component implements OnInit {\n\tconstructor() { }\n\n\tngOnInit() { }\n}",
        "doc": "Angular component with an inline template",
        "grammar": "lsp",
        "label": "angular-component-with-inline-template",
        "matches": [
          "angular component inline template",
          "a-component-inline"
        ],
        "opts": []
      },
      {
        "content": "import { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n\tname: '${1:selector-name}'\n})\n\nexport class ${2:Name}Pipe implements PipeTransform {\n\ttransform(value: any, ...args: any[]): any {\n\t\t$0\n\t}\n}",
        "doc": "Angular pipe",
        "grammar": "lsp",
        "label": "angular-pipe",
        "matches": [
          "angular pipe",
          "a-pipe"
        ],
        "opts": []
      },
      {
        "content": "import { Injectable } from '@angular/core';\n\n@Injectable({providedIn: ${1:'root'}})\nexport class ${2:ServiceName}Service {\n\tconstructor() { }\n\t$0\n}",
        "doc": "Angular Service with Injectable ProvidedIn Root",
        "grammar": "lsp",
        "label": "angular-service",
        "matches": [
          "a-service",
          "angular service"
        ],
        "opts": []
      },
      {
        "content": "{ path: '', pathMatch: 'full', redirectTo: '${1:path}' }$0",
        "doc": "Angular default route path",
        "grammar": "lsp",
        "label": "angular-default-route-path",
        "matches": [
          "a-route-path-default",
          "angular default route path"
        ],
        "opts": []
      },
      {
        "content": "{\n\tpath: '${1:path}', \n\tcomponent: ${2:Component},\n\tchildren: [\n\t\t{ path: '${3:childpath}', component: ${4:ChildComponent} }\n\t]\n}$0",
        "doc": "Angular route path with children",
        "grammar": "lsp",
        "label": "angular-route-path-with-children",
        "matches": [
          "a-route-path-with-children",
          "angular route path children"
        ],
        "opts": []
      },
      {
        "content": "{ path: '**', component: ${1:PathNotFoundComponent} }$0",
        "doc": "Angular 404 route path",
        "grammar": "lsp",
        "label": "angular-404-route-path",
        "matches": [
          "a-route-path-404",
          "angular 404 route path"
        ],
        "opts": []
      },
      {
        "content": "{ path: '${1:path}', component: ${2:Name}Component },",
        "doc": "Angular eager route path",
        "grammar": "lsp",
        "label": "angular-eager-route-path",
        "matches": [
          "a-route-path-eager",
          "angular eager route path"
        ],
        "opts": []
      },
      {
        "content": "{\n\tpath: '${1:path}', \n\tloadChildren: () => import('${2:lazy-path}').then(m => m.${3:lazy-module})\n},",
        "doc": "Angular lazy route path",
        "grammar": "lsp",
        "label": "angular-lazy-route-path",
        "matches": [
          "angular lazy route path",
          "a-route-path-lazy"
        ],
        "opts": []
      },
      {
        "content": "this.route.paramMap\n\t.pipe(switchMap(params => params.get('id')), tap(id => (this.id = +id)))\n\t.subscribe(id => {$1});\n$0",
        "doc": "Angular - subscribe to routing parameters",
        "grammar": "lsp",
        "label": "routing-params-subscribe",
        "matches": [
          "a-route-params-subscribe",
          "angular routing params subscribe"
        ],
        "opts": []
      },
      {
        "content": "return this.httpClient.get('${1:url}');$0",
        "doc": "Angular HttpClient.get",
        "grammar": "lsp",
        "label": "httpclient-get",
        "matches": [
          "angular http client get",
          "a-httpclient-get"
        ],
        "opts": []
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\n@Injectable({providedIn: ${1:'root'}})\nexport class ${2:ServiceName}Service {\n\tconstructor(private httpClient: HttpClient) { }\n\t$0\n}",
        "doc": "Angular service with HttpClient",
        "grammar": "lsp",
        "label": "angular-httpclient-service",
        "matches": [
          "angular http client service",
          "a-service-httpclient"
        ],
        "opts": []
      },
      {
        "content": "import { HttpInterceptor, HttpHandler, HttpRequest, HttpEvent, HttpResponse } from '@angular/common/http';\nimport { Observable } from 'rxjs';\nimport { tap } from 'rxjs/operators';\n\n@Injectable()\nexport class LogInterceptor implements HttpInterceptor {\n\tconstructor() {}\n\n\tintercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n\t\tconst started = Date.now();\n\t\treturn next.handle(req).pipe(\n\t\t\ttap(event => {\n\t\t\t\tif (event instanceof HttpResponse) {\n\t\t\t\t\tconst elapsed = Date.now() - started;\n\t\t\t\t\tconsole.log(`Request for \\${req.urlWithParams} took \\${elapsed} ms.`);\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\t}\n}",
        "doc": "Angular HttpInterceptor for Logging HttpClient",
        "grammar": "lsp",
        "label": "angular-httpinterceptor-for-logging",
        "matches": [
          "angular http interceptor logging",
          "a-http-interceptor-logging"
        ],
        "opts": []
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { HttpEvent, HttpInterceptor, HttpHandler, HttpRequest } from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class HeaderInterceptor implements HttpInterceptor {\n\tconstructor() {}\n\n\tintercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n\t\tconst headers = req.headers\n\t\t\t.set('Content-Type', 'application/json');\n\t\tconst authReq = req.clone({ headers });\n\t\treturn next.handle(authReq);\n\t}\n}",
        "doc": "Angular HttpInterceptor for headers HttpClient",
        "grammar": "lsp",
        "label": "angular-httpinterceptor-for-headers",
        "matches": [
          "angular http interceptor headers",
          "a-http-interceptor-headers"
        ],
        "opts": []
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { HttpInterceptor, HttpEvent, HttpHandler, HttpRequest } from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class ${2:Your}Interceptor implements HttpInterceptor {\n\tintercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n\t\treturn next.handle(req);\n\t}\n}",
        "doc": "Empty Angular HttpInterceptor for HttpClient",
        "grammar": "lsp",
        "label": "angular-httpinterceptor-empty",
        "matches": [
          "a-http-interceptor",
          "angular http interceptor empty"
        ],
        "opts": []
      },
      {
        "content": "@Output() ${1:eventName} = new EventEmitter<${2:eventType}>();",
        "doc": "Angular @Output event and emitter",
        "grammar": "lsp",
        "label": "output-event",
        "matches": [
          "a-output-event",
          "angular output event"
        ],
        "opts": []
      },
      {
        "content": "this.${1:service}.${2:function}\n\t.subscribe(${3:arg} => this.${4:property} = ${3:arg});\n$0",
        "doc": "Angular observable subscribe",
        "grammar": "lsp",
        "label": "subscribe",
        "matches": [
          "a-subscribe",
          "angular subscribe"
        ],
        "opts": []
      },
      {
        "content": "import { Component } from '@angular/core';\n\n@Component({\n\tselector: '${1:prefix-app}',\n\ttemplate: `\n\t\t<router-outlet></router-outlet>\n\t\t`\n})\nexport class ${2:App}Component { }\n$0",
        "doc": "Angular App root component",
        "grammar": "lsp",
        "label": "angular-root-component",
        "matches": [
          "a-component-root",
          "angular root component"
        ],
        "opts": []
      },
      {
        "content": "import { NgModule } from '@angular/core';\nimport { BrowserModule  } from '@angular/platform-browser';\nimport { HttpModule } from '@angular/http';\n\nimport { ${1:App}Component } from './${1:app}.component';\n\n@NgModule({\n\timports: [\n\t\tBrowserModule,\n\t\tHttpModule,\n\t],\n\tdeclarations: [${1:App}Component],\n\tbootstrap: [${1:App}Component],\n})\nexport class ${1:App}Module { }\n$0",
        "doc": "Angular Root Module",
        "grammar": "lsp",
        "label": "angular-root-module",
        "matches": [
          "angular root module",
          "a-module-root"
        ],
        "opts": []
      },
      {
        "content": "import { Routes } from '@angular/router';\n\nexport const routes: Routes = [${0}]",
        "doc": "Route definitions",
        "grammar": "lsp",
        "label": "route-definitions",
        "matches": [
          "angular route definitions",
          "a-routes"
        ],
        "opts": []
      },
      {
        "content": "import { NgModule } from '@angular/core';\n\nimport { ${1:Name}Component } from './${2:name}.component';\n\n@NgModule({\n\timports: [],\n\texports: [],\n\tdeclarations: [${1:Name}Component],\n\tproviders: [],\n})\nexport class ${1:Name}Module { }\n$0",
        "doc": "Angular Module",
        "grammar": "lsp",
        "label": "angular-module",
        "matches": [
          "a-module",
          "angular module"
        ],
        "opts": []
      },
      {
        "content": "import { Directive } from '@angular/core';\n\n@Directive({ selector: '[${1:selector-name}]' })\nexport class ${2:Name}Directive {\n\tconstructor() { }\n}",
        "doc": "Angular directive",
        "grammar": "lsp",
        "label": "angular-directive",
        "matches": [
          "a-directive",
          "angular directive"
        ],
        "opts": []
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { ActivatedRouteSnapshot, CanActivate, RouterStateSnapshot } from '@angular/router';\n\n@Injectable({providedIn: ${1:'root'}})\nexport class ${2:Name}Guard implements CanActivate {\n\tconstructor() { }\n\n\tcanActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {\n\t\treturn true;$0\n\t}\n}",
        "doc": "Angular CanActivate guard",
        "grammar": "lsp",
        "label": "angular-canactivate-guard",
        "matches": [
          "angular can activate guard",
          "a-guard-can-activate"
        ],
        "opts": []
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { ActivatedRouteSnapshot, CanActivateChild, RouterStateSnapshot } from '@angular/router';\n\n@Injectable({providedIn: ${1:'root'}})\nexport class ${2:Name}Guard implements CanActivateChild {\n\tconstructor() { }\n\n\tcanActivateChild(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {\n\t\treturn true;$0\n\t}\n}",
        "doc": "Angular CanActivateChild guard",
        "grammar": "lsp",
        "label": "angular-canactivatechild-guard",
        "matches": [
          "a-guard-can-activate-child",
          "angular can activate child guard"
        ],
        "opts": []
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { CanLoad, Route } from '@angular/router';\n\n@Injectable({providedIn: ${1:'root'}})\nexport class ${2:Name}Guard implements CanLoad {\n\tconstructor() { }\n\n\tcanLoad(route: Route) {\n\t\treturn true;$0\n\t}\n}",
        "doc": "Angular CanLoad guard",
        "grammar": "lsp",
        "label": "angular-canload-guard",
        "matches": [
          "a-guard-can-load",
          "angular can load guard"
        ],
        "opts": []
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { ActivatedRouteSnapshot, CanDeactivate, RouterStateSnapshot } from '@angular/router';\nimport { Observable } from 'rxjs';\n\nimport { ${2:ComponentName}Component } from './${3:filename}.component';\n\n// Consider using this interface for all CanDeactivate guards,\n// and have your components implement this interface, too.\n//\n//   e.g. export class CanDeactivateGuard implements CanDeactivate<CanComponentDeactivate> {\n//\n// export interface CanComponentDeactivate {\n// canDeactivate: () => any;\n// }\n\n@Injectable({providedIn: ${4:'root'}})\nexport class ${1:Name}Guard implements CanDeactivate<${2:ComponentName}Component> {\n\tcanDeactivate(\n\t\tcomponent: ${2:ComponentName}Component,\n\t\tcurrentRoute: ActivatedRouteSnapshot, \n\t\tcurrentState: RouterStateSnapshot\n\t): Observable<boolean>|Promise<boolean>|boolean {\n\t\treturn false;$0\n\t}\n}",
        "doc": "Angular CanDeactivate guard",
        "grammar": "lsp",
        "label": "angular-candeactivate-guard",
        "matches": [
          "angular can deactivate guard",
          "a-guard-can-deactivate"
        ],
        "opts": []
      },
      {
        "content": "import { PreloadingStrategy, Route } from '@angular/router';\nimport { Observable, of } from 'rxjs';\n\nexport class PreloadSelectedModulesList implements PreloadingStrategy {\n\tpreload(route: Route, load: Function): Observable<any> {\n\t\treturn route.data && route.data['${1:preload}'] ? load() : of(null);\n\t}\n}\n$0",
        "doc": "Angular opt-in preload strategy",
        "grammar": "lsp",
        "label": "angular-opt-in-preload-strategy",
        "matches": [
          "a-preload-opt-in-strategy",
          "angular opt-in preload strategy"
        ],
        "opts": []
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { PreloadingStrategy, Route } from '@angular/router';\nimport { Observable, EMPTY } from 'rxjs';\n\n// avoid typing issues for now\nexport declare var navigator;\n\n@Injectable({ providedIn: 'root' })\nexport class NetworkAwarePreloadStrategy implements PreloadingStrategy {\n\tpreload(route: Route, load: () => Observable<any>): Observable<any> {\n\t\treturn this.hasGoodConnection() ? load() : EMPTY;\n\t}\n\n\thasGoodConnection(): boolean {\n\t\tconst conn = navigator.connection;\n\t\tif (conn) {\n\t\t\tif (conn.saveData) {\n\t\t\t\treturn false; // save data mode is enabled, so dont preload\n\t\t\t}\n\t\t\tconst avoidTheseConnections = ['slow-2g', '2g' /* , '3g', '4g' */];\n\t\t\tconst effectiveType = conn.effectiveType || '';\n\t\t\tif (avoidTheseConnections.includes(effectiveType)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}",
        "doc": "Angular network aware preload strategy",
        "grammar": "lsp",
        "label": "angular-network-aware-preload-strategy",
        "matches": [
          "a-preload-network-strategy",
          "angular network-aware preload strategy"
        ],
        "opts": []
      },
      {
        "content": "checkEvents() {\n\tthis.router.events.subscribe(event => {\n\t\tswitch (true) {\n\t\t\tcase event instanceof ${1:eventName}:\n\t\t\t\t$0\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t});\n}",
        "doc": "Angular Router Events",
        "grammar": "lsp",
        "label": "angular-router-events",
        "matches": [
          "angular router events",
          "a-router-events"
        ],
        "opts": []
      },
      {
        "content": "constructor( @Optional() @SkipSelf() parentModule: ${1:ModuleName} {\n\tif (parentModule) {\n\t\tconst msg = `${1:ModuleName} has already been loaded. \n\t\t\tImport ${1:ModuleName} once, only, in the root AppModule.`;\n\t\tthrow new Error(msg);\n\t}\n}",
        "doc": "Angular Module SkipSelf constructor",
        "grammar": "lsp",
        "label": "angular-module-skipself-constructor",
        "matches": [
          "angular module skip self constructor",
          "a-ctor-skip-self"
        ],
        "opts": []
      },
      {
        "content": "import { ${1:Observable} } from 'rxjs';\n$0",
        "doc": "RxJs import",
        "grammar": "lsp",
        "label": "rxjs-import",
        "matches": [
          "angular import rx js",
          "a-rxjs-import"
        ],
        "opts": []
      },
      {
        "content": "import { ${1:map} } from 'rxjs/operators';\n$0",
        "doc": "RxJs import",
        "grammar": "lsp",
        "label": "rxjs-operator-import",
        "matches": [
          "a-rxjs-operator-import",
          "angular import rx js operator"
        ],
        "opts": []
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { Resolve, ActivatedRouteSnapshot } from '@angular/router';\nimport { Observable } from 'rxjs';\n\n@Injectable({ providedIn: ${1:'root'} })\nexport class ${2:YourResolver} implements Resolve<${3:ObjectToResolve}> {\n\tresolve(route: ActivatedRouteSnapshot): Observable<${3:ObjectToResolve}> | Promise<${3:ObjectToResolve}> | ${3:ObjectToResolve} {\n\t\treturn ${0};\n\t}\n}",
        "doc": "Angular Resolver",
        "grammar": "lsp",
        "label": "angular-resolver",
        "matches": [
          "angular resolver",
          "a-resolver"
        ],
        "opts": []
      },
      {
        "content": "import { NgModule } from '@angular/core';\nimport { EffectsModule } from '@ngrx/effects';\nimport { StoreModule } from '@ngrx/store';\nimport { StoreDevtoolsModule } from '@ngrx/store-devtools';\nimport { environment } from '../../environments/environment';\n\n@NgModule({\n  imports: [\n    StoreModule.forRoot({}),\n    EffectsModule.forRoot([]),\n    environment.production ? [] : StoreDevtoolsModule.instrument()\n  ]\n})\nexport class $1StoreModule {}",
        "doc": "NgRx Store Module",
        "grammar": "lsp",
        "label": "ngrx-store-module",
        "matches": [
          "angular ng rx store module",
          "a-ngrx-store-module"
        ],
        "opts": []
      },
      {
        "content": "export const ${1:action} = createAction('[${2:Source}] ${3:Event}');",
        "doc": "Creates an NgRx Action",
        "grammar": "lsp",
        "label": "ngrx-create-action",
        "matches": [
          "a-ngrx-create-action",
          "angular ng rx create action"
        ],
        "opts": []
      },
      {
        "content": "export const ${1:action} = createAction('[${2:Source}] ${3:Event}', props<{${4:key}: ${5:type}}>());",
        "doc": "Creates an NgRx Action with Props",
        "grammar": "lsp",
        "label": "ngrx-create-action-w-props",
        "matches": [
          "angular ng rx create action props",
          "a-ngrx-create-action-props"
        ],
        "opts": []
      },
      {
        "content": "const ${1:feature}Reducer = createReducer(\n\tinitialState,\n\ton($1Actions.action, state => ({ ...state, ${2:prop}: ${3:updatedValue} })),\n);\n\nexport function reducer(state: State | undefined, action: Action) {\n\treturn $1Reducer(state, action);\n}",
        "doc": "Creates an NgRx Reducer",
        "grammar": "lsp",
        "label": "ngrx-create-reducer",
        "matches": [
          "angular ng rx create reducer",
          "a-ngrx-create-reducer"
        ],
        "opts": []
      },
      {
        "content": "${1:effectName}$ = createEffect(() => {\n\treturn this.actions$.pipe(\n\t\t\tofType(${2:action}),\n\t\t\t/** An EMPTY observable only emits completion. Replace with your own observable stream */\n\t\t\t${3:operator}(() => ${4:EMPTY}));\n});",
        "doc": "Creates an NgRx Effect",
        "grammar": "lsp",
        "label": "ngrx-create-effect",
        "matches": [
          "a-ngrx-create-effect",
          "angular ng rx create effect"
        ],
        "opts": []
      },
      {
        "content": "${1:effectName}$ = createEffect(() => {\n\treturn this.actions$.pipe(\n\t\t\tofType(${2:Feature}Actions.${3:action}),\n\t\t\t${4:operator}(() =>\n\t\t\t\t${5:apiSource}.pipe(\n\t\t\t\t\tmap(data => $2Actions.$3Success({ data })),\n\t\t\t\t\tcatchError(error => of($2Actions.$3Failure({ error }))))\n\t\t\t\t),\n\t);\n});",
        "doc": "Creates an NgRx Effect Scaffolded for API Call",
        "grammar": "lsp",
        "label": "ngrx-create-effect-for-api-call",
        "matches": [
          "a-ngrx-create-effect-api",
          "angular ng rx create effect api call"
        ],
        "opts": []
      },
      {
        "content": "export const select${1:Feature}${2:Property} = createSelector(\n\tselect$1,\n\t(state: $1State) => state.${3:property}\n);",
        "doc": "Creates an NgRx Selector",
        "grammar": "lsp",
        "label": "ngrx-create-selector",
        "matches": [
          "angular ng rx create selector",
          "a-ngrx-create-selector"
        ],
        "opts": []
      },
      {
        "content": "export const select${1:Feature}${2:Property} = createSelector(\n\tselect$1,\n\t(state: $1State, props) => ${3:selectLogic}\n);",
        "doc": "Creates an NgRx Selector using props",
        "grammar": "lsp",
        "label": "ngrx-create-selector-w-props",
        "matches": [
          "a-ngrx-create-selector-props",
          "angular ng rx create selector props"
        ],
        "opts": []
      },
      {
        "content": "EntityDataModule.forRoot(${1:entityConfig}),",
        "doc": "Import NgRx Entity Data Module",
        "grammar": "lsp",
        "label": "ngrx-data-import-entity-data-module",
        "matches": [
          "angular ng rx data import entity module",
          "a-ngrx-data-entity-data-module-import"
        ],
        "opts": []
      },
      {
        "content": "import { EntityMetadataMap } from '@ngrx/data';\n\nconst entityMetadata: EntityMetadataMap = {\n  ${1:Model1}: {},${0}\n};\n\nexport const entityConfig = {\n  entityMetadata\n};",
        "doc": "NgRx Data Entity Metadata",
        "grammar": "lsp",
        "label": "ngrx-data-entity-metadata",
        "matches": [
          "a-ngrx-data-entity-metadata",
          "angular ng rx data entity metadata"
        ],
        "opts": []
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport {\n  EntityCollectionServiceBase,\n  EntityCollectionServiceElementsFactory\n} from '@ngrx/data';\nimport { ${1:Model} } from '${2:../core}';\n\n@Injectable({ providedIn: ${3:'root'} })\nexport class ${1:Model}Service extends EntityCollectionServiceBase<${1:Model}> {\n  constructor(serviceElementsFactory: EntityCollectionServiceElementsFactory) {\n    super('${1:Model}', serviceElementsFactory);\n  }\n}",
        "doc": "NgRx Data Entity Collection Data Service",
        "grammar": "lsp",
        "label": "ngrx-data-entity-collection-data-service",
        "matches": [
          "angular ng rx data entity collection service",
          "a-ngrx-data-entity-collection-data-service"
        ],
        "opts": []
      },
      {
        "content": "${1:trackBy}(index: number, ${2:name}: ${3:model}): ${4:number} {\n  return ${2:name}${5:.id};$0\n}",
        "doc": "TrackBy Function",
        "grammar": "lsp",
        "label": "trackby-function",
        "matches": [
          "angular track by function",
          "a-trackby"
        ],
        "opts": []
      }
    ],
    "angular_coffee": [
      {
        "content": "${1:controllerName} = (${2:scope}, ${3:injectables}) ->\n\t${4}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ngc"
        ],
        "opts": []
      },
      {
        "content": "angular.forEach ${1:iterateOver}, (value, key) ->\n\t${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ngfor"
        ],
        "opts": []
      },
      {
        "content": "angular.module '${1:moduleName}', [${2:moduleDependencies}]\n${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ngm"
        ],
        "opts": []
      },
      {
        "content": "${1:moduleName} = angular.module '$1', [${2:moduleDeps}]\n${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ngma"
        ],
        "opts": []
      },
      {
        "content": "${1:moduleName} = angular.module('$1', [${2:moduleDeps}], (${3:configDeps}) ->\n\t${4}\n)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ngmc"
        ],
        "opts": []
      },
      {
        "content": "factory '${1:factoryName}', (${2:dependencies}) ->\n\t${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ngmfa"
        ],
        "opts": []
      },
      {
        "content": "service '${1:serviceName}', (${2:injectables}) ->\n\t${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ngms"
        ],
        "opts": []
      },
      {
        "content": "filter '${1:filterName}', (${2:injectables}) ->\n\t(input, ${3:args}) ->\n\t\t${4}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ngmfi"
        ],
        "opts": []
      },
      {
        "content": "$routeProvider.when '${1:url}',\n\ttemplateUrl: '${2:templateUrl}'\n\tcontroller: '${3:controller}'\n${4}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ngrw"
        ],
        "opts": []
      },
      {
        "content": "$routeProvider.when '${1:url}',\n\ttemplateUrl: '${2:templateUrl}'\n\tcontroller: '${3:controller}'\n\tresolve:\n\t\t${4}\n${5}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ngrwr"
        ],
        "opts": []
      },
      {
        "content": "$routeProvider.otherwise redirectTo: '${1:url}'\n${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ngro"
        ],
        "opts": []
      },
      {
        "content": "$scope.${1:functionName} = (${2:args}) ->\n\t${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "$f"
        ],
        "opts": []
      },
      {
        "content": "$scope.${1:variable} = ${2:value}\n${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "$v"
        ],
        "opts": []
      },
      {
        "content": "$scope.${1:variable} = ${2:variable}\n${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "$va"
        ],
        "opts": []
      },
      {
        "content": "$scope.$watch '${1:watchExpr}', (newValue, oldValue) ->\n\t${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "$w"
        ],
        "opts": []
      },
      {
        "content": "$scope.$on '${1:eventName}', (event, ${2:args}) ->\n\t${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "$on"
        ],
        "opts": []
      },
      {
        "content": "$scope.$broadcast '${1:eventName}', ${2:eventArgs}\n${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "$b"
        ],
        "opts": []
      },
      {
        "content": "$scope.$emit '${1:eventName}', ${2:eventArgs}\n${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "$e"
        ],
        "opts": []
      },
      {
        "content": "compile = (tElement, tAttrs, transclude) ->\n\t(scope, element, attrs) ->\n\t\t${1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ngdcf"
        ],
        "opts": []
      },
      {
        "content": "(scope, element, attrs${1:ctrl}) ->\n\t${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ngdlf"
        ],
        "opts": []
      },
      {
        "content": "directive '${1:directiveName}', factory = (${2:injectables}) ->\n\tdirectiveDefinitionObject =\n\t\t${3:directiveAttrs}\n\t\tcompile: compile = (tElement, tAttrs, transclude) ->\n\t\t\t(scope, element, attrs) ->\n\tdirectiveDefinitionObject",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ngdc"
        ],
        "opts": []
      },
      {
        "content": ".directive('${1:directiveName}', (${2:directiveDeps}) ->\n\t(scope, element, attrs${3:ctrl}) ->\n\t\t${4}\n)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ngdl"
        ],
        "opts": []
      }
    ],
    "apache": [
      {
        "content": "AllowOverride ${1:#:AuthConfig} ${2:#:FileInfo} ${3:#:Indexes} ${4:#:Limit} ${5:#:Options}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "allow"
        ],
        "opts": []
      },
      {
        "content": "Options ${1:#:All} ${2:#:ExecCGI} ${3:#:FollowSymLinks} ${4:#:Includes} ${5:#:IncludesNOEXEC} ${6:#:Indexes} ${7:#:MultiViews} ${8:#:SymLinksIfOwnerMatch}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "opt"
        ],
        "opts": []
      },
      {
        "content": "<VirtualHost ${1:example.org}>\n\tServerAdmin webmaster@${1}\n\tDocumentRoot /www/vhosts/${1}\n\tServerName ${1}\n\tErrorLog logs/${1}-error_log\n\tCustomLog logs/${1}-access_log common\n</VirtualHost>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vhost"
        ],
        "opts": []
      },
      {
        "content": "<Directory ${1:/Library/WebServer/}>\n\t${0}\n</Directory>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dir"
        ],
        "opts": []
      },
      {
        "content": "<IfModule ${1:module_name}>\n        ${2}\n</IfModule>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifmodule"
        ],
        "opts": []
      },
      {
        "content": "<If ${1:condition}>\n        ${2}\n</If>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "RemoteIPHeader X-Forwarded-For",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "RemoteIPHeader"
        ],
        "opts": []
      },
      {
        "content": "<Location ${1:location}>\n        ${2:config}\n</Location>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "location"
        ],
        "opts": []
      },
      {
        "content": "<LocationMatch \"${1:regex}\">\n        ${2:config}\n</LocationMatch>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "locationmatch"
        ],
        "opts": []
      },
      {
        "content": "DirectoryIndex index.php index.html",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "directoryindex"
        ],
        "opts": []
      },
      {
        "content": "Require all granted",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "require"
        ],
        "opts": []
      },
      {
        "content": "<Directory ${1:/}>\n\tDirectoryIndex ${0:index.html}\n\tOrder Deny,Allow\n\tDeny from All\n</Directory>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dir"
        ],
        "opts": []
      },
      {
        "content": "<FilesMatch \"${1:regex}\">\n\t${0:${VISUAL}}\n</FilesMatch>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "filesmatch"
        ],
        "opts": []
      },
      {
        "content": "<IfModule ${1:mod_example.c}>\n\t${0:${VISUAL}}\n</IfModule>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifmodule"
        ],
        "opts": []
      },
      {
        "content": "<LimitExcept ${1:POST GET}>\n\t${0:${VISUAL}}\n</LimitExcept>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "limitexcept"
        ],
        "opts": []
      },
      {
        "content": "<Proxy ${1:*}>\n\t${0:${VISUAL}}\n</Proxy>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "proxy"
        ],
        "opts": []
      },
      {
        "content": "<VirtualHost ${1:*}:${2:80}>\n\tServerAdmin ${3:webmaster@example.com}\n\tDocumentRoot ${4:/www/example.com}\n\tServerName ${0:www.example.com}\n</VirtualHost>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "virtualhost"
        ],
        "opts": []
      }
    ],
    "applescript": [
      {
        "content": "script ${1:#:new_object}\n\ton run\n\t\t${2:TARGET}\n\tend run\nend script",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "script"
        ],
        "opts": []
      },
      {
        "content": "on ${1:#:functionName}(${2:#:arguments})\n\t${3:TARGET}\nend ${1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "on"
        ],
        "opts": []
      },
      {
        "content": "tell ${1:#:app}\n\t${0:TARGET}\nend tell",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tell"
        ],
        "opts": []
      },
      {
        "content": "using terms from ${1:#:app}\n\t${0:TARGET}\nend using terms from",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "terms"
        ],
        "opts": []
      },
      {
        "content": "if ${1:true} then\n\t${0:TARGET}\nend if",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "repeat ${1} times}\n\t${0:TARGET}\nend repeat",
        "doc": "",
        "grammar": "snu",
        "label": "rep",
        "matches": [
          "rept"
        ],
        "opts": []
      },
      {
        "content": "repeat while ${1:#:condition}\n\t${0:TARGET}\nend repeat",
        "doc": "",
        "grammar": "snu",
        "label": "rep",
        "matches": [
          "repwh"
        ],
        "opts": []
      },
      {
        "content": "repeat with ${1} in ${2}\n\t${0:TARGET}\nend repeat",
        "doc": "",
        "grammar": "snu",
        "label": "rep",
        "matches": [
          "repwi"
        ],
        "opts": []
      },
      {
        "content": "try\n\t${0:TARGET}\non error\n\t-- error handling\nend try",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "try"
        ],
        "opts": []
      },
      {
        "content": "with timeout ${1:#:number} seconds\n\t${0:TARGET}\nend timeout",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "timeout"
        ],
        "opts": []
      },
      {
        "content": "considering ${1:#:case}\n\t${0:TARGET}\nend considering",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "con"
        ],
        "opts": []
      },
      {
        "content": "ignoring ${1:#:application responses}\n\t${0:TARGET}\nend ignoring",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ign"
        ],
        "opts": []
      },
      {
        "content": "${1:#:set shell_stdout to }do shell script ${3:\"${2:#script}\"}\n\twithout altering line endings\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "shell"
        ],
        "opts": []
      },
      {
        "content": "set oldDelims to AppleScript's text item delimiters\nset AppleScript's text item delimiters to {\"${1:,}\"}\n${0:#:TARGET}\nset AppleScript's text item delimiters to oldDelims",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "delim"
        ],
        "opts": []
      },
      {
        "content": "prop parent : app \"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "parent"
        ],
        "opts": []
      },
      {
        "content": "display alert \"${1:#:alert text}\"\n\t${2:#:message} \"${3:#:message text}\"\n\t${4:#:as warning}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "alert"
        ],
        "opts": []
      },
      {
        "content": "display dialog \"${1:#:text}\"\n\t${2:#:with icon} ${3:1}\n\tbuttons {\"${4:OK}\"} default button 1",
        "doc": "",
        "grammar": "snu",
        "label": "dialog",
        "matches": [
          "dialog_OK"
        ],
        "opts": []
      },
      {
        "content": "display dialog \"${1:#:text}\"\n\t${2:#:with icon}\n\tbuttons {\"${3:Cancel}\", \"${4:OK}\"}\n\tdefault button \"${4}\"\nset button_pressed to button returned of result\nif button_pressed is \"${4}\" then\n\t${5:#:TARGET}\nelse\n\t-- action for cancel button goes here\nend if",
        "doc": "",
        "grammar": "snu",
        "label": "dialog",
        "matches": [
          "dialog_OK/Cancel"
        ],
        "opts": []
      },
      {
        "content": "display dialog \"${1:#:text}\"\n\t${2:#:with icon}\n\tbuttons {\"${3:Cancel}\", \"${4:Other Choice}\", \"${5:OK}\"}\n\tdefault button \"${5}\"\nset button_pressed to button returned of result\nif button_pressed is \"${5}\" then\n\t${6:TARGET}\nelse if button_pressed is \"${3}\" then\n\t-- action for cancel button goes here\nelse\n\t-- action for other button goes here\nend if",
        "doc": "",
        "grammar": "snu",
        "label": "dialog",
        "matches": [
          "dialog_OK/Cancel/Other"
        ],
        "opts": []
      },
      {
        "content": "set the_result to display dialog \"${1:#:text}\"\n\tdefault answer \"${2:#:type here}\"\n\t${3:#:with icon}\n\tbuttons {\"${4:Cancel}\", \"${5:OK}\"}\n\tdefault button \"${5}\"\nset button_pressed to button returned of the_result\nset text_typed to text returned of the_result\nif button_pressed is \"${5}\" then\n\t${6:#:TARGET}\nelse\n\t-- action for cancel button goes here\nend if",
        "doc": "",
        "grammar": "snu",
        "label": "dialog",
        "matches": [
          "dialog_TextFierld"
        ],
        "opts": []
      },
      {
        "content": "${1:#:set the_application to }choose application with prompt \"${2:#:Choose an application:}\"${3:#:with multiple selections allowed}",
        "doc": "",
        "grammar": "snu",
        "label": "choose",
        "matches": [
          "choose_Applications"
        ],
        "opts": []
      },
      {
        "content": "${1:#:set the_file to }choose file with prompt \"${2:#:Pick a file:}\"\n${3:#:default location path to home folder}\n${4:#:with invisibles}\n${5:#:with multiple selections allowed}\n${6:#:with showing package contents}",
        "doc": "",
        "grammar": "snu",
        "label": "choose",
        "matches": [
          "choose_Files"
        ],
        "opts": []
      },
      {
        "content": "${1:#:set the_folder to }choose folder with prompt \"${2:#:Pick a folder:}\"\n${3:#:default location path to home folder}\n${4:#:with invisibles}\n${5:#:with multiple selections allowed}\n${6:#:with showing package contents}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "choose",
        "matches": [
          "choose_Folders"
        ],
        "opts": []
      },
      {
        "content": "${1:#:set the_filename to }choose file name with prompt \"${2:#:Name this file:}\"\n\tdefault name \"${3:untitled}\" default location ${4:#:path to home folder}",
        "doc": "",
        "grammar": "snu",
        "label": "choose",
        "matches": [
          "choose_NewFile"
        ],
        "opts": []
      },
      {
        "content": "${1:#:set the_url to }choose URL showing ${2:Web} servers with editable URL",
        "doc": "",
        "grammar": "snu",
        "label": "choose",
        "matches": [
          "choose_URL"
        ],
        "opts": []
      },
      {
        "content": "${1:#:set the_color to }choose color default color ${2:{65536, 65536, 65536\\}}",
        "doc": "",
        "grammar": "snu",
        "label": "choose",
        "matches": [
          "choose_Color"
        ],
        "opts": []
      },
      {
        "content": "set the_choice to choose from list ${1}\"\\}}",
        "doc": "",
        "grammar": "snu",
        "label": "choose",
        "matches": [
          "choose_ItemFromList"
        ],
        "opts": []
      }
    ],
    "arduino": [
      {
        "content": "void setup()\n{\n\tSerial.begin(${1:9600});\n\t${2}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "setup"
        ],
        "opts": []
      },
      {
        "content": "void loop()\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "loop"
        ],
        "opts": []
      },
      {
        "content": "#include <${1}.h>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "inc"
        ],
        "opts": []
      },
      {
        "content": "#define ${1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "def"
        ],
        "opts": []
      },
      {
        "content": "if (${1:/* condition */}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "else {\n\t${1}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "el"
        ],
        "opts": []
      },
      {
        "content": "else if (${1:/* condition */}) {\n\t${2}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "elif"
        ],
        "opts": []
      },
      {
        "content": "if (${1:/* condition */}) ${2};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifi"
        ],
        "opts": []
      },
      {
        "content": "switch (${1:/* variable */}) {\n\tcase ${2:/* variable case */}:\n\t\t${3}\n\t\t${4:break;}${5}\n\tdefault:\n\t\t${6}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "switch"
        ],
        "opts": []
      },
      {
        "content": "case ${1:/* variable case */}:\n\t${2}\n\t${3:break;}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case"
        ],
        "opts": []
      },
      {
        "content": "for (int ${2:i} = 0; $2 < ${1:count}; $2${3:++}) {\n\t${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "for (int ${1:i} = ${2:0}; ${3:$1 < 10}; $1${4:++}) {\n\t${5}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forr"
        ],
        "opts": []
      },
      {
        "content": "while (${1:/* condition */}) {\n\t${2}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh"
        ],
        "opts": []
      },
      {
        "content": "do {\n\t${2}\n} while (${1:/* condition */});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "do"
        ],
        "opts": []
      },
      {
        "content": "${1:void} ${2:function_name}(${3})\n{\n\t${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fun"
        ],
        "opts": []
      },
      {
        "content": "pinMode(${1}, OUTPUT);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pinout"
        ],
        "opts": []
      },
      {
        "content": "pinMode(${1}, INPUT);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pinin"
        ],
        "opts": []
      },
      {
        "content": "digitalWrite(${1}, HIGH);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dwHigh"
        ],
        "opts": []
      },
      {
        "content": "digitalWrite(${1}, LOW);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dwLow"
        ],
        "opts": []
      },
      {
        "content": "digitalRead(${1});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dr"
        ],
        "opts": []
      },
      {
        "content": "analogRead(${1});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ar"
        ],
        "opts": []
      },
      {
        "content": "analogWrite(${1});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "aw"
        ],
        "opts": []
      },
      {
        "content": "Serial.read();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sr"
        ],
        "opts": []
      },
      {
        "content": "Serial.write();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sw"
        ],
        "opts": []
      },
      {
        "content": "Serial.print(${1});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sp"
        ],
        "opts": []
      },
      {
        "content": "Serial.println(${1});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sl"
        ],
        "opts": []
      },
      {
        "content": "delay(${1});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dl"
        ],
        "opts": []
      },
      {
        "content": "millis();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ml"
        ],
        "opts": []
      }
    ],
    "asciidoc": [
      {
        "content": "= ${1:Document Name}\n${2:Alice <alice@example.com>}\n${3:Revision line}\n:toc:\n:imagesdir: img/\n:homepage: https://www.example.com\n:icons: font\n:data-uri:\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "Start a new document",
        "matches": [
          "title",
          "doc"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "[source,${1:language}]\n----\n${0}\n----",
        "doc": "",
        "grammar": "snu",
        "label": "source code block --- source ---",
        "matches": [
          "source",
          "block-source"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "[quote, ${1:Name}, ${2:Occasion}}]\n____\n${0}\n____",
        "doc": "",
        "grammar": "snu",
        "label": "quote block --- text ---",
        "matches": [
          "quote",
          "block-quote"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "....\n${0}\n....",
        "doc": "",
        "grammar": "snu",
        "label": "literal block ... text ...",
        "matches": [
          "block-literal",
          "literalblock"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "*${1}*${0}",
        "doc": "",
        "grammar": "snu",
        "label": "*bold*",
        "matches": [
          "bold"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "_${1}_${0}",
        "doc": "",
        "grammar": "snu",
        "label": "_italic_",
        "matches": [
          "italic"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "\\`${1}\\`${0}",
        "doc": "",
        "grammar": "snu",
        "label": "`monospace`",
        "matches": [
          "monospace"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "\\`+${1}+\\`${0}",
        "doc": "",
        "grammar": "snu",
        "label": "`+codespan+`",
        "matches": [
          "codespan"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "+${1}+${0}",
        "doc": "",
        "grammar": "snu",
        "label": "+verbatim+",
        "matches": [
          "verb"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "== ${1:Title}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "== heading on level 2",
        "matches": [
          "section",
          "heading"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "[#${2:Id}]\n== ${1:Title}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "== heading on level 2 with anchor",
        "matches": [
          "section-anchor",
          "heading-anchor"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "include::${1:example.doc}[]${0}",
        "doc": "",
        "grammar": "snu",
        "label": "include::example.doc",
        "matches": [
          "inc"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "'''\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "horizontal rule",
        "matches": [
          "hrule"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "<<<\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "page break",
        "matches": [
          "pagebreak"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "${1:definiendum}::\n${2:definiens}",
        "doc": "",
        "grammar": "snu",
        "label": "definition",
        "matches": [
          "def"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "[cols=\"${1}\", options=\"header\"]\n|===\n|${2:row1-col1}\n${0}\n|===",
        "doc": "",
        "grammar": "snu",
        "label": "table",
        "matches": [
          "table"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "[%header,format=csv]\n|===\n${0}\n|===",
        "doc": "",
        "grammar": "snu",
        "label": "CSV table",
        "matches": [
          "csvtable",
          "tablecsv"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "${1:https://www.example.org}[${2:Text}]${0}",
        "doc": "",
        "grammar": "snu",
        "label": "External link",
        "matches": [
          "link",
          "extlink"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "link:${1:/example.pdf}[${2:Text}]${0}",
        "doc": "",
        "grammar": "snu",
        "label": "Relative link",
        "matches": [
          "linkrel"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "mailto:${1:alice@example.com}[${2:Alice}]${0}",
        "doc": "",
        "grammar": "snu",
        "label": "mailto link",
        "matches": [
          "mailto"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "[[${1:id}]]${0}",
        "doc": "",
        "grammar": "snu",
        "label": "[[id]] text",
        "matches": [
          "anchor"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "[#${1:Id}] ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "[#anchor] #text#, itemize, ...",
        "matches": [
          "anchorblock",
          "block-anchor"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "<<${1:id}>>${0}",
        "doc": "",
        "grammar": "snu",
        "label": "reference to anchor",
        "matches": [
          "ref"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "image::${1:example.jpg}[${2:Description}]\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "image::file[desc]",
        "matches": [
          "image"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "image::${1:example.jpg}[${2:Description},align=\"center\"]\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "Centered image::file[desc]",
        "matches": [
          "imagecenter"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "image:${1:example.jpg}[${2:Description}]${0}",
        "doc": "",
        "grammar": "snu",
        "label": "Inline image:file[desc]",
        "matches": [
          "imageinline"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": ".footnote:[${1:footnotetext}]${0}",
        "doc": "",
        "grammar": "snu",
        "label": "footnote",
        "matches": [
          "footnote"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "[bibliography]\n== References\n- [[${1:id}]] ${2:Entry}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "bibliography",
        "matches": [
          "bib"
        ],
        "opts": [
          "head"
        ]
      }
    ],
    "asciidoctor": [
      {
        "content": ":source-highlighter: rouge$0",
        "doc": "",
        "grammar": "snu",
        "label": "source-highlighter: rouge",
        "matches": [
          "hirouge",
          "highlight-rouge"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": ":source-highlighter: pygments$0",
        "doc": "",
        "grammar": "snu",
        "label": "source-highlighter: pygments",
        "matches": [
          "highlight-pygments",
          "hipygments"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": ":source-highlighter: highlight.js$0",
        "doc": "",
        "grammar": "snu",
        "label": "source-highlighter: highlight.js",
        "matches": [
          "hihighlight.js",
          "highlight-highlight.js"
        ],
        "opts": [
          "head"
        ]
      }
    ],
    "asm": [
      {
        "content": ";;\n;; @brief      ${1:function description}\n;;\n;; @details    ${2:detailed description}\n;;\n;; @param      ${3:param}\n;;\n;; @return     ${4:return}\n;;",
        "doc": "",
        "grammar": "snu",
        "label": ";; @brief ...",
        "matches": [
          "doxy"
        ],
        "opts": [
          "head"
        ]
      }
    ],
    "autoit": [
      {
        "content": "If ${1:condition} Then\n\t${0:; True code}\nEndIf",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "Else\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "el"
        ],
        "opts": []
      },
      {
        "content": "ElseIf ${1:condition} Then\n\t${0:; True code}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eif"
        ],
        "opts": []
      },
      {
        "content": "If ${1:condition} Then\n\t${2:; True code}\nElse\n\t${0:; Else code}\nEndIf",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "If ${1:condition 1} Then\n\t${2:; True code}\nElseIf ${3:condition 2} Then\n\t${4:; True code}\nElse\n\t${0:; Else code}\nEndIf",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifelif"
        ],
        "opts": []
      },
      {
        "content": "Switch (${1:condition})\nCase ${2:case1}:\n\t${3:; Case 1 code}\nCase Else:\n\t${0:; Else code}\nEndSwitch",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "switch"
        ],
        "opts": []
      },
      {
        "content": "Select (${1:condition})\nCase ${2:case1}:\n\t${3:; Case 1 code}\nCase Else:\n\t${0:; Else code}\nEndSelect",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "select"
        ],
        "opts": []
      },
      {
        "content": "While (${1:condition})\n\t${0:; code...}\nWEnd",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh"
        ],
        "opts": []
      },
      {
        "content": "For ${1:n} = ${3:1} to ${2:count}\n\t${0:; code...}\nNext",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "Func ${1:fname}(${2:`indent('.') ? 'self' : ''`}):\n\t${0:Return}\nEndFunc",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "func"
        ],
        "opts": []
      },
      {
        "content": "MsgBox(${0:MsgType}, ${1:\"Title\"}, ${2:\"Message Text\"})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "msg"
        ],
        "opts": []
      },
      {
        "content": "MsgBox(0, \"Debug\", ${0:\"Debug Message\"})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "debug"
        ],
        "opts": []
      },
      {
        "content": "MsgBox(0, \"${0:VarName}\", $1)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "showvar"
        ],
        "opts": []
      }
    ],
    "awk": [
      {
        "content": "#!/usr/bin/awk -f",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#! #!/usr/bin/awk -f"
        ],
        "opts": []
      },
      {
        "content": "@include \"${1}\"${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "inc @include"
        ],
        "opts": []
      },
      {
        "content": "@load \"${1}\"${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "loa @load"
        ],
        "opts": []
      },
      {
        "content": "BEGIN {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "beg BEGIN { ... }"
        ],
        "opts": []
      },
      {
        "content": "BEGINFILE {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "begf BEGINFILE { ... }"
        ],
        "opts": []
      },
      {
        "content": "END {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "end END { ... }"
        ],
        "opts": []
      },
      {
        "content": "ENDFILE {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "endf ENDFILE { ... }"
        ],
        "opts": []
      },
      {
        "content": "print ${1:\"${2}\"}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pri print"
        ],
        "opts": []
      },
      {
        "content": "printf(\"${1:%s}\\n\", ${2})${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "printf printf"
        ],
        "opts": []
      },
      {
        "content": "IGNORECASE = ${1:1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ign IGNORECASE"
        ],
        "opts": []
      },
      {
        "content": "if (${1}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if if {...}"
        ],
        "opts": []
      },
      {
        "content": "if (${1}) {\n\t${2:${VISUAL}}\n} else {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife if ... else ..."
        ],
        "opts": []
      },
      {
        "content": "else if (${1}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eif else if ..."
        ],
        "opts": []
      },
      {
        "content": "else {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "el else {...}"
        ],
        "opts": []
      },
      {
        "content": "while (${1}) {\n\t${2}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh while"
        ],
        "opts": []
      },
      {
        "content": "do {\n\t${0}\n} while (${1})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "do do ... while"
        ],
        "opts": []
      },
      {
        "content": "for (${2:i} = 0; i < ${1:n}; ${3:++i}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for for"
        ],
        "opts": []
      },
      {
        "content": "for (${1:i} in ${2:array}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fore for each"
        ],
        "opts": []
      },
      {
        "content": "switch (${1}) {\ncase ${2}:\n\t${3}\n\tbreak\ndefault:\n\t${0}\n\tbreak\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sw switch"
        ],
        "opts": []
      },
      {
        "content": "case ${1}:\n\t${0}\n\tbreak",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case case"
        ],
        "opts": []
      }
    ],
    "axios": [
      {
        "content": "const axios = require('axios').default;",
        "doc": "require axios",
        "grammar": "lsp",
        "label": "axios-require",
        "matches": [
          "axios require"
        ],
        "opts": []
      },
      {
        "content": "import axios from 'axios';",
        "doc": "import axios",
        "grammar": "lsp",
        "label": "axios-import",
        "matches": [
          "axios import"
        ],
        "opts": []
      },
      {
        "content": "axios.get('${1:uri}')\n.then(function (response) {\n\t${2:success}\n})\n.catch(function (error) {\n\t${3:error}\n})",
        "doc": "Use Axios to make a get request - promise based",
        "grammar": "lsp",
        "label": "axios-get-promise",
        "matches": [
          "axios get promise"
        ],
        "opts": []
      },
      {
        "content": "async function ${1:name}() {\n\ttry {\n\t\tconst response = await axios.get('${2:uri}');\n\t\t${3:success}\n\t}\tcatch (error) {\n\t\t${4:error}\n\t}\n}",
        "doc": "Use Axios to make a get request - async-await",
        "grammar": "lsp",
        "label": "axios-get-async-await",
        "matches": [
          "axios get async await"
        ],
        "opts": []
      },
      {
        "content": "axios.post('${1:uri}', ${2:post})\n.then(function (response) {\n\t${3:success}\n})\n.catch(function (error) {\n\t${4:error}\n})",
        "doc": "Use Axios to make a post request - promise based",
        "grammar": "lsp",
        "label": "axios-post-promise",
        "matches": [
          "axios post promise"
        ],
        "opts": []
      },
      {
        "content": "async function ${1:name}() {\n\ttry {\n\t\tconst response = await axios.post('${2:uri}', ${3:post});\n\t\t${4:success}\n\t}\tcatch (error) {\n\t\t${5:error}\n\t}\n}",
        "doc": "Use Axios to make a post request - async-await",
        "grammar": "lsp",
        "label": "axios-post-async-await",
        "matches": [
          "axios post async await"
        ],
        "opts": []
      },
      {
        "content": "const ${1:instance} = axios.create({\n\tbaseURL: '${2:uri}',\n\ttimeout: $3,\n\theaders: {'${4:key}': '${5:value}'}",
        "doc": "Create an Axios instance for requests",
        "grammar": "lsp",
        "label": "axios-instance",
        "matches": [
          "axios instance"
        ],
        "opts": []
      },
      {
        "content": "axios.defaults.${1:key} = '${2:value}';",
        "doc": "Define global axios defaults, eg. baseURL, headers etc.",
        "grammar": "lsp",
        "label": "axios-defaults",
        "matches": [
          "axios defaults"
        ],
        "opts": []
      },
      {
        "content": "axios.interceptors.request.use(function (config) {\n\t${1:do something}\nreturn config;\n}, function (error) {\n\t${2:do something}\n$return Promise.reject(error);\n});",
        "doc": "You can intercept requests before they are handled by then or catch.",
        "grammar": "lsp",
        "label": "axios-interceptors-request",
        "matches": [
          "axios interceptors request"
        ],
        "opts": []
      },
      {
        "content": "axios.interceptors.response.use(function (response) {\n\t${1:do something}\nreturn response;\n}, function (error) {\n\t${2:do something}\n$return Promise.reject(error);\n});",
        "doc": "You can intercept responses before they are handled by then or catch.",
        "grammar": "lsp",
        "label": "axios-interceptors-response",
        "matches": [
          "axios interceptors response"
        ],
        "opts": []
      }
    ],
    "base": [
      {
        "content": "var ${1:name} = ${2:value};",
        "doc": "var assignment",
        "grammar": "lsp",
        "label": "var-assignment",
        "matches": [
          "base var"
        ],
        "opts": []
      },
      {
        "content": "let ${1:name} = ${2:value};",
        "doc": "let assignment",
        "grammar": "lsp",
        "label": "let-assignment",
        "matches": [
          "base let"
        ],
        "opts": []
      },
      {
        "content": "let {${1:name}} = ${2:value};",
        "doc": "Object destructing",
        "grammar": "lsp",
        "label": "destructuring-let-assignment",
        "matches": [
          "base let destruct object"
        ],
        "opts": []
      },
      {
        "content": "let [${1:name}] = ${2:value};",
        "doc": "Array destructing",
        "grammar": "lsp",
        "label": "destructuring-let-array",
        "matches": [
          "base let destruct array"
        ],
        "opts": []
      },
      {
        "content": "const ${1:name} = ${2:value};",
        "doc": "const assignment",
        "grammar": "lsp",
        "label": "const-assignment",
        "matches": [
          "base const"
        ],
        "opts": []
      },
      {
        "content": "const {${1:name}} = ${2:value};",
        "doc": "Object destructing",
        "grammar": "lsp",
        "label": "destructuring-const-assignment",
        "matches": [
          "base const destruct object"
        ],
        "opts": []
      },
      {
        "content": "const [${2:propertyName}] = ${1:arrayToDestruct};",
        "doc": "Array destructing",
        "grammar": "lsp",
        "label": "destructingarray",
        "matches": [
          "base const destruct array"
        ],
        "opts": []
      },
      {
        "content": "if (${1:condition}) {\n\t${0}\n}",
        "doc": "if statement",
        "grammar": "lsp",
        "label": "if-statement",
        "matches": [
          "base if"
        ],
        "opts": []
      },
      {
        "content": "else {\n\t${0}\n}",
        "doc": "else statement",
        "grammar": "lsp",
        "label": "else-statement",
        "matches": [
          "base else"
        ],
        "opts": []
      },
      {
        "content": "if (${1:condition}) {\n\t${0}\n} else {\n\t\n}",
        "doc": "if/else statement",
        "grammar": "lsp",
        "label": "if-else-statement",
        "matches": [
          "base if else"
        ],
        "opts": []
      },
      {
        "content": "else if (${1:condition}) {\n\t${0}\n}",
        "doc": "else if statement",
        "grammar": "lsp",
        "label": "else-if-statement",
        "matches": [
          "base else if"
        ],
        "opts": []
      },
      {
        "content": "${1:condition} ? ${2:expression} : ${3:expression};",
        "doc": "ternary operator",
        "grammar": "lsp",
        "label": "ternary-operator",
        "matches": [
          "base ternary operator"
        ],
        "opts": []
      },
      {
        "content": "for (let ${1:i} = 0, ${2:len} = ${3:iterable}.length; ${1:i} < ${2:len}; ${1:i}++) {\n\t${0}\n}",
        "doc": "for loop",
        "grammar": "lsp",
        "label": "for-loop",
        "matches": [
          "base for"
        ],
        "opts": []
      },
      {
        "content": "for (let ${1:i} = ${2:iterable}.length - 1; ${1:i} >= 0; ${1:i}--) {\n\t${0}\n}",
        "doc": "reverse for loop",
        "grammar": "lsp",
        "label": "reverse-for-loop",
        "matches": [
          "base for reverse"
        ],
        "opts": []
      },
      {
        "content": "for (let ${1:key} in ${2:array}) {\n\tif (${2:array}.hasOwnProperty(${1:key})) {\n\t\t${0}\n\t}\n}",
        "doc": "for in loop",
        "grammar": "lsp",
        "label": "for-in-loop",
        "matches": [
          "base for in"
        ],
        "opts": []
      },
      {
        "content": "for (let ${1:key} of ${2:array}) {\n\t${0}\n}",
        "doc": "for of loop (ES6)",
        "grammar": "lsp",
        "label": "for-of-loop-es6-",
        "matches": [
          "base for of"
        ],
        "opts": []
      },
      {
        "content": "while (${1:condition}) {\n\t${0}\n}",
        "doc": "while loop",
        "grammar": "lsp",
        "label": "while-loop",
        "matches": [
          "base while"
        ],
        "opts": []
      },
      {
        "content": "try {\n\t${0}\n} catch (${1:err}) {\n\t\n}",
        "doc": "try/catch",
        "grammar": "lsp",
        "label": "try-catch",
        "matches": [
          "base try catch"
        ],
        "opts": []
      },
      {
        "content": "try {\n\t${0}\n} finally {\n\t\n}",
        "doc": "try/finally",
        "grammar": "lsp",
        "label": "try-finally",
        "matches": [
          "base try finally"
        ],
        "opts": []
      },
      {
        "content": "try {\n\t${0}\n} catch (${1:err}) {\n\t\n} finally {\n\t\n}",
        "doc": "try/catch/finally",
        "grammar": "lsp",
        "label": "try-catch-finally",
        "matches": [
          "base try catch finally"
        ],
        "opts": []
      },
      {
        "content": "switch (${1:expr}) {\n\tcase ${2:value}:\n\t\treturn $0;\n\tdefault:\n\t\treturn;\n}",
        "doc": "switch case",
        "grammar": "lsp",
        "label": "switch-case",
        "matches": [
          "base switch case"
        ],
        "opts": []
      },
      {
        "content": "function (${1:arguments}) {\n\t${0}\n}",
        "doc": "anonymous function",
        "grammar": "lsp",
        "label": "anonymous-function",
        "matches": [
          "base function anonymous"
        ],
        "opts": []
      },
      {
        "content": "function ${1:name}(${2:arguments}) {\n\t${0}\n}",
        "doc": "named function",
        "grammar": "lsp",
        "label": "named-function",
        "matches": [
          "base function named"
        ],
        "opts": []
      },
      {
        "content": "((${1:arguments}) => {\n\t${0}\n})(${2});",
        "doc": "immediately-invoked function expression (IIFE)",
        "grammar": "lsp",
        "label": "immediately-invoked-function-expression-iife-",
        "matches": [
          "base function immediate"
        ],
        "opts": []
      },
      {
        "content": "${1:fn}.apply(${2:this}, ${3:arguments})",
        "doc": "function apply",
        "grammar": "lsp",
        "label": "function-apply",
        "matches": [
          "base function apply"
        ],
        "opts": []
      },
      {
        "content": "${1:fn}.call(${2:this}, ${3:arguments})",
        "doc": "function call",
        "grammar": "lsp",
        "label": "function-call",
        "matches": [
          "base function call"
        ],
        "opts": []
      },
      {
        "content": "${1:fn}.bind(${2:this}, ${3:arguments})",
        "doc": "function bind",
        "grammar": "lsp",
        "label": "function-bind",
        "matches": [
          "base function bind"
        ],
        "opts": []
      },
      {
        "content": "(${1:arguments}) => ${2:statement}",
        "doc": "arrow function (ES6)",
        "grammar": "lsp",
        "label": "arrow-function-es6-",
        "matches": [
          "base function arrow"
        ],
        "opts": []
      },
      {
        "content": "(${1:arguments}) => {\n\t${0}\n}",
        "doc": "arrow function with body (ES6)",
        "grammar": "lsp",
        "label": "arrow-function-with-body-es6-",
        "matches": [
          "base function arrow body"
        ],
        "opts": []
      },
      {
        "content": "function* (${1:arguments}) {\n\t${0}\n}",
        "doc": "generator function (ES6)",
        "grammar": "lsp",
        "label": "generator-function-es6-",
        "matches": [
          "base function generator"
        ],
        "opts": []
      },
      {
        "content": "function* ${1:name}(${2:arguments}) {\n\t${0}\n}",
        "doc": "named generator function (ES6)",
        "grammar": "lsp",
        "label": "named-generator-function-es6-",
        "matches": [
          "base function generator named"
        ],
        "opts": []
      },
      {
        "content": "[...Array(${1:length}).keys()]${0}",
        "doc": "sequence of 0..n",
        "grammar": "lsp",
        "label": "sequence-of-0-n",
        "matches": [
          "base sequence of"
        ],
        "opts": []
      },
      {
        "content": "${1}.forEach((${2:item}) => {\n\t${0}\n});",
        "doc": "forEach loop",
        "grammar": "lsp",
        "label": "foreach-loop",
        "matches": [
          "base foreach"
        ],
        "opts": []
      },
      {
        "content": "${1}.map((${2:item}) => {\n\t${0}\n});",
        "doc": "map",
        "grammar": "lsp",
        "label": "map",
        "matches": [
          "base map"
        ],
        "opts": []
      },
      {
        "content": "${1}.reduce((${2:previous}, ${3:current}) => {\n\t${0}\n}${4:, initial});",
        "doc": "reduce",
        "grammar": "lsp",
        "label": "reduce",
        "matches": [
          "base reduce"
        ],
        "opts": []
      },
      {
        "content": "${1}.filter(${2:item} => {\n\t${0}\n});",
        "doc": "filter",
        "grammar": "lsp",
        "label": "filter",
        "matches": [
          "base filter"
        ],
        "opts": []
      },
      {
        "content": "${1}.find(${2:item} => {\n\t${0}\n});",
        "doc": "find",
        "grammar": "lsp",
        "label": "find",
        "matches": [
          "base find"
        ],
        "opts": []
      },
      {
        "content": "class ${1:name} {\n\tconstructor(${2:arguments}) {\n\t\t${0}\n\t}\n}",
        "doc": "class (ES6)",
        "grammar": "lsp",
        "label": "class-es6-",
        "matches": [
          "base class"
        ],
        "opts": []
      },
      {
        "content": "class ${1:name} extends ${2:base} {\n\tconstructor(${3:arguments}) {\n\t\tsuper(${3:arguments});\n\t\t${0}\n\t}\n}",
        "doc": "child class (ES6)",
        "grammar": "lsp",
        "label": "child-class-es6-",
        "matches": [
          "base child class"
        ],
        "opts": []
      },
      {
        "content": "constructor(${1:arguments}) {\n\tsuper(${1:arguments});${0}\n}",
        "doc": "class constructor (ES6)",
        "grammar": "lsp",
        "label": "class-constructor-es6-",
        "matches": [
          "base class constructor"
        ],
        "opts": []
      },
      {
        "content": "${1:method}(${2:arguments}) {\n\t${0}\n}",
        "doc": "method (ES6 syntax)",
        "grammar": "lsp",
        "label": "method-es6-syntax-",
        "matches": [
          "base method"
        ],
        "opts": []
      },
      {
        "content": "get ${1:property}() {\n\t${0}\n}",
        "doc": "getter (ES6 syntax)",
        "grammar": "lsp",
        "label": "getter-es6-syntax-",
        "matches": [
          "base getter"
        ],
        "opts": []
      },
      {
        "content": "set ${1:property}(${2:value}) {\n\t${0}\n}",
        "doc": "setter (ES6 syntax)",
        "grammar": "lsp",
        "label": "setter-es6-syntax-",
        "matches": [
          "base setter"
        ],
        "opts": []
      },
      {
        "content": "get ${1:property}() {\n\t${0}\n}\nset ${1:property}(${2:value}) {\n\t\n}",
        "doc": "getter and setter (ES6 syntax)",
        "grammar": "lsp",
        "label": "getter-and-setter-es6-syntax-",
        "matches": [
          "base getter setter"
        ],
        "opts": []
      },
      {
        "content": "${1:Class}.prototype.${2:method} = function(${3:arguments}) {\n\t${0}\n};",
        "doc": "prototype method",
        "grammar": "lsp",
        "label": "prototype-method",
        "matches": [
          "base prototype method"
        ],
        "opts": []
      },
      {
        "content": "Object.assign(${1:dest}, ${2:source})",
        "doc": "Object.assign",
        "grammar": "lsp",
        "label": "object-assign",
        "matches": [
          "base object assign"
        ],
        "opts": []
      },
      {
        "content": "Object.assign({}, ${1:original}, ${2:source})",
        "doc": "Object.assign copy (shallow clone)",
        "grammar": "lsp",
        "label": "object-assign-copy-shallow-clone-",
        "matches": [
          "base object assign copy"
        ],
        "opts": []
      },
      {
        "content": "return ${0};",
        "doc": "return",
        "grammar": "lsp",
        "label": "return",
        "matches": [
          "base return"
        ],
        "opts": []
      },
      {
        "content": "return new Promise((resolve, reject) => {\n\t${0}\n});",
        "doc": "return Promise (ES6)",
        "grammar": "lsp",
        "label": "return-promise-es6-",
        "matches": [
          "base return promise"
        ],
        "opts": []
      },
      {
        "content": "return (\n\t${0}\n);",
        "doc": "return complex value (such as JSX components)",
        "grammar": "lsp",
        "label": "return-complex-value-such-as-jsx-components-",
        "matches": [
          "base return complex value"
        ],
        "opts": []
      },
      {
        "content": "typeof ${1:source} === '${2:undefined}'",
        "doc": "typeof",
        "grammar": "lsp",
        "label": "typeof",
        "matches": [
          "base typeof"
        ],
        "opts": []
      },
      {
        "content": "${1:source} instanceof ${2:Object}",
        "doc": "instanceof",
        "grammar": "lsp",
        "label": "instanceof",
        "matches": [
          "base instanceof"
        ],
        "opts": []
      },
      {
        "content": "new Promise((resolve, reject) => {\n\t${0}\n})",
        "doc": "Promise (ES6)",
        "grammar": "lsp",
        "label": "promise-es6-",
        "matches": [
          "base promise"
        ],
        "opts": []
      },
      {
        "content": "${1:promise}.then((${2:value}) => {\n\t${0}\n})",
        "doc": "Promise.then",
        "grammar": "lsp",
        "label": "promise-then",
        "matches": [
          "base promise then"
        ],
        "opts": []
      },
      {
        "content": "${1:promise}.catch((${2:err}) => {\n\t${0}\n})",
        "doc": "Promise.catch",
        "grammar": "lsp",
        "label": "promise-catch",
        "matches": [
          "base promise catch"
        ],
        "opts": []
      },
      {
        "content": "export const ${1:exportVariable} = ${2:localVariable};\n",
        "doc": "Export named variable in ES6 syntax",
        "grammar": "lsp",
        "label": "exportnamedvariable",
        "matches": [
          "base export named variable"
        ],
        "opts": []
      },
      {
        "content": "export const ${1:functionName} = (${2:params}) => {\n\t$0\n};\n",
        "doc": "Export named function in ES6 syntax",
        "grammar": "lsp",
        "label": "exportnamedfunction",
        "matches": [
          "base export named function"
        ],
        "opts": []
      },
      {
        "content": "export default function ${1:${TM_FILENAME_BASE}}(${2:params}) {\n\t$0\n};\n",
        "doc": "Export default function in ES6 syntax",
        "grammar": "lsp",
        "label": "exportdefaultfunction",
        "matches": [
          "base export default function"
        ],
        "opts": []
      },
      {
        "content": "export default class ${1:className} {\n\t$0\n};\n",
        "doc": "Export default class in ES6 syntax",
        "grammar": "lsp",
        "label": "exportclass",
        "matches": [
          "base export class"
        ],
        "opts": []
      },
      {
        "content": "export default class ${1:className} extends ${2:baseclassName} {\n\t$0\n};\n",
        "doc": "Export default class which extends a base one in ES6 syntax",
        "grammar": "lsp",
        "label": "exportclassextends",
        "matches": [
          "base export class extends"
        ],
        "opts": []
      },
      {
        "content": "import ${2:moduleName} from '${1:module}';$0",
        "doc": "Imports entire module statement in ES6 syntax",
        "grammar": "lsp",
        "label": "import",
        "matches": [
          "base import"
        ],
        "opts": []
      },
      {
        "content": "import '${1:module}';$0",
        "doc": "Imports entire module in ES6 syntax without module name",
        "grammar": "lsp",
        "label": "importnomodulename",
        "matches": [
          "base import no module name"
        ],
        "opts": []
      },
      {
        "content": "import { $2 } from '${1:module}';$0",
        "doc": "Imports only a portion of the module in ES6 syntax",
        "grammar": "lsp",
        "label": "importdestructing",
        "matches": [
          "base import destructing"
        ],
        "opts": []
      },
      {
        "content": "import * as ${2:alias} from '${1:module}';$0",
        "doc": "Imports everything as alias from the module in ES6 syntax",
        "grammar": "lsp",
        "label": "importeverything",
        "matches": [
          "base import everything"
        ],
        "opts": []
      },
      {
        "content": "import { ${2:originalName} as ${3:alias} } from '${1:module}';$0",
        "doc": "Imports a specific portion of the module by assigning a local alias in ES6 syntax",
        "grammar": "lsp",
        "label": "importas",
        "matches": [
          "base import as"
        ],
        "opts": []
      },
      {
        "content": "require('${1:module}');",
        "doc": "require",
        "grammar": "lsp",
        "label": "require",
        "matches": [
          "base require"
        ],
        "opts": []
      },
      {
        "content": "require('./${1:module}');",
        "doc": "require local",
        "grammar": "lsp",
        "label": "require-local",
        "matches": [
          "base require local"
        ],
        "opts": []
      },
      {
        "content": "const ${1:module} = require('${1:module}');",
        "doc": "require assignment",
        "grammar": "lsp",
        "label": "require-assignment",
        "matches": [
          "base require assignment"
        ],
        "opts": []
      },
      {
        "content": "const ${1:module} = require('./${1:module}');",
        "doc": "require assignment local",
        "grammar": "lsp",
        "label": "require-assignment-local",
        "matches": [
          "base require assignment local"
        ],
        "opts": []
      },
      {
        "content": "const {${1:module}} = require('${1:module}');",
        "doc": "destructuring require assignment",
        "grammar": "lsp",
        "label": "destructuring-require-assignment",
        "matches": [
          "base require assignment"
        ],
        "opts": []
      },
      {
        "content": "const {${1:module}} = require('./${1:module}');",
        "doc": "destructuring require assignment local",
        "grammar": "lsp",
        "label": "destructuring-require-assignment-local",
        "matches": [
          "base require assignment local destruct"
        ],
        "opts": []
      },
      {
        "content": "exports.${1:member} = ${2:value};",
        "doc": "exports.member",
        "grammar": "lsp",
        "label": "exports-member",
        "matches": [
          "base exports member"
        ],
        "opts": []
      },
      {
        "content": "module.exports = ${1:name};",
        "doc": "module.exports",
        "grammar": "lsp",
        "label": "module-exports",
        "matches": [
          "base module exports"
        ],
        "opts": []
      },
      {
        "content": "module.exports = {\n\t${1:member}\n};",
        "doc": "module exports object",
        "grammar": "lsp",
        "label": "module-exports-object",
        "matches": [
          "base module exports object"
        ],
        "opts": []
      },
      {
        "content": "${1:emitter}.on('${2:event}', (${3:arguments}) => {\n\t${0}\n});",
        "doc": "event handler",
        "grammar": "lsp",
        "label": "event-handler",
        "matches": [
          "base event handler"
        ],
        "opts": []
      },
      {
        "content": "console.assert(${1:expression}, ${2:object});",
        "doc": "If the specified expression is false, the message is written to the console along with a stack trace",
        "grammar": "lsp",
        "label": "consoleassert",
        "matches": [
          "base console assert"
        ],
        "opts": []
      },
      {
        "content": "console.clear();",
        "doc": "Clears the console",
        "grammar": "lsp",
        "label": "consoleclear",
        "matches": [
          "base console clear"
        ],
        "opts": []
      },
      {
        "content": "console.count(${1:label});",
        "doc": "Writes the the number of times that count() has been invoked at the same line and with the same label",
        "grammar": "lsp",
        "label": "consolecount",
        "matches": [
          "base console count"
        ],
        "opts": []
      },
      {
        "content": "console.debug(${1:object});",
        "doc": "Displays a message in the console. Also display a blue right arrow icon along with the logged message in Safari",
        "grammar": "lsp",
        "label": "consoledebug",
        "matches": [
          "base console debug"
        ],
        "opts": []
      },
      {
        "content": "console.dir(${1:object});",
        "doc": "Prints a JavaScript representation of the specified object",
        "grammar": "lsp",
        "label": "consoledir",
        "matches": [
          "base console dir"
        ],
        "opts": []
      },
      {
        "content": "console.error(${1:object});",
        "doc": "Displays a message in the console and also includes a stack trace from where the method was called",
        "grammar": "lsp",
        "label": "consoleerror",
        "matches": [
          "base console error"
        ],
        "opts": []
      },
      {
        "content": "console.group('${1:label}');",
        "doc": "Groups and indents all following output by an additional level, until console.groupEnd() is called.",
        "grammar": "lsp",
        "label": "consolegroup",
        "matches": [
          "base console group"
        ],
        "opts": []
      },
      {
        "content": "console.groupEnd();",
        "doc": "Closes out the corresponding console.group().",
        "grammar": "lsp",
        "label": "consolegroupend",
        "matches": [
          "base console group end"
        ],
        "opts": []
      },
      {
        "content": "console.log(${1:object});",
        "doc": "Displays a message in the console",
        "grammar": "lsp",
        "label": "consolelog",
        "matches": [
          "base console log"
        ],
        "opts": []
      },
      {
        "content": "console.log('${1:object} :>> ', ${1:object});",
        "doc": "Displays an object in the console with its name",
        "grammar": "lsp",
        "label": "consolelogobject",
        "matches": [
          "base console log object"
        ],
        "opts": []
      },
      {
        "content": "console.trace(${1:object});",
        "doc": "Prints a stack trace from the point where the method was called",
        "grammar": "lsp",
        "label": "consoletrace",
        "matches": [
          "base console trace"
        ],
        "opts": []
      },
      {
        "content": "console.warn(${1:object});",
        "doc": "Displays a message in the console but also displays a yellow warning icon along with the logged message",
        "grammar": "lsp",
        "label": "consolewarn",
        "matches": [
          "base console warn"
        ],
        "opts": []
      },
      {
        "content": "console.info(${1:object});",
        "doc": "Displays a message in the console but also displays a blue information icon along with the logged message",
        "grammar": "lsp",
        "label": "consoleinfo",
        "matches": [
          "base console info"
        ],
        "opts": []
      },
      {
        "content": "console.table(${1:object});",
        "doc": "Displays tabular data as a table.",
        "grammar": "lsp",
        "label": "consoletable",
        "matches": [
          "base console table"
        ],
        "opts": []
      },
      {
        "content": "console.time(${1:object});",
        "doc": "Sets starting point for execution time measurement",
        "grammar": "lsp",
        "label": "consoletime",
        "matches": [
          "base console time"
        ],
        "opts": []
      },
      {
        "content": "console.timeEnd(${1:object});",
        "doc": "Sets end point for execution time measurement",
        "grammar": "lsp",
        "label": "consoletimeend",
        "matches": [
          "base console time end"
        ],
        "opts": []
      },
      {
        "content": "setTimeout(() => {\n\t${0}\n}, ${1:delay});",
        "doc": "setTimeout",
        "grammar": "lsp",
        "label": "settimeout",
        "matches": [
          "base set timeout"
        ],
        "opts": []
      },
      {
        "content": "setInterval(() => {\n\t${0}\n}, ${1:delay});",
        "doc": "setInterval",
        "grammar": "lsp",
        "label": "setinterval",
        "matches": [
          "base set interval"
        ],
        "opts": []
      },
      {
        "content": "setImmediate(() => {\n\t${0}\n});",
        "doc": "setImmediate",
        "grammar": "lsp",
        "label": "setimmediate",
        "matches": [
          "base set immediate"
        ],
        "opts": []
      },
      {
        "content": "process.nextTick(() => {\n\t${0}\n});",
        "doc": "process nextTick",
        "grammar": "lsp",
        "label": "process-nexttick",
        "matches": [
          "base process next tick"
        ],
        "opts": []
      },
      {
        "content": "'use strict';",
        "doc": "insert 'use strict' statement",
        "grammar": "lsp",
        "label": "insert-use-strict-statement",
        "matches": [
          "base use strict"
        ],
        "opts": []
      }
    ],
    "beancount": [
      {
        "content": "${1:YYYY}-${2:MM}-${3:DD} open ${4:Account} ${8:#:Commodity}",
        "doc": "",
        "grammar": "snu",
        "label": "open account",
        "matches": [
          "open"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "${1:YYYY}-${2:MM}-${3:DD} close ${4:#:Account}",
        "doc": "",
        "grammar": "snu",
        "label": "close account",
        "matches": [
          "close"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "${1:YYYY}-${2:MM}-${3:DD} commodity ${4:Commodity}",
        "doc": "",
        "grammar": "snu",
        "label": "declare commodity",
        "matches": [
          "commodity",
          "currency"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "${1:YYYY}-${2:MM}-${3:DD} * \"${5:Payee}\" \"${6:Narration}\"\n\t${9:Account} ${10:Amount} ${11:Commodity}\n\t${14:Account} ${15:#:Amount} ${16:#:Commodity}",
        "doc": "",
        "grammar": "snu",
        "label": "transaction",
        "matches": [
          "transaction"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "${1:YYYY}-${2:MM}-${3:DD} balance ${4:Account} ${5:Amount} ${6:#:Commodity}",
        "doc": "",
        "grammar": "snu",
        "label": "balance",
        "matches": [
          "balance"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "${1:YYYY}-${2:MM}-${3:DD} pad ${4:BalanceAccount} ${5:PadAccount}",
        "doc": "",
        "grammar": "snu",
        "label": "pad",
        "matches": [
          "pad"
        ],
        "opts": [
          "head"
        ]
      }
    ],
    "bib": [
      {
        "content": "@article{${1:LABEL},\n    author = {${2}},\n    title = {${3}},\n    journal = {${4}},\n    year = {${5}},\n    memo = {volume, number, pages, month, note}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "article",
          "@article"
        ],
        "opts": []
      },
      {
        "content": "@book{${1:LABEL},\n    author/editor = {${2}},\n    title = {${3}},\n    publisher = {${4}},\n    year = {${5}},\n    memo = {volume, series, address, edition, month, note},\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@book",
          "book"
        ],
        "opts": []
      },
      {
        "content": "@booklet{${1:LABEL},\n    title = {${2}},\n    memo = {author, howpublished, address, month, year, note},\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@booklet",
          "booklet"
        ],
        "opts": []
      },
      {
        "content": "@inbook{${1:LABEL},\n    author/editor = {${2}},\n    title = {${3}},\n    chapter/pages = {${4}},\n    publisher = {${5}},\n    year = {${6}},\n    memo = {volume, series, address, edition, month, note},\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@inbook",
          "inbook"
        ],
        "opts": []
      },
      {
        "content": "@incollection{${1:LABEL},\n    author = {${2}},\n    title = {${3}},\n    booktitle = {${4}},\n    year = {${5}},\n    memo = {editor, pages, organization, publisher, address, month, note},\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "incollection",
          "@incollection"
        ],
        "opts": []
      },
      {
        "content": "@inproceedings{${1:LABEL},\n    author = {${2}},\n    title = {${3}},\n    booktitle = {${4}},\n    year = {${5}},\n    memo = {editor, volume, number, series, pages, address, month,\n        organization, publisher, note}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@inproceedings @conference conference",
          "inproceedings"
        ],
        "opts": []
      },
      {
        "content": "@manual{${1:LABEL},\n    title = {${2}},\n    memo = {author, organization, address, edition, month, year, note},\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "manual",
          "@manual"
        ],
        "opts": []
      },
      {
        "content": "@mastersthesis{${1:LABEL},\n    author = {${2}},\n    title = {${3}},\n    school = {${4}},\n    year = {${5}},\n    memo = {address, month, note},\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mastersthesis",
          "@mastersthesis"
        ],
        "opts": []
      },
      {
        "content": "@misc{${1:LABEL},\n    memo = {author, title, howpublished, month, year, note},\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "misc",
          "@misc"
        ],
        "opts": []
      },
      {
        "content": "@online{${1:LABEL},\n    author = {${2}},\n    title = {${3}},\n    url = {${4}},\n    note = {year/date},\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@online",
          "online"
        ],
        "opts": []
      },
      {
        "content": "@phdthesis{${1:LABEL},\n    author = {${2}},\n    title = {${3}},\n    school = {${4}},\n    year = {${5}},\n    memo = {address, month, note},\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@phdthesis",
          "phdthesis"
        ],
        "opts": []
      },
      {
        "content": "@proceedings{${1:LABEL},\n    title = {${2}},\n    year = {${3}},\n    memo = {editor, publisher, organization, address, month, note},\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "proceedings",
          "@proceedings"
        ],
        "opts": []
      },
      {
        "content": "@techreport{${1:LABEL},\n    author = {${2}},\n    title = {${3}},\n    institution = {${4}},\n    year = {${5}},\n    memo = {type, number, address, month, note},\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@techreport",
          "techreport"
        ],
        "opts": []
      },
      {
        "content": "@unpublished{${1:LABEL},\n    author = {${2}},\n    title = {${3}},\n    note = {${4}},\n    memo = {month, year},\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@unpublished",
          "unpublished"
        ],
        "opts": []
      },
      {
        "content": "address = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "address"
        ],
        "opts": []
      },
      {
        "content": "annote = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "annote"
        ],
        "opts": []
      },
      {
        "content": "author = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "author"
        ],
        "opts": []
      },
      {
        "content": "booktitle = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "booktitle"
        ],
        "opts": []
      },
      {
        "content": "crossref = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "crossref"
        ],
        "opts": []
      },
      {
        "content": "chapter = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "chapter"
        ],
        "opts": []
      },
      {
        "content": "edition = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "edition"
        ],
        "opts": []
      },
      {
        "content": "editor = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "editor"
        ],
        "opts": []
      },
      {
        "content": "eprint = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eprint"
        ],
        "opts": []
      },
      {
        "content": "howpublished = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "howpublished"
        ],
        "opts": []
      },
      {
        "content": "institution = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "institution"
        ],
        "opts": []
      },
      {
        "content": "journal = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "journal"
        ],
        "opts": []
      },
      {
        "content": "key = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "key"
        ],
        "opts": []
      },
      {
        "content": "month = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "month"
        ],
        "opts": []
      },
      {
        "content": "note = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "note"
        ],
        "opts": []
      },
      {
        "content": "number = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "number"
        ],
        "opts": []
      },
      {
        "content": "organization = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "organization"
        ],
        "opts": []
      },
      {
        "content": "pages = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pages"
        ],
        "opts": []
      },
      {
        "content": "publisher = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "publisher"
        ],
        "opts": []
      },
      {
        "content": "school = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "school"
        ],
        "opts": []
      },
      {
        "content": "series = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "series"
        ],
        "opts": []
      },
      {
        "content": "title = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "title"
        ],
        "opts": []
      },
      {
        "content": "type = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "type"
        ],
        "opts": []
      },
      {
        "content": "url = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "url"
        ],
        "opts": []
      },
      {
        "content": "volume = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "volume"
        ],
        "opts": []
      },
      {
        "content": "year = {${1}},\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "year"
        ],
        "opts": []
      },
      {
        "content": "@online{${1:name},\n\tauthor={${2:author}},\n\ttitle={${3:title}},\n\tdate={${4:date}},\n\turl={${5:url}}\n}\n$0",
        "doc": null,
        "grammar": "snu",
        "label": "Online resource",
        "matches": [
          "online"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "@article{${1:name},\n\tauthor={${2:author}},\n\ttitle={${3:title}},\n\tjournaltitle={${4:journal}},\n\tvolume={${5:NN}},\n\tnumber={${6:NN}},\n\tyear={${7:YYYY}},\n\tpages={${8:NN}--${9:NN}}\n}\n$0",
        "doc": null,
        "grammar": "snu",
        "label": "Article reference",
        "matches": [
          "article"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "@book{${1:name},\n\tauthor={${2:author}},\n\ttitle={${3:title}},\n\tsubtitle={${4:subtitle}},\n\tyear={${5:YYYY}},\n\tlocation={${6:somewhere}},\n\tpublisher={${7:publisher}},\n\tpages={${8:NN}--${9:NN}}\n}\n$0",
        "doc": null,
        "grammar": "snu",
        "label": "Book reference",
        "matches": [
          "book"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "@inbook{${1:name},\n\tauthor={${2:author}},\n\ttitle={${3:title}},\n\tsubtitle={${4:subtitle}},\n\tbooktitle={${5:book}},\n\teditor={${6:editor}},\n\tyear={${7:YYYY}},\n\tlocation={${8:somewhere}},\n\tpublisher={${9:publisher}},\n\tpages={${10:NN}--${11:NN}}\n}\n$0",
        "doc": null,
        "grammar": "snu",
        "label": "In Book reference",
        "matches": [
          "inb"
        ],
        "opts": [
          "b"
        ]
      }
    ],
    "bindzone": [],
    "blade": [
      {
        "content": "@yield('${1}')",
        "doc": "",
        "grammar": "snu",
        "label": "@yield",
        "matches": [
          "yl"
        ],
        "opts": []
      },
      {
        "content": "@extends('${1}')",
        "doc": "",
        "grammar": "snu",
        "label": "@extends",
        "matches": [
          "ext"
        ],
        "opts": []
      },
      {
        "content": "@section('${1}', '${2}')",
        "doc": "",
        "grammar": "snu",
        "label": "@section",
        "matches": [
          "sec"
        ],
        "opts": []
      },
      {
        "content": "@section('${1:section name}')\n    ${2}\n@endsection",
        "doc": "",
        "grammar": "snu",
        "label": "@section ... @endsection",
        "matches": [
          "section"
        ],
        "opts": []
      },
      {
        "content": "@section('${1:section name}')\n    @parent\n    ${2}\n@endsection",
        "doc": "",
        "grammar": "snu",
        "label": "@section @parent ... @endsection",
        "matches": [
          "section-parent"
        ],
        "opts": []
      },
      {
        "content": "@component('${1}')\n    ${2}\n@endcomponent",
        "doc": "",
        "grammar": "snu",
        "label": "@component ... @endcomponent",
        "matches": [
          "compo"
        ],
        "opts": []
      },
      {
        "content": "@slot('${1}')\n    ${2}\n@endslot",
        "doc": "",
        "grammar": "snu",
        "label": "@slot ... @endslot",
        "matches": [
          "slot"
        ],
        "opts": []
      },
      {
        "content": "@if(${1:condition})\n   ${2}\n@endif",
        "doc": "",
        "grammar": "snu",
        "label": "if ... endif",
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "@if (${1:condition})\n   ${2}\n@elseif (${3:condition})\n   ${4}\n@else\n   ${5}\n@endif",
        "doc": "",
        "grammar": "snu",
        "label": "if elseif else endif",
        "matches": [
          "ifelse"
        ],
        "opts": []
      },
      {
        "content": "@unless (${1:condition})\n    ${2}\n@endunless",
        "doc": "",
        "grammar": "snu",
        "label": "@unless ... @endunless",
        "matches": [
          "unless"
        ],
        "opts": []
      },
      {
        "content": "@isset(${1})\n    ${2}\n@endisset",
        "doc": "",
        "grammar": "snu",
        "label": "@isset ... @endisset",
        "matches": [
          "isset"
        ],
        "opts": []
      },
      {
        "content": "@empty(${1})\n    ${2}\n@endempty",
        "doc": "",
        "grammar": "snu",
        "label": "@empty ... @endempty",
        "matches": [
          "empty"
        ],
        "opts": []
      },
      {
        "content": "@for ($i = 0; $i < ${1}; $i++)\n    ${2}\n@endfor",
        "doc": "",
        "grammar": "snu",
        "label": "@for ... @endfor",
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "@foreach (${1} as ${2})\n    ${3}\n@endforeach",
        "doc": "",
        "grammar": "snu",
        "label": "@foreach ... @endforeach",
        "matches": [
          "foreach"
        ],
        "opts": []
      },
      {
        "content": "@forelse (${1} as ${2})\n    ${3}\n@empty\n    ${4}\n@endforelse",
        "doc": "",
        "grammar": "snu",
        "label": "@forelse ... @empty ... @endforeach",
        "matches": [
          "forelse"
        ],
        "opts": []
      },
      {
        "content": "@while (${1})\n    ${2}\n@endwhile",
        "doc": "",
        "grammar": "snu",
        "label": "@while ... @endwhile",
        "matches": [
          "while"
        ],
        "opts": []
      },
      {
        "content": "{{-- ${1} --}}",
        "doc": "",
        "grammar": "snu",
        "label": "{{-- comments --}}",
        "matches": [
          "comment"
        ],
        "opts": []
      },
      {
        "content": "@php\n    ${1}\n@endphp",
        "doc": "",
        "grammar": "snu",
        "label": "@php ... @endphp",
        "matches": [
          "php"
        ],
        "opts": []
      },
      {
        "content": "@include('${1}')",
        "doc": "",
        "grammar": "snu",
        "label": "@include",
        "matches": [
          "include"
        ],
        "opts": []
      },
      {
        "content": "@break",
        "doc": null,
        "grammar": "snu",
        "label": "@break",
        "matches": [
          "break"
        ],
        "opts": []
      },
      {
        "content": "@component('$1')\n\t${2:${VISUAL}}\n@endcomponent",
        "doc": null,
        "grammar": "snu",
        "label": "@component directive",
        "matches": [
          "component"
        ],
        "opts": []
      },
      {
        "content": "@each('$1', $$2, '$3')",
        "doc": null,
        "grammar": "snu",
        "label": "@each directive",
        "matches": [
          "each"
        ],
        "opts": []
      },
      {
        "content": "@else",
        "doc": null,
        "grammar": "snu",
        "label": "@else directive",
        "matches": [
          "else"
        ],
        "opts": []
      },
      {
        "content": "@else if ($1)\n\t${2:${VISUAL}}",
        "doc": null,
        "grammar": "snu",
        "label": "@else if directive",
        "matches": [
          "eif"
        ],
        "opts": []
      },
      {
        "content": "@for ($1)\n\t${2:${VISUAL}}\n@endfor",
        "doc": null,
        "grammar": "snu",
        "label": "@for directive",
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "@foreach ($$1 as $$2)\n\t${3:${VISUAL}}\n@endforeach",
        "doc": null,
        "grammar": "snu",
        "label": "@foreach directive",
        "matches": [
          "foreach"
        ],
        "opts": []
      },
      {
        "content": "@extends('$1')",
        "doc": null,
        "grammar": "snu",
        "label": "@extends directive",
        "matches": [
          "extends"
        ],
        "opts": []
      },
      {
        "content": "@if ($1)\n\t${2:${VISUAL}}\n@endif",
        "doc": null,
        "grammar": "snu",
        "label": "@if directive",
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "@if ($1)\n\t${2:${VISUAL}}\n@else\n\t${3:${VISUAL}}\n@endif",
        "doc": null,
        "grammar": "snu",
        "label": "@if @else structure",
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "@include('$1')",
        "doc": null,
        "grammar": "snu",
        "label": "@include directive",
        "matches": [
          "include"
        ],
        "opts": []
      },
      {
        "content": "@includeIf('$1')",
        "doc": null,
        "grammar": "snu",
        "label": "@includeIf directive",
        "matches": [
          "includeIf"
        ],
        "opts": []
      },
      {
        "content": "@isset\n\t${1:${VISUAL}}\n@endisset",
        "doc": null,
        "grammar": "snu",
        "label": "@isset directive",
        "matches": [
          "isset"
        ],
        "opts": []
      },
      {
        "content": "@inject('$1', '$2')",
        "doc": null,
        "grammar": "snu",
        "label": "@inject directive",
        "matches": [
          "inject"
        ],
        "opts": []
      },
      {
        "content": "@lang('$1')",
        "doc": null,
        "grammar": "snu",
        "label": "@lang directive",
        "matches": [
          "lang"
        ],
        "opts": [
          "i"
        ]
      },
      {
        "content": "@php\n\t${1:${VISUAL}}\n@endphp",
        "doc": null,
        "grammar": "snu",
        "label": "@php directive",
        "matches": [
          "php"
        ],
        "opts": []
      },
      {
        "content": "@push('$1')\n\t${2:${VISUAL}}\n@endpush",
        "doc": null,
        "grammar": "snu",
        "label": "@push directive",
        "matches": [
          "push"
        ],
        "opts": []
      },
      {
        "content": "@section('$1')",
        "doc": null,
        "grammar": "snu",
        "label": "@section directive",
        "matches": [
          "section"
        ],
        "opts": []
      },
      {
        "content": "@show",
        "doc": null,
        "grammar": "snu",
        "label": "@show directive",
        "matches": [
          "show"
        ],
        "opts": []
      },
      {
        "content": "@slot('$1')\n\t${2:${VISUAL}}\n@endslot",
        "doc": null,
        "grammar": "snu",
        "label": "@slot directive",
        "matches": [
          "slot"
        ],
        "opts": []
      },
      {
        "content": "@unless\n\t${1:${VISUAL}}\n@endunless",
        "doc": null,
        "grammar": "snu",
        "label": "@unless directive",
        "matches": [
          "unless"
        ],
        "opts": []
      },
      {
        "content": "@verbatim\n\t${0:$VISUAL}\n@endverbatim",
        "doc": null,
        "grammar": "snu",
        "label": "@verbatim directive",
        "matches": [
          "verbatim"
        ],
        "opts": []
      },
      {
        "content": "@while ($1)\n\t${2:${VISUAL}}\n@endwhile",
        "doc": null,
        "grammar": "snu",
        "label": "@while directive",
        "matches": [
          "wh"
        ],
        "opts": []
      },
      {
        "content": "@yield('$1')",
        "doc": null,
        "grammar": "snu",
        "label": "@yield directive",
        "matches": [
          "yield"
        ],
        "opts": []
      },
      {
        "content": "{{ $1 }}",
        "doc": null,
        "grammar": "snu",
        "label": "{{ }} statement.",
        "matches": [
          "{"
        ],
        "opts": [
          "i"
        ]
      },
      {
        "content": "{!! $1 !!}",
        "doc": null,
        "grammar": "snu",
        "label": "{!! !!} statement",
        "matches": [
          "{!"
        ],
        "opts": [
          "i"
        ]
      }
    ],
    "c": [
      {
        "content": "int main(int argc, char *argv[])\n{\n\t${0}\n\treturn 0;\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "main"
        ],
        "opts": []
      },
      {
        "content": "int main(void)\n{\n\t${0}\n\treturn 0;\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mainn"
        ],
        "opts": []
      },
      {
        "content": "#include <${1:stdio}.h>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "inc"
        ],
        "opts": []
      },
      {
        "content": "#include \"${1:`vim_snippets#Filename(\"$1.h\")`}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Inc"
        ],
        "opts": []
      },
      {
        "content": "#ifndef $1\n#define ${1:SYMBOL} ${2:value}\n#endif /* ifndef $1 */",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ndef"
        ],
        "opts": []
      },
      {
        "content": "#define",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "def"
        ],
        "opts": []
      },
      {
        "content": "#ifdef ${1:FOO}\n\t${2:#define }\n#endif",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifdef"
        ],
        "opts": []
      },
      {
        "content": "#if ${1:FOO}\n\t${0:${VISUAL}}\n#endif",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#if"
        ],
        "opts": []
      },
      {
        "content": "#ifndef ${1:`toupper(vim_snippets#Filename('$1_H', 'UNTITLED_H'))`}\n#define $1\n${0}\n#endif /* end of include guard: $1 */",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "once"
        ],
        "opts": []
      },
      {
        "content": "#ifdef __cplusplus\nextern \"C\" {\n#endif\n${0}\n#ifdef __cplusplus\n} /* extern \"C\" */\n#endif",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nocxx"
        ],
        "opts": []
      },
      {
        "content": "if (${1:true}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "if (${1:true}) {\n\t${2:${VISUAL}}\n} else {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "else {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "el"
        ],
        "opts": []
      },
      {
        "content": "else if (${1:true}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "elif"
        ],
        "opts": []
      },
      {
        "content": "if (${1:true}) ${0};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifi"
        ],
        "opts": []
      },
      {
        "content": "${1:/* condition */} ? ${2:a} : ${3:b}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "t"
        ],
        "opts": []
      },
      {
        "content": "switch (${1:/* variable */}) {\n\tcase ${2:/* variable case */}:\n\t\t${3}\n\t\t${4:break;}${5}\n\tdefault:\n\t\t${6}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "switch"
        ],
        "opts": []
      },
      {
        "content": "switch (${1:/* variable */}) {\n\tcase ${2:/* variable case */}:\n\t\t${3}\n\t\t${4:break;}${5}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "switchndef"
        ],
        "opts": []
      },
      {
        "content": "case ${1:/* variable case */}:\n\t${2}\n\t${3:break;}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case"
        ],
        "opts": []
      },
      {
        "content": "return ${0};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ret"
        ],
        "opts": []
      },
      {
        "content": "for (int ${2:i} = 0; $2 < ${1:count}; $2${3:++}) {\n\t${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "for (int ${1:i} = ${2:0}; ${3:$1 < 10}; $1${4:++}) {\n\t${5}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forr"
        ],
        "opts": []
      },
      {
        "content": "while (${1:/* condition */}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh"
        ],
        "opts": []
      },
      {
        "content": "do {\n\t${0:${VISUAL}}\n} while (${1:/* condition */});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "do"
        ],
        "opts": []
      },
      {
        "content": "${1:void} ${2:function_name}(${3})\n{\n\t${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fun"
        ],
        "opts": []
      },
      {
        "content": "${1:void} ${2:function_name}()\n{\n\t${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fun0"
        ],
        "opts": []
      },
      {
        "content": "/*! \\brief ${1:Brief function description here}\n *\n *  ${2:Detailed description of the function}\n *\n * \\return ${3:Return parameter description}\n */\n${4:void} ${5:function_name}()\n{\n\t${6}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dfun0"
        ],
        "opts": []
      },
      {
        "content": "${1:void} ${2:function_name}(${3:Type} ${4:Parameter})\n{\n\t${5}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fun1"
        ],
        "opts": []
      },
      {
        "content": "/*! \\brief ${1:Brief function description here}\n *\n *  ${2:Detailed description of the function}\n *\n * \\param $3 ${4:Parameter description}\n * \\return ${5:Return parameter description}\n */\n${6:void} ${7:function_name}(${8:Type} ${3:Parameter})\n{\n\t${9}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dfun1"
        ],
        "opts": []
      },
      {
        "content": "${1:void} ${2:function_name}(${3:Type} ${4:Parameter}, ${5:Type} ${6:Parameter})\n{\n\t${7}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fun2"
        ],
        "opts": []
      },
      {
        "content": "/*! \\brief ${1:Brief function description here}\n *\n *  ${2:Detailed description of the function}\n *\n * \\param $3 ${4:Parameter description}\n * \\param $5 ${6:Parameter description}\n * \\return ${7:Return parameter description}\n */\n${8:void} ${9:function_name}(${10:Type} ${3:Parameter}, ${11:Type} ${5:Parameter})\n{\n\t${12}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dfun2"
        ],
        "opts": []
      },
      {
        "content": "${1:void} ${2:function_name}(${3:Type} ${4:Parameter}, ${5:Type} ${6:Parameter}, ${7:Type} ${8:Parameter})\n{\n\t${9}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fun3"
        ],
        "opts": []
      },
      {
        "content": "/*! \\brief ${1:Brief function description here}\n *\n *  ${2:Detailed description of the function}\n *\n * \\param $3 ${4:Parameter description}\n * \\param $5 ${6:Parameter description}\n * \\param $7 ${8:Parameter description}\n * \\return ${9:Return parameter description}\n */\n${10:void} ${11:function_name}(${12:Type} ${3:Parameter}, ${13:Type} ${5:Parameter}, ${14:Type} ${7:Parameter})\n{\n\t${15}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dfun3"
        ],
        "opts": []
      },
      {
        "content": "${1:void} ${2:function_name}(${3});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fund"
        ],
        "opts": []
      },
      {
        "content": "typedef ${1:int} ${2:MyCustomType};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "td"
        ],
        "opts": []
      },
      {
        "content": "/*! \\struct $1\n *  \\brief ${3:Brief struct description}\n *\n *  ${4:Detailed description}\n */\nstruct ${1:`vim_snippets#Filename('$1_t', 'name')`} {\n\t${2:Data} /*!< ${4:Description} */\n}${5: /* optional variable list */};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "st"
        ],
        "opts": []
      },
      {
        "content": "/*! \\struct $2\n *  \\brief ${5:Brief struct description}\n *\n *  ${6:Detailed description}\n */\ntypedef struct ${2:_$1 }{\n\tm_${3:Data} /*!< ${4:Description} */\n} ${1:`vim_snippets#Filename('$1_t', 'name')`};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tds"
        ],
        "opts": []
      },
      {
        "content": "/*! \\enum $1\n *\n *  ${2:Detailed description}\n */\nenum ${1:name} { ${0} };",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "enum"
        ],
        "opts": []
      },
      {
        "content": "/*! \\enum $2\n *\n *  ${4:Detailed description}\n */\ntypedef enum {\n\t${1:Data} /*!< ${3:Description} */\n} ${2:foo};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tde"
        ],
        "opts": []
      },
      {
        "content": "printf(\"${1:%s}\\n\"${2});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pr"
        ],
        "opts": []
      },
      {
        "content": "fprintf(${1:stderr}, \"${2:%s}\\n\"${3});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fpr"
        ],
        "opts": []
      },
      {
        "content": "printf(\"${1:} = %d\\n\", $1);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prd"
        ],
        "opts": []
      },
      {
        "content": "printf(\"${1:} = %f\\n\", $1);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prf"
        ],
        "opts": []
      },
      {
        "content": "printf(\"${1:} = %${2}\\n\", $1);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prx"
        ],
        "opts": []
      },
      {
        "content": "int choice;\nwhile (1)\n{\n\tstatic struct option long_options[] =\n\t{\n\t\t/* Use flags like so:\n\t\t{\"verbose\",\tno_argument,\t&verbose_flag, 'V'}*/\n\t\t/* Argument styles: no_argument, required_argument, optional_argument */\n\t\t{\"version\", no_argument,\t0,\t'v'},\n\t\t{\"help\",\tno_argument,\t0,\t'h'},\n\t\t${1}\n\t\t{0,0,0,0}\n\t};\n\tint option_index = 0;\n\t/* Argument parameters:\n\t\tno_argument: \" \"\n\t\trequired_argument: \":\"\n\t\toptional_argument: \"::\" */\n\tchoice = getopt_long( argc, argv, \"vh\",\n\t\t\t\tlong_options, &option_index);\n\tif (choice == -1)\n\t\tbreak;\n\tswitch( choice )\n\t{\n\t\tcase 'v':\n\t\t\t${2}\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\t${3}\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\t/* getopt_long will have already printed an error */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Not sure how to get here... */\n\t\t\treturn EXIT_FAILURE;\n\t}\n}\n/* Deal with non-option arguments here */\nif ( optind < argc )\n{\n\twhile ( optind < argc )\n\t{\n\t\t${0}\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "getopt"
        ],
        "opts": []
      },
      {
        "content": "/*! TODO: ${1:Todo description here}\n *  \\todo $1\n */",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "todo"
        ],
        "opts": []
      },
      {
        "content": "[${1}]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "."
        ],
        "opts": []
      },
      {
        "content": "__asm__ __volatile__(\n\"${0}\\n\\t\"\n:\n:\n);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asm"
        ],
        "opts": []
      },
      {
        "content": "if (${1:#:condition}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if () {}",
        "matches": [
          "if"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "else {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "else {}",
        "matches": [
          "else"
        ],
        "opts": []
      },
      {
        "content": "else if (${1:#:condition}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "else () {}",
        "matches": [
          "elseif"
        ],
        "opts": []
      },
      {
        "content": "if (${1:#:condition}) {\n    ${2:TARGET}\n} else {\n    ${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if () {} else {}",
        "matches": [
          "ifelse"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "for (${1:int} ${2:i} = ${3:0}; $2 < ${4}; $2++) {\n    ${0:#:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "for () {}",
        "matches": [
          "for"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "for (int ${1:i} = 0; $1 < ${2}; $1++) {\n    ${0:#:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "for (int x;...; x++) {}",
        "matches": [
          "fori"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "for (int ${1:i} = ${2}; $1 >= 0; $1--) {\n    ${0:#:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "for (int x; ...; x--) {}",
        "matches": [
          "forri"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "while (${1:#:condition}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "while () {}",
        "matches": [
          "while"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "do {\n    ${0:TARGET:code}\n} while (${1:#:condition});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "do_while",
          "do"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "switch (${1:#:var}) {\n\tcase ${2:#:val}:\n\t\t${0:TARGET}\n\t\tbreak;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "switch () {}",
        "matches": [
          "switch"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "case ${1}:\n\t${0}\n\tbreak;",
        "doc": "",
        "grammar": "snu",
        "label": "case: break;",
        "matches": [
          "case"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "(${1:#:condition}) ? ${2:#:a} : ${3:#:b}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "conditional"
        ],
        "opts": []
      },
      {
        "content": "${1:void} ${2:#:func_name}(${3:void}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "func() {}",
        "matches": [
          "func",
          "function"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "struct ${1:#:name} {\n    ${0:TARGET:data}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "struct {}",
        "matches": [
          "struct"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "typedef struct ${1:#:name} {\n    ${0:TARGET:data}\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "struct_typedef"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "enum ${1:#:name} {\n    ${0:TARGET}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "enum {}",
        "matches": [
          "enum"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "int main(int argc, char* argv[])\n{\n\t${0:TARGET}\n\treturn 0;\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "main"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "#include <stdio.h>\nint main(int argc, char* argv[])\n{\n    puts(\"hello, world!\");\n    return 0;\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "helloworld"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "#include <${1:stdio}.h>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#inc, #include",
          "inc"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "#include \"${1}.h\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "inc2",
          "#inc2, #include2"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "#if ${1}\n${0}\n#endif",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#if"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "#ifdef ${1:#:SYMBOL}\n${0}\n#endif",
        "doc": "",
        "grammar": "snu",
        "label": "#ifdef ... #endif",
        "matches": [
          "#ifdef",
          "ifdef"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "#ifndef $1\n#define ${1:#:SYMBOL}\n#endif${0}",
        "doc": "",
        "grammar": "snu",
        "label": "#ifndef ... #define ... #endif",
        "matches": [
          "ifndef",
          "#ifndef"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "#define ${1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "def",
          "#def, #define"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "#ifndef ${1:#:SYMBOL}\n    #define $1\n    ${0:TARGET}\n#endif /* end of include guard */",
        "doc": "",
        "grammar": "snu",
        "label": "#ifndef ... #define ... #endif",
        "matches": [
          "once",
          "include-guard"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "printf(\"${1}\\n\"${2});",
        "doc": "",
        "grammar": "snu",
        "label": "printf(\"...\\n\", ...);",
        "matches": [
          "printf"
        ],
        "opts": []
      },
      {
        "content": "scanf(\"${1}\", ${2});",
        "doc": "",
        "grammar": "snu",
        "label": "scanf(\"...\", ...);",
        "matches": [
          "scanf"
        ],
        "opts": []
      },
      {
        "content": "fprintf(${1:stderr}, \"${2}\\n\"${3});",
        "doc": "",
        "grammar": "snu",
        "label": "fprintf(..., \"...\\n\", ...);",
        "matches": [
          "fprintf"
        ],
        "opts": []
      },
      {
        "content": "fopen(\"${1:PATH}\", \"${2:MODE}\");\n${0:TARGET}\nfclose(${3:FD});",
        "doc": "",
        "grammar": "snu",
        "label": "fopen(\"...\", \"...\");",
        "matches": [
          "fopen"
        ],
        "opts": []
      },
      {
        "content": "fgets(${0:ROW}, ${1:LENGTH}, ${2:stdin});",
        "doc": "",
        "grammar": "snu",
        "label": "fgets(row, length, file);",
        "matches": [
          "fgets"
        ],
        "opts": []
      },
      {
        "content": "fscanf(${1:stdin}, \"${2}\", ${3});",
        "doc": "",
        "grammar": "snu",
        "label": "fscanf(file, \"...\", ...);",
        "matches": [
          "fscanf"
        ],
        "opts": []
      },
      {
        "content": "fwrite(${1:ARRAY}, sizeof(${2:TYPE}), ${3:N_MEMBERS}, ${4:FILE})",
        "doc": "",
        "grammar": "snu",
        "label": "fwrite(......, file)",
        "matches": [
          "fwrite"
        ],
        "opts": []
      },
      {
        "content": "fread(${1:ARRAY}, sizeof(${2:TYPE}), ${3:N_MEMBERS}, ${4:FILE})",
        "doc": "",
        "grammar": "snu",
        "label": "fread(......, file)",
        "matches": [
          "fread"
        ],
        "opts": []
      },
      {
        "content": "memcpy(${1:DEST}, ${2:SRC}, ${3:NBYTES})",
        "doc": "",
        "grammar": "snu",
        "label": "memcpy(dest, src, nbytes)",
        "matches": [
          "memcpy"
        ],
        "opts": []
      },
      {
        "content": "($2 *)malloc(${1:N_MEMBERS} * sizeof(${2:TYPE}));\n${0}\nfree(${3:MEM});",
        "doc": "",
        "grammar": "snu",
        "label": "malloc(size)",
        "matches": [
          "malloc"
        ],
        "opts": []
      },
      {
        "content": "($2 *)calloc(${1:N_MEMBERS}, sizeof(${2:TYPE}));\n${0}\nfree(${3:MEM});",
        "doc": "",
        "grammar": "snu",
        "label": "calloc(n, size)",
        "matches": [
          "calloc"
        ],
        "opts": []
      },
      {
        "content": "($3 *)realloc(${1:OLD}, ${2:N_MEMBERS} * sizeof(${3:TYPE}));\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "realloc(old, size)",
        "matches": [
          "realloc"
        ],
        "opts": []
      },
      {
        "content": "srand(time(NULL));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "seed_rand"
        ],
        "opts": []
      },
      {
        "content": "typedef ${1:#:base_type} ${2:#:custom_type};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "typedef"
        ],
        "opts": []
      },
      {
        "content": "sizeof(${0:TARGET})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sizeof",
          "size"
        ],
        "opts": []
      },
      {
        "content": "(sizeof(${1:#:array}) / sizeof(*($1)))",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sizeof_array",
          "array_size"
        ],
        "opts": []
      },
      {
        "content": "_Static_assert(${1:#:condition}, ${2:#:message});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "_static_assert",
          "_Static_assert"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "static_assert(${1:#:condition}, ${2:#:message});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "static_assert"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "_Generic(${1:#:expression}, ${2:#:association-list})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "generic, select",
          "_Generic"
        ],
        "opts": []
      },
      {
        "content": "va_list ${1:ap};\nva_start($1, ${2:LAST_ARG});\n${0}\nva_end($1);",
        "doc": "",
        "grammar": "snu",
        "label": "va_start(va_list, last_arg); ... ; va_end()",
        "matches": [
          "va_list"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "/* ${1:#:comment} */\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "/*",
          "comment"
        ],
        "opts": []
      },
      {
        "content": "/**\n * @brief    ${1:function description}\n *\n * @details  ${2:detailed description}\n *\n * @param    ${3:param}\n *\n * @return   ${4:return type}\n */",
        "doc": "",
        "grammar": "snu",
        "label": "/** @brief ...",
        "matches": [
          "doxy"
        ],
        "opts": [
          "head"
        ]
      }
    ],
    "chef": [
      {
        "content": "# Cookbook File resource\ncookbook_file ${1:\"/path/to/file\"} do # The remote path where the file will reside\n\t${2:#}backup ${3} # How many backups of this file to keep. Set to false  if you want no backups\n\t${4:#}group ${5} # The group owner of the file (string or id)\n\t${6:#}mode ${7} # The octal mode of the file - e.g. 0755\n\t${8:#}owner ${9} # The owner for the file\n\t${10:#}source ${11} # The basename of the source file\n\t${12:#}cookbook ${13} # The cookbook this file is stored in\n\t${14:#}${15: action :create} # Create this file (Default)\n\t${16:#}${17: action :create_if_missing} # Create only if it doesn't exist yet\n\t${18:#}${0: action :delete} # Delete this file\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cookbook_file"
        ],
        "opts": []
      },
      {
        "content": "# Execute resource\nexecute ${1:\"command to execute\"} do # The command to execute\n\t${2:#}creates ${3:nil} # A file this command creates - if the file exists, the command will not be run.\n\t${4:#}cwd ${5:nil} # Current working directory to run the command from.\n\t${6:#}environment ${7:nil} # A hash of environment variables to set before running this command.\n\t${8:#}group ${9:nil} # A group name or group ID that we should change to before running this command.\n\t${10:#}path ${11:nil} # An array of paths to use when searching for the command. Nil uses system path.\n\t${12:#}returns ${13:0} # The return value of the command - this resource raises an exception if the return value does not match.\n\t${14:#}timeout ${15:nil} # How many seconds to let the command run before timing it out.\n\t${16:#}user ${17:nil} # A user name or user ID that we should change to before running this command.\n\t${18:#}umask ${19:nil} # Umask for files created by the command\n\t${20:#}${21:action :run} # Run this command (Default)\n\t${22:#}${0:action :nothing} # Do not run this command\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "execute"
        ],
        "opts": []
      },
      {
        "content": "# Link resource\nlink ${1:\"/target/file\"} do # The file name of the link\n\t${2:#}to ${3} # The real file you want to link to\n\t${4:#}link_type ${5:symbolic} # Either :symbolic or :hard\n\t${6:#}owner ${7} # The owner of the symlink\n\t${8:#}group ${9} # The group of the symlink\n\t${10:#}${11:action :create} # Create a link (Default)\n\t${12:#}${0:action :delete} # Delete a link\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "link"
        ],
        "opts": []
      },
      {
        "content": "# Package resource\npackage ${1:\"package_name\"} do # Name of the package to install\n\t${2:#}version ${3:nil} # The version of the package to install/upgrade\n\t${4:#}response_file ${5:nil} # An optional response file - used to pre-seed packages (note: the file is fetched by Remote File)\n\t${6:#}source ${7} # Used to provide an optional package source for providers that use a local file (rubygems, dpkg and rpm)\n\t${8:#}options ${9:nil} # Add additional options to the underlying package command\n\t${10:#}gem_binary ${11:gem} # A gem_package attribut to specify a gem binary. Useful for installing ruby 1.9 gems while running chef in ruby 1.8\n\t${12:#}${13:action :install} # Install a package - if version is provided, install that specific version (Default)\n\t${14:#}${15:action :upgrade} # Upgrade a package - if version is provided, upgrade to that specific version\n\t${16:#}${17:action :remove} # Remove a package\n\t${18:#}${0:action :purge} # Purge a package (this usually entails removing configuration files as well as the package itself)\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "package"
        ],
        "opts": []
      },
      {
        "content": "# Service resource\nservice ${1:\"service_name\"} do # Name of the service\n\t${2:#}enabled ${3:nil} # Whether the service is enabled at boot time\n\t${4:#}running ${5:nil} # Make sure the service is running. Start if stopped\n\t${6:#}pattern ${7} # Pattern to look for in the process table\n\t${8:#}start_command ${9:nil} # Command used to start this service\n\t${10:#}stop_command ${11:nil} # Command used to stop this service\n\t${12:#}status_command ${13:nil} # Command used to check the service run status\n\t${14:#}restart_command ${15:nil} # Command used to restart this service\n\t${16:#}reload_command ${17:nil} # Command used to tell this service to reload its configuration\n\t${18:#}supports ${19:false} # Features this service supports, ie :restart, :reload, :status\n\t${20:#}${21:action :enable} # Enable this service\n\t${22:#}${23:action :disable} # Disable this service\n\t${24:#}${25:action :nothing} # Don't do anything with this service (Default)\n\t${26:#}${27:action :start} # Start this service\n\t${28:#}${29:action :stop} # Stop this service\n\t${30:#}${31:action :restart} # Restart this service\n\t${32:#}${0:action :reload} # Reload the configuration for this service\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "service"
        ],
        "opts": []
      },
      {
        "content": "# File resource\nfile ${1:\"/path/to/file\"} do # Path to the file\n\t${2:#}backup ${3:5} # How many backups of this file to keep. Set to false if you want no backups.\n\t${4:#}owner ${5} # The owner for the file\n\t${6:#}group ${7} # The group owner of the file (string or id)\n\t${8:#}mode ${9} # The octal mode of the file (4-digit format)\n\t${10:#}content ${11:nil} # A string to write to the file. This will replace any previous content if set\n\t${12:#}${13:action :create} # Create this file (Default)\n\t${14:#}${15:action :delete} # Delete this file\n\t${16:#}${0:action :touch} # Touch this file (update the mtime/atime)\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "file"
        ],
        "opts": []
      },
      {
        "content": "# Directory resource\ndirectory ${1:\"/path/to/dir\"} do # The path to the directory\n\t${2:#}group ${3} # The group owner of the directory (string or id)\n\t${4:#}mode ${5} # The octal mode of the directory, eg 0755\n\t${6:#}owner ${7} # The owner for the directory\n\t${10:#}recursive ${11:false} # When deleting the directory, delete it recursively. When creating the directory, create recursively (ie, mkdir -p)\n\t${12:#}${13:action :create} # Create this directory (Default)\n\t${14:#}${0:action :delete} # Delete this directory\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "directory"
        ],
        "opts": []
      },
      {
        "content": "# Template resource\ntemplate ${1:\"/path/to/file\"} do # Path to the file\n\t${2:#}cookbook ${3:nil} # Specify the cookbook where the template is located, default is current cookbook\n\t${4:#}source ${5:nil} # Template source file. Found in templates/default for the cookbook\n\t${6:#}variables ${7} # Variables to use in the template\n\t${8:#}local ${9:false} # Is the template already present on the node?\n\t${10:#}backup ${11:5} # How many backups of this file to keep. Set to false if you want no backups.\n\t${12:#}owner ${13} # The owner for the file\n\t${14:#}group ${15} # The group owner of the file (string or id)\n\t${16:#}mode ${17} # The octal mode of the file (4-digit format)\n\t${18:#}content ${19:nil} # A string to write to the file. This will replace any previous content if set\n\t${20:#}${21:action :create} # Create the file (Default)\n\t${22:#}${23:action :delete} # Delete this file\n\t${24:#}${0:action :touch} # Touch this file (update the mtime/atime)\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "template"
        ],
        "opts": []
      },
      {
        "content": "# SCM Resource, Chef::Provider::Subversion\nsvn ${1:\"/destination/path\"} do # Path to clone/checkout/export the source to\n\t${2:#}repository ${3} # URI of the repository\n\t${4:#}revision ${5:\"HEAD\"} # revision to checkout. can be symbolic, like \"HEAD\" or an SCM specific revision id\n\t${6:#}reference ${7} # (Git only) alias for revision\n\t${8:#}user ${9:nil} # System user to own the checked out code\n\t${10:#}group ${11:nil} # System group to own the checked out code\n\t${12:#}svn_username ${13} # (Subversion only) Username for Subversion operations\n\t${14:#}svn_password ${15} # (Subversion only) Password for Subversion operations\n\t${16:#}svn_arguments ${17} # (Subversion only) Extra arguments passed to the subversion command\n\t${18:#}${19:action :sync} # Update the source to the specified revision, or get a new checkout (Default)\n\t${20:#}${21:action :checkout} # Checkout the source. Does nothing if a checkout is available\n\t${22:#}${0:action :export} # Export the source, excluding or removing any version control artifacts\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "svn"
        ],
        "opts": []
      },
      {
        "content": "# SCM Resource, Chef::Provider::Git\ngit ${1:\"/destination/path\"} do # Path to clone/checkout/export the source to\n\t${2:#}repository ${3} # URI of the repository\n\t${4:#}revision ${5:\"HEAD\"} # revision to checkout. can be symbolic, like \"HEAD\" or an SCM specific revision id\n\t${6:#}reference ${7} # (Git only) alias for revision\n\t${8:#}user ${9:nil} # System user to own the checked out code\n\t${10:#}group ${11:nil} # System group to own the checked out code\n\t${12:#}depth ${13:nil} # (Git only) Number of past revisions to include in Git shallow clone\n\t${14:#}enable_submodules ${15:\"false\"} # (Git only) performs a submodule init and submodule update\n\t${16:#}remote ${17:\"origin\"} # (Git only) remote repository to use for syncing an existing clone\n\t${18:#}ssh_wrapper ${19} # (Git only) path to a wrapper script for running SSH with git. GIT_SSH environment variable is set to this.\n\t${20:#}${21:action :sync} # Update the source to the specified revision, or get a new clone (Default)\n\t${22:#}${23:action :checkout} # Clone the source. Does nothing if a checkout is available\n\t${24:#}${0:action :export} # Export the source, excluding or removing any version control artifacts\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "git"
        ],
        "opts": []
      },
      {
        "content": "# Deploy resource\ndeploy ${1:\"/deploy/dir/\"} do # Path to deploy to\n\t${2:#}deploy_to ${3} # The \"meta root\" for your application.\n\t${4:#}repository ${5} # URI of the repository\n\t${6:#}repo ${7} # alias for repository\n\t${8:#}revision ${9:\"HEAD\"} # revision to checkout. can be symbolic, like \"HEAD\" or an SCM specific revision id\n\t${10:#}branch ${11} # alias for revision\n\t${12:#}user ${13:nil} # System user to run the deploy as\n\t${14:#}group ${15:nil} # System group to run the deploy as\n\t${16:#}svn_username ${17} # (Subversion only) Username for Subversion operations}\n\t${18:#}svn_password ${19} # (Subversion only) Password for Subversion operations}\n\t${20:#}svn_arguments ${21} # (Subversion only) Extra arguments passed to the subversion command}\n\t${22:#}shallow_clone ${23:nil} # (Git only) boolean, true sets clone depth to 5\n\t${24:#}enable_submodules ${25:false} # (Git only) performs a submodule init and submodule update\n\t${26:#}remote ${27:\"origin\"} # (Git only) remote repository to use for syncing an existing clone\n\t${28:#}ssh_wrapper ${29} # (Git only) path to a wrapper script for running SSH with git. GIT_SSH environment variable is set to this.\n\t${30:#}git_ssh_wrapper ${31} # alias for ssh_wrapper\n\t${32:#}scm_provider ${33:Chef::Provider::Git} # SCM Provider to use.\n\t${34:#}repository_cache ${35: \"cached-copy\"} # Name of the subdirectory where the pristine copy of your app's source is kept\n\t${36:#}environment ${37} # A hash of the form {\"ENV_VARIABLE\"=>\"VALUE\"}}\n\t${38:#}purge_before_symlink ${39:%w(log tmp/pids public/system)} # An array of paths, relative to app root, to be removed from a checkout before symlinking\n\t${40:#}create_dirs_before_symlink ${41:%w(tmp public config)} # Directories to create before symlinking. Runs after purge_before_symlink\n\t${42:#}symlinks ${43:\"system\" => \"public/system\", \"pids\" => \"tmp/pids\", \"log\" => \"log\"} # A hash that maps files in the shared directory to their paths in the current release\n\t${44:#}symlink_before_migrate ${45:\"config/database.yml\" => \"config/database.yml\"} # A hash that maps files in the shared directory into the current release. Runs before migration\n\t${46:#}migrate ${47:false} # Should the migration command be executed? (true or false)\n\t${48:#}migration_command ${49} # A string containing a shell command to execute to run the migration\n\t${50:#}restart_command ${51:nil} # A code block to evaluate or a string containing a shell command\n\t${52:#}before_migrate ${53:\"deploy/before_migrate.rb\"} # A block or path to a file containing chef code to run before migrating\n\t${54:#}before_symlink ${55:\"deploy/before_symlink.rb\"} # A block or path to a file containing chef code to run before symlinking\n\t${56:#}before_restart ${57:\"deploy/before_restart.rb\"} # A block or path to a file containing chef code to run before restarting\n\t${58:#}after_restart ${59:\"deploy/after_restart.rb\"} # A block or path to a file containing chef code to run after restarting\n\t${60:#}${61::deploy} # Deploy the application (Default)\n\t${62:#}${63::force_deploy} # For the revision deploy strategy, this removes any existing release of the same code version and re-deploys in its place\n\t${64:#}${0::rollback} # Rollback the application to the previous release\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "deploy"
        ],
        "opts": []
      }
    ],
    "classnames": [
      {
        "content": "${1:classNames}('${2:foo}', '${3:bar}');",
        "doc": null,
        "grammar": "lsp",
        "label": "classnames-usage",
        "matches": [
          "classnames usage"
        ],
        "opts": []
      },
      {
        "content": "${1:classNames}({ '${2:foo-bar}': true });",
        "doc": null,
        "grammar": "lsp",
        "label": "classnames-usage-object",
        "matches": [
          "classnames usage object"
        ],
        "opts": []
      },
      {
        "content": "import ${1:classNames} from 'classnames/bind';",
        "doc": null,
        "grammar": "lsp",
        "label": "classnames-import-bind",
        "matches": [
          "classnames import bind"
        ],
        "opts": []
      },
      {
        "content": "const ${1:cx} = ${2:classNames}.bind(styles);",
        "doc": null,
        "grammar": "lsp",
        "label": "classnames-bind-usage",
        "matches": [
          "classnames bind usage"
        ],
        "opts": []
      }
    ],
    "clojure": [
      {
        "content": "(comment\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "comm"
        ],
        "opts": []
      },
      {
        "content": "(condp ${1:pred} ${2:expr}\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "condp"
        ],
        "opts": []
      },
      {
        "content": "(def ${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "def"
        ],
        "opts": []
      },
      {
        "content": "(defmethod ${1:multifn} \"${2:doc-string}\" ${3:dispatch-val} [${4:args}]\n\t${0:code})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defm"
        ],
        "opts": []
      },
      {
        "content": "(defmulti ${1:name} \"${2:doc-string}\" ${0:dispatch-fn})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defmm"
        ],
        "opts": []
      },
      {
        "content": "(defmacro ${1:name} \"${2:doc-string}\" ${0:dispatch-fn})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defma"
        ],
        "opts": []
      },
      {
        "content": "(defn ${1:name} \"${2:doc-string}\" [${3:arg-list}]\n\t${0:code})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defn"
        ],
        "opts": []
      },
      {
        "content": "(defprotocol ${1:name}\n\t${0:code})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defp"
        ],
        "opts": []
      },
      {
        "content": "(defrecord ${1:name} [${2:fields}]\n\t${3:protocol}\n\t${0:code})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defr"
        ],
        "opts": []
      },
      {
        "content": "(deftest ${1:name}\n\t(is (= ${0:assertion})))",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "deft"
        ],
        "opts": []
      },
      {
        "content": "(is (= ${1} ${0}))",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "is"
        ],
        "opts": []
      },
      {
        "content": "(deftype ${1:Name} [${2:fields}]\n\t${3:Protocol}\n\t${0:code})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defty"
        ],
        "opts": []
      },
      {
        "content": "(doseq [${1:elem} ${2:coll}]\n\t${0:code})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doseq"
        ],
        "opts": []
      },
      {
        "content": "(fn [${1:arg-list}] ${0:code})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fn"
        ],
        "opts": []
      },
      {
        "content": "(if ${1:test-expr}\n\t${2:then-expr}\n\t${0:else-expr})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "(if-let [${1:result} ${2:test-expr}]\n\t(${3:then-expr} $1)\n\t(${0:else-expr}))",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if-let"
        ],
        "opts": []
      },
      {
        "content": "(:import [${1:package}])\n\t& {:keys [${1:keys}] :or {${0:defaults}}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "imp"
        ],
        "opts": []
      },
      {
        "content": "(let [${1:name} ${2:expr}]\n\t${0:code})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "let"
        ],
        "opts": []
      },
      {
        "content": "(letfn [(${1:name}) [${2:args}]\n\t${0:code})])",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "letfn"
        ],
        "opts": []
      },
      {
        "content": "(map ${1:func} ${0:coll})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "map"
        ],
        "opts": []
      },
      {
        "content": "(map #(${1:lambda}) ${0:coll})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mapl"
        ],
        "opts": []
      },
      {
        "content": "(${1:name} [${2:this} ${3:args}]\n\t${0:code})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "met"
        ],
        "opts": []
      },
      {
        "content": "(ns ${0:name})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ns"
        ],
        "opts": []
      },
      {
        "content": "(dotimes [_ 10]\n\t(time\n\t\t(dotimes [_ ${1:times}]\n\t\t\t${0:code})))",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dotimes"
        ],
        "opts": []
      },
      {
        "content": "(${1:name} [${2:this} ${0:args}])",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pmethod"
        ],
        "opts": []
      },
      {
        "content": "(:refer-clojure :exclude [${0}])",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "refer"
        ],
        "opts": []
      },
      {
        "content": "(:require [${1:namespace} :as [${0}]])",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "require"
        ],
        "opts": []
      },
      {
        "content": "(:use [${1:namespace} :only [${0}]])",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "use"
        ],
        "opts": []
      },
      {
        "content": "(println ${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "print"
        ],
        "opts": []
      },
      {
        "content": "(reduce ${1:(fn [p n] ${3})} ${2})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "reduce"
        ],
        "opts": []
      },
      {
        "content": "(when ${1:test} ${0:body})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "when"
        ],
        "opts": []
      },
      {
        "content": "(when-let [${1:result} ${2:test}]\n\t${0:body})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "when-let"
        ],
        "opts": []
      },
      {
        "content": "(defn ${1:name}\n\t\"${2:doc}\"\n\t[${3}]\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": "defn function \"...\" [...] ...",
        "matches": [
          "defn-doc"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "(try\n\t${1}\n\t(catch ${2:Exception} e ${3:nil}))",
        "doc": "",
        "grammar": "snu",
        "label": "(try ... (catch ...",
        "matches": [
          "try"
        ],
        "opts": []
      },
      {
        "content": "(dosync\n\t(ref-set ${1:ref} ${2:value}))",
        "doc": "",
        "grammar": "snu",
        "label": "(dosync (ref-set ...",
        "matches": [
          "ref-set"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "#^:shebang '[\nexec java -cp \\`locate clojure- | grep -P \"clojure-[\\\\d\\\\.]+\\\\.jar$\" | tail -1\\` clojure.main \"\\$0\"\n]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "shebang"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "(binding [*out* *err*]\n  (println ${0:TARGET}))",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "warn"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "(defrecord ${1:record} [${2:constructor-args}]\n  ${3:protocol} (${3:method} [${5}] ${6}))",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defrecord"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "(defrecord ${1:type} [${2:constructor-args}]\n  ${3:protocol} (${3:method} [${5}] ${6}))",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "deftype"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "(ns ${1:example}\n  (:require [clojure.core.match :as m]))\n; vim: set lispwords+=m/match :",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "require-core-match"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "(deftest ${1:a}-test\n  (testing \"${2:hello}\"\n    ${0:TARGET:(is (= 0 1))}))",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "deftest"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "(:require [clojure.core.strint :refer (<<)])",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "use-strint-in-ns"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "[org.clojars.hozumi/clj-glob \"0.1.2\"]\n(:require [org.satta.glob :as g])\n(g/glob \"${0:TARGET}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dir-glob"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "(Thread/sleep ${1})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sleep"
        ],
        "opts": []
      },
      {
        "content": "(defproject ${1:aaa} \"0.1-SNAPSHOT\"\n  :description \"FIXME: write description\"\n  :url \"https://github.com/${2}\"\n  :license {:name \"GNU GPL v3+\"\n            :url \"http://www.gnu.org/licenses/gpl-3.0.en.html\"}\n  :dependencies [[org.clojure/clojure \"1.7.0\"]]\n  :main ^:skip-aot ${3:aaa.core}\n  :target-path \"target/%s\"\n  :min-lein-version \"2.3.0\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defproejct"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "(ns ${1:`substitute(substitute(substitute(expand('%:p:r'), '.*/\\(src\\|test\\)/', '', ''), '/', '.', 'g'), '_', '-', 'g')`}\n  (:require `expand('%:r') =~ '_test$' ? '[clojure.test :refer :all]' : ''`${2:}))",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ns"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "(let [bench-before (System/currentTimeMillis)]\n  ${1:TARGET}\n  (prn 'Took (- (System/currentTimeMillis) bench-before) 'msec))",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bench"
        ],
        "opts": []
      },
      {
        "content": "@#'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "private"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "(:members (clojure.reflect/refrect ${1}))",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "java-methods"
        ],
        "opts": [
          "head"
        ]
      }
    ],
    "cmake": [
      {
        "content": "project(${1:project_name})\nset(${2:PROJECT}_VERSION_MAJOR 0)\nset($2_VERSION_MINOR 0)\nset($2_VERSION_TEENY 1)\nset(PACKAGE_VERSION \"${$2_VERSION_MAJOR}.${$2_VERSION_MINOR}.${$2_VERSION_TEENY}\")\ncmake_minimum_required(VERSION ${3:2.8})\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "new_project"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "if(${1:#:condition})\n\t${0}\nendif()",
        "doc": "",
        "grammar": "snu",
        "label": "if() endif()",
        "matches": [
          "if"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "if(${1:#:condition})\n\t${2}\nelse()\n\t${3}\nendif()",
        "doc": "",
        "grammar": "snu",
        "label": "if() else() endif()",
        "matches": [
          "if_else"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "foreach(${1:item} ${2:items})\n\t${3}\nendforeach($1)",
        "doc": "",
        "grammar": "snu",
        "label": "foreach() endforeach()",
        "matches": [
          "foreach"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "macro(${1:name} ${2:args})\n\t${3}\nendmacro($1)",
        "doc": "",
        "grammar": "snu",
        "label": "macro() endmacro()",
        "matches": [
          "macro"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "function(${1:name} ${2:args})\n\t${3}\nendfunction($1)",
        "doc": "",
        "grammar": "snu",
        "label": "function() endfunction()",
        "matches": [
          "function"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "message(\"${1}\")",
        "doc": "",
        "grammar": "snu",
        "label": "message(\"...\")",
        "matches": [
          "message"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "message(STATUS \"${1}\")",
        "doc": "",
        "grammar": "snu",
        "label": "message(STATUS \"...\")",
        "matches": [
          "status_message"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "message(WARNING \"${1}\")",
        "doc": "",
        "grammar": "snu",
        "label": "message(WARNING \"...\")",
        "matches": [
          "warning_message"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "message(AUTHOR_WARNING \"${1}\")",
        "doc": "",
        "grammar": "snu",
        "label": "message(AUTHOR_WARNING \"...\")",
        "matches": [
          "author_warning_message"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "message(SEND_ERROR \"${1}\")",
        "doc": "",
        "grammar": "snu",
        "label": "message(SEND_ERROR \"...\")",
        "matches": [
          "send_error_message"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "message(FATAL_ERROR \"${1}\")",
        "doc": "",
        "grammar": "snu",
        "label": "message(FATAL_ERROR \"...\")",
        "matches": [
          "fatal_error_message"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "while(${1:#:condition})\n\t${2}\nendwhile()",
        "doc": "",
        "grammar": "snu",
        "label": "while() endwhile()",
        "matches": [
          "while"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "file(GLOB_RECURSE ${1:#:var} ${2:#:glob_paths})",
        "doc": "",
        "grammar": "snu",
        "label": "file(GLOB_RECURSE ...)",
        "matches": [
          "file_GLOBE_RECURSE"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "cmake_minimum_required(VERSION ${1:2.8.2})\nproject(${2:ProjectName})\nfind_package(${3:library})\ninclude_directories(${$3_INCLUDE_DIRS})\nadd_subdirectory(${0:src})\nadd_executable($2)\ntarget_link_libraries($2 ${$3_LIBRARIES})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "init"
        ],
        "opts": []
      },
      {
        "content": "project(${0:Name})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "proj"
        ],
        "opts": []
      },
      {
        "content": "cmake_minimum_required(VERSION ${0:2.8.2})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "min"
        ],
        "opts": []
      },
      {
        "content": "include_directories(${${0:include_dir}})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "include"
        ],
        "opts": []
      },
      {
        "content": "find_package(${1:library} ${0:REQUIRED})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "find"
        ],
        "opts": []
      },
      {
        "content": "file(glob ${1:srcs} *.${0:cpp})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "glob"
        ],
        "opts": []
      },
      {
        "content": "add_subdirectory(${0:src})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "subdir"
        ],
        "opts": []
      },
      {
        "content": "add_library(${1:lib} ${${0:srcs}})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lib"
        ],
        "opts": []
      },
      {
        "content": "target_link_libraries(${1:bin} ${0:somelib})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "link"
        ],
        "opts": []
      },
      {
        "content": "add_executable(${1:bin})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bin"
        ],
        "opts": []
      },
      {
        "content": "set(${1:var} ${0:val})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "set"
        ],
        "opts": []
      },
      {
        "content": "add_dependencies(${1:target}\n\t${0:dep}\n)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dep"
        ],
        "opts": []
      },
      {
        "content": "include(ExternalProject)\nExternalProject_Add(${1:googletest}\n  URL ${2:http://googletest.googlecode.com/files/gtest-1.7.0.zip}\n  URL_HASH SHA1=${3:f85f6d2481e2c6c4a18539e391aa4ea8ab0394af}\n  SOURCE_DIR \"${4:${CMAKE_BINARY_DIR}/gtest-src}\"\n  BINARY_DIR \"${0:${CMAKE_BINARY_DIR}/gtest-build}\"\n  CONFIGURE_COMMAND \"\"\n  BUILD_COMMAND     \"\"\n  INSTALL_COMMAND   \"\"\n  TEST_COMMAND      \"\"\n)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Ext_url"
        ],
        "opts": []
      },
      {
        "content": "include(ExternalProject)\nExternalProject_Add(${1:googletest}\n  GIT_REPOSITORY    ${2:https://github.com/google/googletest.git}\n  GIT_TAG           ${3:master}\n  SOURCE_DIR        \"${4:${CMAKE_BINARY_DIR}/googletest-src}\"\n  BINARY_DIR        \"${0:${CMAKE_BINARY_DIR}/googletest-build}\"\n  CONFIGURE_COMMAND \"\"\n  BUILD_COMMAND     \"\"\n  INSTALL_COMMAND   \"\"\n  TEST_COMMAND      \"\"\n)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Ext_git"
        ],
        "opts": []
      },
      {
        "content": "set_target_properties(${1:target}\n\t${2:properties} ${3:compile_flags}\n\t${0:\"-O3 -Wall -pedantic\"}\n)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "props"
        ],
        "opts": []
      },
      {
        "content": "add_test(${1:ATestName} ${0:testCommand --options})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "test"
        ],
        "opts": []
      }
    ],
    "codeigniter": [
      {
        "content": "<?php if ( ! defined('BASEPATH')) exit('No direct script access allowed');\nclass ${1:ClassName} extends CI_Controller\n{\n\tfunction __construct()\n\t{\n\t\tparent::__construct();\n\t\t${2:// code...}\n\t}\n\tfunction ${3:index}()\n\t{\n\t\t${4:// code...}\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_controller"
        ],
        "opts": []
      },
      {
        "content": "<?php if ( ! defined('BASEPATH')) exit('No direct script access allowed');\nclass ${1:ClassName_model} extends CI_Model\n{\n\tfunction __construct()\n\t{\n\t\tparent::__construct();\n\t\t${2:// code...}\n\t}\n} ",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_model"
        ],
        "opts": []
      },
      {
        "content": "<?php if ( ! defined('BASEPATH')) exit('No direct script access allowed');\nclass ${1:ClassName_model} extends CI_Model\n{\n\tprivate $table = '${2:table_name}';\n\tfunction __construct()\n\t{\n\t\tparent::__construct();\n\t\t${3:// code...}\n\t}\n\tpublic function create($data)\n\t{\n\t\tif($this->db->insert($this->table, $data))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\tpublic function read($id)\n\t{\n\t\treturn $this->db->get_where($this->table, array('id', $id))->result();\n\t}\n\tpublic function update($id, $data)\n\t{\n\t\tif($this->db->update($this->table, $data, array('id' => $id)))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\tpublic function delete($id)\n\t{\n\t\tif(is_array($id))\n\t\t{\n\t\t\t$this->db->trans_start();\n\t\t\tforeach($id as $elem)\n\t\t\t\t$this->db->delete($this->table, array('id' => $elem));\n\t\t\t$this->db->trans_complete();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif($this->db->delete($this->table, array('id' => $id)))\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t}\n\tpublic function listRows($limit = null, $offset = 0)\n\t{\n\t\tif(!is_null($limit))\n\t\t\t$this->db->limit($limit, $offset);\n\t\treturn $this->db->get($this->table)->result();\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_model_crudl"
        ],
        "opts": []
      },
      {
        "content": "$this->load->view(\"${1:view_name}\", $${2:data});${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_load-view"
        ],
        "opts": []
      },
      {
        "content": "$this->db->insert(\"${1:table}\", $${2:data});${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_db-insert"
        ],
        "opts": []
      },
      {
        "content": "$this->db->select(\"${1:id, ...}\");${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_db-select"
        ],
        "opts": []
      },
      {
        "content": "$this->db->from(\"${1:table}\");${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_db-from"
        ],
        "opts": []
      },
      {
        "content": "$this->db->join(\"${1:table}\", \"${2:condition}\", \"${3:type}\");${4}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_db-join"
        ],
        "opts": []
      },
      {
        "content": "$this->db->where(\"${1:key}\", \"${2:value}\");${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_db-where"
        ],
        "opts": []
      },
      {
        "content": "$this->db->or_where(\"${1:key}\", \"${2:value}\");${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_db-or_where"
        ],
        "opts": []
      },
      {
        "content": "$this->db->get(\"${1:table}\", ${2:limit}, ${3:offset});${4}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_db-get"
        ],
        "opts": []
      },
      {
        "content": "$this->db->delete(\"${1:table}\", \"${2:where}\");${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_db-delete"
        ],
        "opts": []
      },
      {
        "content": "$this->db->update(\"${1:table}\", $${2:set}, $${3:where});${4}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_db-update"
        ],
        "opts": []
      },
      {
        "content": "$this->input->post(\"${1:index}\");${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_input-post"
        ],
        "opts": []
      },
      {
        "content": "$this->input->get(\"${1:index}\");${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_input-get"
        ],
        "opts": []
      },
      {
        "content": "$this->input->cookie(\"${1:index}\");${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_input-cookie"
        ],
        "opts": []
      },
      {
        "content": "$this->input->server(\"${1:index}\");${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_input-server"
        ],
        "opts": []
      },
      {
        "content": "$this->input->user_agent();${1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_input-user_agent"
        ],
        "opts": []
      },
      {
        "content": "$this->input->is_ajax_request();${1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_input-is_ajax_request"
        ],
        "opts": []
      },
      {
        "content": "$this->input->is_cli_request();${1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_input-is_cli_request"
        ],
        "opts": []
      },
      {
        "content": "$this->form_validation->set_rules(\"${1:field}\", \"${2:label}\", \"${3:trim|required}\");${4}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_form_validation-set_rules"
        ],
        "opts": []
      },
      {
        "content": "form_open(\"${1:action}\");${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_form_open"
        ],
        "opts": []
      },
      {
        "content": "form_open_multipart(\"${1:action}\");${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_form_open_multipart"
        ],
        "opts": []
      },
      {
        "content": "form_hidden(\"${1:name}\", \"${2:value}\");${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_form_hidden"
        ],
        "opts": []
      },
      {
        "content": "form_input(\"${1:name}\", \"${2:value}\");${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_form_input"
        ],
        "opts": []
      },
      {
        "content": "form_password(\"${1:name}\", \"${2:value}\");${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_form_password"
        ],
        "opts": []
      },
      {
        "content": "form_upload(\"${1:name}\", \"${2:value}\");${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_form_upload"
        ],
        "opts": []
      },
      {
        "content": "form_textarea(\"${1:name}\", \"${2:value}\");${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_form_textarea"
        ],
        "opts": []
      },
      {
        "content": "form_dropdown(\"${1:name}\", $${2:options}, $${3:selected);${4}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_form_dropdown"
        ],
        "opts": []
      },
      {
        "content": "form_checkbox(\"${1:name}\", \"${2:value}\");${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_form_checkbox"
        ],
        "opts": []
      },
      {
        "content": "form_radio(\"${1:name}\", \"${2:value}\");${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_form_radio"
        ],
        "opts": []
      },
      {
        "content": "form_submit(\"${1:name}\", \"${2:value}\");${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_form_submit"
        ],
        "opts": []
      },
      {
        "content": "form_reset(\"${1:name}\", \"${2:value}\");${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_form_reset"
        ],
        "opts": []
      },
      {
        "content": "form_button(\"${1:name}\", \"${2:value}\");${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_form_button"
        ],
        "opts": []
      },
      {
        "content": "form_label(\"${1:label text}\", \"${2:id}\");${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_form_label"
        ],
        "opts": []
      },
      {
        "content": "form_close();${1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_form_close"
        ],
        "opts": []
      },
      {
        "content": "validation_errors();${1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_validation_errors"
        ],
        "opts": []
      },
      {
        "content": "$this->session->userdata(\"${1:item}\");${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_session_userdata"
        ],
        "opts": []
      },
      {
        "content": "$this->session->set_userdata($${1:array});${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_session_set_userdata"
        ],
        "opts": []
      },
      {
        "content": "$this->session->flashdata(\"${1:item}\");${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_session_flashdata"
        ],
        "opts": []
      },
      {
        "content": "$this->session->set_flashdata(\"${1:item}\", \"${2:value}\");${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci_session_set_flashdata"
        ],
        "opts": []
      }
    ],
    "coffee": [
      {
        "content": "for ${1:name} in ${2:array}\n\tdo ($1) ->\n\t\t${0:// body}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forindo"
        ],
        "opts": []
      },
      {
        "content": "for ${1:name} in ${2:array}\n\t${0:# body...}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fora"
        ],
        "opts": []
      },
      {
        "content": "for ${1:key}, ${2:value} of ${3:object}\n\t${0:# body...}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "foro"
        ],
        "opts": []
      },
      {
        "content": "for ${1:name} in [${2:start}..${3:finish}]\n\t${0:# body...}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forr"
        ],
        "opts": []
      },
      {
        "content": "for ${1:name} in [${2:start}..${3:finish}] by ${4:step}\n\t${0:# body...}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forrb"
        ],
        "opts": []
      },
      {
        "content": "for ${1:name} in [${2:start}...${3:finish}]\n\t${0:# body...}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forrex"
        ],
        "opts": []
      },
      {
        "content": "for ${1:name} in [${2:start}...${3:finish}] by ${4:step}\n\t${0:# body...}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forrexb"
        ],
        "opts": []
      },
      {
        "content": "(${1:args}) ->\n\t${0:# body...}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fun"
        ],
        "opts": []
      },
      {
        "content": "(${1:args}) =>\n\t${0:# body...}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bfun"
        ],
        "opts": []
      },
      {
        "content": "class ${1:`substitute(vim_snippets#Filename(), '\\(_\\|^\\)\\(.\\)', '\\u\\2', 'g')`}\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cla class .."
        ],
        "opts": []
      },
      {
        "content": "class ${1:`substitute(vim_snippets#Filename(), '\\(_\\|^\\)\\(.\\)', '\\u\\2', 'g')`}\n\tconstructor: (${2:args}) ->\n\t\t${3}\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cla class .. constructor: .."
        ],
        "opts": []
      },
      {
        "content": "class ${1:`substitute(vim_snippets#Filename(), '\\(_\\|^\\)\\(.\\)', '\\u\\2', 'g')`} extends ${2:ParentClass}\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cla class .. extends .."
        ],
        "opts": []
      },
      {
        "content": "class ${1:`substitute(vim_snippets#Filename(), '\\(_\\|^\\)\\(.\\)', '\\u\\2', 'g')`} extends ${2:ParentClass}\n\tconstructor: (${3:args}) ->\n\t\t${4}\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cla class .. extends .. constructor: .."
        ],
        "opts": []
      },
      {
        "content": "if ${1:condition}\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "if ${1:condition}\n\t${2:${VISUAL}}\nelse\n\t${0:# body...}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "else if ${1:condition}\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eif"
        ],
        "opts": []
      },
      {
        "content": "if ${1:condition} then ${2:value} else ${0:other}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifte"
        ],
        "opts": []
      },
      {
        "content": "${1:action} unless ${0:condition}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "unl"
        ],
        "opts": []
      },
      {
        "content": "switch ${1:object}\n\twhen ${2:value}\n\t\t${0:# body...}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "swi"
        ],
        "opts": []
      },
      {
        "content": "console.log ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "log"
        ],
        "opts": []
      },
      {
        "content": "try\n\t${1:${VISUAL}}\ncatch ${2:error}\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "try"
        ],
        "opts": []
      },
      {
        "content": "${2:$1} = require '${1:sys}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "req"
        ],
        "opts": []
      },
      {
        "content": "${0:root} = exports ? this",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "exp"
        ],
        "opts": []
      },
      {
        "content": "JSON.parse ${0:jstr}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jsonp"
        ],
        "opts": []
      },
      {
        "content": "JSON.stringify ${0:object}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jsons"
        ],
        "opts": []
      },
      {
        "content": "${1:#:object} = require('$1')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "req"
        ],
        "opts": []
      },
      {
        "content": "console.log ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "log"
        ],
        "opts": []
      },
      {
        "content": "${1:#:action} unless ${2:#:condition}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "unl"
        ],
        "opts": []
      },
      {
        "content": "try\n  ${1:TARGET}\ncatch ${2:#:error}\n  ${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "try"
        ],
        "opts": []
      },
      {
        "content": "if ${1:#:condition}\n  ${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "else if ${1:#:condition}\n  ${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "elif"
        ],
        "opts": []
      },
      {
        "content": "if ${1:#:condition} then ${2:#:value} else ${3:#:other}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifte"
        ],
        "opts": []
      },
      {
        "content": "if ${1:#:condition}\n  ${2:TARGET}\nelse\n  ${3:#:body...}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "switch ${1:#:object}\n  when ${2:#:value}\n    ${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "swi"
        ],
        "opts": []
      },
      {
        "content": "\\`${1:javascript}\\`",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "^j"
        ],
        "opts": []
      },
      {
        "content": "for ${1:#:name} in [${2:#:start}..${3:#:finish}]${4: by ${5:#:step\\}}\n  ${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forr"
        ],
        "opts": []
      },
      {
        "content": "for ${1:#:name} in [${2:#:start}...${3:#:finish}]${4: by ${5:#:step\\}}\n  ${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forrex"
        ],
        "opts": []
      },
      {
        "content": "for ${1:#:key}, ${2:#:value} of ${3:#:object}\n  ${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "foro"
        ],
        "opts": []
      },
      {
        "content": "for ${1:#:name} in ${2:#:array}\n  ${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fora"
        ],
        "opts": []
      },
      {
        "content": "${1:#:name} = (${2:#:args}) ->\n  ${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fun"
        ],
        "opts": []
      },
      {
        "content": "(${1:#:args}) =>\n  ${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bfun"
        ],
        "opts": []
      },
      {
        "content": "class ${1:#:ClassName}${2: extends ${3:#:Ancestor\\}}\nconstructor: (${4:#:args}) ->\n          ${5:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "cla",
        "matches": [
          "cla"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "${1:name} = `!p snip.rv = \"(\" if t[2] else \"\"`${2:args}`!p snip.rv = \") \" if t[2] else \"\"`->\n\t${0:# body...}",
        "doc": null,
        "grammar": "snu",
        "label": "Function",
        "matches": [
          "fun"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "`!p snip.rv = \"(\" if t[1] else \"\"`${1:args}`!p snip.rv = \") \" if t[1] else \"\"`=>`!p snip.rv = \" \" if t[2] and not t[2].startswith(\"\\n\") else \"\"`${2:expr}",
        "doc": null,
        "grammar": "snu",
        "label": "Function (bound)",
        "matches": [
          "bfun"
        ],
        "opts": [
          "i"
        ]
      },
      {
        "content": "if ${1:condition}\n\t${0:# body...}",
        "doc": null,
        "grammar": "snu",
        "label": "If",
        "matches": [
          "if"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "if ${1:condition}\n\t${2:# body...}\nelse\n\t${3:# body...}",
        "doc": null,
        "grammar": "snu",
        "label": "If .. Else",
        "matches": [
          "ife"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "else if ${1:condition}\n\t${0:# body...}",
        "doc": null,
        "grammar": "snu",
        "label": "Else if",
        "matches": [
          "elif"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "if ${1:condition} then ${2:value} else ${3:other}",
        "doc": null,
        "grammar": "snu",
        "label": "Ternary if",
        "matches": [
          "ifte"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:action} unless ${2:condition}",
        "doc": null,
        "grammar": "snu",
        "label": "Unless",
        "matches": [
          "unl"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "for ${1:name} in ${2:array}\n\t${0:# body...}",
        "doc": null,
        "grammar": "snu",
        "label": "Array Comprehension",
        "matches": [
          "fora"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "for ${1:key}, ${2:value} of ${3:Object}\n\t${0:# body...}",
        "doc": null,
        "grammar": "snu",
        "label": "Object Comprehension",
        "matches": [
          "foro"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "for ${1:name} in [${2:start}..${3:finish}]`!p snip.rv = \" by \" if t[4] else \"\"`${4:step}\n\t${0:# body...}",
        "doc": null,
        "grammar": "snu",
        "label": "Range Comprehension (inclusive)",
        "matches": [
          "forr"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "for ${1:name} in [${2:start}...${3:finish}]`!p snip.rv = \" by \" if t[4] else \"\"`${4:step}\n\t${0:# body...}",
        "doc": null,
        "grammar": "snu",
        "label": "Range Comprehension (exclusive)",
        "matches": [
          "forrex"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "switch ${1:object}\n\twhen ${2:value}\n\t\t${3:# body...}\n\telse\n\t\t$0",
        "doc": null,
        "grammar": "snu",
        "label": "Switch",
        "matches": [
          "swi"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "switch ${1:object}\n\twhen ${2:condition}`!p snip.rv = \" then \" if t[3] else \"\"`${3:value}\n\telse`!p snip.rv = \" \" if t[4] and not t[4].startswith(\"\\n\") else \"\"`${4:value}",
        "doc": null,
        "grammar": "snu",
        "label": "Switch when .. then",
        "matches": [
          "swit"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "class ${1:ClassName}`!p snip.rv = \" extends \" if t[2] else \"\"`${2:Ancestor}\n\n\t${3:constructor:`!p snip.rv = \" (\" if t[4] else \"\"`${4:args}`!p snip.rv = \")\" if t[4] else \"\"` ->\n\t\t${5:# body...}}\n\t$0",
        "doc": null,
        "grammar": "snu",
        "label": "Class",
        "matches": [
          "cla"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "try\n\t$1\ncatch ${2:error}\n\t$3",
        "doc": null,
        "grammar": "snu",
        "label": "Try .. Catch",
        "matches": [
          "try"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1/^'?(\\w+)'?$/\\L$1\\E/} = require(${1:'${2:sys}'})",
        "doc": null,
        "grammar": "snu",
        "label": "Require",
        "matches": [
          "req"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "#{$1}$0",
        "doc": null,
        "grammar": "snu",
        "label": "Interpolated Code",
        "matches": [
          "#"
        ],
        "opts": [
          "i"
        ]
      },
      {
        "content": "console.log ${1:\"${2:msg}\"}",
        "doc": null,
        "grammar": "snu",
        "label": "Log",
        "matches": [
          "log"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:key}:${2:value}",
        "doc": null,
        "grammar": "snu",
        "label": "Key:value for object",
        "matches": [
          "kv"
        ],
        "opts": [
          "b"
        ]
      }
    ],
    "coffee-jasmine": [
      {
        "content": "describe '${1:description}', ->\n\t$0",
        "doc": null,
        "grammar": "snu",
        "label": "Describe (coffee)",
        "matches": [
          "des"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "it '${1:description}', ->\n\t$0",
        "doc": null,
        "grammar": "snu",
        "label": "it (coffee)",
        "matches": [
          "it"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "beforeEach ->\n\t$0",
        "doc": null,
        "grammar": "snu",
        "label": "before each (coffee)",
        "matches": [
          "bef"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "afterEach ->\n\t$0",
        "doc": null,
        "grammar": "snu",
        "label": "after each (coffee)",
        "matches": [
          "aft"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "jasmine.any($1)",
        "doc": null,
        "grammar": "snu",
        "label": "any (coffee)",
        "matches": [
          "any"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "runs ->\n\t$0",
        "doc": null,
        "grammar": "snu",
        "label": "runs (coffee)",
        "matches": [
          "ru"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "waits($1)",
        "doc": null,
        "grammar": "snu",
        "label": "waits (coffee)",
        "matches": [
          "wa"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "expect(${1:target})$0",
        "doc": null,
        "grammar": "snu",
        "label": "expect (coffee)",
        "matches": [
          "ex"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "expect(${1:target}).toEqual(${2:value})",
        "doc": null,
        "grammar": "snu",
        "label": "expect to equal (coffee)",
        "matches": [
          "ee"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "expect(${1:target}).toMatch(${2:pattern})",
        "doc": null,
        "grammar": "snu",
        "label": "expect to match (coffee)",
        "matches": [
          "em"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "expect(${1:target}).toHaveAttr('${2:attr}'${3:, '${4:value}'})",
        "doc": null,
        "grammar": "snu",
        "label": "expect to have attribute (coffee)",
        "matches": [
          "eha"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "expect(${1:target}).toBeTruthy()",
        "doc": null,
        "grammar": "snu",
        "label": "expect to be truthy (coffee)",
        "matches": [
          "et"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "expect(${1:target}).toBeFalsy()",
        "doc": null,
        "grammar": "snu",
        "label": "expect to be falsy (coffee)",
        "matches": [
          "ef"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "expect(${1:target}).toBeDefined()",
        "doc": null,
        "grammar": "snu",
        "label": "expect to be defined (coffee)",
        "matches": [
          "ed"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "expect(${1:target}).toBeNull()",
        "doc": null,
        "grammar": "snu",
        "label": "expect to be null (coffee)",
        "matches": [
          "en"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "expect(${1:target}).toContain(${2:value})",
        "doc": null,
        "grammar": "snu",
        "label": "expect to contain (coffee)",
        "matches": [
          "ec"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "expect(${1:target}).toBeVisible()",
        "doc": null,
        "grammar": "snu",
        "label": "expect to be visible (coffee)",
        "matches": [
          "ev"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "expect(${1:target}).toBeHidden()",
        "doc": null,
        "grammar": "snu",
        "label": "expect to be hidden (coffee)",
        "matches": [
          "eh"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "expect(${1:target}).not$0",
        "doc": null,
        "grammar": "snu",
        "label": "expect not (coffee)",
        "matches": [
          "notx"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "expect(${1:target}).not.toEqual(${2:value})",
        "doc": null,
        "grammar": "snu",
        "label": "expect not to equal (coffee)",
        "matches": [
          "note"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "expect(${1:target}).not.toMatch(${2:pattern})",
        "doc": null,
        "grammar": "snu",
        "label": "expect not to match (coffee)",
        "matches": [
          "notm"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "expect(${1:target}).not.toHaveAttr('${2:attr}'${3:, '${4:value}'})",
        "doc": null,
        "grammar": "snu",
        "label": "expect to not have attribute (coffee)",
        "matches": [
          "notha"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "expect(${1:target}).not.toBeTruthy()",
        "doc": null,
        "grammar": "snu",
        "label": "expect not to be truthy (coffee)",
        "matches": [
          "nott"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "expect(${1:target}).not.toBeFalsy()",
        "doc": null,
        "grammar": "snu",
        "label": "expect not to be falsy (coffee)",
        "matches": [
          "notf"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "expect(${1:target}).not.toBeDefined()",
        "doc": null,
        "grammar": "snu",
        "label": "expect not to be defined (coffee)",
        "matches": [
          "notd"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "expect(${1:target}).not.toBeNull()",
        "doc": null,
        "grammar": "snu",
        "label": "expect not to be null (coffee)",
        "matches": [
          "notn"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "expect(${1:target}).not.toContain(${2:value})",
        "doc": null,
        "grammar": "snu",
        "label": "expect not to contain (coffee)",
        "matches": [
          "notc"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "expect(${1:target}).not.toBeVisible()",
        "doc": null,
        "grammar": "snu",
        "label": "expect not to be visible (coffee)",
        "matches": [
          "notv"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "expect(${1:target}).not.toBeHidden()",
        "doc": null,
        "grammar": "snu",
        "label": "expect not to be hidden (coffee)",
        "matches": [
          "noth"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "spyOn(${1:object}, \"${2:method}\")$0",
        "doc": null,
        "grammar": "snu",
        "label": "spy on (coffee)",
        "matches": [
          "s"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "spyOn(${1:object}, \"${2:method}\").andReturn(${3:arguments})",
        "doc": null,
        "grammar": "snu",
        "label": "spy on and return (coffee)",
        "matches": [
          "sr"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "spyOn(${1:object}, \"${2:method}\").andThrow(${3:exception})",
        "doc": null,
        "grammar": "snu",
        "label": "spy on and throw (coffee)",
        "matches": [
          "st"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "spyOn(${1:object}, \"${2:method}\").andCallThrough()",
        "doc": null,
        "grammar": "snu",
        "label": "spy on and call through (coffee)",
        "matches": [
          "sct"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "spyOn(${1:object}, \"${2:method}\").andCallFake(${3:function})",
        "doc": null,
        "grammar": "snu",
        "label": "spy on and call fake (coffee)",
        "matches": [
          "scf"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "expect(${1:target}).wasCalled()",
        "doc": null,
        "grammar": "snu",
        "label": "expect was called (coffee)",
        "matches": [
          "esc"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "expect(${1:target}).wasCalledWith(${2:arguments})",
        "doc": null,
        "grammar": "snu",
        "label": "expect was called with (coffee)",
        "matches": [
          "escw"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "expect(${1:target}).wasNotCalled()",
        "doc": null,
        "grammar": "snu",
        "label": "expect was not called (coffee)",
        "matches": [
          "notsc"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "expect(${1:target}).wasNotCalledWith(${2:arguments})",
        "doc": null,
        "grammar": "snu",
        "label": "expect was not called with (coffee)",
        "matches": [
          "noscw"
        ],
        "opts": [
          "b"
        ]
      }
    ],
    "coffee-react": [
      {
        "content": "${1:classname}Class = React.createClass\n\tdisplayName: \"$1\"\n\trender: ->\n\t\t$2\n$1 = React.createFactory($1)",
        "doc": null,
        "grammar": "snu",
        "label": "React define Class",
        "matches": [
          "createClass"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "propTypes: ->\n\t${1:myVar}: React.PropTypes.${2:type}${3:.isRequired}",
        "doc": null,
        "grammar": "snu",
        "label": "React define propTypes",
        "matches": [
          "PropTypes"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:myVar}: React.PropTypes.${2:type}${3:.isRequired}\n$4",
        "doc": null,
        "grammar": "snu",
        "label": "React propType (key/value)",
        "matches": [
          "propType"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "@setState\n\t${1:myvar}: ${2:myvalue}\n\t$3",
        "doc": null,
        "grammar": "snu",
        "label": "React setState",
        "matches": [
          "setState"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "getInitialState: ->\n\t${1:myvar}: ${2:myvalue}\n\t$3",
        "doc": null,
        "grammar": "snu",
        "label": "React define getInitialState",
        "matches": [
          "getInitialState"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "getDefaultProps: ->\n\t${1:myvar}: ${2:myvalue}\n\t$3",
        "doc": null,
        "grammar": "snu",
        "label": "React define getDefaultProps",
        "matches": [
          "getDefaultProps"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "componentWillMount: ->\n\t$1",
        "doc": null,
        "grammar": "snu",
        "label": "React define componentWillMount",
        "matches": [
          "componentWillMount"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "componentDidMount: ->\n\t$1",
        "doc": null,
        "grammar": "snu",
        "label": "React define componentDidMount",
        "matches": [
          "componentDidMount"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "componentWillReceiveProps: (nextProps) ->\n\t$1",
        "doc": null,
        "grammar": "snu",
        "label": "React define componentWillReceiveProps",
        "matches": [
          "componentWillReceiveProps"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "shouldComponentUpdate: (nextProps, nextState) ->\n\t$1",
        "doc": null,
        "grammar": "snu",
        "label": "React define shouldComponentUpdate",
        "matches": [
          "shouldComponentUpdate"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "componentWillUpdate: (nextProps, nextState) ->\n\t$1",
        "doc": null,
        "grammar": "snu",
        "label": "React define componentWillUpdate",
        "matches": [
          "componentWillUpdate"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "componentDidUpdate: (prevProps, prevState) ->\n\t$1",
        "doc": null,
        "grammar": "snu",
        "label": "React define componentDidUpdate",
        "matches": [
          "componentDidUpdate"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "componentWillUnmount: ->\n\t$1",
        "doc": null,
        "grammar": "snu",
        "label": "React define componentWillUnmount",
        "matches": [
          "componentWillUnmount"
        ],
        "opts": [
          "b"
        ]
      }
    ],
    "cpp": [
      {
        "content": "#include <${1:iostream}>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "incc"
        ],
        "opts": []
      },
      {
        "content": "#include <boost/${1:shared_ptr}.hpp>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "binc"
        ],
        "opts": []
      },
      {
        "content": "std::array<${1:T}, ${2:N}> ${3};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "array"
        ],
        "opts": []
      },
      {
        "content": "std::vector<${1:T}> ${2};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vector"
        ],
        "opts": []
      },
      {
        "content": "std::deque<${1:T}> ${2};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "deque"
        ],
        "opts": []
      },
      {
        "content": "std::forward_list<${1:T}> ${2};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "flist"
        ],
        "opts": []
      },
      {
        "content": "std::list<${1:T}> ${2};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "list"
        ],
        "opts": []
      },
      {
        "content": "std::set<${1:T}> ${2};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "set"
        ],
        "opts": []
      },
      {
        "content": "std::map<${1:Key}, ${2:T}> ${3};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "map"
        ],
        "opts": []
      },
      {
        "content": "std::multiset<${1:T}> ${2};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mset"
        ],
        "opts": []
      },
      {
        "content": "std::multimap<${1:Key}, ${2:T}> ${3};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mmap"
        ],
        "opts": []
      },
      {
        "content": "std::unordered_set<${1:T}> ${2};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "uset"
        ],
        "opts": []
      },
      {
        "content": "std::unordered_map<${1:Key}, ${2:T}> ${3};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "umap"
        ],
        "opts": []
      },
      {
        "content": "std::unordered_multiset<${1:T}> ${2};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "umset"
        ],
        "opts": []
      },
      {
        "content": "std::unordered_multimap<${1:Key}, ${2:T}> ${3};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ummap"
        ],
        "opts": []
      },
      {
        "content": "std::stack<${1:T}> ${2};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "stack"
        ],
        "opts": []
      },
      {
        "content": "std::queue<${1:T}> ${2};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "queue"
        ],
        "opts": []
      },
      {
        "content": "std::priority_queue<${1:T}> ${2};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pqueue"
        ],
        "opts": []
      },
      {
        "content": "std::shared_ptr<${1:T}> ${2} = std::make_shared<$1>(${3});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "msp"
        ],
        "opts": []
      },
      {
        "content": "auto ${1} = std::make_shared<${2:T}>(${3});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "amsp"
        ],
        "opts": []
      },
      {
        "content": "std::unique_ptr<${1:T}> ${2} = std::make_unique<$1>(${3});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mup"
        ],
        "opts": []
      },
      {
        "content": "auto ${1} = std::make_unique<${2:T}>(${3});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "amup"
        ],
        "opts": []
      },
      {
        "content": "private",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pri"
        ],
        "opts": []
      },
      {
        "content": "protected",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pro"
        ],
        "opts": []
      },
      {
        "content": "public",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pub"
        ],
        "opts": []
      },
      {
        "content": "friend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fr"
        ],
        "opts": []
      },
      {
        "content": "mutable",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mu"
        ],
        "opts": []
      },
      {
        "content": "/*! \\class $1\n *  \\brief ${3:Brief class description}\n *\n *  ${4:Detailed description}\n */\nclass ${1:`vim_snippets#Filename('$1', 'name')`}\n{\npublic:\n\t$1(${2});\n\tvirtual ~$1();\nprotected:\n\tm_${5}; /*!< ${6:Member description} */\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cl"
        ],
        "opts": []
      },
      {
        "content": "${4:void} ${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction}(${3}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mfun"
        ],
        "opts": []
      },
      {
        "content": "/*! \\brief ${4:Brief function description here}\n *\n *  ${5:Detailed description}\n *\n * \\return ${6:Return parameter description}\n */\n${3:void} ${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction}() {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dmfun0"
        ],
        "opts": []
      },
      {
        "content": "/*! \\brief ${6:Brief function description here}\n *\n *  ${7:Detailed description}\n *\n * \\param $4 ${8:Parameter description}\n * \\return ${9:Return parameter description}\n */\n${5:void} ${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction}(${3:Type} ${4:Parameter}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dmfun1"
        ],
        "opts": []
      },
      {
        "content": "/*! \\brief ${8:Brief function description here}\n *\n *  ${9:Detailed description}\n *\n * \\param $4 ${10:Parameter description}\n * \\param $6 ${11:Parameter description}\n * \\return ${12:Return parameter description}\n */\n${7:void} ${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction}(${3:Type} ${4:Parameter},${5:Type} ${6:Parameter}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dmfun2"
        ],
        "opts": []
      },
      {
        "content": "namespace ${1:`vim_snippets#Filename('', 'my')`} {\n\t${0}\n} /* namespace $1 */",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ns"
        ],
        "opts": []
      },
      {
        "content": "namespace {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ans"
        ],
        "opts": []
      },
      {
        "content": "std::cout << ${1} << std::endl;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cout"
        ],
        "opts": []
      },
      {
        "content": "std::cin >> ${1};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cin"
        ],
        "opts": []
      },
      {
        "content": "static_cast<${1:unsigned}>(${2:expr})${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sca"
        ],
        "opts": []
      },
      {
        "content": "dynamic_cast<${1:unsigned}>(${2:expr})${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dca"
        ],
        "opts": []
      },
      {
        "content": "reinterpret_cast<${1:unsigned}>(${2:expr})${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rca"
        ],
        "opts": []
      },
      {
        "content": "const_cast<${1:unsigned}>(${2:expr})${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cca"
        ],
        "opts": []
      },
      {
        "content": "for (int ${2:i} = 0; $2 < ${1:count}; $2${3:++}) {\n\t${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fori"
        ],
        "opts": []
      },
      {
        "content": "for (${1:auto} ${2:i} : ${3:container}) {\n\t${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fore"
        ],
        "opts": []
      },
      {
        "content": "for (${1:std::vector}<${2:type}>::${3:const_iterator} ${4:i} = ${5:container}.begin(); $4 != $5.end(); ++$4) {\n\t${6}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "iter"
        ],
        "opts": []
      },
      {
        "content": "for (auto ${1:i} = ${2:container}.begin(); $1 != $2.end(); ++$1) {\n\t${3:std::cout << *$1 << std::endl;}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "itera"
        ],
        "opts": []
      },
      {
        "content": "[${1}](${2}){${3}};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ld"
        ],
        "opts": []
      },
      {
        "content": "[${1}](${2}){\n\t${3}\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lld"
        ],
        "opts": []
      },
      {
        "content": "try {\n}catch(${1}) {\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "try"
        ],
        "opts": []
      },
      {
        "content": "auto ${1:name}(${2}) -> ${3:void}\n{\n\t${0}\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "af auto function"
        ],
        "opts": []
      },
      {
        "content": "#include <${1:iostream}>${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#inc, #include",
          "inc"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "#include \"${1}\"${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "inc2",
          "#inc2, #include2"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "template<typename ${1:T}> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "template <T>",
        "matches": [
          "template"
        ],
        "opts": []
      },
      {
        "content": "class ${1:#:name} {\n    ${2}\npublic:\n    $1(${3});\n};\n$1::$1($3) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "class {}",
        "matches": [
          "class"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "class ${1:#:name} {\n    ${2}\n};",
        "doc": "",
        "grammar": "snu",
        "label": "class {}",
        "matches": [
          "class-without-constructor"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "try {\n    ${1:#:TARGET}\n} catch (${2:...}) {\n    ${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "try catch",
        "matches": [
          "try"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "for (${1:auto&& }${2:var} : ${3:container}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "for (:) {}",
        "matches": [
          "for_CPP11"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "[${1}](${2})${3}{ ${4:TARGET} }${0:;}",
        "doc": "",
        "grammar": "snu",
        "label": "[](){}",
        "matches": [
          "lambda"
        ],
        "opts": []
      },
      {
        "content": "enum struct ${1:#:name} { ${2:#:TARGET} };",
        "doc": "",
        "grammar": "snu",
        "label": "enum struct {};",
        "matches": [
          "enum_scoped"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "static_assert( ${1}, \"${2}\" );${0}",
        "doc": "",
        "grammar": "snu",
        "label": "static_assert(,\"\")",
        "matches": [
          "static_assert"
        ],
        "opts": []
      },
      {
        "content": "namespace ${1:#:name} {\n    ${0:TARGET}\n} // namespace $1",
        "doc": "",
        "grammar": "snu",
        "label": "namespace {}",
        "matches": [
          "namespace"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "static_cast<${1}>(${2})${0}",
        "doc": "",
        "grammar": "snu",
        "label": "static_cast<>()",
        "matches": [
          "static_cast"
        ],
        "opts": []
      },
      {
        "content": "reinterpret_cast<${1}>(${2})${0}",
        "doc": "",
        "grammar": "snu",
        "label": "reinterpret_cast<>()",
        "matches": [
          "reinterpret_cast"
        ],
        "opts": []
      },
      {
        "content": "const_cast<${1}>(${2})${0}",
        "doc": "",
        "grammar": "snu",
        "label": "const_cast<>()",
        "matches": [
          "const_cast"
        ],
        "opts": []
      },
      {
        "content": "dynamic_cast<${1}>(${2})${0}",
        "doc": "",
        "grammar": "snu",
        "label": "dynamic_cast<>()",
        "matches": [
          "dynamic_cast"
        ],
        "opts": []
      },
      {
        "content": "#include <iostream>\nint main(int argc, char* argv[])\n{\n    std::cout << \"hello, world!\" << std::endl;\n    return 0;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "#include<iostream> int main...",
        "matches": [
          "helloworld"
        ],
        "opts": []
      },
      {
        "content": "std::cout << ${0:TARGET} << std::endl;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p"
        ],
        "opts": [
          "head"
        ]
      }
    ],
    "crystal": [
      {
        "content": "require \"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "req require"
        ],
        "opts": []
      },
      {
        "content": "case ${1:object}\nwhen ${2:condition}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case"
        ],
        "opts": []
      },
      {
        "content": "when ${1:condition}\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "when"
        ],
        "opts": []
      },
      {
        "content": "def ${1:method_name}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "def"
        ],
        "opts": []
      },
      {
        "content": "private def ${1:method_name}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pdef"
        ],
        "opts": []
      },
      {
        "content": "if ${1:condition}\n\t${0:${VISUAL}}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "if ${1:condition}\n\t${2:${VISUAL}}\nelse\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "while ${1:condition}\n\t${0:${VISUAL}}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh"
        ],
        "opts": []
      },
      {
        "content": "class ${1:`substitute(vim_snippets#Filename(), \"\\(_\\|^\\)\\(.\\)\", \"\\u\\2\", \"g\")`}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cla class .. end"
        ],
        "opts": []
      },
      {
        "content": "module ${1:`substitute(vim_snippets#Filename(), \"\\(_\\|^\\)\\(.\\)\", \"\\u\\2\", \"g\")`}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mod class .. end"
        ],
        "opts": []
      },
      {
        "content": "getter ${0:name}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "r"
        ],
        "opts": []
      },
      {
        "content": "getter! ${0:name}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "r!"
        ],
        "opts": []
      },
      {
        "content": "getter? ${0:name}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "r?"
        ],
        "opts": []
      },
      {
        "content": "setter ${0:name}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "w"
        ],
        "opts": []
      },
      {
        "content": "setter! ${0:name}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "w!"
        ],
        "opts": []
      },
      {
        "content": "setter? ${0:name}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "w?"
        ],
        "opts": []
      },
      {
        "content": "property ${0:name}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rw"
        ],
        "opts": []
      },
      {
        "content": "property! ${0:name}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rw!"
        ],
        "opts": []
      },
      {
        "content": "property? ${0:name}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rw?"
        ],
        "opts": []
      },
      {
        "content": "def self.${1:class_method_name}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defs"
        ],
        "opts": []
      },
      {
        "content": "def initialize(${1})\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defi"
        ],
        "opts": []
      },
      {
        "content": "do\n\t${0:${VISUAL}}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "do"
        ],
        "opts": []
      },
      {
        "content": "do |${1:v}|\n\t${2}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dov"
        ],
        "opts": []
      },
      {
        "content": "describe ${1:`substitute(substitute(vim_snippets#Filename(), \"_spec$\", \"\", \"\"), \"\\(_\\|^\\)\\(.\\)\", \"\\u\\2\", \"g\")`} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "desc"
        ],
        "opts": []
      },
      {
        "content": "it \"${1}\" do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "it"
        ],
        "opts": []
      },
      {
        "content": "def ${1:method_name}${2:(${3:*args})}\n\t$0\nend",
        "doc": null,
        "grammar": "snu",
        "label": "def <name>...",
        "matches": [
          "\"\\b(de)?f"
        ],
        "opts": [
          "r"
        ]
      },
      {
        "content": "private def ${1:method_name}${2:(${3:*args})}\n\t$0\nend",
        "doc": null,
        "grammar": "snu",
        "label": "private def <name>...",
        "matches": [
          "\"\\b(pde)?f"
        ],
        "opts": [
          "r"
        ]
      }
    ],
    "cs": [
      {
        "content": "${1:public} static int Main(string[] args)\n{\n\t${0}\n\treturn 0;\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sim"
        ],
        "opts": []
      },
      {
        "content": "public class Application\n{\n\t${1:public} static int Main(string[] args)\n\t{\n\t\t${0}\n\t\treturn 0;\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "simc"
        ],
        "opts": []
      },
      {
        "content": "${1:public} static void Main(string[] args)\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "svm"
        ],
        "opts": []
      },
      {
        "content": "if (${1:true})\n{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "else\n{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "el"
        ],
        "opts": []
      },
      {
        "content": "if (${1})\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifs"
        ],
        "opts": []
      },
      {
        "content": "${1} ? ${2} : ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "t"
        ],
        "opts": []
      },
      {
        "content": "${1} ? ${2} : ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "?"
        ],
        "opts": []
      },
      {
        "content": "do\n{\n\t${0:${VISUAL}}\n} while (${1:true});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "do"
        ],
        "opts": []
      },
      {
        "content": "while (${1:true})\n{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh"
        ],
        "opts": []
      },
      {
        "content": "for (int ${1:i} = 0; $1 < ${2:count}; $1${3:++})\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "for (int ${1:i} = ${2:length}; $1 >= 0; $1--)\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forr"
        ],
        "opts": []
      },
      {
        "content": "foreach (${1:var} ${2:entry} in ${3})\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fore"
        ],
        "opts": []
      },
      {
        "content": "foreach (${1:var} ${2:entry} in ${3})\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "foreach"
        ],
        "opts": []
      },
      {
        "content": "foreach (${1:var} ${2:entry} in ${3})\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "each"
        ],
        "opts": []
      },
      {
        "content": "public interface ${1:`vim_snippets#Filename()`}\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "interface"
        ],
        "opts": []
      },
      {
        "content": "public interface ${1:`vim_snippets#Filename()`}\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if+"
        ],
        "opts": []
      },
      {
        "content": "public class ${1:`vim_snippets#Filename()`}\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "class"
        ],
        "opts": []
      },
      {
        "content": "${2:public} class ${1:`vim_snippets#Filename()`}\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cls"
        ],
        "opts": []
      },
      {
        "content": "public class ${1:`vim_snippets#Filename()`}\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cls+"
        ],
        "opts": []
      },
      {
        "content": "public static class ${1:`vim_snippets#Filename()`}\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cls+^"
        ],
        "opts": []
      },
      {
        "content": "internal class ${1:`vim_snippets#Filename()`}\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cls&"
        ],
        "opts": []
      },
      {
        "content": "internal static class ${1:`vim_snippets#Filename()`}\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cls&^"
        ],
        "opts": []
      },
      {
        "content": "protected class ${1:`vim_snippets#Filename()`}\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cls|"
        ],
        "opts": []
      },
      {
        "content": "protected abstract class ${1:`vim_snippets#Filename()`}\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cls|%"
        ],
        "opts": []
      },
      {
        "content": "public ${1:`vim_snippets#Filename()`}()\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ctor"
        ],
        "opts": []
      },
      {
        "content": "${1:public} ${2:int} ${3} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prop"
        ],
        "opts": []
      },
      {
        "content": "${1:public} ${2:int} ${3} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p"
        ],
        "opts": []
      },
      {
        "content": "public ${1:int} ${2} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p+"
        ],
        "opts": []
      },
      {
        "content": "public ${1:int} ${2} { get; internal set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p+&"
        ],
        "opts": []
      },
      {
        "content": "public ${1:int} ${2} { get; protected set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p+|"
        ],
        "opts": []
      },
      {
        "content": "public ${1:int} ${2} { get; private set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p+-"
        ],
        "opts": []
      },
      {
        "content": "internal ${1:int} ${2} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p&"
        ],
        "opts": []
      },
      {
        "content": "internal ${1:int} ${2} { get; protected set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p&|"
        ],
        "opts": []
      },
      {
        "content": "internal ${1:int} ${2} { get; private set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p&-"
        ],
        "opts": []
      },
      {
        "content": "protected ${1:int} ${2} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p|"
        ],
        "opts": []
      },
      {
        "content": "protected ${1:int} ${2} { get; private set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p|-"
        ],
        "opts": []
      },
      {
        "content": "private ${1:int} ${2} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p-"
        ],
        "opts": []
      },
      {
        "content": "${1:public} int ${2} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pi"
        ],
        "opts": []
      },
      {
        "content": "public int ${1} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pi+"
        ],
        "opts": []
      },
      {
        "content": "public int ${1} { get; internal set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pi+&"
        ],
        "opts": []
      },
      {
        "content": "public int ${1} { get; protected set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pi+|"
        ],
        "opts": []
      },
      {
        "content": "public int ${1} { get; private set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pi+-"
        ],
        "opts": []
      },
      {
        "content": "internal int ${1} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pi&"
        ],
        "opts": []
      },
      {
        "content": "internal int ${1} { get; protected set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pi&|"
        ],
        "opts": []
      },
      {
        "content": "internal int ${1} { get; private set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pi&-"
        ],
        "opts": []
      },
      {
        "content": "protected int ${1} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pi|"
        ],
        "opts": []
      },
      {
        "content": "protected int ${1} { get; private set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pi|-"
        ],
        "opts": []
      },
      {
        "content": "private int ${1} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pi-"
        ],
        "opts": []
      },
      {
        "content": "${1:public} bool ${2} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pb"
        ],
        "opts": []
      },
      {
        "content": "public bool ${1} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pb+"
        ],
        "opts": []
      },
      {
        "content": "public bool ${1} { get; internal set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pb+&"
        ],
        "opts": []
      },
      {
        "content": "public bool ${1} { get; protected set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pb+|"
        ],
        "opts": []
      },
      {
        "content": "public bool ${1} { get; private set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pb+-"
        ],
        "opts": []
      },
      {
        "content": "internal bool ${1} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pb&"
        ],
        "opts": []
      },
      {
        "content": "internal bool ${1} { get; protected set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pb&|"
        ],
        "opts": []
      },
      {
        "content": "internal bool ${1} { get; private set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pb&-"
        ],
        "opts": []
      },
      {
        "content": "protected bool ${1} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pb|"
        ],
        "opts": []
      },
      {
        "content": "protected bool ${1} { get; private set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pb|-"
        ],
        "opts": []
      },
      {
        "content": "private bool ${1} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pb-"
        ],
        "opts": []
      },
      {
        "content": "${1:public} string ${2} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ps"
        ],
        "opts": []
      },
      {
        "content": "public string ${1} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ps+"
        ],
        "opts": []
      },
      {
        "content": "public string ${1} { get; internal set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ps+&"
        ],
        "opts": []
      },
      {
        "content": "public string ${1} { get; protected set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ps+|"
        ],
        "opts": []
      },
      {
        "content": "public string ${1} { get; private set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ps+-"
        ],
        "opts": []
      },
      {
        "content": "internal string ${1} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ps&"
        ],
        "opts": []
      },
      {
        "content": "internal string ${1} { get; protected set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ps&|"
        ],
        "opts": []
      },
      {
        "content": "internal string ${1} { get; private set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ps&-"
        ],
        "opts": []
      },
      {
        "content": "protected string ${1} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ps|"
        ],
        "opts": []
      },
      {
        "content": "protected string ${1} { get; private set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ps|-"
        ],
        "opts": []
      },
      {
        "content": "private string ${1} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ps-"
        ],
        "opts": []
      },
      {
        "content": "${1:public} ${2:void} ${3}(${4})\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "m"
        ],
        "opts": []
      },
      {
        "content": "public ${1:void} ${2}(${3})\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "m+"
        ],
        "opts": []
      },
      {
        "content": "internal ${1:void} ${2}(${3})\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "m&"
        ],
        "opts": []
      },
      {
        "content": "protected ${1:void} ${2}(${3})\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "m|"
        ],
        "opts": []
      },
      {
        "content": "private ${1:void} ${2}(${3})\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "m-"
        ],
        "opts": []
      },
      {
        "content": "${1:public} int ${2}(${3})\n{\n\t${0:return 0;}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mi"
        ],
        "opts": []
      },
      {
        "content": "public int ${1}(${2})\n{\n\t${0:return 0;}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mi+"
        ],
        "opts": []
      },
      {
        "content": "internal int ${1}(${2})\n{\n\t${0:return 0;}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mi&"
        ],
        "opts": []
      },
      {
        "content": "protected int ${1}(${2})\n{\n\t${0:return 0;}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mi|"
        ],
        "opts": []
      },
      {
        "content": "private int ${1}(${2})\n{\n\t${0:return 0;}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mi-"
        ],
        "opts": []
      },
      {
        "content": "${1:public} bool ${2}(${3})\n{\n\t${0:return false;}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mb"
        ],
        "opts": []
      },
      {
        "content": "public bool ${1}(${2})\n{\n\t${0:return false;}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mb+"
        ],
        "opts": []
      },
      {
        "content": "internal bool ${1}(${2})\n{\n\t${0:return false;}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mb&"
        ],
        "opts": []
      },
      {
        "content": "protected bool ${1}(${2})\n{\n\t${0:return false;}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mb|"
        ],
        "opts": []
      },
      {
        "content": "private bool ${1}(${2})\n{\n\t${0:return false;}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mb-"
        ],
        "opts": []
      },
      {
        "content": "${1:public} string ${2}(${3})\n{\n\t${0:return \"\";}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ms"
        ],
        "opts": []
      },
      {
        "content": "public string ${1}(${2})\n{\n\t${0:return \"\";}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ms+"
        ],
        "opts": []
      },
      {
        "content": "internal string ${1}(${2})\n{\n\t${0:return \"\";}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ms&"
        ],
        "opts": []
      },
      {
        "content": "protected string ${1:}(${2:})\n{\n\t${0:return \"\";}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ms|"
        ],
        "opts": []
      },
      {
        "content": "private string ${1}(${2})\n{\n\t${0:return \"\";}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ms-"
        ],
        "opts": []
      },
      {
        "content": "public struct ${1:`vim_snippets#Filename()`}\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "struct"
        ],
        "opts": []
      },
      {
        "content": "enum ${1}\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "enum"
        ],
        "opts": []
      },
      {
        "content": "public enum ${1}\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "enum+"
        ],
        "opts": []
      },
      {
        "content": "#if\n\t${0}\n#endif",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#if"
        ],
        "opts": []
      },
      {
        "content": "/// <summary>\n/// ${0}\n/// </summary>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "///"
        ],
        "opts": []
      },
      {
        "content": "<param name=\"${1}\">${2:$1}</param>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "<p"
        ],
        "opts": []
      },
      {
        "content": "<exception cref=\"${1:System.Exception}\">${2}</exception>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "<ex"
        ],
        "opts": []
      },
      {
        "content": "<returns>${1}</returns>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "<r"
        ],
        "opts": []
      },
      {
        "content": "<see cref=\"${1}\"/>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "<s"
        ],
        "opts": []
      },
      {
        "content": "<remarks>${1}</remarks>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "<rem"
        ],
        "opts": []
      },
      {
        "content": "<code>${1}</code>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "<c"
        ],
        "opts": []
      },
      {
        "content": "Console.WriteLine(${1});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cw"
        ],
        "opts": []
      },
      {
        "content": "public override bool Equals(object obj)\n{\n\tif (obj == null || GetType() != obj.GetType())\n\t{\n\t\treturn false;\n\t}\n\t${0:throw new NotImplementedException();}\n\treturn base.Equals(obj);\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eq"
        ],
        "opts": []
      },
      {
        "content": "public class ${1:MyException} : ${2:Exception}\n{\n\tpublic $1() { }\n\tpublic $1(string message) : base(message) { }\n\tpublic $1(string message, Exception inner) : base(message, inner) { }\n\tprotected $1(\n\t\tSystem.Runtime.Serialization.SerializationInfo info,\n\t\tSystem.Runtime.Serialization.StreamingContext context)\n\t\t\t: base(info, context) { }\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "exc"
        ],
        "opts": []
      },
      {
        "content": "public ${1:object} this[${2:int} index]\n{\n\tget { ${0} }\n\tset { ${0} }\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "index"
        ],
        "opts": []
      },
      {
        "content": "EventHandler temp = ${1:MyEvent};\nif (${2:temp} != null)\n{\n\t$2();\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "inv"
        ],
        "opts": []
      },
      {
        "content": "lock (${1:this})\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lock"
        ],
        "opts": []
      },
      {
        "content": "namespace ${1:MyNamespace}\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "namespace"
        ],
        "opts": []
      },
      {
        "content": "public ${1:int} ${2:MyProperty} { get; set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "propr"
        ],
        "opts": []
      },
      {
        "content": "private ${1:int} ${2:myVar};\npublic $1 ${3:MyProperty}\n{\n\tget { return $2; }\n\tset { $2 = value; }\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "propf"
        ],
        "opts": []
      },
      {
        "content": "public ${1:int} ${2:MyProperty} { get; private set; }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "propg"
        ],
        "opts": []
      },
      {
        "content": "switch (${1:switch_on})\n{\n\t${0}\n\tdefault:\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "switch"
        ],
        "opts": []
      },
      {
        "content": "try\n{\n\t${0:${VISUAL}}\n}\ncatch (${1:System.Exception})\n{\n\tthrow;\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "try"
        ],
        "opts": []
      },
      {
        "content": "try\n{\n\t${0:${VISUAL}}\n}\nfinally\n{\n\t${1}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tryf"
        ],
        "opts": []
      },
      {
        "content": "using (${1:resource})\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "usi"
        ],
        "opts": []
      },
      {
        "content": "namespace ${1:#:Name} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "namespace {}",
        "matches": [
          "name",
          "namespace"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "class ${1:#:Name} ${2::} ${3:Parent}${4:,} ${5:Interface} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "class {}",
        "matches": [
          "class"
        ],
        "opts": []
      },
      {
        "content": "struct ${1:#:Name} ${2::} ${3:Interface} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "struct {}",
        "matches": [
          "struct"
        ],
        "opts": []
      },
      {
        "content": "interface ${1:#:IName} ${2::} ${3:Parent} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "interface {}",
        "matches": [
          "interface"
        ],
        "opts": []
      },
      {
        "content": "${1:void} ${2:#:Method}(${3:#:arguments}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "method"
        ],
        "opts": []
      },
      {
        "content": "enum ${1:#:Name} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "enum {}",
        "matches": [
          "enum"
        ],
        "opts": []
      },
      {
        "content": "delegate ${1:void} ${2:#:Delegate}(${3:#:arguments});${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "delegate"
        ],
        "opts": []
      },
      {
        "content": "${1:int} ${2:#:Name} { get${3:;} ${4:#:private }set${5:;} }${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prop",
          "property"
        ],
        "opts": []
      },
      {
        "content": "get {${1:TARGET}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "get {}",
        "matches": [
          "get"
        ],
        "opts": []
      },
      {
        "content": "set {${1:TARGET}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "set {}",
        "matches": [
          "set"
        ],
        "opts": []
      },
      {
        "content": "#define ${0:#:SYMBOL}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "def",
          "define"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "#undef ${0:#:SYMBOL}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "undef",
          "und"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "#if ${1:SYMBOL}\n    ${0:TARGET}\n#endif",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifdef"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "#warning ${0:#:message}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "warning",
          "warn"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "#error ${0:#:message}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "error",
          "err"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "#line ${0:#:number}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "line"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "#region ${1:#:name}\n    ${0:TARGET}\n#endregion",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "reg",
          "region"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "#pragma warning ${2:disable} ${3:#:errno}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pragma_warning",
          "pragma pragma_warn"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "if (${1:#:condition}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if () {}",
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "else if (${1:#:condition}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "else if () {}",
        "matches": [
          "elseif",
          "elif"
        ],
        "opts": []
      },
      {
        "content": "if (${1:#:condition}) {\n    ${2:TARGET}\n} else {\n    ${3:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if () {} else {}",
        "matches": [
          "ifel",
          "ifelse"
        ],
        "opts": []
      },
      {
        "content": "while (${1:#:condition}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "while () {}",
        "matches": [
          "while"
        ],
        "opts": []
      },
      {
        "content": "do {\n    ${0:TARGET}\n} while (${1:#:condition});",
        "doc": "",
        "grammar": "snu",
        "label": "do {} while() {}",
        "matches": [
          "do_while",
          "dowhile"
        ],
        "opts": []
      },
      {
        "content": "for (${1:#:var}; ${2:#:condition}; ${3:#:effect}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "for () {}",
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "foreach (${1:#:var} in ${2:#:iter}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "foreach () {}",
        "matches": [
          "fore",
          "foreach"
        ],
        "opts": []
      },
      {
        "content": "switch (${1:#:var}) {\ncase ${2:#:val}:\n    ${0:TARGET}\n    break;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "switch () {}",
        "matches": [
          "switch"
        ],
        "opts": []
      },
      {
        "content": "case ${1:#:val}:\n    ${0:TARGET}\n    break;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "break;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "break"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "goto case ${1:#:Val};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "goto"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "default:\n    ${0:TARGET}\n    break;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "default"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "try {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "try_n",
          "try_without_catch_nor_finally"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "try {\n    ${0:TARGET}\n} catch (${1:Exception} ${2:e}) {\n    ${3:Console.WriteLine(e.Message);}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "try {} catch () {}",
        "matches": [
          "try_catch",
          "try"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "try {\n    ${0:TARGET}\n} catch {\n    ${1}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "try {} catch {}",
        "matches": [
          "try_cn",
          "try_catch_n"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "try {\n    ${0:TARGET}\n} catch (${1:Exception} ${2:e}) {\n    ${3:Console.WriteLine(e.Message);}\n} finally {\n    ${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "try {} catch () {} finally {}",
        "matches": [
          "try_cf",
          "try_catch_finally"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "try {\n    ${0:TARGET}\n} finally {\n    ${1}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "try {} finally {}",
        "matches": [
          "try_finally",
          "try_f"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "try {\n    ${0:TARGET}\n} catch {\n    ${1}\n} finally {\n    ${2}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "try {} catch {} finally {}",
        "matches": [
          "try_cnf",
          "try_catch_n_finally"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "catch (${1:Exception} ${2:e}) {\n    ${0:Console.WriteLine(e.Message);}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "catch () {}",
        "matches": [
          "catch"
        ],
        "opts": []
      },
      {
        "content": "catch {\n    ${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "catch {}",
        "matches": [
          "catch_n"
        ],
        "opts": []
      },
      {
        "content": "finally {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "finally {}",
        "matches": [
          "finally",
          "fin"
        ],
        "opts": []
      },
      {
        "content": "throw ${0:#:exception}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "throw"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "lock (${1:#:resource}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "lock () {}",
        "matches": [
          "lock"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "using (${1:#:resource}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "using () {}",
        "matches": [
          "using resource",
          "using_resource"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "checked (${1:#:var}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "checked () {}",
        "matches": [
          "checked"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "unchecked (${1:#:var}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "unchecked () {}",
        "matches": [
          "unchecked"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "unsafe {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "unsafe {}",
        "matches": [
          "unsafe"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "fixed (${1:#:type}* ${2:#:var} = ${3:#:adress}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "fixed () {}",
        "matches": [
          "fixed"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "using ${1:#:path};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "using_import",
          "import"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "using ${1:Name} = ${2:Type};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "using_typedef",
          "typedef"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "System.Linq",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "s.l"
        ],
        "opts": []
      },
      {
        "content": "System.Collections.Generic",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "s.c.g"
        ],
        "opts": []
      },
      {
        "content": "System.Text",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "s.t"
        ],
        "opts": []
      },
      {
        "content": "System.IO",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "s.i"
        ],
        "opts": []
      },
      {
        "content": "System.Diagnostics",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "s.d"
        ],
        "opts": []
      },
      {
        "content": "System.Runtie.CompilerServices",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "s.r.c"
        ],
        "opts": []
      },
      {
        "content": "System.Windows.Forms",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "s.w.f"
        ],
        "opts": []
      },
      {
        "content": "[SerializableAttribute]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "serial",
          "serializable"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "[Conditional(\"${1:#:SYMBOL}\")]${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "conditional",
          "cond"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "[Obsolete(\"${1:#:description}\")]${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "obs dep deprecated",
          "obsolete"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "[assembly: InternalsVisibleTo(\"${1:#:FriendName}\")]${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "internals asmInternalsVisibleTo friend_attr",
          "asm_internals_visible_to"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "<c>${1:#:text}</c>",
        "doc": "",
        "grammar": "snu",
        "label": "<c></c>",
        "matches": [
          "c"
        ],
        "opts": []
      },
      {
        "content": "<code>${0:#:content}</code>",
        "doc": "",
        "grammar": "snu",
        "label": "<code></code>",
        "matches": [
          "code"
        ],
        "opts": []
      },
      {
        "content": "<example>${0:#:description}</example>",
        "doc": "",
        "grammar": "snu",
        "label": "<example></example>",
        "matches": [
          "example"
        ],
        "opts": []
      },
      {
        "content": "<exception cref=\"${1:#:class}\">${2:#:description}</exception>",
        "doc": "",
        "grammar": "snu",
        "label": "<exception cref=\"\"></exception>",
        "matches": [
          "exception"
        ],
        "opts": []
      },
      {
        "content": "<include file='${1:#:filename}' path='${2:#:tabpath}[@${3:#:name}=\"${4:#:id}\"]'/>",
        "doc": "",
        "grammar": "snu",
        "label": "<include file='' path=''/>",
        "matches": [
          "include"
        ],
        "opts": []
      },
      {
        "content": "<param name=\"${1:#:name}\">${0:#:description}</param>",
        "doc": "",
        "grammar": "snu",
        "label": "<param name=\"\"></param>",
        "matches": [
          "param"
        ],
        "opts": []
      },
      {
        "content": "<paramref name=\"${1:#:name}\"/>",
        "doc": "",
        "grammar": "snu",
        "label": "<paramref name=\"\"/>",
        "matches": [
          "paramref"
        ],
        "opts": []
      },
      {
        "content": "<returns>${0:#:description}</returns>",
        "doc": "",
        "grammar": "snu",
        "label": "<returns></returns>",
        "matches": [
          "returns"
        ],
        "opts": []
      },
      {
        "content": "<remarks>${0:#:description}</remarks>",
        "doc": "",
        "grammar": "snu",
        "label": "<remarks></remarks>",
        "matches": [
          "remarks"
        ],
        "opts": []
      },
      {
        "content": "<see cref=\"${1:#:member}\"/>",
        "doc": "",
        "grammar": "snu",
        "label": "<see cref=\"\"/>",
        "matches": [
          "see"
        ],
        "opts": []
      },
      {
        "content": "<seealso cref=\"${1:#:member}\"/>}",
        "doc": "",
        "grammar": "snu",
        "label": "<seealso cref=\"\"/>",
        "matches": [
          "seealso"
        ],
        "opts": []
      },
      {
        "content": "<summary>${0:#:description}</summary>",
        "doc": "",
        "grammar": "snu",
        "label": "<summary></summary>",
        "matches": [
          "summary"
        ],
        "opts": []
      },
      {
        "content": "<typeparam name=\"${1:#:name}\">${0:#:description}</typeparam>",
        "doc": "",
        "grammar": "snu",
        "label": "<typeparam name=\"\"></typeparam>",
        "matches": [
          "typeparam"
        ],
        "opts": []
      },
      {
        "content": "<typeparamref name=\"${1:#:name}\"/>",
        "doc": "",
        "grammar": "snu",
        "label": "<typeparamref name=\"\"/>",
        "matches": [
          "typeparamref"
        ],
        "opts": []
      },
      {
        "content": "<value>${0:#:description}</value>",
        "doc": "",
        "grammar": "snu",
        "label": "<value></value>",
        "matches": [
          "value"
        ],
        "opts": []
      },
      {
        "content": "public static void Main(string[] args) {\n    ${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "main"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "Console.WriteLine(${1:#:message});${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "writeline",
          "println p"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "Console.Write(${1:#:message});${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "write",
          "print"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "public class ${1:Hello} {\n    public static void Main(string[] args) {\n        System.Console.WriteLine(\"Hello, world!\");\n    }\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "helloworld"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "[TestFixture]\npublic class ${1}Test {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tc",
          "testclass"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "[SetUp]\npublic void SetUp() {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tsu",
          "testsetup"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "[TearDown]\npublic void TearDown() {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ttd",
          "testteardown"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "[Test]\npublic void ${1:#:Name}Test() {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "test"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "[Category(\"${0:#:category}\")]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "category"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "namespace ${1:MyNamespace}\n{\n\t${VISUAL}$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "namespace",
        "matches": [
          "namespace"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:public} class ${2:`!p snip.rv = snip.basename`}\n{\n\t$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "class",
        "matches": [
          "class"
        ],
        "opts": [
          "w"
        ]
      },
      {
        "content": "struct ${1:`!p snip.rv = snip.basename`}\n{\n\t$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "struct",
        "matches": [
          "struct"
        ],
        "opts": [
          "w"
        ]
      },
      {
        "content": "interface I${1:`!p snip.rv = snip.basename`}\n{\n\t$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "interface",
        "matches": [
          "interface"
        ],
        "opts": [
          "w"
        ]
      },
      {
        "content": "enum ${1:MyEnum} { ${2:Item} };",
        "doc": null,
        "grammar": "snu",
        "label": "enumeration",
        "matches": [
          "enum"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "static int Main(string[] args)\n{\n\t$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "static int main",
        "matches": [
          "sim"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "static void Main(string[] args)\n{\n\t$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "static void main",
        "matches": [
          "svm"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "public ${1:int} ${2:MyProperty} { get; set; }",
        "doc": null,
        "grammar": "snu",
        "label": "Simple property declaration",
        "matches": [
          "prop"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "private ${1:int} ${2:_myProperty};\n\npublic $1 ${3:MyProperty}\n{\n\tget { return $2; }\n\tset { $2 = value; }\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Full property declaration",
        "matches": [
          "propfull"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "public ${1:int} ${2:MyProperty} { get; private set; }",
        "doc": null,
        "grammar": "snu",
        "label": "Property with a private setter",
        "matches": [
          "propg"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "#if ${1:DEBUG}\n${VISUAL}$0\n#endif",
        "doc": null,
        "grammar": "snu",
        "label": "#if #endif",
        "matches": [
          "#if"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "#region ${1:Region}\n${VISUAL}$0\n#endregion",
        "doc": null,
        "grammar": "snu",
        "label": "#region #endregion",
        "matches": [
          "#region"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "for (int ${1:i} = 0; $1 < ${2:10}; $1++)\n{\n\t${VISUAL}$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "for loop",
        "matches": [
          "for"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "for (int ${1:i} = ${2:10}; $1 >= 0; $1--)\n{\n\t${VISUAL}$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "for loop (reverse)",
        "matches": [
          "forr"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "foreach (${3:var} ${2:item} in ${1:items})\n{\n\t${VISUAL}$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "foreach loop",
        "matches": [
          "foreach"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "while (${1:true})\n{\n\t${VISUAL}$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "while loop",
        "matches": [
          "while"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "do\n{\n\t${VISUAL}$0\n} while (${1:true});",
        "doc": null,
        "grammar": "snu",
        "label": "do loop",
        "matches": [
          "do"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "if ($1)\n{\n\t${VISUAL}$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "if statement",
        "matches": [
          "if"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "if ($1)\n{\n\t${VISUAL}$0\n}\nelse\n{\n}",
        "doc": null,
        "grammar": "snu",
        "label": "if else statement",
        "matches": [
          "ife"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "else if ($1)\n{\n\t$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "else if",
        "matches": [
          "elif"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "else if ($1)\n{\n\t$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "else if",
        "matches": [
          "elseif"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "if ($1 != null)\n{\n\t${VISUAL}$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "if not null",
        "matches": [
          "ifnn"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "switch (${1:statement})\n{\n\tcase ${2:value}:\n\t\tbreak;\n\n\tdefault:\n\t\t$0break;\n}",
        "doc": null,
        "grammar": "snu",
        "label": "switch statement",
        "matches": [
          "switch"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "case ${1:value}:\n\t$2\n\tbreak;",
        "doc": null,
        "grammar": "snu",
        "label": "case",
        "matches": [
          "case"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "using (${1:resource})\n{\n\t${VISUAL}$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "using statement",
        "matches": [
          "using"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "unchecked\n{\n\t${VISUAL}$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "unchecked block",
        "matches": [
          "unchecked"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "checked\n{\n\t${VISUAL}$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "checked block",
        "matches": [
          "checked"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "unsafe\n{\n\t${VISUAL}$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "unsafe",
        "matches": [
          "unsafe"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "try\n{\n\t${VISUAL}$0\n}\ncatch (${1:Exception} ${2:e})\n{\n\tthrow;\n}",
        "doc": null,
        "grammar": "snu",
        "label": "try catch block",
        "matches": [
          "try"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "try\n{\n\t${VISUAL}$0\n}\nfinally\n{\n}",
        "doc": null,
        "grammar": "snu",
        "label": "try finally block",
        "matches": [
          "tryf"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "throw new $1Exception(\"$2\");",
        "doc": null,
        "grammar": "snu",
        "label": "throw",
        "matches": [
          "throw"
        ],
        "opts": []
      },
      {
        "content": "var ${1:seq} =\n\tfrom ${2:item1} in ${3:items1}\n\tjoin ${4:item2} in ${5:items2} on $2.${6:prop1} equals $4.${7:prop2}\n\tselect ${8:$2.prop3}\n\twhere ${9:clause}",
        "doc": null,
        "grammar": "snu",
        "label": "LINQ syntax",
        "matches": [
          "from"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "Debug.Assert(${1:true});",
        "doc": null,
        "grammar": "snu",
        "label": "Debug.Assert",
        "matches": [
          "da"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "Console.WriteLine(\"$1\");",
        "doc": null,
        "grammar": "snu",
        "label": "Console.WriteLine",
        "matches": [
          "cw"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "Console.ReadLine();",
        "doc": null,
        "grammar": "snu",
        "label": "Console.ReadLine",
        "matches": [
          "cr"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "Console.WriteLine(\"${2:`!p\nsnip.rv = ' '.join(['{' + str(i) + '}' for i in range(t[1].count(','))])\n`}\"${1:, something});",
        "doc": null,
        "grammar": "snu",
        "label": "Console.WriteLine with parameters",
        "matches": [
          "cwp"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "MessageBox.Show(\"${1:message}\");",
        "doc": null,
        "grammar": "snu",
        "label": "Message box",
        "matches": [
          "mbox"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "public override bool Equals(object obj) => Equals(obj as ${1:TYPE});\n\npublic bool Equals($1 other)  // IEquatable<$1>\n{\n\tif (object.ReferenceEquals(other, null))\n\t\treturn false;\n\tif (object.ReferenceEquals(this, other))\n\t\treturn true;\n\tif (this.GetType() != other.GetType())\n\t\treturn false;\n\t$0\n\treturn base.Equals(other);\n}\n\npublic override int GetHashCode() => base.GetHashCode();\n\npublic static bool operator ==($1 x, $1 y) =>\n\t(object.ReferenceEquals(x, null) && object.ReferenceEquals(y, null))\n\t|| (!object.ReferenceEquals(x, null) && x.Equals(y));\n\npublic static bool operator !=($1 x, $1 y) => !(x == y);\n",
        "doc": null,
        "grammar": "snu",
        "label": "Equality for a type",
        "matches": [
          "equals"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:public} ${2:void} ${3:MyMethod}(${4})\n{\n\t$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Method",
        "matches": [
          "mth"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:public} static ${2:void} ${3:MyMethod}(${4})\n{\n\t$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Static method",
        "matches": [
          "mths"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:public} ${2:`!p snip.rv = snip.basename or \"untitled\"`}(${3})\n{\n\t$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Constructor",
        "matches": [
          "ctor"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "/// <summary>\n/// $0\n/// </summary>",
        "doc": null,
        "grammar": "snu",
        "label": "XML summary comment",
        "matches": [
          "///"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "<param name=\"${1}\">${2}</param>",
        "doc": null,
        "grammar": "snu",
        "label": "XML pramameter comment",
        "matches": [
          "<p"
        ],
        "opts": [
          "w"
        ]
      },
      {
        "content": "<exception cref=\"${1:System.Exception}\">${2}</exception>",
        "doc": null,
        "grammar": "snu",
        "label": "XML exception comment",
        "matches": [
          "<ex"
        ],
        "opts": [
          "w"
        ]
      },
      {
        "content": "<returns>$0</returns>",
        "doc": null,
        "grammar": "snu",
        "label": "XML returns comment",
        "matches": [
          "<r"
        ],
        "opts": [
          "w"
        ]
      },
      {
        "content": "<code>$0</code>",
        "doc": null,
        "grammar": "snu",
        "label": "XML code comment",
        "matches": [
          "<c"
        ],
        "opts": [
          "w"
        ]
      }
    ],
    "css": [
      {
        "content": "background: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "background",
          "bg"
        ],
        "opts": []
      },
      {
        "content": "background-attachment: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "backattachment",
          "ba"
        ],
        "opts": []
      },
      {
        "content": "background-color: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bc",
          "backcolor"
        ],
        "opts": []
      },
      {
        "content": "background-image: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "backimage",
          "bi"
        ],
        "opts": []
      },
      {
        "content": "background-position: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "backposition",
          "bp"
        ],
        "opts": []
      },
      {
        "content": "background-repeat: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "br",
          "backrepeat"
        ],
        "opts": []
      },
      {
        "content": "border: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "border",
          "b"
        ],
        "opts": []
      },
      {
        "content": "border-style: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "border-style",
          "bs"
        ],
        "opts": []
      },
      {
        "content": "border-color: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bc",
          "border-color"
        ],
        "opts": []
      },
      {
        "content": "border-width: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bw",
          "border-width"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-width: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bbw",
          "border-bottom-width"
        ],
        "opts": []
      },
      {
        "content": "border-top-width: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "btw",
          "border-top-width"
        ],
        "opts": []
      },
      {
        "content": "border-left-width: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "border-left-width",
          "blw"
        ],
        "opts": []
      },
      {
        "content": "border-right-width: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "border-right-width",
          "brw"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-style: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "border-bottom-style",
          "bbs"
        ],
        "opts": []
      },
      {
        "content": "border-top-style: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "border-top-style",
          "bts"
        ],
        "opts": []
      },
      {
        "content": "border-left-style: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "border-left-style",
          "bls"
        ],
        "opts": []
      },
      {
        "content": "border-right-style: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "brs",
          "border-right-style"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-color: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bbc",
          "border-bottom-color"
        ],
        "opts": []
      },
      {
        "content": "border-top-color: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "border-top-color",
          "btc"
        ],
        "opts": []
      },
      {
        "content": "border-left-color: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "border-left-color",
          "blc"
        ],
        "opts": []
      },
      {
        "content": "border-right-color: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "border-right-color",
          "brc"
        ],
        "opts": []
      },
      {
        "content": "outline: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "outline",
          "ol"
        ],
        "opts": []
      },
      {
        "content": "outline-color: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "oc",
          "outline-color"
        ],
        "opts": []
      },
      {
        "content": "outline-style: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "outline-style",
          "os"
        ],
        "opts": []
      },
      {
        "content": "outline-width: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ow",
          "outline-width"
        ],
        "opts": []
      },
      {
        "content": "color: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "color",
          "c"
        ],
        "opts": []
      },
      {
        "content": "direction: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "direction",
          "d"
        ],
        "opts": []
      },
      {
        "content": "letter-spacing: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "letter-spacing",
          "ls"
        ],
        "opts": []
      },
      {
        "content": "line-height: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lh",
          "line-height"
        ],
        "opts": []
      },
      {
        "content": "text-align: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "text-align",
          "ta"
        ],
        "opts": []
      },
      {
        "content": "text-decoration: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "text-decoration",
          "td"
        ],
        "opts": []
      },
      {
        "content": "text-indent: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "text-indent",
          "ti"
        ],
        "opts": []
      },
      {
        "content": "text-transform: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tt",
          "text-transform"
        ],
        "opts": []
      },
      {
        "content": "unicode-bidi: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ub",
          "unicode-bidi"
        ],
        "opts": []
      },
      {
        "content": "white-space: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "white-space",
          "ws"
        ],
        "opts": []
      },
      {
        "content": "word-spacing: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ws",
          "word-spacing"
        ],
        "opts": []
      },
      {
        "content": "font: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "font",
          "f"
        ],
        "opts": []
      },
      {
        "content": "font-family: ${1:\"Times New Roman\",Georgia,Serif};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ff",
          "font-family"
        ],
        "opts": []
      },
      {
        "content": "font-size: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "font-size",
          "fs"
        ],
        "opts": []
      },
      {
        "content": "font-style: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fs",
          "font-style"
        ],
        "opts": []
      },
      {
        "content": "font-weight: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fw",
          "font-weight"
        ],
        "opts": []
      },
      {
        "content": "margin: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "m",
          "margin"
        ],
        "opts": []
      },
      {
        "content": "margin-bottom: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mb",
          "margin-bottom"
        ],
        "opts": []
      },
      {
        "content": "margin-top: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mt",
          "margin-top"
        ],
        "opts": []
      },
      {
        "content": "margin-left: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "margin-left",
          "ml"
        ],
        "opts": []
      },
      {
        "content": "margin-right: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mr",
          "margin-right"
        ],
        "opts": []
      },
      {
        "content": "padding: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "padding",
          "p"
        ],
        "opts": []
      },
      {
        "content": "padding-bottom: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "padding-bottom",
          "pb"
        ],
        "opts": []
      },
      {
        "content": "padding-top: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "padding-top",
          "pt"
        ],
        "opts": []
      },
      {
        "content": "padding-left: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "padding-left",
          "pl"
        ],
        "opts": []
      },
      {
        "content": "padding-right: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pr",
          "padding-right"
        ],
        "opts": []
      },
      {
        "content": "list-style: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ls",
          "list-style"
        ],
        "opts": []
      },
      {
        "content": "list-style-image: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lsi",
          "list-style-image"
        ],
        "opts": []
      },
      {
        "content": "list-style-position: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "list-style-position",
          "lsp"
        ],
        "opts": []
      },
      {
        "content": "list-style-type: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lst",
          "list-style-type"
        ],
        "opts": []
      },
      {
        "content": "content: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "content",
          "c"
        ],
        "opts": []
      },
      {
        "content": "height: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "height",
          "h"
        ],
        "opts": []
      },
      {
        "content": "max-height: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "max-height",
          "mah"
        ],
        "opts": []
      },
      {
        "content": "max-width: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "max-width",
          "maw"
        ],
        "opts": []
      },
      {
        "content": "min-height: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "min-height",
          "mih"
        ],
        "opts": []
      },
      {
        "content": "min-width: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "miw",
          "min-width"
        ],
        "opts": []
      },
      {
        "content": "width: ${1};${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "width",
          "w"
        ],
        "opts": []
      },
      {
        "content": "@media ${1:condition} {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "@media ...",
        "matches": [
          "media"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "@media ${1:all} and (min-width: ${2:SIZE}) {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "@media all and (min-width) {...}",
        "matches": [
          "media-min-width"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "@media ${1:all} and (max-width: ${2:SIZE}) {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "@media all and (max-width) {...}",
        "matches": [
          "media-max-width"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "${1} {\n\t${2:${VISUAL}}\n}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ". \"selector { }\""
        ],
        "opts": []
      },
      {
        "content": "!important",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "! \"!important\""
        ],
        "opts": []
      },
      {
        "content": "-moz-border-image: url(${1}) ${2:0} ${3:0} ${4:0} ${5:0} ${6:stretch} ${7:stretch};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdi:m+"
        ],
        "opts": []
      },
      {
        "content": "-moz-border-image: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdi:m"
        ],
        "opts": []
      },
      {
        "content": "-moz-border-radius: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdrz:m"
        ],
        "opts": []
      },
      {
        "content": "-moz-box-shadow: ${1:0} ${2:0} ${3:0} #${4:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bxsh:m+"
        ],
        "opts": []
      },
      {
        "content": "-moz-box-shadow: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bxsh:m"
        ],
        "opts": []
      },
      {
        "content": "-webkit-border-image: url(${1}) ${2:0} ${3:0} ${4:0} ${5:0} ${6:stretch} ${7:stretch};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdi:w+"
        ],
        "opts": []
      },
      {
        "content": "-webkit-border-image: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdi:w"
        ],
        "opts": []
      },
      {
        "content": "-webkit-border-radius: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdrz:w"
        ],
        "opts": []
      },
      {
        "content": "-webkit-box-shadow: ${1:0} ${2:0} ${3:0} #${4:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bxsh:w+"
        ],
        "opts": []
      },
      {
        "content": "-webkit-box-shadow: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bxsh:w"
        ],
        "opts": []
      },
      {
        "content": "@font-face {\n\tfont-family: ${1};\n\tsrc: url(${2});\n}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@f"
        ],
        "opts": []
      },
      {
        "content": "@import url(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@i"
        ],
        "opts": []
      },
      {
        "content": "@media ${1:print} {\n\t${2:${VISUAL}}\n}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@m \"@media mediatype { }\""
        ],
        "opts": []
      },
      {
        "content": "align-content: ${1:stretch};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac"
        ],
        "opts": []
      },
      {
        "content": "align-content: start;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:s"
        ],
        "opts": []
      },
      {
        "content": "align-content: end;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:e"
        ],
        "opts": []
      },
      {
        "content": "align-content: center;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:c"
        ],
        "opts": []
      },
      {
        "content": "align-content: flex-start;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:fs"
        ],
        "opts": []
      },
      {
        "content": "align-content: flex-end;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:fe"
        ],
        "opts": []
      },
      {
        "content": "align-content: space-between;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:sb"
        ],
        "opts": []
      },
      {
        "content": "align-content: space-around;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:sa"
        ],
        "opts": []
      },
      {
        "content": "align-content: space-evenly;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:se"
        ],
        "opts": []
      },
      {
        "content": "align-content: stretch;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:st"
        ],
        "opts": []
      },
      {
        "content": "align-content: baseline;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:b"
        ],
        "opts": []
      },
      {
        "content": "align-content: first baseline;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:fb"
        ],
        "opts": []
      },
      {
        "content": "align-content: last baseline;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:lb"
        ],
        "opts": []
      },
      {
        "content": "align-items: ${1:stretch};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ai"
        ],
        "opts": []
      },
      {
        "content": "align-items: start;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ai:s"
        ],
        "opts": []
      },
      {
        "content": "align-items: end;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ai:e"
        ],
        "opts": []
      },
      {
        "content": "align-items: center;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ai:c"
        ],
        "opts": []
      },
      {
        "content": "align-items: flex-start;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ai:fs"
        ],
        "opts": []
      },
      {
        "content": "align-items: flex-end;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ai:fe"
        ],
        "opts": []
      },
      {
        "content": "align-items: stretch;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ai:st"
        ],
        "opts": []
      },
      {
        "content": "align-items: baseline;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ai:b"
        ],
        "opts": []
      },
      {
        "content": "align-items: first baseline;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ai:fb"
        ],
        "opts": []
      },
      {
        "content": "align-items: last baseline;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ai:lb"
        ],
        "opts": []
      },
      {
        "content": "align-self: ${1:stretch};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as"
        ],
        "opts": []
      },
      {
        "content": "align-self: start;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as:s"
        ],
        "opts": []
      },
      {
        "content": "align-self: end;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as:e"
        ],
        "opts": []
      },
      {
        "content": "align-self: center;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as:c"
        ],
        "opts": []
      },
      {
        "content": "align-self: stretch;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as:st"
        ],
        "opts": []
      },
      {
        "content": "align-self: flex-start;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as:fs"
        ],
        "opts": []
      },
      {
        "content": "align-self: flex-end;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as:fe"
        ],
        "opts": []
      },
      {
        "content": "align-self: baseline;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as:b"
        ],
        "opts": []
      },
      {
        "content": "align-self: first baseline;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as:fb"
        ],
        "opts": []
      },
      {
        "content": "align-self: last baseline;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as:lb"
        ],
        "opts": []
      },
      {
        "content": "background: #${1:fff} url(${2}) ${3:0} ${4:0} ${5:no-repeat};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bg+"
        ],
        "opts": []
      },
      {
        "content": "background-attachment: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bga"
        ],
        "opts": []
      },
      {
        "content": "background-attachment: fixed;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bga:f"
        ],
        "opts": []
      },
      {
        "content": "background-attachment: scroll;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bga:s"
        ],
        "opts": []
      },
      {
        "content": "background-break: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgbk"
        ],
        "opts": []
      },
      {
        "content": "background-break: bounding-box;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgbk:bb"
        ],
        "opts": []
      },
      {
        "content": "background-break: continuous;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgbk:c"
        ],
        "opts": []
      },
      {
        "content": "background-break: each-box;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgbk:eb"
        ],
        "opts": []
      },
      {
        "content": "background-clip: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgcp"
        ],
        "opts": []
      },
      {
        "content": "background-clip: border-box;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgcp:bb"
        ],
        "opts": []
      },
      {
        "content": "background-clip: content-box;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgcp:cb"
        ],
        "opts": []
      },
      {
        "content": "background-clip: no-clip;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgcp:nc"
        ],
        "opts": []
      },
      {
        "content": "background-clip: padding-box;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgcp:pb"
        ],
        "opts": []
      },
      {
        "content": "background-color: #${1:fff};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgc"
        ],
        "opts": []
      },
      {
        "content": "background-color: transparent;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgc:t"
        ],
        "opts": []
      },
      {
        "content": "background-image: url(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgi"
        ],
        "opts": []
      },
      {
        "content": "background-image: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgi:n"
        ],
        "opts": []
      },
      {
        "content": "background-origin: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgo"
        ],
        "opts": []
      },
      {
        "content": "background-origin: border-box;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgo:bb"
        ],
        "opts": []
      },
      {
        "content": "background-origin: content-box;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgo:cb"
        ],
        "opts": []
      },
      {
        "content": "background-origin: padding-box;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgo:pb"
        ],
        "opts": []
      },
      {
        "content": "background-position-x: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgpx"
        ],
        "opts": []
      },
      {
        "content": "background-position-y: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgpy"
        ],
        "opts": []
      },
      {
        "content": "background-position: ${1:0} ${2:0};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgp"
        ],
        "opts": []
      },
      {
        "content": "background-repeat: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgr"
        ],
        "opts": []
      },
      {
        "content": "background-repeat: no-repeat;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgr:n"
        ],
        "opts": []
      },
      {
        "content": "background-repeat: repeat-x;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgr:x"
        ],
        "opts": []
      },
      {
        "content": "background-repeat: repeat-y;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgr:y"
        ],
        "opts": []
      },
      {
        "content": "background-repeat: repeat;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgr:r"
        ],
        "opts": []
      },
      {
        "content": "background-size: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgz"
        ],
        "opts": []
      },
      {
        "content": "background-size: auto;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgz:a"
        ],
        "opts": []
      },
      {
        "content": "background-size: contain;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgz:ct"
        ],
        "opts": []
      },
      {
        "content": "background-size: cover;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgz:cv"
        ],
        "opts": []
      },
      {
        "content": "background: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bg"
        ],
        "opts": []
      },
      {
        "content": "filter: progid:DXImageTransform.Microsoft.AlphaImageLoader(src='${1}',sizingMethod='${0:crop}');",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bg:ie"
        ],
        "opts": []
      },
      {
        "content": "background: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bg:n"
        ],
        "opts": []
      },
      {
        "content": "border: ${1:1px} ${2:solid} #${3:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bd+"
        ],
        "opts": []
      },
      {
        "content": "border-bottom: ${1:1px} ${2:solid} #${3:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdb+"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-color: #${1:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbc"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-image: url(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbi"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-image: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbi:n"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-left-image: url(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbli"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-left-image: continue;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbli:c"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-left-image: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbli:n"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-left-radius: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdblrz"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-right-image: url(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbri"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-right-image: continue;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbri:c"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-right-image: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbri:n"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-right-radius: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbrrz"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-style: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbs"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-style: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbs:n"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-width: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbw"
        ],
        "opts": []
      },
      {
        "content": "border-bottom: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdb"
        ],
        "opts": []
      },
      {
        "content": "border-bottom: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdb:n"
        ],
        "opts": []
      },
      {
        "content": "border-break: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbk"
        ],
        "opts": []
      },
      {
        "content": "border-break: close;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbk:c"
        ],
        "opts": []
      },
      {
        "content": "border-collapse: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdcl"
        ],
        "opts": []
      },
      {
        "content": "border-collapse: collapse;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdcl:c"
        ],
        "opts": []
      },
      {
        "content": "border-collapse: separate;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdcl:s"
        ],
        "opts": []
      },
      {
        "content": "border-color: #${1:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdc"
        ],
        "opts": []
      },
      {
        "content": "border-corner-image: url(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdci"
        ],
        "opts": []
      },
      {
        "content": "border-corner-image: continue;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdci:c"
        ],
        "opts": []
      },
      {
        "content": "border-corner-image: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdci:n"
        ],
        "opts": []
      },
      {
        "content": "border-fit: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdf"
        ],
        "opts": []
      },
      {
        "content": "border-fit: clip;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdf:c"
        ],
        "opts": []
      },
      {
        "content": "border-fit: overwrite;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdf:of"
        ],
        "opts": []
      },
      {
        "content": "border-fit: overwrite;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdf:ow"
        ],
        "opts": []
      },
      {
        "content": "border-fit: repeat;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdf:r"
        ],
        "opts": []
      },
      {
        "content": "border-fit: scale;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdf:sc"
        ],
        "opts": []
      },
      {
        "content": "border-fit: space;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdf:sp"
        ],
        "opts": []
      },
      {
        "content": "border-fit: stretch;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdf:st"
        ],
        "opts": []
      },
      {
        "content": "border-image: url(${1}) ${2:0} ${3:0} ${4:0} ${5:0} ${6:stretch} ${7:stretch};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdi"
        ],
        "opts": []
      },
      {
        "content": "border-image: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdi:n"
        ],
        "opts": []
      },
      {
        "content": "border-left: ${1:1px} ${2:solid} #${3:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdl+"
        ],
        "opts": []
      },
      {
        "content": "border-left-color: #${1:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdlc"
        ],
        "opts": []
      },
      {
        "content": "border-left-image: url(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdli"
        ],
        "opts": []
      },
      {
        "content": "border-left-image: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdli:n"
        ],
        "opts": []
      },
      {
        "content": "border-left-style: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdls"
        ],
        "opts": []
      },
      {
        "content": "border-left-style: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdls:n"
        ],
        "opts": []
      },
      {
        "content": "border-left-width: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdlw"
        ],
        "opts": []
      },
      {
        "content": "border-left: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdl"
        ],
        "opts": []
      },
      {
        "content": "border-left: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdl:n"
        ],
        "opts": []
      },
      {
        "content": "border-length: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdlt"
        ],
        "opts": []
      },
      {
        "content": "border-length: auto;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdlt:a"
        ],
        "opts": []
      },
      {
        "content": "border-radius: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdrz"
        ],
        "opts": []
      },
      {
        "content": "border-right: ${1:1px} ${2:solid} #${3:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdr+"
        ],
        "opts": []
      },
      {
        "content": "border-right-color: #${1:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdrc"
        ],
        "opts": []
      },
      {
        "content": "border-right-image: url(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdri"
        ],
        "opts": []
      },
      {
        "content": "border-right-image: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdri:n"
        ],
        "opts": []
      },
      {
        "content": "border-right-style: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdrs"
        ],
        "opts": []
      },
      {
        "content": "border-right-style: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdrs:n"
        ],
        "opts": []
      },
      {
        "content": "border-right-width: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdrw"
        ],
        "opts": []
      },
      {
        "content": "border-right: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdr"
        ],
        "opts": []
      },
      {
        "content": "border-right: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdr:n"
        ],
        "opts": []
      },
      {
        "content": "border-spacing: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdsp"
        ],
        "opts": []
      },
      {
        "content": "border-style: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds"
        ],
        "opts": []
      },
      {
        "content": "border-style: dashed;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:ds"
        ],
        "opts": []
      },
      {
        "content": "border-style: dot-dash;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:dtds"
        ],
        "opts": []
      },
      {
        "content": "border-style: dot-dot-dash;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:dtdtds"
        ],
        "opts": []
      },
      {
        "content": "border-style: dotted;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:dt"
        ],
        "opts": []
      },
      {
        "content": "border-style: double;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:db"
        ],
        "opts": []
      },
      {
        "content": "border-style: groove;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:g"
        ],
        "opts": []
      },
      {
        "content": "border-style: hidden;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:h"
        ],
        "opts": []
      },
      {
        "content": "border-style: inset;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:i"
        ],
        "opts": []
      },
      {
        "content": "border-style: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:n"
        ],
        "opts": []
      },
      {
        "content": "border-style: outset;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:o"
        ],
        "opts": []
      },
      {
        "content": "border-style: ridge;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:r"
        ],
        "opts": []
      },
      {
        "content": "border-style: solid;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:s"
        ],
        "opts": []
      },
      {
        "content": "border-style: wave;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:w"
        ],
        "opts": []
      },
      {
        "content": "border-top: ${1:1px} ${2:solid} #${3:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdt+"
        ],
        "opts": []
      },
      {
        "content": "border-top-color: #${1:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdtc"
        ],
        "opts": []
      },
      {
        "content": "border-top-image: url(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdti"
        ],
        "opts": []
      },
      {
        "content": "border-top-image: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdti:n"
        ],
        "opts": []
      },
      {
        "content": "border-top-left-image: url(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdtli"
        ],
        "opts": []
      },
      {
        "content": "border-corner-image: continue;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdtli:c"
        ],
        "opts": []
      },
      {
        "content": "border-corner-image: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdtli:n"
        ],
        "opts": []
      },
      {
        "content": "border-top-left-radius: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdtlrz"
        ],
        "opts": []
      },
      {
        "content": "border-top-right-image: url(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdtri"
        ],
        "opts": []
      },
      {
        "content": "border-top-right-image: continue;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdtri:c"
        ],
        "opts": []
      },
      {
        "content": "border-top-right-image: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdtri:n"
        ],
        "opts": []
      },
      {
        "content": "border-top-right-radius: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdtrrz"
        ],
        "opts": []
      },
      {
        "content": "border-top-style: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdts"
        ],
        "opts": []
      },
      {
        "content": "border-top-style: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdts:n"
        ],
        "opts": []
      },
      {
        "content": "border-top-width: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdtw"
        ],
        "opts": []
      },
      {
        "content": "border-top: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdt"
        ],
        "opts": []
      },
      {
        "content": "border-top: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdt:n"
        ],
        "opts": []
      },
      {
        "content": "border-width: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdw"
        ],
        "opts": []
      },
      {
        "content": "border: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bd"
        ],
        "opts": []
      },
      {
        "content": "border: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bd:n"
        ],
        "opts": []
      },
      {
        "content": "bottom: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "b"
        ],
        "opts": []
      },
      {
        "content": "bottom: auto;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "b:a"
        ],
        "opts": []
      },
      {
        "content": "box-shadow: ${1:0} ${2:0} ${3:0} #${4:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bxsh+"
        ],
        "opts": []
      },
      {
        "content": "box-shadow: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bxsh"
        ],
        "opts": []
      },
      {
        "content": "box-shadow: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bxsh:n"
        ],
        "opts": []
      },
      {
        "content": "box-sizing: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bxz"
        ],
        "opts": []
      },
      {
        "content": "box-sizing: border-box;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bxz:bb"
        ],
        "opts": []
      },
      {
        "content": "box-sizing: content-box;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bxz:cb"
        ],
        "opts": []
      },
      {
        "content": "caption-side: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cps"
        ],
        "opts": []
      },
      {
        "content": "caption-side: bottom;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cps:b"
        ],
        "opts": []
      },
      {
        "content": "caption-side: top;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cps:t"
        ],
        "opts": []
      },
      {
        "content": "clear: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cl"
        ],
        "opts": []
      },
      {
        "content": "clear: both;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cl:b"
        ],
        "opts": []
      },
      {
        "content": "clear: left;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cl:l"
        ],
        "opts": []
      },
      {
        "content": "clear: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cl:n"
        ],
        "opts": []
      },
      {
        "content": "clear: right;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cl:r"
        ],
        "opts": []
      },
      {
        "content": "clip: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cp"
        ],
        "opts": []
      },
      {
        "content": "clip: auto;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cp:a"
        ],
        "opts": []
      },
      {
        "content": "clip: rect(${1:0} ${2:0} ${3:0} ${4:0});${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cp:r"
        ],
        "opts": []
      },
      {
        "content": "color: #${1:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "c"
        ],
        "opts": []
      },
      {
        "content": "content: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ct"
        ],
        "opts": []
      },
      {
        "content": "content: attr(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ct:a"
        ],
        "opts": []
      },
      {
        "content": "content: close-quote;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ct:cq"
        ],
        "opts": []
      },
      {
        "content": "content: counter(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ct:c"
        ],
        "opts": []
      },
      {
        "content": "content: counters(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ct:cs"
        ],
        "opts": []
      },
      {
        "content": "content: no-close-quote;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ct:ncq"
        ],
        "opts": []
      },
      {
        "content": "content: no-open-quote;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ct:noq"
        ],
        "opts": []
      },
      {
        "content": "content: normal;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ct:n"
        ],
        "opts": []
      },
      {
        "content": "content: open-quote;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ct:oq"
        ],
        "opts": []
      },
      {
        "content": "counter-increment: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "coi"
        ],
        "opts": []
      },
      {
        "content": "counter-reset: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cor"
        ],
        "opts": []
      },
      {
        "content": "cursor: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cur"
        ],
        "opts": []
      },
      {
        "content": "cursor: auto;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cur:a"
        ],
        "opts": []
      },
      {
        "content": "cursor: crosshair;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cur:c"
        ],
        "opts": []
      },
      {
        "content": "cursor: default;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cur:d"
        ],
        "opts": []
      },
      {
        "content": "cursor: hand;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cur:ha"
        ],
        "opts": []
      },
      {
        "content": "cursor: help;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cur:he"
        ],
        "opts": []
      },
      {
        "content": "cursor: move;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cur:m"
        ],
        "opts": []
      },
      {
        "content": "cursor: pointer;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cur:p"
        ],
        "opts": []
      },
      {
        "content": "cursor: text;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cur:t"
        ],
        "opts": []
      },
      {
        "content": "display: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d"
        ],
        "opts": []
      },
      {
        "content": "display: -moz-inline-box;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:mib"
        ],
        "opts": []
      },
      {
        "content": "display: -moz-inline-stack;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:mis"
        ],
        "opts": []
      },
      {
        "content": "display: block;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:b"
        ],
        "opts": []
      },
      {
        "content": "display: compact;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:cp"
        ],
        "opts": []
      },
      {
        "content": "display: grid;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:g"
        ],
        "opts": []
      },
      {
        "content": "display: flex;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:f"
        ],
        "opts": []
      },
      {
        "content": "display: inline-block;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:ib"
        ],
        "opts": []
      },
      {
        "content": "display: inline-table;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:itb"
        ],
        "opts": []
      },
      {
        "content": "display: inline;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:i"
        ],
        "opts": []
      },
      {
        "content": "display: list-item;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:li"
        ],
        "opts": []
      },
      {
        "content": "display: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:n"
        ],
        "opts": []
      },
      {
        "content": "display: run-in;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:ri"
        ],
        "opts": []
      },
      {
        "content": "display: table-caption;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:tbcp"
        ],
        "opts": []
      },
      {
        "content": "display: table-cell;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:tbc"
        ],
        "opts": []
      },
      {
        "content": "display: table-column-group;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:tbclg"
        ],
        "opts": []
      },
      {
        "content": "display: table-column;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:tbcl"
        ],
        "opts": []
      },
      {
        "content": "display: table-footer-group;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:tbfg"
        ],
        "opts": []
      },
      {
        "content": "display: table-header-group;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:tbhg"
        ],
        "opts": []
      },
      {
        "content": "display: table-row-group;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:tbrg"
        ],
        "opts": []
      },
      {
        "content": "display: table-row;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:tbr"
        ],
        "opts": []
      },
      {
        "content": "display: table;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:tb"
        ],
        "opts": []
      },
      {
        "content": "empty-cells: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ec"
        ],
        "opts": []
      },
      {
        "content": "empty-cells: hide;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ec:h"
        ],
        "opts": []
      },
      {
        "content": "empty-cells: show;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ec:s"
        ],
        "opts": []
      },
      {
        "content": "expression()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "exp"
        ],
        "opts": []
      },
      {
        "content": "flex: ${1:0} ${2:1} ${0:auto};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fx"
        ],
        "opts": []
      },
      {
        "content": "flex-basis: ${0:auto};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fxb"
        ],
        "opts": []
      },
      {
        "content": "flex-basis: auto;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fxb:a"
        ],
        "opts": []
      },
      {
        "content": "flex-direction: ${0:row};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fxd"
        ],
        "opts": []
      },
      {
        "content": "flex-direction: column;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fxd:c"
        ],
        "opts": []
      },
      {
        "content": "flex-direction: column-reverse;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fxd:cr"
        ],
        "opts": []
      },
      {
        "content": "flex-direction: row;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fxd:r"
        ],
        "opts": []
      },
      {
        "content": "flex-direction: row-reverse;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fxd:rr"
        ],
        "opts": []
      },
      {
        "content": "flex-flow: ${1:row} ${0:nowrap};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fxf"
        ],
        "opts": []
      },
      {
        "content": "flex-grow: ${0:0};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fxg"
        ],
        "opts": []
      },
      {
        "content": "flex-shrink: ${0:1};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fxs"
        ],
        "opts": []
      },
      {
        "content": "flex-wrap: ${0:nowrap};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fxw"
        ],
        "opts": []
      },
      {
        "content": "flex-wrap: nowrap;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fxw:n"
        ],
        "opts": []
      },
      {
        "content": "flex-wrap: wrap;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fxw:w"
        ],
        "opts": []
      },
      {
        "content": "flex-wrap: wrap-reverse;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fxw:wr"
        ],
        "opts": []
      },
      {
        "content": "float: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fl"
        ],
        "opts": []
      },
      {
        "content": "float: left;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fl:l"
        ],
        "opts": []
      },
      {
        "content": "float: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fl:n"
        ],
        "opts": []
      },
      {
        "content": "float: right;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fl:r"
        ],
        "opts": []
      },
      {
        "content": "font: ${1:1em} ${2:Arial},${3:sans-serif};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "f+"
        ],
        "opts": []
      },
      {
        "content": "font-effect: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fef"
        ],
        "opts": []
      },
      {
        "content": "font-effect: emboss;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fef:eb"
        ],
        "opts": []
      },
      {
        "content": "font-effect: engrave;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fef:eg"
        ],
        "opts": []
      },
      {
        "content": "font-effect: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fef:n"
        ],
        "opts": []
      },
      {
        "content": "font-effect: outline;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fef:o"
        ],
        "opts": []
      },
      {
        "content": "font-emphasize-position: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "femp"
        ],
        "opts": []
      },
      {
        "content": "font-emphasize-position: after;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "femp:a"
        ],
        "opts": []
      },
      {
        "content": "font-emphasize-position: before;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "femp:b"
        ],
        "opts": []
      },
      {
        "content": "font-emphasize-style: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fems"
        ],
        "opts": []
      },
      {
        "content": "font-emphasize-style: accent;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fems:ac"
        ],
        "opts": []
      },
      {
        "content": "font-emphasize-style: circle;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fems:c"
        ],
        "opts": []
      },
      {
        "content": "font-emphasize-style: disc;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fems:ds"
        ],
        "opts": []
      },
      {
        "content": "font-emphasize-style: dot;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fems:dt"
        ],
        "opts": []
      },
      {
        "content": "font-emphasize-style: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fems:n"
        ],
        "opts": []
      },
      {
        "content": "font-emphasize: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fem"
        ],
        "opts": []
      },
      {
        "content": "font-family: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ff"
        ],
        "opts": []
      },
      {
        "content": "font-family: ${0:'Monotype Corsiva','Comic Sans MS'},cursive;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ff:c"
        ],
        "opts": []
      },
      {
        "content": "font-family: ${0:Capitals,Impact},fantasy;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ff:f"
        ],
        "opts": []
      },
      {
        "content": "font-family: ${0:Monaco,'Courier New'},monospace;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ff:m"
        ],
        "opts": []
      },
      {
        "content": "font-family: ${0:Helvetica,Arial},sans-serif;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ff:ss"
        ],
        "opts": []
      },
      {
        "content": "font-family: ${0:Georgia,'Times New Roman'},serif;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ff:s"
        ],
        "opts": []
      },
      {
        "content": "font-size-adjust: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fza"
        ],
        "opts": []
      },
      {
        "content": "font-size-adjust: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fza:n"
        ],
        "opts": []
      },
      {
        "content": "font-size: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fz"
        ],
        "opts": []
      },
      {
        "content": "font-smooth: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fsm"
        ],
        "opts": []
      },
      {
        "content": "font-smooth: always;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fsm:aw"
        ],
        "opts": []
      },
      {
        "content": "font-smooth: auto;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fsm:a"
        ],
        "opts": []
      },
      {
        "content": "font-smooth: never;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fsm:n"
        ],
        "opts": []
      },
      {
        "content": "font-stretch: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fst"
        ],
        "opts": []
      },
      {
        "content": "font-stretch: condensed;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fst:c"
        ],
        "opts": []
      },
      {
        "content": "font-stretch: expanded;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fst:e"
        ],
        "opts": []
      },
      {
        "content": "font-stretch: extra-condensed;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fst:ec"
        ],
        "opts": []
      },
      {
        "content": "font-stretch: extra-expanded;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fst:ee"
        ],
        "opts": []
      },
      {
        "content": "font-stretch: normal;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fst:n"
        ],
        "opts": []
      },
      {
        "content": "font-stretch: semi-condensed;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fst:sc"
        ],
        "opts": []
      },
      {
        "content": "font-stretch: semi-expanded;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fst:se"
        ],
        "opts": []
      },
      {
        "content": "font-stretch: ultra-condensed;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fst:uc"
        ],
        "opts": []
      },
      {
        "content": "font-stretch: ultra-expanded;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fst:ue"
        ],
        "opts": []
      },
      {
        "content": "font-style: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fs"
        ],
        "opts": []
      },
      {
        "content": "font-style: italic;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fs:i"
        ],
        "opts": []
      },
      {
        "content": "font-style: normal;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fs:n"
        ],
        "opts": []
      },
      {
        "content": "font-style: oblique;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fs:o"
        ],
        "opts": []
      },
      {
        "content": "font-variant: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fv"
        ],
        "opts": []
      },
      {
        "content": "font-variant: normal;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fv:n"
        ],
        "opts": []
      },
      {
        "content": "font-variant: small-caps;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fv:sc"
        ],
        "opts": []
      },
      {
        "content": "font-weight: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fw"
        ],
        "opts": []
      },
      {
        "content": "font-weight: bold;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fw:b"
        ],
        "opts": []
      },
      {
        "content": "font-weight: bolder;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fw:br"
        ],
        "opts": []
      },
      {
        "content": "font-weight: lighter;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fw:lr"
        ],
        "opts": []
      },
      {
        "content": "font-weight: normal;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fw:n"
        ],
        "opts": []
      },
      {
        "content": "font: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "f"
        ],
        "opts": []
      },
      {
        "content": "grid: ${1};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "g"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-flow: ${1:row};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gaf"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-flow: ${1:row} ${2:dense};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gaf+"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-flow: row;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gaf:r"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-flow: column;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gaf:c"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-flow: dense;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gaf:d"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-flow: row dense;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gaf:rd"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-flow: column dense;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gaf:cd"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-rows: ${1};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gar"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-rows: auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gar:a"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-rows: max-content;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gar:mac"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-rows: min-content;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gar:mic"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-columns: ${1};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gac"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-columns: auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gac:a"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-columns: max-content;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gac:mac"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-columns: min-content;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gac:mic"
        ],
        "opts": []
      },
      {
        "content": "grid-template: ${1};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gt"
        ],
        "opts": []
      },
      {
        "content": "grid-template: ${1} / ${2};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gt+"
        ],
        "opts": []
      },
      {
        "content": "grid-template-rows: ${1};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gtr"
        ],
        "opts": []
      },
      {
        "content": "grid-template-columns: ${1};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gtc"
        ],
        "opts": []
      },
      {
        "content": "grid-template-areas: ${1};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gta"
        ],
        "opts": []
      },
      {
        "content": "grid-gap: ${1};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gg"
        ],
        "opts": []
      },
      {
        "content": "grid-gap: ${1} ${2};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gg+"
        ],
        "opts": []
      },
      {
        "content": "grid-gap: 0;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gg:0"
        ],
        "opts": []
      },
      {
        "content": "grid-row-gap: ${1};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "grg"
        ],
        "opts": []
      },
      {
        "content": "grid-row-gap: 0;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "grg:0"
        ],
        "opts": []
      },
      {
        "content": "grid-column-gap: ${1};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gcg"
        ],
        "opts": []
      },
      {
        "content": "grid-column-gap: 0;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gcg:0"
        ],
        "opts": []
      },
      {
        "content": "grid-row: ${1} / ${2};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gr"
        ],
        "opts": []
      },
      {
        "content": "grid-row-start: ${1};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "grs"
        ],
        "opts": []
      },
      {
        "content": "grid-row-end: ${1};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gre"
        ],
        "opts": []
      },
      {
        "content": "grid-column: ${1} / ${2};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gc"
        ],
        "opts": []
      },
      {
        "content": "grid-column-start: ${1};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gcs"
        ],
        "opts": []
      },
      {
        "content": "grid-column-end: ${1};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gce"
        ],
        "opts": []
      },
      {
        "content": "height: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "h"
        ],
        "opts": []
      },
      {
        "content": "height: auto;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "h:a"
        ],
        "opts": []
      },
      {
        "content": "justify-content: ${1};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc"
        ],
        "opts": []
      },
      {
        "content": "justify-content: start;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc:s"
        ],
        "opts": []
      },
      {
        "content": "justify-content: end;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc:e"
        ],
        "opts": []
      },
      {
        "content": "justify-content: center;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc:c"
        ],
        "opts": []
      },
      {
        "content": "justify-content: flex-start;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc:fs"
        ],
        "opts": []
      },
      {
        "content": "justify-content: flex-end;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc:fe"
        ],
        "opts": []
      },
      {
        "content": "justify-content: space-between;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc:sb"
        ],
        "opts": []
      },
      {
        "content": "justify-content: space-around;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc:sa"
        ],
        "opts": []
      },
      {
        "content": "justify-content: space-evenly;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc:se"
        ],
        "opts": []
      },
      {
        "content": "justify-content: stretch;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc:st"
        ],
        "opts": []
      },
      {
        "content": "justify-content: left;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc:l"
        ],
        "opts": []
      },
      {
        "content": "justify-content: right;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc:r"
        ],
        "opts": []
      },
      {
        "content": "justify-items: ${1:stretch};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ji"
        ],
        "opts": []
      },
      {
        "content": "justify-items: start;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ji:s"
        ],
        "opts": []
      },
      {
        "content": "justify-items: end;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ji:e"
        ],
        "opts": []
      },
      {
        "content": "justify-items: center;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ji:c"
        ],
        "opts": []
      },
      {
        "content": "justify-items: stretch;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ji:st"
        ],
        "opts": []
      },
      {
        "content": "justify-self: ${1:stretch};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "js"
        ],
        "opts": []
      },
      {
        "content": "justify-self: start;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "js:s"
        ],
        "opts": []
      },
      {
        "content": "justify-self: end;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "js:e"
        ],
        "opts": []
      },
      {
        "content": "justify-self: center;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "js:c"
        ],
        "opts": []
      },
      {
        "content": "justify-self: stretch;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "js:st"
        ],
        "opts": []
      },
      {
        "content": "left: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "l"
        ],
        "opts": []
      },
      {
        "content": "left: auto;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "l:a"
        ],
        "opts": []
      },
      {
        "content": "letter-spacing: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lts"
        ],
        "opts": []
      },
      {
        "content": "line-height: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lh"
        ],
        "opts": []
      },
      {
        "content": "list-style-image: url(${1});${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lisi"
        ],
        "opts": []
      },
      {
        "content": "list-style-image: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lisi:n"
        ],
        "opts": []
      },
      {
        "content": "list-style-position: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lisp"
        ],
        "opts": []
      },
      {
        "content": "list-style-position: inside;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lisp:i"
        ],
        "opts": []
      },
      {
        "content": "list-style-position: outside;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lisp:o"
        ],
        "opts": []
      },
      {
        "content": "list-style-type: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "list"
        ],
        "opts": []
      },
      {
        "content": "list-style-type: circle;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "list:c"
        ],
        "opts": []
      },
      {
        "content": "list-style-type: decimal-leading-zero;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "list:dclz"
        ],
        "opts": []
      },
      {
        "content": "list-style-type: decimal;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "list:dc"
        ],
        "opts": []
      },
      {
        "content": "list-style-type: disc;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "list:d"
        ],
        "opts": []
      },
      {
        "content": "list-style-type: lower-roman;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "list:lr"
        ],
        "opts": []
      },
      {
        "content": "list-style-type: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "list:n"
        ],
        "opts": []
      },
      {
        "content": "list-style-type: square;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "list:s"
        ],
        "opts": []
      },
      {
        "content": "list-style-type: upper-roman;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "list:ur"
        ],
        "opts": []
      },
      {
        "content": "list-style: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lis"
        ],
        "opts": []
      },
      {
        "content": "list-style: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lis:n"
        ],
        "opts": []
      },
      {
        "content": "margin-bottom: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mb"
        ],
        "opts": []
      },
      {
        "content": "margin-bottom: auto;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mb:a"
        ],
        "opts": []
      },
      {
        "content": "margin-left: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ml"
        ],
        "opts": []
      },
      {
        "content": "margin-left: auto;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ml:a"
        ],
        "opts": []
      },
      {
        "content": "margin-right: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mr"
        ],
        "opts": []
      },
      {
        "content": "margin-right: auto;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mr:a"
        ],
        "opts": []
      },
      {
        "content": "margin-top: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mt"
        ],
        "opts": []
      },
      {
        "content": "margin-top: auto;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mt:a"
        ],
        "opts": []
      },
      {
        "content": "margin: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "m"
        ],
        "opts": []
      },
      {
        "content": "margin: ${1:0} ${2:0} ${3:0} ${4:0};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "m:4"
        ],
        "opts": []
      },
      {
        "content": "margin: ${1:0} ${2:0} ${3:0};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "m:3"
        ],
        "opts": []
      },
      {
        "content": "margin: ${1:0} ${2:0};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "m:2"
        ],
        "opts": []
      },
      {
        "content": "margin: 0;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "m:0"
        ],
        "opts": []
      },
      {
        "content": "margin: auto;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "m:a"
        ],
        "opts": []
      },
      {
        "content": "max-height: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mah"
        ],
        "opts": []
      },
      {
        "content": "max-height: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mah:n"
        ],
        "opts": []
      },
      {
        "content": "max-width: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "maw"
        ],
        "opts": []
      },
      {
        "content": "max-width: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "maw:n"
        ],
        "opts": []
      },
      {
        "content": "min-height: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mih"
        ],
        "opts": []
      },
      {
        "content": "min-width: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "miw"
        ],
        "opts": []
      },
      {
        "content": "opacity: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "op"
        ],
        "opts": []
      },
      {
        "content": "filter: progid:DXImageTransform.Microsoft.Alpha(Opacity=${1:100});${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "op:ie"
        ],
        "opts": []
      },
      {
        "content": "-ms-filter: 'progid:DXImageTransform.Microsoft.Alpha(Opacity=${0:100})';",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "op:ms"
        ],
        "opts": []
      },
      {
        "content": "orphans: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "orp"
        ],
        "opts": []
      },
      {
        "content": "order: ${0:0};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "or"
        ],
        "opts": []
      },
      {
        "content": "outline: ${1:1px} ${2:solid} #${3:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "o+"
        ],
        "opts": []
      },
      {
        "content": "outline-color: ${1:#000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "oc"
        ],
        "opts": []
      },
      {
        "content": "outline-color: invert;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "oc:i"
        ],
        "opts": []
      },
      {
        "content": "outline-offset: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "oo"
        ],
        "opts": []
      },
      {
        "content": "outline-style: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "os"
        ],
        "opts": []
      },
      {
        "content": "outline-width: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ow"
        ],
        "opts": []
      },
      {
        "content": "outline: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "o"
        ],
        "opts": []
      },
      {
        "content": "outline: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "o:n"
        ],
        "opts": []
      },
      {
        "content": "overflow-style: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovs"
        ],
        "opts": []
      },
      {
        "content": "overflow-style: auto;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovs:a"
        ],
        "opts": []
      },
      {
        "content": "overflow-style: marquee;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovs:mq"
        ],
        "opts": []
      },
      {
        "content": "overflow-style: move;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovs:mv"
        ],
        "opts": []
      },
      {
        "content": "overflow-style: panner;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovs:p"
        ],
        "opts": []
      },
      {
        "content": "overflow-style: scrollbar;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovs:s"
        ],
        "opts": []
      },
      {
        "content": "overflow-x: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovx"
        ],
        "opts": []
      },
      {
        "content": "overflow-x: auto;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovx:a"
        ],
        "opts": []
      },
      {
        "content": "overflow-x: hidden;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovx:h"
        ],
        "opts": []
      },
      {
        "content": "overflow-x: scroll;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovx:s"
        ],
        "opts": []
      },
      {
        "content": "overflow-x: visible;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovx:v"
        ],
        "opts": []
      },
      {
        "content": "overflow-y: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovy"
        ],
        "opts": []
      },
      {
        "content": "overflow-y: auto;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovy:a"
        ],
        "opts": []
      },
      {
        "content": "overflow-y: hidden;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovy:h"
        ],
        "opts": []
      },
      {
        "content": "overflow-y: scroll;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovy:s"
        ],
        "opts": []
      },
      {
        "content": "overflow-y: visible;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovy:v"
        ],
        "opts": []
      },
      {
        "content": "overflow: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ov"
        ],
        "opts": []
      },
      {
        "content": "overflow: auto;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ov:a"
        ],
        "opts": []
      },
      {
        "content": "overflow: hidden;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ov:h"
        ],
        "opts": []
      },
      {
        "content": "overflow: scroll;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ov:s"
        ],
        "opts": []
      },
      {
        "content": "overflow: visible;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ov:v"
        ],
        "opts": []
      },
      {
        "content": "padding-bottom: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pb"
        ],
        "opts": []
      },
      {
        "content": "padding-left: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pl"
        ],
        "opts": []
      },
      {
        "content": "padding-right: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pr"
        ],
        "opts": []
      },
      {
        "content": "padding-top: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pt"
        ],
        "opts": []
      },
      {
        "content": "padding: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p"
        ],
        "opts": []
      },
      {
        "content": "padding: ${1:0} ${2:0} ${3:0} ${4:0};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p:4"
        ],
        "opts": []
      },
      {
        "content": "padding: ${1:0} ${2:0} ${3:0};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p:3"
        ],
        "opts": []
      },
      {
        "content": "padding: ${1:0} ${2:0};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p:2"
        ],
        "opts": []
      },
      {
        "content": "padding: 0;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p:0"
        ],
        "opts": []
      },
      {
        "content": "place-content: ${1};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc"
        ],
        "opts": []
      },
      {
        "content": "place-content: ${1} ${2};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc+"
        ],
        "opts": []
      },
      {
        "content": "place-content: start;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc:s"
        ],
        "opts": []
      },
      {
        "content": "place-content: end;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc:e"
        ],
        "opts": []
      },
      {
        "content": "place-content: center;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc:c"
        ],
        "opts": []
      },
      {
        "content": "place-content: flex-start;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc:fs"
        ],
        "opts": []
      },
      {
        "content": "place-content: flex-end;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc:fe"
        ],
        "opts": []
      },
      {
        "content": "place-content: space-between;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc:sb"
        ],
        "opts": []
      },
      {
        "content": "place-content: space-around;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc:sa"
        ],
        "opts": []
      },
      {
        "content": "place-content: space-evenly;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc:se"
        ],
        "opts": []
      },
      {
        "content": "place-content: stretch;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc:st"
        ],
        "opts": []
      },
      {
        "content": "page-break-after: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgba"
        ],
        "opts": []
      },
      {
        "content": "page-break-after: always;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgba:aw"
        ],
        "opts": []
      },
      {
        "content": "page-break-after: auto;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgba:a"
        ],
        "opts": []
      },
      {
        "content": "page-break-after: left;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgba:l"
        ],
        "opts": []
      },
      {
        "content": "page-break-after: right;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgba:r"
        ],
        "opts": []
      },
      {
        "content": "page-break-before: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgbb"
        ],
        "opts": []
      },
      {
        "content": "page-break-before: always;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgbb:aw"
        ],
        "opts": []
      },
      {
        "content": "page-break-before: auto;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgbb:a"
        ],
        "opts": []
      },
      {
        "content": "page-break-before: left;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgbb:l"
        ],
        "opts": []
      },
      {
        "content": "page-break-before: right;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgbb:r"
        ],
        "opts": []
      },
      {
        "content": "page-break-inside: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgbi"
        ],
        "opts": []
      },
      {
        "content": "page-break-inside: auto;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgbi:a"
        ],
        "opts": []
      },
      {
        "content": "page-break-inside: avoid;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgbi:av"
        ],
        "opts": []
      },
      {
        "content": "place-items: ${1:stretch};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pi"
        ],
        "opts": []
      },
      {
        "content": "place-items: ${1:stretch} ${2:stretch};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pi+"
        ],
        "opts": []
      },
      {
        "content": "place-items: start;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pi:s"
        ],
        "opts": []
      },
      {
        "content": "place-items: end;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pi:e"
        ],
        "opts": []
      },
      {
        "content": "place-items: center;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pi:c"
        ],
        "opts": []
      },
      {
        "content": "",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pi:st"
        ],
        "opts": []
      },
      {
        "content": "position: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pos"
        ],
        "opts": []
      },
      {
        "content": "position: absolute;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pos:a"
        ],
        "opts": []
      },
      {
        "content": "position: fixed;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pos:f"
        ],
        "opts": []
      },
      {
        "content": "position: relative;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pos:r"
        ],
        "opts": []
      },
      {
        "content": "position: static;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pos:s"
        ],
        "opts": []
      },
      {
        "content": "place-self: ${1:stretch};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ps"
        ],
        "opts": []
      },
      {
        "content": "place-self: ${1:stretch} ${2:stretch};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ps+"
        ],
        "opts": []
      },
      {
        "content": "place-self: start;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ps:s"
        ],
        "opts": []
      },
      {
        "content": "place-self: end;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ps:e"
        ],
        "opts": []
      },
      {
        "content": "place-self: center;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ps:c"
        ],
        "opts": []
      },
      {
        "content": "place-self: stretch;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ps:st"
        ],
        "opts": []
      },
      {
        "content": "quotes: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "q"
        ],
        "opts": []
      },
      {
        "content": "quotes: '\\201C' '\\201D' '\\2018' '\\2019';",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "q:en"
        ],
        "opts": []
      },
      {
        "content": "quotes: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "q:n"
        ],
        "opts": []
      },
      {
        "content": "quotes: '\\00AB' '\\00BB' '\\201E' '\\201C';",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "q:ru"
        ],
        "opts": []
      },
      {
        "content": "resize: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rz"
        ],
        "opts": []
      },
      {
        "content": "resize: both;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rz:b"
        ],
        "opts": []
      },
      {
        "content": "resize: horizontal;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rz:h"
        ],
        "opts": []
      },
      {
        "content": "resize: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rz:n"
        ],
        "opts": []
      },
      {
        "content": "resize: vertical;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rz:v"
        ],
        "opts": []
      },
      {
        "content": "right: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "r"
        ],
        "opts": []
      },
      {
        "content": "right: auto;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "r:a"
        ],
        "opts": []
      },
      {
        "content": "table-layout: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tbl"
        ],
        "opts": []
      },
      {
        "content": "table-layout: auto;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tbl:a"
        ],
        "opts": []
      },
      {
        "content": "table-layout: fixed;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tbl:f"
        ],
        "opts": []
      },
      {
        "content": "text-align-last: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tal"
        ],
        "opts": []
      },
      {
        "content": "text-align-last: auto;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tal:a"
        ],
        "opts": []
      },
      {
        "content": "text-align-last: center;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tal:c"
        ],
        "opts": []
      },
      {
        "content": "text-align-last: left;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tal:l"
        ],
        "opts": []
      },
      {
        "content": "text-align-last: right;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tal:r"
        ],
        "opts": []
      },
      {
        "content": "text-align: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ta"
        ],
        "opts": []
      },
      {
        "content": "text-align: center;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ta:c"
        ],
        "opts": []
      },
      {
        "content": "text-align: left;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ta:l"
        ],
        "opts": []
      },
      {
        "content": "text-align: right;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ta:r"
        ],
        "opts": []
      },
      {
        "content": "text-decoration: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "td"
        ],
        "opts": []
      },
      {
        "content": "text-decoration: line-through;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "td:l"
        ],
        "opts": []
      },
      {
        "content": "text-decoration: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "td:n"
        ],
        "opts": []
      },
      {
        "content": "text-decoration: overline;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "td:o"
        ],
        "opts": []
      },
      {
        "content": "text-decoration: underline;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "td:u"
        ],
        "opts": []
      },
      {
        "content": "text-emphasis: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "te"
        ],
        "opts": []
      },
      {
        "content": "text-emphasis: accent;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "te:ac"
        ],
        "opts": []
      },
      {
        "content": "text-emphasis: after;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "te:a"
        ],
        "opts": []
      },
      {
        "content": "text-emphasis: before;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "te:b"
        ],
        "opts": []
      },
      {
        "content": "text-emphasis: circle;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "te:c"
        ],
        "opts": []
      },
      {
        "content": "text-emphasis: disc;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "te:ds"
        ],
        "opts": []
      },
      {
        "content": "text-emphasis: dot;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "te:dt"
        ],
        "opts": []
      },
      {
        "content": "text-emphasis: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "te:n"
        ],
        "opts": []
      },
      {
        "content": "text-height: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "th"
        ],
        "opts": []
      },
      {
        "content": "text-height: auto;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "th:a"
        ],
        "opts": []
      },
      {
        "content": "text-height: font-size;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "th:f"
        ],
        "opts": []
      },
      {
        "content": "text-height: max-size;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "th:m"
        ],
        "opts": []
      },
      {
        "content": "text-height: text-size;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "th:t"
        ],
        "opts": []
      },
      {
        "content": "text-indent: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ti"
        ],
        "opts": []
      },
      {
        "content": "text-indent: -9999px;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ti:-"
        ],
        "opts": []
      },
      {
        "content": "text-justify: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tj"
        ],
        "opts": []
      },
      {
        "content": "text-justify: auto;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tj:a"
        ],
        "opts": []
      },
      {
        "content": "text-justify: distribute;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tj:d"
        ],
        "opts": []
      },
      {
        "content": "text-justify: inter-cluster;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tj:ic"
        ],
        "opts": []
      },
      {
        "content": "text-justify: inter-ideograph;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tj:ii"
        ],
        "opts": []
      },
      {
        "content": "text-justify: inter-word;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tj:iw"
        ],
        "opts": []
      },
      {
        "content": "text-justify: kashida;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tj:k"
        ],
        "opts": []
      },
      {
        "content": "text-justify: tibetan;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tj:t"
        ],
        "opts": []
      },
      {
        "content": "text-outline: ${1:0} ${2:0} #${3:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "to+"
        ],
        "opts": []
      },
      {
        "content": "text-outline: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "to"
        ],
        "opts": []
      },
      {
        "content": "text-outline: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "to:n"
        ],
        "opts": []
      },
      {
        "content": "text-replace: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tr"
        ],
        "opts": []
      },
      {
        "content": "text-replace: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tr:n"
        ],
        "opts": []
      },
      {
        "content": "text-shadow: ${1:0} ${2:0} ${3:0} #${4:000};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tsh+"
        ],
        "opts": []
      },
      {
        "content": "text-shadow: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tsh"
        ],
        "opts": []
      },
      {
        "content": "text-shadow: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tsh:n"
        ],
        "opts": []
      },
      {
        "content": "text-transform: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tt"
        ],
        "opts": []
      },
      {
        "content": "text-transform: capitalize;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tt:c"
        ],
        "opts": []
      },
      {
        "content": "text-transform: lowercase;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tt:l"
        ],
        "opts": []
      },
      {
        "content": "text-transform: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tt:n"
        ],
        "opts": []
      },
      {
        "content": "text-transform: uppercase;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tt:u"
        ],
        "opts": []
      },
      {
        "content": "text-wrap: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tw"
        ],
        "opts": []
      },
      {
        "content": "text-wrap: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tw:no"
        ],
        "opts": []
      },
      {
        "content": "text-wrap: normal;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tw:n"
        ],
        "opts": []
      },
      {
        "content": "text-wrap: suppress;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tw:s"
        ],
        "opts": []
      },
      {
        "content": "text-wrap: unrestricted;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tw:u"
        ],
        "opts": []
      },
      {
        "content": "top: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "t"
        ],
        "opts": []
      },
      {
        "content": "top: auto;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "t:a"
        ],
        "opts": []
      },
      {
        "content": "vertical-align: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "va"
        ],
        "opts": []
      },
      {
        "content": "vertical-align: baseline;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "va:bl"
        ],
        "opts": []
      },
      {
        "content": "vertical-align: bottom;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "va:b"
        ],
        "opts": []
      },
      {
        "content": "vertical-align: middle;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "va:m"
        ],
        "opts": []
      },
      {
        "content": "vertical-align: sub;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "va:sub"
        ],
        "opts": []
      },
      {
        "content": "vertical-align: super;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "va:sup"
        ],
        "opts": []
      },
      {
        "content": "vertical-align: text-bottom;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "va:tb"
        ],
        "opts": []
      },
      {
        "content": "vertical-align: text-top;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "va:tt"
        ],
        "opts": []
      },
      {
        "content": "vertical-align: top;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "va:t"
        ],
        "opts": []
      },
      {
        "content": "visibility: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "v"
        ],
        "opts": []
      },
      {
        "content": "visibility: collapse;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "v:c"
        ],
        "opts": []
      },
      {
        "content": "visibility: hidden;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "v:h"
        ],
        "opts": []
      },
      {
        "content": "visibility: visible;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "v:v"
        ],
        "opts": []
      },
      {
        "content": "white-space-collapse: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whsc"
        ],
        "opts": []
      },
      {
        "content": "white-space-collapse: break-all;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whsc:ba"
        ],
        "opts": []
      },
      {
        "content": "white-space-collapse: break-strict;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whsc:bs"
        ],
        "opts": []
      },
      {
        "content": "white-space-collapse: keep-all;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whsc:k"
        ],
        "opts": []
      },
      {
        "content": "white-space-collapse: loose;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whsc:l"
        ],
        "opts": []
      },
      {
        "content": "white-space-collapse: normal;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whsc:n"
        ],
        "opts": []
      },
      {
        "content": "white-space: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whs"
        ],
        "opts": []
      },
      {
        "content": "white-space: normal;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whs:n"
        ],
        "opts": []
      },
      {
        "content": "white-space: nowrap;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whs:nw"
        ],
        "opts": []
      },
      {
        "content": "white-space: pre-line;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whs:pl"
        ],
        "opts": []
      },
      {
        "content": "white-space: pre-wrap;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whs:pw"
        ],
        "opts": []
      },
      {
        "content": "white-space: pre;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whs:p"
        ],
        "opts": []
      },
      {
        "content": "widows: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wid"
        ],
        "opts": []
      },
      {
        "content": "width: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "w"
        ],
        "opts": []
      },
      {
        "content": "width: auto;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "w:a"
        ],
        "opts": []
      },
      {
        "content": "word-break: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wob"
        ],
        "opts": []
      },
      {
        "content": "word-break: break-all;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wob:ba"
        ],
        "opts": []
      },
      {
        "content": "word-break: break-strict;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wob:bs"
        ],
        "opts": []
      },
      {
        "content": "word-break: keep-all;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wob:k"
        ],
        "opts": []
      },
      {
        "content": "word-break: loose;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wob:l"
        ],
        "opts": []
      },
      {
        "content": "word-break: normal;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wob:n"
        ],
        "opts": []
      },
      {
        "content": "word-spacing: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wos"
        ],
        "opts": []
      },
      {
        "content": "word-wrap: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wow"
        ],
        "opts": []
      },
      {
        "content": "word-wrap: none;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wow:no"
        ],
        "opts": []
      },
      {
        "content": "word-wrap: normal;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wow:n"
        ],
        "opts": []
      },
      {
        "content": "word-wrap: suppress;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wow:s"
        ],
        "opts": []
      },
      {
        "content": "word-wrap: unrestricted;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wow:u"
        ],
        "opts": []
      },
      {
        "content": "z-index: ${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "z"
        ],
        "opts": []
      },
      {
        "content": "z-index: auto;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "z:a"
        ],
        "opts": []
      },
      {
        "content": "zoom: 1;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "zoo"
        ],
        "opts": []
      },
      {
        "content": ":hover",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ":h"
        ],
        "opts": []
      },
      {
        "content": ":first-child",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ":fc"
        ],
        "opts": []
      },
      {
        "content": ":last-child",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ":lc"
        ],
        "opts": []
      },
      {
        "content": ":nth-child(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ":nc"
        ],
        "opts": []
      },
      {
        "content": ":nth-last-child(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ":nlc"
        ],
        "opts": []
      },
      {
        "content": ":only-child",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ":oc"
        ],
        "opts": []
      },
      {
        "content": ":after",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ":a"
        ],
        "opts": []
      },
      {
        "content": ":before",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ":b"
        ],
        "opts": []
      },
      {
        "content": "::after",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "::a"
        ],
        "opts": []
      },
      {
        "content": "::before",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "::b"
        ],
        "opts": []
      },
      {
        "content": "padding: ${1:0};$0",
        "doc": null,
        "grammar": "snu",
        "label": "padding",
        "matches": [
          "p"
        ],
        "opts": []
      },
      {
        "content": "margin: ${1:0};$0",
        "doc": null,
        "grammar": "snu",
        "label": "margin",
        "matches": [
          "m"
        ],
        "opts": []
      },
      {
        "content": "border: ${1:0};$0",
        "doc": null,
        "grammar": "snu",
        "label": "border",
        "matches": [
          "bd"
        ],
        "opts": []
      },
      {
        "content": "display: ${1:none};$0",
        "doc": null,
        "grammar": "snu",
        "label": "display",
        "matches": [
          "d"
        ],
        "opts": []
      },
      {
        "content": "background: ${1:none};$0",
        "doc": null,
        "grammar": "snu",
        "label": "background",
        "matches": [
          "bg"
        ],
        "opts": []
      },
      {
        "content": "font-family: ${1:\"Helvetica Neue\", Helvetica, Arial, sans-serif};$0",
        "doc": null,
        "grammar": "snu",
        "label": "font-family",
        "matches": [
          "ff"
        ],
        "opts": []
      },
      {
        "content": "height: ${1:auto};$0",
        "doc": null,
        "grammar": "snu",
        "label": "height",
        "matches": [
          "h"
        ],
        "opts": []
      },
      {
        "content": "width: ${1:auto};$0",
        "doc": null,
        "grammar": "snu",
        "label": "width",
        "matches": [
          "w"
        ],
        "opts": []
      },
      {
        "content": "position: ${1:relative};$0",
        "doc": null,
        "grammar": "snu",
        "label": "position",
        "matches": [
          "pos"
        ],
        "opts": []
      },
      {
        "content": "text-transform: ${1:none};$0",
        "doc": null,
        "grammar": "snu",
        "label": "text-transform",
        "matches": [
          "tt"
        ],
        "opts": []
      },
      {
        "content": "!important",
        "doc": null,
        "grammar": "snu",
        "label": "!important CSS (!)",
        "matches": [
          "!"
        ],
        "opts": []
      },
      {
        "content": "text-shadow: ${1:${2:color} ${3:offset-x} ${4:offset-y} ${5:blur}};$0",
        "doc": null,
        "grammar": "snu",
        "label": "text-shadow: color-hex x y blur (text)",
        "matches": [
          "tsh"
        ],
        "opts": []
      },
      {
        "content": "box-shadow: ${1:${2:offset-x} ${3:offset-y} ${4:blur} ${5:spread} ${6:color}};$0",
        "doc": null,
        "grammar": "snu",
        "label": "box-shadow: color-hex x y blur (text)",
        "matches": [
          "bxsh"
        ],
        "opts": []
      },
      {
        "content": "rgb(${1:255}, ${2:255}, ${3:255})$0",
        "doc": null,
        "grammar": "snu",
        "label": "color rgb",
        "matches": [
          "rgb"
        ],
        "opts": []
      },
      {
        "content": "rgba(${1:255}, ${2:255}, ${3:255}, ${4:0.5})$0",
        "doc": null,
        "grammar": "snu",
        "label": "color rgba",
        "matches": [
          "rgba"
        ],
        "opts": []
      },
      {
        "content": "hsl(${1:360}, ${2:100}%, ${3:100}%)$0",
        "doc": null,
        "grammar": "snu",
        "label": "color hsl",
        "matches": [
          "hsl"
        ],
        "opts": []
      },
      {
        "content": "hsla(${1:360}, ${2:100}%, ${3:100}%, ${4:0.5})$0",
        "doc": null,
        "grammar": "snu",
        "label": "color hsla",
        "matches": [
          "hsla"
        ],
        "opts": []
      },
      {
        "content": ":first-child",
        "doc": null,
        "grammar": "snu",
        "label": null,
        "matches": [
          ":fc"
        ],
        "opts": []
      },
      {
        "content": ":last-child",
        "doc": null,
        "grammar": "snu",
        "label": null,
        "matches": [
          ":lc"
        ],
        "opts": []
      },
      {
        "content": ":nth-child($0)",
        "doc": null,
        "grammar": "snu",
        "label": null,
        "matches": [
          ":nc"
        ],
        "opts": []
      },
      {
        "content": ":nth-last-child($0)",
        "doc": null,
        "grammar": "snu",
        "label": null,
        "matches": [
          ":nlc"
        ],
        "opts": []
      },
      {
        "content": ":only-child",
        "doc": null,
        "grammar": "snu",
        "label": null,
        "matches": [
          ":oc"
        ],
        "opts": []
      },
      {
        "content": ":after",
        "doc": null,
        "grammar": "snu",
        "label": null,
        "matches": [
          ":a"
        ],
        "opts": []
      },
      {
        "content": ":before",
        "doc": null,
        "grammar": "snu",
        "label": null,
        "matches": [
          ":b"
        ],
        "opts": []
      },
      {
        "content": "::after",
        "doc": null,
        "grammar": "snu",
        "label": null,
        "matches": [
          "::a"
        ],
        "opts": []
      },
      {
        "content": "::before",
        "doc": null,
        "grammar": "snu",
        "label": null,
        "matches": [
          "::b"
        ],
        "opts": []
      },
      {
        "content": "background-attachment: ${1:scroll/fixed};$0",
        "doc": null,
        "grammar": "snu",
        "label": "background-attachment: scroll:fixed (background)",
        "matches": [
          "background"
        ],
        "opts": []
      },
      {
        "content": "background-color: #${1:DDD};$0",
        "doc": null,
        "grammar": "snu",
        "label": "background-color:  color-hex (background)",
        "matches": [
          "background"
        ],
        "opts": []
      },
      {
        "content": "background-color: ${1:red};$0",
        "doc": null,
        "grammar": "snu",
        "label": "background-color:  color-name (background)",
        "matches": [
          "background"
        ],
        "opts": []
      },
      {
        "content": "background-color: rgb(${1:255},${2:255},${3:255});$0",
        "doc": null,
        "grammar": "snu",
        "label": "background-color:  color-rgb (background)",
        "matches": [
          "background"
        ],
        "opts": []
      },
      {
        "content": "background-color: transparent;$0",
        "doc": null,
        "grammar": "snu",
        "label": "background-color:  transparent (background)",
        "matches": [
          "background"
        ],
        "opts": []
      },
      {
        "content": "background-image: none;$0",
        "doc": null,
        "grammar": "snu",
        "label": "background-image:  none (background)",
        "matches": [
          "background"
        ],
        "opts": []
      },
      {
        "content": "background-image: url($1);$0",
        "doc": null,
        "grammar": "snu",
        "label": "background-image:  url (background)",
        "matches": [
          "background"
        ],
        "opts": []
      },
      {
        "content": "background-position: ${1:top left/top center/top right/center left/center center/center right/bottom left/bottom center/bottom right/x-% y-%/x-pos y-pos};$0",
        "doc": null,
        "grammar": "snu",
        "label": "background-position:  position (background)",
        "matches": [
          "background"
        ],
        "opts": []
      },
      {
        "content": "background-repeat: ${1:repeat/repeat-x/repeat-y/no-repeat};$0",
        "doc": null,
        "grammar": "snu",
        "label": "background-repeat:  r:r-x:r-y:n-r (background)",
        "matches": [
          "background"
        ],
        "opts": []
      },
      {
        "content": "background:${6: #${1:DDD}} url($2) ${3:repeat/repeat-x/repeat-y/no-repeat} ${4:scroll/fixed} ${5:top left/top center/top right/center left/center center/center right/bottom left/bottom center/bottom right/x-% y-%/x-pos y-pos};$0",
        "doc": null,
        "grammar": "snu",
        "label": "background:  color image repeat attachment position (background)",
        "matches": [
          "background"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-color: #${1:999};$0",
        "doc": null,
        "grammar": "snu",
        "label": "border-bottom-color: size style color (border)",
        "matches": [
          "border"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-style: ${1:none/hidden/dotted/dashed/solid/double/groove/ridge/inset/outset};$0",
        "doc": null,
        "grammar": "snu",
        "label": "border-bottom-style: size style color (border)",
        "matches": [
          "border"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-width: ${1:1}px ${2:solid} #${3:999};$0",
        "doc": null,
        "grammar": "snu",
        "label": "border-bottom-width: size style color (border)",
        "matches": [
          "border"
        ],
        "opts": []
      },
      {
        "content": "border-bottom: ${1:1}px ${2:solid} #${3:999};$0",
        "doc": null,
        "grammar": "snu",
        "label": "border-bottom: size style color (border)",
        "matches": [
          "border"
        ],
        "opts": []
      },
      {
        "content": "border-color: ${1:999};$0",
        "doc": null,
        "grammar": "snu",
        "label": "border-color: color (border)",
        "matches": [
          "border"
        ],
        "opts": []
      },
      {
        "content": "border-right-color: #${1:999};$0",
        "doc": null,
        "grammar": "snu",
        "label": "border-left-color: color (border)",
        "matches": [
          "border"
        ],
        "opts": []
      },
      {
        "content": "border-left-style: ${1:none/hidden/dotted/dashed/solid/double/groove/ridge/inset/outset};$0",
        "doc": null,
        "grammar": "snu",
        "label": "border-left-style: style (border)",
        "matches": [
          "border"
        ],
        "opts": []
      },
      {
        "content": "border-left-width: ${1:1}px",
        "doc": null,
        "grammar": "snu",
        "label": "border-left-width: size (border)",
        "matches": [
          "border"
        ],
        "opts": []
      },
      {
        "content": "border-left: ${1:1}px ${2:solid} #${3:999};$0",
        "doc": null,
        "grammar": "snu",
        "label": "border-left: size style color (border)",
        "matches": [
          "border"
        ],
        "opts": []
      },
      {
        "content": "border-right-color: #${1:999};$0",
        "doc": null,
        "grammar": "snu",
        "label": "border-right-color: color (border)",
        "matches": [
          "border"
        ],
        "opts": []
      },
      {
        "content": "border-right-style: ${1:none/hidden/dotted/dashed/solid/double/groove/ridge/inset/outset};$0",
        "doc": null,
        "grammar": "snu",
        "label": "border-right-style: style (border)",
        "matches": [
          "border"
        ],
        "opts": []
      },
      {
        "content": "border-right-width: ${1:1}px",
        "doc": null,
        "grammar": "snu",
        "label": "border-right-width: size (border)",
        "matches": [
          "border"
        ],
        "opts": []
      },
      {
        "content": "border-right: ${1:1}px ${2:solid} #${3:999};$0",
        "doc": null,
        "grammar": "snu",
        "label": "border-right: size style color (border)",
        "matches": [
          "border"
        ],
        "opts": []
      },
      {
        "content": "border-style: ${1:none/hidden/dotted/dashed/solid/double/groove/ridge/inset/outset};$0",
        "doc": null,
        "grammar": "snu",
        "label": "border-style: style (border)",
        "matches": [
          "border"
        ],
        "opts": []
      },
      {
        "content": "border-top-color: #${1:999};$0",
        "doc": null,
        "grammar": "snu",
        "label": "border-top-color: color (border)",
        "matches": [
          "border"
        ],
        "opts": []
      },
      {
        "content": "border-top-style: ${1:none/hidden/dotted/dashed/solid/double/groove/ridge/inset/outset};$0",
        "doc": null,
        "grammar": "snu",
        "label": "border-top-style: style (border)",
        "matches": [
          "border"
        ],
        "opts": []
      },
      {
        "content": "border-top-width: ${1:1}px",
        "doc": null,
        "grammar": "snu",
        "label": "border-top-width: size (border)",
        "matches": [
          "border"
        ],
        "opts": []
      },
      {
        "content": "border-top: ${1:1}px ${2:solid} #${3:999};$0",
        "doc": null,
        "grammar": "snu",
        "label": "border-top: size style color (border)",
        "matches": [
          "border"
        ],
        "opts": []
      },
      {
        "content": "border-width: ${1:1px};$0",
        "doc": null,
        "grammar": "snu",
        "label": "border-width: width (border)",
        "matches": [
          "border"
        ],
        "opts": []
      },
      {
        "content": "border: ${1:1px} ${2:solid} #${3:999};$0",
        "doc": null,
        "grammar": "snu",
        "label": "border:   size style color (border)",
        "matches": [
          "border"
        ],
        "opts": []
      },
      {
        "content": "clear: ${1:left/right/both/none};$0",
        "doc": null,
        "grammar": "snu",
        "label": "clear: value (clear)",
        "matches": [
          "clear"
        ],
        "opts": []
      },
      {
        "content": "color: #${1:DDD};$0",
        "doc": null,
        "grammar": "snu",
        "label": "color:  color-hex (color)",
        "matches": [
          "color"
        ],
        "opts": []
      },
      {
        "content": "color: ${1:red};$0",
        "doc": null,
        "grammar": "snu",
        "label": "color:  color-name (color)",
        "matches": [
          "color"
        ],
        "opts": []
      },
      {
        "content": "color: rgb(${1:255},${2:255},${3:255});$0",
        "doc": null,
        "grammar": "snu",
        "label": "color:  color-rgb (color)",
        "matches": [
          "color"
        ],
        "opts": []
      },
      {
        "content": "cursor: ${1:default/auto/crosshair/pointer/move/*-resize/text/wait/help};$0",
        "doc": null,
        "grammar": "snu",
        "label": "cursor: type (cursor)",
        "matches": [
          "cursor"
        ],
        "opts": []
      },
      {
        "content": "cursor: url($1);$0",
        "doc": null,
        "grammar": "snu",
        "label": "cursor: url (cursor)",
        "matches": [
          "cursor"
        ],
        "opts": []
      },
      {
        "content": "direction: ${1:ltr|rtl};$0",
        "doc": null,
        "grammar": "snu",
        "label": "direction: ltr|rtl (direction)",
        "matches": [
          "direction"
        ],
        "opts": []
      },
      {
        "content": "display: block;$0",
        "doc": null,
        "grammar": "snu",
        "label": "display: block (display)",
        "matches": [
          "display"
        ],
        "opts": []
      },
      {
        "content": "display: ${1:none/inline/block/list-item/run-in/compact/marker};$0",
        "doc": null,
        "grammar": "snu",
        "label": "display: common-types (display)",
        "matches": [
          "display"
        ],
        "opts": []
      },
      {
        "content": "display: inline;$0",
        "doc": null,
        "grammar": "snu",
        "label": "display: inline (display)",
        "matches": [
          "display"
        ],
        "opts": []
      },
      {
        "content": "display: ${1:table/inline-table/table-row-group/table-header-group/table-footer-group/table-row/table-column-group/table-column/table-cell/table-caption};$0",
        "doc": null,
        "grammar": "snu",
        "label": "display: table-types (display)",
        "matches": [
          "display"
        ],
        "opts": []
      },
      {
        "content": "float: ${1:left/right/none};$0",
        "doc": null,
        "grammar": "snu",
        "label": "float: left:right:none (float)",
        "matches": [
          "float"
        ],
        "opts": []
      },
      {
        "content": "font-family: ${1:Arial, \"MS Trebuchet\"}, ${2:sans-}serif;$0",
        "doc": null,
        "grammar": "snu",
        "label": "font-family:   family (font)",
        "matches": [
          "font"
        ],
        "opts": []
      },
      {
        "content": "font-size: ${1:100%};$0",
        "doc": null,
        "grammar": "snu",
        "label": "font-size: size (font)",
        "matches": [
          "font"
        ],
        "opts": []
      },
      {
        "content": "font-style: ${1:normal/italic/oblique};$0",
        "doc": null,
        "grammar": "snu",
        "label": "font-style:   normal:italic:oblique (font)",
        "matches": [
          "font"
        ],
        "opts": []
      },
      {
        "content": "font-variant: ${1:normal/small-caps};$0",
        "doc": null,
        "grammar": "snu",
        "label": "font-variant:   normal:small-caps (font)",
        "matches": [
          "font"
        ],
        "opts": []
      },
      {
        "content": "font-weight: ${1:normal/bold};$0",
        "doc": null,
        "grammar": "snu",
        "label": "font-weight: weight (font)",
        "matches": [
          "font"
        ],
        "opts": []
      },
      {
        "content": "font: ${1:normal/italic/oblique} ${2:normal/small-caps} ${3:normal/bold} ${4:1em/1.5em} ${5:Arial}, ${6:sans-}serif;$0",
        "doc": null,
        "grammar": "snu",
        "label": "font:   style variant weight size:line-height font -family (font)",
        "matches": [
          "font"
        ],
        "opts": []
      },
      {
        "content": "font: ${1:75%} ${2:\"Lucida Grande\", \"Trebuchet MS\", Verdana,} ${3:sans-}serif;$0",
        "doc": null,
        "grammar": "snu",
        "label": "font: size font (font)",
        "matches": [
          "font"
        ],
        "opts": []
      },
      {
        "content": "letter-spacing: $1em;$0",
        "doc": null,
        "grammar": "snu",
        "label": "letter-spacing:   length-em (letter)",
        "matches": [
          "letter"
        ],
        "opts": []
      },
      {
        "content": "letter-spacing: $1px;$0",
        "doc": null,
        "grammar": "snu",
        "label": "letter-spacing:   length-px (letter)",
        "matches": [
          "letter"
        ],
        "opts": []
      },
      {
        "content": "list-style-image: url($1);$0",
        "doc": null,
        "grammar": "snu",
        "label": "list-style-image: url (list)",
        "matches": [
          "list"
        ],
        "opts": []
      },
      {
        "content": "list-style-position: ${1:inside/outside};$0",
        "doc": null,
        "grammar": "snu",
        "label": "list-style-position: pos (list)",
        "matches": [
          "list"
        ],
        "opts": []
      },
      {
        "content": "list-style-type: ${1:cjk-ideographic/hiragana/katakana/hiragana-iroha/katakana-iroha};$0",
        "doc": null,
        "grammar": "snu",
        "label": "list-style-type: asian (list)",
        "matches": [
          "list"
        ],
        "opts": []
      },
      {
        "content": "list-style-type: ${1:none/disc/circle/square};$0",
        "doc": null,
        "grammar": "snu",
        "label": "list-style-type: marker(list)",
        "matches": [
          "list"
        ],
        "opts": []
      },
      {
        "content": "list-style-type: ${1:decimal/decimal-leading-zero/zero};$0",
        "doc": null,
        "grammar": "snu",
        "label": "list-style-type: numeric (list)",
        "matches": [
          "list"
        ],
        "opts": []
      },
      {
        "content": "list-style-type: ${1:hebrew/armenian/georgian};$0",
        "doc": null,
        "grammar": "snu",
        "label": "list-style-type: other (list)",
        "matches": [
          "list"
        ],
        "opts": []
      },
      {
        "content": "list-style-type: ${1:lower-roman/upper-roman/lower-alpha/upper-alpha/lower-greek/lower-latin/upper-latin};$0",
        "doc": null,
        "grammar": "snu",
        "label": "list-style-type: roman-alpha-greek (list)",
        "matches": [
          "list"
        ],
        "opts": []
      },
      {
        "content": "list-style: ${1:none/disc/circle/square/decimal/zero} ${2:inside/outside} url($3);$0",
        "doc": null,
        "grammar": "snu",
        "label": "list-style: type position image (list)",
        "matches": [
          "list"
        ],
        "opts": []
      },
      {
        "content": "margin-bottom: ${1:20px};$0",
        "doc": null,
        "grammar": "snu",
        "label": "margin-bottom: length (margin)",
        "matches": [
          "margin"
        ],
        "opts": []
      },
      {
        "content": "margin-left: ${1:20px};$0",
        "doc": null,
        "grammar": "snu",
        "label": "margin-left: length (margin)",
        "matches": [
          "margin"
        ],
        "opts": []
      },
      {
        "content": "margin-right: ${1:20px};$0",
        "doc": null,
        "grammar": "snu",
        "label": "margin-right: length (margin)",
        "matches": [
          "margin"
        ],
        "opts": []
      },
      {
        "content": "margin-top: ${1:20px};$0",
        "doc": null,
        "grammar": "snu",
        "label": "margin-top: length (margin)",
        "matches": [
          "margin"
        ],
        "opts": []
      },
      {
        "content": "margin: ${1:20px};$0",
        "doc": null,
        "grammar": "snu",
        "label": "margin:   all (margin)",
        "matches": [
          "margin"
        ],
        "opts": []
      },
      {
        "content": "margin: ${1:20px} ${2:0px} ${3:40px} ${4:0px};$0",
        "doc": null,
        "grammar": "snu",
        "label": "margin: T R B L (margin)",
        "matches": [
          "margin"
        ],
        "opts": []
      },
      {
        "content": "margin: ${1:20px} ${2:0px};$0",
        "doc": null,
        "grammar": "snu",
        "label": "margin: V H (margin)",
        "matches": [
          "margin"
        ],
        "opts": []
      },
      {
        "content": "marker-offset: auto;$0",
        "doc": null,
        "grammar": "snu",
        "label": "marker-offset: auto (marker)",
        "matches": [
          "marker"
        ],
        "opts": []
      },
      {
        "content": "marker-offset: ${1:10px};$0",
        "doc": null,
        "grammar": "snu",
        "label": "marker-offset: length (marker)",
        "matches": [
          "marker"
        ],
        "opts": []
      },
      {
        "content": "overflow: ${1:visible/hidden/scroll/auto};$0",
        "doc": null,
        "grammar": "snu",
        "label": "overflow: type (overflow)",
        "matches": [
          "overflow"
        ],
        "opts": []
      },
      {
        "content": "padding-bottom: ${1:20px};$0",
        "doc": null,
        "grammar": "snu",
        "label": "padding-bottom: length (margin)",
        "matches": [
          "padding"
        ],
        "opts": []
      },
      {
        "content": "padding-left: ${1:20px};$0",
        "doc": null,
        "grammar": "snu",
        "label": "padding-left: length (margin)",
        "matches": [
          "padding"
        ],
        "opts": []
      },
      {
        "content": "padding-right: ${1:20px};$0",
        "doc": null,
        "grammar": "snu",
        "label": "padding-right: length (margin)",
        "matches": [
          "padding"
        ],
        "opts": []
      },
      {
        "content": "padding-top: ${1:20px};$0",
        "doc": null,
        "grammar": "snu",
        "label": "padding-top: length (margin)",
        "matches": [
          "padding"
        ],
        "opts": []
      },
      {
        "content": "padding: ${1:20px} ${2:0px} ${3:40px} ${4:0px};$0",
        "doc": null,
        "grammar": "snu",
        "label": "padding:   T R B L (padding)",
        "matches": [
          "padding"
        ],
        "opts": []
      },
      {
        "content": "padding: ${1:20px} ${2:0px};$0",
        "doc": null,
        "grammar": "snu",
        "label": "padding:   V H (padding)",
        "matches": [
          "padding"
        ],
        "opts": []
      },
      {
        "content": "padding: ${1:20px};$0",
        "doc": null,
        "grammar": "snu",
        "label": "padding:   all (padding)",
        "matches": [
          "padding"
        ],
        "opts": []
      },
      {
        "content": "position: ${1:static/relative/absolute/fixed};$0",
        "doc": null,
        "grammar": "snu",
        "label": "position: type (position)",
        "matches": [
          "position"
        ],
        "opts": []
      },
      {
        "content": "{\n\t/* $1 */\n\t$0\n",
        "doc": null,
        "grammar": "snu",
        "label": "properties { } ( } )",
        "matches": [
          "{"
        ],
        "opts": []
      },
      {
        "content": "scrollbar-base-color:       ${1:#CCCCCC};${2:\nscrollbar-arrow-color:      ${3:#000000};\nscrollbar-track-color:      ${4:#999999};\nscrollbar-3dlight-color:    ${5:#EEEEEE};\nscrollbar-highlight-color:  ${6:#FFFFFF};\nscrollbar-face-color:       ${7:#CCCCCC};\nscrollbar-shadow-color:     ${9:#999999};\nscrollbar-darkshadow-color: ${8:#666666};}",
        "doc": null,
        "grammar": "snu",
        "label": "scrollbar",
        "matches": [
          "scrollbar"
        ],
        "opts": []
      },
      {
        "content": "$1::-moz-selection,\n$1::selection {\n\tcolor: ${2:inherit};\n\tbackground: ${3:inherit};\n}",
        "doc": null,
        "grammar": "snu",
        "label": "selection",
        "matches": [
          "selection"
        ],
        "opts": []
      },
      {
        "content": "text-align: ${1:left/right/center/justify};$0",
        "doc": null,
        "grammar": "snu",
        "label": "text-align: left:center:right (txt)",
        "matches": [
          "text"
        ],
        "opts": []
      },
      {
        "content": "text-decoration: ${1:none/underline/overline/line-through/blink};$0",
        "doc": null,
        "grammar": "snu",
        "label": "text-decoration: none:underline:overline:line-through:blink (text)",
        "matches": [
          "text"
        ],
        "opts": []
      },
      {
        "content": "text-indent: ${1:10}px;$0",
        "doc": null,
        "grammar": "snu",
        "label": "text-indent: length (text)",
        "matches": [
          "text"
        ],
        "opts": []
      },
      {
        "content": "text-transform: ${1:capitalize/uppercase/lowercase};$0",
        "doc": null,
        "grammar": "snu",
        "label": "text-transform: capitalize:upper:lower (text)",
        "matches": [
          "text"
        ],
        "opts": []
      },
      {
        "content": "vertical-align: ${1:baseline/sub/super/top/text-top/middle/bottom/text-bottom/length/%};$0",
        "doc": null,
        "grammar": "snu",
        "label": "vertical-align: type (vertical)",
        "matches": [
          "vertical"
        ],
        "opts": []
      },
      {
        "content": "visibility: ${1:visible/hidden/collapse};$0",
        "doc": null,
        "grammar": "snu",
        "label": "visibility: type (visibility)",
        "matches": [
          "visibility"
        ],
        "opts": []
      },
      {
        "content": "white-space: ${1:normal/pre/nowrap};$0",
        "doc": null,
        "grammar": "snu",
        "label": "white-space:  normal:pre:nowrap (white)",
        "matches": [
          "white"
        ],
        "opts": []
      },
      {
        "content": "word-spacing: ${1:10px};$0",
        "doc": null,
        "grammar": "snu",
        "label": "word-spacing:  length (word)",
        "matches": [
          "word"
        ],
        "opts": []
      },
      {
        "content": "z-index: $1;$0",
        "doc": null,
        "grammar": "snu",
        "label": "z-index: index (z)",
        "matches": [
          "z"
        ],
        "opts": []
      }
    ],
    "cuda": [
      {
        "content": "__global__ void ${1:kernel}(${2:void}) {\n\t${0:// TODO: Implement}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "kern \"Kernel definition\""
        ],
        "opts": []
      },
      {
        "content": "__device__ ${1:int} ${2:foo}(${3:void}) {\n\t${0:// TODO: Implement}\n\treturn 0;\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dev \"Device function definition\""
        ],
        "opts": []
      },
      {
        "content": "${1:kernel}<<<${2:args}>>>(${3});${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "call \"Kernel call\""
        ],
        "opts": []
      },
      {
        "content": "__syncthreads();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sync \"Synchonize threads\""
        ],
        "opts": []
      },
      {
        "content": "threadIdx.${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tid \"Thread Index\""
        ],
        "opts": []
      },
      {
        "content": "blockIdx.${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bid \"Block Index\""
        ],
        "opts": []
      },
      {
        "content": "blockDim.${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdim \"Block Dimension\""
        ],
        "opts": []
      },
      {
        "content": "int ${1:index} = threadIdx.${2:x} + blockIdx.$2 * blockDim.$2;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ii \"Get current index (1D)\""
        ],
        "opts": []
      },
      {
        "content": "int ${1:x} = threadIdx.x + blockIdx.x * blockDim.x;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ix \"Get current X index (1D)\""
        ],
        "opts": []
      },
      {
        "content": "int ${1:y} = threadIdx.y + blockIdx.y * blockDim.y;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "iy \"Get current Y index (1D)\""
        ],
        "opts": []
      },
      {
        "content": "int ${1:z} = threadIdx.z + blockIdx.z * blockDim.z;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "iz \"Get current Z index (1D)\""
        ],
        "opts": []
      },
      {
        "content": "int ${1:x} = threadIdx.x + blockIdx.x * blockDim.x;\nint ${2:y} = threadIdx.y + blockIdx.y * blockDim.y;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ixy \"Get current X,Y index (2D)\""
        ],
        "opts": []
      },
      {
        "content": "int ${1:x} = threadIdx.x + blockIdx.x * blockDim.x;\nint ${3:z} = threadIdx.z + blockIdx.z * blockDim.z;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ixz \"Get current X,Z index (2D)\""
        ],
        "opts": []
      },
      {
        "content": "int ${2:y} = threadIdx.y + blockIdx.y * blockDim.y;\nint ${3:z} = threadIdx.z + blockIdx.z * blockDim.z;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "iyz \"Get current Y,Z index (2D)\""
        ],
        "opts": []
      },
      {
        "content": "int ${1:x} = threadIdx.x + blockIdx.x * blockDim.x;\nint ${2:y} = threadIdx.y + blockIdx.y * blockDim.y;\nint ${3:z} = threadIdx.z + blockIdx.z * blockDim.z;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ixyz \"Get current X,Y,Z index (3D)\""
        ],
        "opts": []
      },
      {
        "content": "__shared__ ${1:int} ${2:memo}[${3:SIZE}];${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "share \"Shared memory declaration\""
        ],
        "opts": []
      }
    ],
    "cypress": [
      {
        "content": "cy.getCookies();",
        "doc": "Get all of the browser cookies.",
        "grammar": "lsp",
        "label": "cypress-cookies-get-all",
        "matches": [
          "cypress cookies get all"
        ],
        "opts": []
      },
      {
        "content": "cy.clearCookies();",
        "doc": "Clear all browser cookies for current domain and subdomain.",
        "grammar": "lsp",
        "label": "cypress-cookies-clear-all",
        "matches": [
          "cypress cookies clear all"
        ],
        "opts": []
      },
      {
        "content": "cy.get('${1:selector}');",
        "doc": "Get one or more DOM elements by selector or alias",
        "grammar": "lsp",
        "label": "cypress-get",
        "matches": [
          "cypress get"
        ],
        "opts": []
      },
      {
        "content": "cy.go('${1:direction}');",
        "doc": "Navigate back or forward to the previous or next URL in the browser’s history.",
        "grammar": "lsp",
        "label": "cypress-go",
        "matches": [
          "cypress go"
        ],
        "opts": []
      },
      {
        "content": "cy.scrollTo(${1:x}, ${2:y});",
        "doc": "Scroll to a position defined by the distance in pixels from window/element’s x and y or percentage of the window/element’s width and height.",
        "grammar": "lsp",
        "label": "cypress-scroll-to-coordinates",
        "matches": [
          "cypress scroll to coordinates"
        ],
        "opts": []
      },
      {
        "content": "cy.scrollTo('${1:position}');",
        "doc": "Scroll to a specified position. Valid positions are topLeft, top, topRight, left, center, right, bottomLeft, bottom, and bottomRight.",
        "grammar": "lsp",
        "label": "cypress-scroll-to-position",
        "matches": [
          "cypress scroll to position"
        ],
        "opts": []
      },
      {
        "content": "cy.request({\n\tmethod: '${1:METHOD}',\n\turl: '${2:url}',\n\tbody: ${3:body}\n});",
        "doc": "Make an HTTP request.",
        "grammar": "lsp",
        "label": "cypress-request",
        "matches": [
          "cypress request"
        ],
        "opts": []
      },
      {
        "content": "cy.route('${1:METHOD}', '${2:url}', ${3:response});",
        "doc": "Use cy.route() to manage the behavior of network requests.",
        "grammar": "lsp",
        "label": "cypress-route",
        "matches": [
          "cypress route"
        ],
        "opts": []
      },
      {
        "content": "cy.server();",
        "doc": "Start a server to begin routing responses to cy.route() and to change the behavior of network requests.",
        "grammar": "lsp",
        "label": "cypress-server",
        "matches": [
          "cypress server"
        ],
        "opts": []
      },
      {
        "content": "cy.viewport(${1:width}, ${2:height});",
        "doc": "Control the size of the screen for your application.",
        "grammar": "lsp",
        "label": "cypress-viewport",
        "matches": [
          "cypress viewport"
        ],
        "opts": []
      },
      {
        "content": "cy.viewport('${1:preset}');",
        "doc": "Control the size of the screen for your application via presets. Preset supports the following options: ipad-2, ipad-mini, iphone-3, iphone-4, iphone-5, iphone-6, iphone-6+, iphone-x, iphone-xr, macbook-11, macbook-13, macbook-15, samsung-note9, samsung-s10",
        "grammar": "lsp",
        "label": "cypress-viewport-preset",
        "matches": [
          "cypress viewport preset"
        ],
        "opts": []
      },
      {
        "content": "cy.visit('${1:url}');",
        "doc": "Visit a remote URL",
        "grammar": "lsp",
        "label": "cypress-visit",
        "matches": [
          "cypress visit"
        ],
        "opts": []
      },
      {
        "content": "cy.wait(${1:time});",
        "doc": "Wait for a number of milliseconds or wait for an aliased resource to resolve before moving on to the next command.",
        "grammar": "lsp",
        "label": "cypress-wait",
        "matches": [
          "cypress wait"
        ],
        "opts": []
      }
    ],
    "d": [
      {
        "content": "import ",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "imp"
        ],
        "opts": []
      },
      {
        "content": "public import",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pimp"
        ],
        "opts": []
      },
      {
        "content": "std.stdio",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "io"
        ],
        "opts": []
      },
      {
        "content": "std.traits",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "traits"
        ],
        "opts": []
      },
      {
        "content": "std.conv",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "conv"
        ],
        "opts": []
      },
      {
        "content": "std.array",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "arr"
        ],
        "opts": []
      },
      {
        "content": "std.algorithm",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "algo"
        ],
        "opts": []
      },
      {
        "content": "import std.stdio, std.string, std.array;\nimport std.traits, std.conv, std.algorithm;\nimport std.math, std.regex;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "theusual"
        ],
        "opts": []
      },
      {
        "content": "for(int ${1:i} = 0; $1 < ${2:count}; $1++) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "foreach(${1:elem}; ${2:range}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fe"
        ],
        "opts": []
      },
      {
        "content": "foreach(${1:i}, ${2:elem}; ${3:range}) {\n\t${0}\t\n} ",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fei"
        ],
        "opts": []
      },
      {
        "content": "foreach_reverse(${1:elem}; ${2:range}) {\n\t${0}\t\n} ",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fer"
        ],
        "opts": []
      },
      {
        "content": "foreach_reverse(${1:i}, ${2:elem}; ${3:range}) {\n\t${0}  \n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "feri"
        ],
        "opts": []
      },
      {
        "content": "scope(exit) ${1:f.close();}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sce"
        ],
        "opts": []
      },
      {
        "content": "scope(success) ${1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "scs"
        ],
        "opts": []
      },
      {
        "content": "scope(failure) ${1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "scf"
        ],
        "opts": []
      },
      {
        "content": "else {\n\t${1}\t\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "el"
        ],
        "opts": []
      },
      {
        "content": "else if(${1}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eif"
        ],
        "opts": []
      },
      {
        "content": "if(${1}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "if(${1}) {\n\t${2}\t\n} else {\n\t${3}\t\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "if(${1}) {\n\t${2}\t\n} else if(${3}) {\n\t${4}\n} else {\n\t${5}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifee"
        ],
        "opts": []
      },
      {
        "content": "switch(${1}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sw"
        ],
        "opts": []
      },
      {
        "content": "case ${1:0}:\n\t${2}\n\tbreak;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cs"
        ],
        "opts": []
      },
      {
        "content": "default:\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "def"
        ],
        "opts": []
      },
      {
        "content": "final switch(${1}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fsw"
        ],
        "opts": []
      },
      {
        "content": "try {\n\t${1:${VISUAL}}\n} catch(${2:Exception} ${3:e}) {\n\t${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "try"
        ],
        "opts": []
      },
      {
        "content": "try {\n\t${0:${VISUAL}}\n} catch(${1:Exception} ${2:e}) {\n\t${3}\n} finally {\n\t${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tcf"
        ],
        "opts": []
      },
      {
        "content": "while(${1:cond}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh"
        ],
        "opts": []
      },
      {
        "content": "do {\n\t${1}\n} while(${2});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dowh"
        ],
        "opts": []
      },
      {
        "content": "static if(${1:cond}) {\n\t${2}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sif"
        ],
        "opts": []
      },
      {
        "content": "static if(${1}) {\n\t${2}\n} else {\n\t${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sife"
        ],
        "opts": []
      },
      {
        "content": "static if(${1}) {\n\t${2}\n} else static if(${3}) {\n\t${4}\n} else {\n\t${5}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sifee"
        ],
        "opts": []
      },
      {
        "content": "else static if(${1}) {\n\t${2}\n} ",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "seif"
        ],
        "opts": []
      },
      {
        "content": "(${1: a > b}) ? ${2:a} : ${3:b}; ",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "?"
        ],
        "opts": []
      },
      {
        "content": "with(${1:exp}) {\n\t${2}\n} ${0}\t",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "with"
        ],
        "opts": []
      },
      {
        "content": "${1:auto} ${2:func}(${3:params}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fun"
        ],
        "opts": []
      },
      {
        "content": "in {\n\t${1}\n} out {\n\t${2}\n} body {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "contr"
        ],
        "opts": []
      },
      {
        "content": "(${1:x}) => ${2:x}${0:;}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "l"
        ],
        "opts": []
      },
      {
        "content": "function (${1:int x}) => ${2}${3:;}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "funl"
        ],
        "opts": []
      },
      {
        "content": "delegate (${1:int x}) => ${2}${3:;} ",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "del"
        ],
        "opts": []
      },
      {
        "content": "template ${1:`vim_snippets#Filename(\"$2\", \"untitled\")`}(${2:T}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "temp"
        ],
        "opts": []
      },
      {
        "content": "template ${1:`vim_snippets#Filename(\"$2\", \"untitled\")`}(${2:T}) if(${3:isSomeString!}$2) {\n\t${0}\t\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tempif"
        ],
        "opts": []
      },
      {
        "content": "int opApply(Dg)(Dg dg) if(ParameterTypeTuble!Dg.length == 2) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "opApply"
        ],
        "opts": []
      },
      {
        "content": "pure @safe nothrow",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "psn"
        ],
        "opts": []
      },
      {
        "content": "@safe",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "safe"
        ],
        "opts": []
      },
      {
        "content": "@trusted",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "trusted"
        ],
        "opts": []
      },
      {
        "content": "@system",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "system"
        ],
        "opts": []
      },
      {
        "content": "class${1:(T)} ${2:`vim_snippets#Filename(\"$3\", \"untitled\")`} {\n\t${0}\t\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cl"
        ],
        "opts": []
      },
      {
        "content": "struct${1:(T)} ${2:`vim_snippets#Filename(\"$3\", \"untitled\")`} {\n\t${0}\t\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "str"
        ],
        "opts": []
      },
      {
        "content": "union${1:(T)} ${2:`vim_snippets#Filename(\"$3\", \"untitled\")`} {\n\t${0}\t\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "uni"
        ],
        "opts": []
      },
      {
        "content": "interface I${1:`vim_snippets#Filename(\"$2\", \"untitled\")`} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "inter"
        ],
        "opts": []
      },
      {
        "content": "enum ${1} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "enum"
        ],
        "opts": []
      },
      {
        "content": "public",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pu"
        ],
        "opts": []
      },
      {
        "content": "private",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pr"
        ],
        "opts": []
      },
      {
        "content": "protected",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "po"
        ],
        "opts": []
      },
      {
        "content": "this(${1}) {\n\t${0}\n} ",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ctor"
        ],
        "opts": []
      },
      {
        "content": "~this(${1}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dtor"
        ],
        "opts": []
      },
      {
        "content": "alias ${1:b} = ${2:a};\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "al"
        ],
        "opts": []
      },
      {
        "content": "alias ${1:value} this;\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "alth"
        ],
        "opts": []
      },
      {
        "content": "void main() {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "main"
        ],
        "opts": []
      },
      {
        "content": "void main(string[] args) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "maina"
        ],
        "opts": []
      },
      {
        "content": "module ${1:main};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mod"
        ],
        "opts": []
      },
      {
        "content": "${1:auto} ${2:var} = ${0:1};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "var"
        ],
        "opts": []
      },
      {
        "content": "${1:auto} ${2:var} = new ${3:Object}(${4});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "new"
        ],
        "opts": []
      },
      {
        "content": "auto ${1:f} = File(${2:\"useful_info.xml\"}, ${3:\"rw\"});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "file"
        ],
        "opts": []
      },
      {
        "content": "map!(${1:f})(${2:xs});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "map"
        ],
        "opts": []
      },
      {
        "content": "filter!(${1:p})(${2:xs});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "filter"
        ],
        "opts": []
      },
      {
        "content": "reduce!(${1:f})(${2:xs});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "reduce"
        ],
        "opts": []
      },
      {
        "content": "find!(${1:p})($2:xs);\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "find"
        ],
        "opts": []
      },
      {
        "content": "${1:int}[${2:string}] ${3:dict} = ${0};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "aa"
        ],
        "opts": []
      },
      {
        "content": "#!/usr/bin/env rdmd",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#!"
        ],
        "opts": []
      },
      {
        "content": "#!/usr/bin/env rdmd",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bang"
        ],
        "opts": []
      },
      {
        "content": "#!/usr/bin/env rdmd",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rdmd"
        ],
        "opts": []
      },
      {
        "content": "isSomeString!${1:S}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isstr"
        ],
        "opts": []
      },
      {
        "content": "isNumeric!${1:N}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isnum"
        ],
        "opts": []
      },
      {
        "content": "to!string(${1:x});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tos"
        ],
        "opts": []
      },
      {
        "content": "to!int(${1:str});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "toi"
        ],
        "opts": []
      },
      {
        "content": "to!double(${1:str});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tod"
        ],
        "opts": []
      },
      {
        "content": "unittest {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "un"
        ],
        "opts": []
      },
      {
        "content": "version(${1:Posix}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ver"
        ],
        "opts": []
      },
      {
        "content": "debug {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "de"
        ],
        "opts": []
      },
      {
        "content": "shared static this(${1}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sst"
        ],
        "opts": []
      },
      {
        "content": "// Typedef is deprecated. Use alias instead.\ntypedef",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "td"
        ],
        "opts": []
      },
      {
        "content": "inout",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ino"
        ],
        "opts": []
      },
      {
        "content": "immutable",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "imm"
        ],
        "opts": []
      },
      {
        "content": "final",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fin"
        ],
        "opts": []
      },
      {
        "content": "const",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "con"
        ],
        "opts": []
      },
      {
        "content": "private static immutable ${1:int} ${2:Constant} = ${3:1};\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "psi"
        ],
        "opts": []
      },
      {
        "content": "pragma(${1})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prag"
        ],
        "opts": []
      },
      {
        "content": "pragma(msg, ${1:Warning});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pms"
        ],
        "opts": []
      },
      {
        "content": "asm {\n\t${1}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asm"
        ],
        "opts": []
      },
      {
        "content": "mixin(${1:`writeln(\"Hello, World!\");`});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mixin"
        ],
        "opts": []
      },
      {
        "content": "override",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "over"
        ],
        "opts": []
      },
      {
        "content": "return ${1};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ret"
        ],
        "opts": []
      },
      {
        "content": "__FILE__",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "FILE"
        ],
        "opts": []
      },
      {
        "content": "__MODULE__",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "MOD"
        ],
        "opts": []
      },
      {
        "content": "__LINE__",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "LINE"
        ],
        "opts": []
      },
      {
        "content": "__FUNCTION__",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "FUN"
        ],
        "opts": []
      },
      {
        "content": "__PRETTY_FUNCTION__",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "PF"
        ],
        "opts": []
      },
      {
        "content": "cast(${1:T})(${2:val});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cast"
        ],
        "opts": []
      },
      {
        "content": "/*\n * ${1}\n*/",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "/*"
        ],
        "opts": []
      },
      {
        "content": "// I don't know how this works. Don't touch it.",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "idk"
        ],
        "opts": []
      },
      {
        "content": "// Don't FUCKING touch this.",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "idfk"
        ],
        "opts": []
      },
      {
        "content": "foreach (${1:#:var}; ${2:#:list}) {\n    ${3:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "foreach() {}",
        "matches": [
          "foreach"
        ],
        "opts": []
      },
      {
        "content": "class ${1:#:name} {\n    ${2:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "class {}",
        "matches": [
          "class"
        ],
        "opts": []
      },
      {
        "content": "struct ${1:#:name} {\n    ${2:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "struct {}",
        "matches": [
          "struct"
        ],
        "opts": []
      },
      {
        "content": "enum ${1:#:name} {\n    ${2:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "enum {}",
        "matches": [
          "enum"
        ],
        "opts": []
      },
      {
        "content": "import ${1:std.stdio};",
        "doc": null,
        "grammar": "snu",
        "label": "import (imp)",
        "matches": [
          "imp"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "public import ${1:/*module*/};",
        "doc": null,
        "grammar": "snu",
        "label": "public import (pimp)",
        "matches": [
          "pimp"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "override ${1:/*function*/}",
        "doc": null,
        "grammar": "snu",
        "label": "override (over)",
        "matches": [
          "over"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "alias ${1:/*orig*/} ${2:/*alias*/};",
        "doc": null,
        "grammar": "snu",
        "label": "alias (al)",
        "matches": [
          "al"
        ],
        "opts": []
      },
      {
        "content": "mixin ${1:/*mixed_in*/} ${2:/*name*/};",
        "doc": null,
        "grammar": "snu",
        "label": "mixin (mixin)",
        "matches": [
          "mixin"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "new $1($2);",
        "doc": null,
        "grammar": "snu",
        "label": "new (new)",
        "matches": [
          "new"
        ],
        "opts": []
      },
      {
        "content": "@safe const pure nothrow",
        "doc": null,
        "grammar": "snu",
        "label": "@safe const pure nothrow (scpn)",
        "matches": [
          "scpn"
        ],
        "opts": []
      },
      {
        "content": "@safe pure nothrow",
        "doc": null,
        "grammar": "snu",
        "label": "@safe pure nothrow (spn)",
        "matches": [
          "spn"
        ],
        "opts": []
      },
      {
        "content": "continue;",
        "doc": null,
        "grammar": "snu",
        "label": "continue (cont)",
        "matches": [
          "cont"
        ],
        "opts": []
      },
      {
        "content": "@disable ${1:/*method*/};",
        "doc": null,
        "grammar": "snu",
        "label": "@disable (dis)",
        "matches": [
          "dis"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "public:\n\t${1:/*members*/}",
        "doc": null,
        "grammar": "snu",
        "label": "public (pub)",
        "matches": [
          "pub"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "private:\n\t${1:/*members*/}",
        "doc": null,
        "grammar": "snu",
        "label": "private (priv)",
        "matches": [
          "priv"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "protected:\n\t${1:/*members*/}",
        "doc": null,
        "grammar": "snu",
        "label": "protected (prot)",
        "matches": [
          "prot"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "package:\n\t${1:/*members*/}",
        "doc": null,
        "grammar": "snu",
        "label": "package (pack)",
        "matches": [
          "pack"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "return ${1:/*value to return*/};",
        "doc": null,
        "grammar": "snu",
        "label": "return (ret)",
        "matches": [
          "ret"
        ],
        "opts": []
      },
      {
        "content": "auto ${1:/*variable*/} = ${2:/*value*/};",
        "doc": null,
        "grammar": "snu",
        "label": "auto (auto)",
        "matches": [
          "auto"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "const ${1:/*variable*/} = ${2:/*value*/};",
        "doc": null,
        "grammar": "snu",
        "label": "const (con)",
        "matches": [
          "con"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "size_t ${1:/*variable*/} = ${2:/*value*/};",
        "doc": null,
        "grammar": "snu",
        "label": "size_t (siz)",
        "matches": [
          "siz"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "super(${1:/*args*/});",
        "doc": null,
        "grammar": "snu",
        "label": "super (sup)",
        "matches": [
          "sup"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "tuple(${1:/*args*/})",
        "doc": null,
        "grammar": "snu",
        "label": "tuple (tup)",
        "matches": [
          "tup"
        ],
        "opts": []
      },
      {
        "content": "writeln(${1:/*args*/});",
        "doc": null,
        "grammar": "snu",
        "label": "writeln (wr)",
        "matches": [
          "wr"
        ],
        "opts": []
      },
      {
        "content": "to!(${1:/*type*/})(${2:/*arg*/})",
        "doc": null,
        "grammar": "snu",
        "label": "to (to)",
        "matches": [
          "to"
        ],
        "opts": []
      },
      {
        "content": "enforce(${1:/*condition*/},\n\tnew $2Exception(${3:/*args*/}));",
        "doc": null,
        "grammar": "snu",
        "label": "enforce (enf)",
        "matches": [
          "enf"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "if(${1:/*condition*/})\n{\n\t${VISUAL}$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "if .. (if)",
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "if(${1:/*condition*/})\n{\n\t$2\n}\nelse\n{\n\t${3:/*else*/}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "if .. else (ife)",
        "matches": [
          "ife"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "else\n{\n\t${VISUAL}$1\n}",
        "doc": null,
        "grammar": "snu",
        "label": "else (el)",
        "matches": [
          "el"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "else if(${1:/*condition*/})\n{\n\t${VISUAL}$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "else if (elif)",
        "matches": [
          "elif"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "switch(${1:/*var*/})\n{\n\tcase ${2:/*value*/}:\n\t\t$3\n\t\tbreak;\n\tcase ${4:/*value*/}:\n\t\t$5\n\t\tbreak;\n\t${7:/*more cases*/}\n\tdefault:\n\t\t${6:assert(false);}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "switch (sw)",
        "matches": [
          "sw"
        ],
        "opts": []
      },
      {
        "content": "final switch(${1:/*var*/})\n{\n\tcase ${2:/*value*/}:\n\t\t$3\n\t\tbreak;\n\tcase ${4:/*value*/}:\n\t\t$5\n\t\tbreak;\n\t${7:/*more cases*/}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "final switch (fsw)",
        "matches": [
          "fsw"
        ],
        "opts": []
      },
      {
        "content": "case ${1:/*value*/}:\n\t$2\n\tbreak;",
        "doc": null,
        "grammar": "snu",
        "label": "case (case)",
        "matches": [
          "case"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:/*condition*/} ? ${2:/*then*/} : ${3:/*else*/}$4",
        "doc": null,
        "grammar": "snu",
        "label": "ternary operator (?:)",
        "matches": [
          "?:"
        ],
        "opts": []
      },
      {
        "content": "do\n{\n\t${VISUAL}$2\n} while(${1:/*condition*/});",
        "doc": null,
        "grammar": "snu",
        "label": "do while (do)",
        "matches": [
          "do"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "while(${1:/*condition*/})\n{\n\t${VISUAL}$2\n}",
        "doc": null,
        "grammar": "snu",
        "label": "while (wh)",
        "matches": [
          "wh"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "for (${4:size_t} ${2:i} = 0; $2 < ${1:count}; ${3:++$2})\n{\n\t${VISUAL}$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "for (for)",
        "matches": [
          "for"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "for(;;)\n{\n\t${VISUAL}$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "forever (forever)",
        "matches": [
          "forever"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "foreach(${1:/*elem*/}; ${2:/*range*/})\n{\n\t${VISUAL}$3\n}",
        "doc": null,
        "grammar": "snu",
        "label": "foreach (fore)",
        "matches": [
          "fore"
        ],
        "opts": []
      },
      {
        "content": "foreach(${1:/*elem*/}; ${2:/*range*/}) if(${3:/*condition*/})\n{\n\t${VISUAL}$4\n}",
        "doc": null,
        "grammar": "snu",
        "label": "foreach if (forif)",
        "matches": [
          "forif"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "in\n{\n\tassert(${1:/*condition*/}, \"${2:error message}\");\n\t$3\n}\nbody",
        "doc": null,
        "grammar": "snu",
        "label": "in contract (in)",
        "matches": [
          "in"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "out${1:(result)}\n{\n\tassert(${2:/*condition*/}, \"${3:error message}\");\n\t$4\n}\nbody",
        "doc": null,
        "grammar": "snu",
        "label": "out contract (out)",
        "matches": [
          "out"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "invariant()\n{\n\tassert(${1:/*condition*/}, \"${2:error message}\");\n\t$3\n}",
        "doc": null,
        "grammar": "snu",
        "label": "invariant (inv)",
        "matches": [
          "inv"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:void} ${2:/*function name*/}(${3:/*args*/}) ${4:@safe pure nothrow}\n{\n\t${VISUAL}$5\n}",
        "doc": null,
        "grammar": "snu",
        "label": "function definition (fun)",
        "matches": [
          "fun"
        ],
        "opts": []
      },
      {
        "content": "void ${1:/*function name*/}(${2:/*args*/}) ${3:@safe pure nothrow}\n{\n\t${VISUAL}$4\n}",
        "doc": null,
        "grammar": "snu",
        "label": "void function definition (void)",
        "matches": [
          "void"
        ],
        "opts": []
      },
      {
        "content": "this(${1:/*args*/})\n{\n\t${VISUAL}$2\n}",
        "doc": null,
        "grammar": "snu",
        "label": "ctor (this)",
        "matches": [
          "this"
        ],
        "opts": [
          "w"
        ]
      },
      {
        "content": "@property ${1:/*type*/} ${2:/*member_name*/}() const pure nothrow {return ${3:$2_};}",
        "doc": null,
        "grammar": "snu",
        "label": "getter property (get)",
        "matches": [
          "get"
        ],
        "opts": []
      },
      {
        "content": "@property void ${1:/*member_name*/}(${2:/*type*/} rhs) pure nothrow {${3:$1_} = rhs;}",
        "doc": null,
        "grammar": "snu",
        "label": "setter property (set)",
        "matches": [
          "set"
        ],
        "opts": []
      },
      {
        "content": "void main(string[] args)\n{\n\t${VISUAL}${0: /*code*/}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Main",
        "matches": [
          "main"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "mixin Signal!(${1:/*args*/}) ${2:/*name*/};",
        "doc": null,
        "grammar": "snu",
        "label": "signal (signal)",
        "matches": [
          "signal"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "scope(${1:exit})\n{\n\t${VISUAL}$2\n}",
        "doc": null,
        "grammar": "snu",
        "label": "scope (scope)",
        "matches": [
          "scope"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "with($1)\n{\n\t${VISUAL}$2\n}",
        "doc": null,
        "grammar": "snu",
        "label": "with (with)",
        "matches": [
          "with"
        ],
        "opts": []
      },
      {
        "content": "try\n{\n\t${VISUAL}${1:/*code to try*/}\n}\ncatch($2Exception e)\n{\n\t${3:/*handle exception*/}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "try/catch (try)",
        "matches": [
          "try"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "try\n{\n\t${VISUAL}${1:/*code to try*/}\n}\ncatch($2Exception e)\n{\n\t${3:/*handle exception*/}\n}\nfinally\n{\n\t${4:/*cleanup*/}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "try/catch/finally (tryf)",
        "matches": [
          "tryf"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "catch($1Exception e)\n{\n\t${2:/*handle exception*/}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "catch (catch)",
        "matches": [
          "catch"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "throw new $1Exception(\"$2\");",
        "doc": null,
        "grammar": "snu",
        "label": "throw (thr)",
        "matches": [
          "thr"
        ],
        "opts": []
      },
      {
        "content": "struct ${1:`!p snip.rv = (snip.basename or \"name\")`}\n{\n\t$2\n}",
        "doc": null,
        "grammar": "snu",
        "label": "struct (struct)",
        "matches": [
          "struct"
        ],
        "opts": []
      },
      {
        "content": "union ${1:`!p snip.rv = (snip.basename or \"name\")`}\n{\n\t$2\n}",
        "doc": null,
        "grammar": "snu",
        "label": "union (union)",
        "matches": [
          "union"
        ],
        "opts": []
      },
      {
        "content": "class ${1:`!p snip.rv = (snip.basename or \"name\")`}\n{\n\t$2\n}",
        "doc": null,
        "grammar": "snu",
        "label": "class (class)",
        "matches": [
          "class"
        ],
        "opts": []
      },
      {
        "content": "interface ${1:`!p snip.rv = (snip.basename or \"name\")`}\n{\n\t$2\n}",
        "doc": null,
        "grammar": "snu",
        "label": "interface (inter)",
        "matches": [
          "inter"
        ],
        "opts": []
      },
      {
        "content": "enum ${1:`!p snip.rv = (snip.basename or \"name\")`}\n{\n\t$2\n}",
        "doc": null,
        "grammar": "snu",
        "label": "enum (enum)",
        "matches": [
          "enum"
        ],
        "opts": []
      },
      {
        "content": "/// ${3:/*documentation*/}\nclass $1Exception : $2Exception\n{\n\tpublic this(string msg, string file = __FILE__, int line = __LINE__)\n\t{\n\t\tsuper(msg, file, line);\n\t}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "exception declaration (exc)",
        "matches": [
          "exc"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "version(${1:/*version name*/})\n{\n\t${VISUAL}$2\n}",
        "doc": null,
        "grammar": "snu",
        "label": "version (version)",
        "matches": [
          "version"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "debug\n{\n\t${VISUAL}$1\n}",
        "doc": null,
        "grammar": "snu",
        "label": "debug",
        "matches": [
          "debug"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "template ${2:/*name*/}(${1:/*args*/})\n{\n\t$3\n}",
        "doc": null,
        "grammar": "snu",
        "label": "template (temp)",
        "matches": [
          "temp"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "assert(${1:false}, \"${2:TODO}\");\n",
        "doc": null,
        "grammar": "snu",
        "label": "assert (ass)",
        "matches": [
          "ass"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "unittest\n{\n\t$1\n}",
        "doc": null,
        "grammar": "snu",
        "label": "unittest (unittest)",
        "matches": [
          "unittest"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:/*return type*/} opDispatch(string s)()\n{\n\t$2;\n}",
        "doc": null,
        "grammar": "snu",
        "label": "opDispatch (opDis)",
        "matches": [
          "opDis"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "void opAssign($1 rhs) ${2:@safe pure nothrow}\n{\n\t$2\n}",
        "doc": null,
        "grammar": "snu",
        "label": "opAssign (op=)",
        "matches": [
          "op="
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "int opCmp($1 rhs) @safe const pure nothrow\n{\n\t$2\n}",
        "doc": null,
        "grammar": "snu",
        "label": "opCmp (opCmp)",
        "matches": [
          "opCmp"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "int opApply(int delegate(ref ${1:/*iterated type/s*/}) dg)\n{\n\tint result = 0;\n\t${2:/*loop*/}\n\t{\n\t\tresult = dg(${3:/*arg/s*/});\n\t\tif(result){break;}\n\t}\n\treturn result;\n}",
        "doc": null,
        "grammar": "snu",
        "label": "opApply (opApply)",
        "matches": [
          "opApply"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "string toString() @safe const pure nothrow\n{\n\t$1\n}",
        "doc": null,
        "grammar": "snu",
        "label": "toString (toString)",
        "matches": [
          "toString"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "// TODO: $1",
        "doc": null,
        "grammar": "snu",
        "label": "TODO (todo)",
        "matches": [
          "todo"
        ],
        "opts": []
      },
      {
        "content": "/// ${1:description}\n///\n/// ${2:details}",
        "doc": null,
        "grammar": "snu",
        "label": "generic ddoc block (doc)",
        "matches": [
          "doc"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "/// ${1:description}\n///\n/// ${2:Params:  ${3:param} = ${4:param description}\n///\t\t\t $5}\n///\n/// ${6:Returns: ${7:return value}}\n///\n/// ${8:Throws:  $9Exception $10}",
        "doc": null,
        "grammar": "snu",
        "label": "function ddoc block (fdoc)",
        "matches": [
          "fdoc"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "Params:  ${1:param} = ${2:param description}\n///\t\t\t$3",
        "doc": null,
        "grammar": "snu",
        "label": "Params (Par)",
        "matches": [
          "Par"
        ],
        "opts": []
      },
      {
        "content": "Returns:  ${1:return value/s}",
        "doc": null,
        "grammar": "snu",
        "label": "Returns (Ret)",
        "matches": [
          "Ret"
        ],
        "opts": []
      },
      {
        "content": "Throws:  $1Exception $2",
        "doc": null,
        "grammar": "snu",
        "label": "Throws (Thr)",
        "matches": [
          "Thr"
        ],
        "opts": []
      },
      {
        "content": "Examples:\n/// --------------------\n/// ${1:example code}\n/// --------------------",
        "doc": null,
        "grammar": "snu",
        "label": "Examples (Example)",
        "matches": [
          "Example"
        ],
        "opts": []
      },
      {
        "content": "// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation; either version 2 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n//\n// Copyright (C) ${1:Author}, `!v strftime(\"%Y\")`\n\n$2",
        "doc": null,
        "grammar": "snu",
        "label": "GPL (gpl)",
        "matches": [
          "gpl"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "//          Copyright ${1:Author} `!v strftime(\"%Y\")`.\n// Distributed under the Boost Software License, Version 1.0.\n//    (See accompanying file LICENSE_1_0.txt or copy at\n//          http://www.boost.org/LICENSE_1_0.txt)\n\n$2",
        "doc": null,
        "grammar": "snu",
        "label": "Boost (boost)",
        "matches": [
          "boost"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "//          Copyright ${1:Author} `!v strftime(\"%Y\")`.\n// Distributed under the Boost Software License, Version 1.0.\n//    (See accompanying file LICENSE_1_0.txt or copy at\n//          http://www.boost.org/LICENSE_1_0.txt)\n\nmodule $2.`!v vim_snippets#Filename('$1', 'name')`;\n\n\n$3",
        "doc": null,
        "grammar": "snu",
        "label": "New module (module)",
        "matches": [
          "module"
        ],
        "opts": [
          "b"
        ]
      }
    ],
    "dart": [
      {
        "content": "library ${1};\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lib"
        ],
        "opts": []
      },
      {
        "content": "import 'package:${1}/${2}.dart';\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "im"
        ],
        "opts": []
      },
      {
        "content": "new RegExp(r'${1}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rgx"
        ],
        "opts": []
      },
      {
        "content": "var ${1} = ${2};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "var"
        ],
        "opts": []
      },
      {
        "content": "main() {\n  ${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "main"
        ],
        "opts": []
      },
      {
        "content": "static ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "st"
        ],
        "opts": []
      },
      {
        "content": "final ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fi"
        ],
        "opts": []
      },
      {
        "content": "return ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "re"
        ],
        "opts": []
      },
      {
        "content": "break;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "br"
        ],
        "opts": []
      },
      {
        "content": "throw ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "th"
        ],
        "opts": []
      },
      {
        "content": "class ${1:`vim_snippets#Filename(\"\", \"untitled\")`} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cl"
        ],
        "opts": []
      },
      {
        "content": "interface ${1:`vim_snippets#Filename(\"\", \"untitled\")`} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "in"
        ],
        "opts": []
      },
      {
        "content": "implements ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "imp"
        ],
        "opts": []
      },
      {
        "content": "extends ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ext"
        ],
        "opts": []
      },
      {
        "content": "if (${1:true}) {\n  ${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "if (${1:true}) {\n  ${2}\n} else {\n  ${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "else",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "el"
        ],
        "opts": []
      },
      {
        "content": "switch (${1}) {\n  ${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sw"
        ],
        "opts": []
      },
      {
        "content": "case ${1}:\n  ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cs"
        ],
        "opts": []
      },
      {
        "content": "default:\n  ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "de"
        ],
        "opts": []
      },
      {
        "content": "for (var ${2:i} = 0, len = ${1:things}.length; $2 < len; ${3:++}$2) {\n  ${0:$1[$2]}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "for (final ${2:item} in ${1:itemList}) {\n  ${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fore"
        ],
        "opts": []
      },
      {
        "content": "while (${1:/* condition */}) {\n  ${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh"
        ],
        "opts": []
      },
      {
        "content": "do {\n  ${0}\n} while (${0:/* condition */});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dowh"
        ],
        "opts": []
      },
      {
        "content": "assert(${0:/* condition */});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as"
        ],
        "opts": []
      },
      {
        "content": "try {\n  ${0:${VISUAL}}\n} catch (${1:Exception e}) {\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "try"
        ],
        "opts": []
      },
      {
        "content": "try {\n  ${0:${VISUAL}}\n} catch (${1:Exception e}) {\n} finally {\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tryf"
        ],
        "opts": []
      }
    ],
    "dart-flutter": [
      {
        "content": "class $1 extends StatelessWidget {\n\t@override\n\tWidget build(BuildContext context) {\n\t\treturn Container(\n\t\t\t$2\n\t\t);\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "stless"
        ],
        "opts": []
      },
      {
        "content": "class $1 extends StatefulWidget {\n\t@override\n\t_$1State createState() => _$1State();\n}\nclass _$1State extends State<$1> {\n\t@override\n\tWidget build(BuildContext context) {\n\t\treturn Container(\n\t\t\t$2\n\t\t);\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "stful"
        ],
        "opts": []
      },
      {
        "content": "class $1 extends StatefulWidget {\n\t@override\n\t_$1State createState() => _$1State();\n}\nclass _$1State extends State<$1>\n\t\twith SingleTickerProviderStateMixin {\n\tAnimationController _controller;\n\t@override\n\tvoid initState() {\n\t\tsuper.initState();\n\t\t_controller = AnimationController(vsync: this);\n\t}\n\t@override\n\tvoid dispose() {\n\t\tsuper.dispose();\n\t\t_controller.dispose();\n\t}\n\t@override\n\tWidget build(BuildContext context) {\n\t\treturn Container(\n\t\t\t$2\n\t\t);\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "stanim"
        ],
        "opts": []
      }
    ],
    "diff": [
      {
        "content": "Description: ${1}\nOrigin: ${2:vendor|upstream|other}, ${3:url of the original patch}\nBug: ${4:url in upstream bugtracker}\nForwarded: ${5:no|not-needed|url}\nAuthor: ${6:`g:snips_author`}\nReviewed-by: ${7:name and email}\nLast-Update: ${8:`strftime(\"%Y-%m-%d\")`}\nApplied-Upstream: ${0:upstream version|url|commit}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "header DEP-3 style header"
        ],
        "opts": []
      }
    ],
    "django": [
      {
        "content": "${1:FIELDNAME} = models.AutoField(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "auto"
        ],
        "opts": []
      },
      {
        "content": "${1:FIELDNAME} = models.BigIntegerField(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bigint"
        ],
        "opts": []
      },
      {
        "content": "${1:FIELDNAME} = models.BinaryField(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "binary"
        ],
        "opts": []
      },
      {
        "content": "${1:FIELDNAME} = models.BooleanField(${0:default=True})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bool"
        ],
        "opts": []
      },
      {
        "content": "${1:FIELDNAME} = models.CharField(max_length=${2}${0:, blank=True})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "char"
        ],
        "opts": []
      },
      {
        "content": "${1:FIELDNAME} = models.CommaSeparatedIntegerField(max_length=${2}${0:, blank=True})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "comma"
        ],
        "opts": []
      },
      {
        "content": "${1:FIELDNAME} = models.DateField(${2:auto_now_add=True, auto_now=True}${0:, blank=True, null=True})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "date"
        ],
        "opts": []
      },
      {
        "content": "${1:FIELDNAME} = models.DateTimeField(${2:auto_now_add=True, auto_now=True}${0:, blank=True, null=True})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "datetime"
        ],
        "opts": []
      },
      {
        "content": "${1:FIELDNAME} = models.DecimalField(max_digits=${2}, decimal_places=${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "decimal"
        ],
        "opts": []
      },
      {
        "content": "${1:FIELDNAME} = models.EmailField(max_length=${2:75}${0:, blank=True})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "email"
        ],
        "opts": []
      },
      {
        "content": "${1:FIELDNAME} = models.FileField(upload_to=${2:path/for/upload}${0:, max_length=100})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "file"
        ],
        "opts": []
      },
      {
        "content": "${1:FIELDNAME} = models.FilePathField(path=${2:\"/abs/path/to/dir\"}${3:, max_length=100}${4:, match=\"*.ext\"}${5:, recursive=True}${0:, blank=True, })",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "filepath"
        ],
        "opts": []
      },
      {
        "content": "${1:FIELDNAME} = models.FloatField(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "float"
        ],
        "opts": []
      },
      {
        "content": "${1:FIELDNAME} = models.ImageField(upload_to=${2:path/for/upload}${3:, height_field=height, width_field=width}${0:, max_length=100})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "image"
        ],
        "opts": []
      },
      {
        "content": "${1:FIELDNAME} = models.IntegerField(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "int"
        ],
        "opts": []
      },
      {
        "content": "${1:FIELDNAME} = models.IPAddressField(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ip"
        ],
        "opts": []
      },
      {
        "content": "${1:FIELDNAME} = models.NullBooleanField(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nullbool"
        ],
        "opts": []
      },
      {
        "content": "${1:FIELDNAME} = models.PositiveIntegerField(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "posint"
        ],
        "opts": []
      },
      {
        "content": "${1:FIELDNAME} = models.PositiveSmallIntegerField(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "possmallint"
        ],
        "opts": []
      },
      {
        "content": "${1:FIELDNAME} = models.SlugField(max_length=${2:50}${0:, blank=True})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "slug"
        ],
        "opts": []
      },
      {
        "content": "${1:FIELDNAME} = models.SmallIntegerField(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "smallint"
        ],
        "opts": []
      },
      {
        "content": "${1:FIELDNAME} = models.TextField(${0:blank=True})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "text"
        ],
        "opts": []
      },
      {
        "content": "${1:FIELDNAME} = models.TimeField(${2:auto_now_add=True, auto_now=True}${0:, blank=True, null=True})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "time"
        ],
        "opts": []
      },
      {
        "content": "${1:FIELDNAME} = models.URLField(${2:verify_exists=False}${3:, max_length=200}${0:, blank=True})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "url"
        ],
        "opts": []
      },
      {
        "content": "${1:FIELDNAME} = models.XMLField(schema_path=${2:None}${0:, blank=True})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "xml"
        ],
        "opts": []
      },
      {
        "content": "${1:FIELDNAME} = models.ForeignKey(${2:OtherModel}${3:, related_name=''}${4:, limit_choices_to=}${0:, to_field=''})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fk"
        ],
        "opts": []
      },
      {
        "content": "${1:FIELDNAME} = models.ManyToManyField(${2:OtherModel}${3:, related_name=''}${4:, limit_choices_to=}${5:, symmetrical=False}${6:, through=''}${0:, db_table=''})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "m2m"
        ],
        "opts": []
      },
      {
        "content": "${1:FIELDNAME} = models.OneToOneField(${2:OtherModel}${3:, parent_link=True}${4:, related_name=''}${5:, limit_choices_to=}${0:, to_field=''})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "o2o"
        ],
        "opts": []
      },
      {
        "content": "class ${1:FormName}(forms.Form):\n\t\"\"\"${2:docstring}\"\"\"\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "form"
        ],
        "opts": []
      },
      {
        "content": "class ${1:ModelName}(models.Model):\n\t\"\"\"${2:docstring}\"\"\"\n\t${3}\n\tclass Meta:\n\t\t${4}\n\tdef __unicode__(self):\n\t\t${5}\n\tdef save(self, *args, **kwargs):\n\t\t${6}\n\t@models.permalink\n\tdef get_absolute_url(self):\n\t\treturn ('${7:view_or_url_name}' ${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "model"
        ],
        "opts": []
      },
      {
        "content": "class ${1:ModelName}Admin(admin.ModelAdmin):\n\t${0}\nadmin.site.register($1, $1Admin)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "modeladmin"
        ],
        "opts": []
      },
      {
        "content": "class ${0:ModelName}Inline(admin.TabularInline):\n\tmodel = $1",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tabularinline"
        ],
        "opts": []
      },
      {
        "content": "class ${0:ModelName}Inline(admin.StackedInline):\n\tmodel = $1",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "stackedinline"
        ],
        "opts": []
      },
      {
        "content": "return render_to_response('${1:template.html}', {\n\t\t${2}\n\t}${0:, context_instance=RequestContext(request)}\n)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "r2r"
        ],
        "opts": []
      },
      {
        "content": "class ${1:FORMNAME}(forms.Form):\n\n\t${2:# TODO: Define form fields here}",
        "doc": null,
        "grammar": "snu",
        "label": "Form",
        "matches": [
          "form"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "class ${1:MODELNAME}Form(forms.ModelForm):\n\n\tclass Meta:\n\t\tmodel = $1",
        "doc": null,
        "grammar": "snu",
        "label": "ModelForm",
        "matches": [
          "modelform"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = forms.BooleanField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "BooleanField",
        "matches": [
          "fbool"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = forms.CharField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "CharField",
        "matches": [
          "fchar"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = forms.ChoiceField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "ChoiceField",
        "matches": [
          "fchoice"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = forms.ComboField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "ComboField",
        "matches": [
          "fcombo"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = forms.DateField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "DateField",
        "matches": [
          "fdate"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = forms.DateTimeField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "DateTimeField",
        "matches": [
          "fdatetime"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = forms.DecimalField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "DecimalField",
        "matches": [
          "fdecimal"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = forms.EmailField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "EmailField",
        "matches": [
          "fmail"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = forms.FileField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "FileField",
        "matches": [
          "ffile"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = forms.FilePathField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "FilePathField",
        "matches": [
          "ffilepath"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = forms.FloatField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "FloatField",
        "matches": [
          "ffloat"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = forms.IPAddressField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "IPAddressField",
        "matches": [
          "fip"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = forms.ImageField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "ImageField",
        "matches": [
          "fimg"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = forms.IntegerField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "IntegerField",
        "matches": [
          "fint"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = forms.ModelChoiceField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "ModelChoiceField",
        "matches": [
          "fmochoice"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = forms.ModelMultipleChoiceField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "ModelMultipleChoiceField",
        "matches": [
          "fmomuchoice"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = forms.MultiValueField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "MultiValueField",
        "matches": [
          "fmuval"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = forms.MultipleChoiceField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "MultipleChoiceField",
        "matches": [
          "fmuchoice"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = forms.NullBooleanField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "NullBooleanField",
        "matches": [
          "fnullbool"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = forms.RegexField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "RegexField",
        "matches": [
          "freg"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = forms.SlugField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "SlugField",
        "matches": [
          "fslug"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = forms.SplitDateTimeField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "SplitDateTimeField",
        "matches": [
          "fsdatetime"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = forms.TimeField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "TimeField",
        "matches": [
          "ftime"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = forms.TypedChoiceField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "TypedChoiceField",
        "matches": [
          "ftchoice"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = forms.TypedMultipleChoiceField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "TypedMultipleChoiceField",
        "matches": [
          "ftmuchoice"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = forms.URLField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "URLField",
        "matches": [
          "furl"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "class ${1:MODELNAME}(models.Model):\n\t$0\n\tclass Meta:\n\t\tverbose_name = \"$1\"\n\t\tverbose_name_plural = \"$1s\"\n\n\tdef __str__(self):\n\t\treturn super($1, self).__str__()\n",
        "doc": null,
        "grammar": "snu",
        "label": "Model",
        "matches": [
          "model"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "class ${1:MODELNAME}(models.Model):\n\t${2:# TODO: Define fields here}\n\n\tclass Meta:\n\t\tverbose_name = \"$1\"\n\t\tverbose_name_plural = \"$1s\"\n\n\tdef __str__(self):\n\t\treturn super($1, self).__str__()\n\n\tdef save(self):\n\t\treturn super($1, self).save()\n\n\tdef get_absolute_url(self):\n\t\treturn ('')\n\n\t${3:# TODO: Define custom methods here}\n",
        "doc": null,
        "grammar": "snu",
        "label": "Model",
        "matches": [
          "modelfull"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = models.AutoField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "AutoField",
        "matches": [
          "mauto"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = models.BigIntegerField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "BigIntegerField",
        "matches": [
          "mbigint"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = models.BooleanField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "BooleanField",
        "matches": [
          "mbool"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = models.CharField($2, max_length=${3:50})",
        "doc": null,
        "grammar": "snu",
        "label": "CharField",
        "matches": [
          "mchar"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = models.CommaSeparatedIntegerField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "CommaSeparatedIntegerField",
        "matches": [
          "mcoseint"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = models.DateField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "DateField",
        "matches": [
          "mdate"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = models.DateTimeField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "DateTimeField",
        "matches": [
          "mdatetime"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = models.DecimalField(max_digits=${2:10}, decimal_places=${3:2})",
        "doc": null,
        "grammar": "snu",
        "label": "DecimalField",
        "matches": [
          "mdecimal"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = models.EmailField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "EmailField",
        "matches": [
          "memail"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = models.FileField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "FileField",
        "matches": [
          "mfile"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = models.FilePathField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "FilePathField",
        "matches": [
          "mfilepath"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = models.FloatField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "FloatField",
        "matches": [
          "mfloat"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = models.ForeignKey($2)",
        "doc": null,
        "grammar": "snu",
        "label": "ForeignKey",
        "matches": [
          "fk"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = models.IPAddressField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "IPAddressField",
        "matches": [
          "mip"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = models.ImageField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "ImageField",
        "matches": [
          "mimg"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = models.IntegerField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "IntegerField",
        "matches": [
          "mint"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = models.ManyToManyField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "ManyToManyField",
        "matches": [
          "m2m"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = models.NullBooleanField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "NullBooleanField",
        "matches": [
          "mnullbool"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = models.OneToOneField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "OneToOneField",
        "matches": [
          "o2o"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = models.PhoneNumberField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "PhoneNumberField",
        "matches": [
          "mphone"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = models.PositiveIntegerField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "PositiveIntegerField",
        "matches": [
          "mposint"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = models.PositiveSmallIntegerField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "PositiveSmallIntegerField",
        "matches": [
          "mpossmallint"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = models.SlugField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "SlugField",
        "matches": [
          "mslug"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = models.SmallIntegerField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "SmallIntegerField",
        "matches": [
          "msmallint"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = models.TextField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "TextField",
        "matches": [
          "mtext"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = models.TimeField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "TimeField",
        "matches": [
          "mtime"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = models.URLField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "URLField",
        "matches": [
          "murl"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = models.USStateField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "USStateField",
        "matches": [
          "musstate"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:FIELDNAME} = models.XMLField($2)",
        "doc": null,
        "grammar": "snu",
        "label": "XMLField",
        "matches": [
          "mxml"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "class $1Admin(admin.ModelAdmin):\n\t'''\n\t\tAdmin View for $1\n\t'''\n\tlist_display = ('$2',)\n\tlist_filter = ('$3',)\n\tinlines = [\n\t\t$4Inline,\n\t]\n\traw_id_fields = ('$5',)\n\treadonly_fields = ('$6',)\n\tsearch_fields = ['$7']\nadmin.site.register($1, $1Admin)",
        "doc": null,
        "grammar": "snu",
        "label": "Model Admin View",
        "matches": [
          "adminview"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "class ${1:MODEL_NAME}CreateView(CreateView):\n\tmodel = $1\n\ttemplate_name = \"${2:TEMPLATE_NAME}\"",
        "doc": null,
        "grammar": "snu",
        "label": "Generic Create View",
        "matches": [
          "createview"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "class ${1:MODEL_NAME}DeleteView(DeleteView):\n\tmodel = $1\n\ttemplate_name = \"${2:TEMPLATE_NAME}\"",
        "doc": null,
        "grammar": "snu",
        "label": "Generic Delete View",
        "matches": [
          "deleteview"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "class ${1:MODEL_NAME}DetailView(DetailView):\n\tmodel = $1\n\ttemplate_name = \"${2:TEMPLATE_NAME}\"",
        "doc": null,
        "grammar": "snu",
        "label": "Generic Detail View",
        "matches": [
          "detailview"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "class ${1:MODEL_NAME}ListView(ListView):\n\tmodel = $1\n\ttemplate_name = \"${2:TEMPLATE_NAME}\"",
        "doc": null,
        "grammar": "snu",
        "label": "Generic List View",
        "matches": [
          "listview"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "class $1Inline(admin.StackedInline):\n\t'''\n\tStacked Inline View for $1\n\t'''\n\tmodel = ${2:$1}\n\tmin_num = ${3:3}\n\tmax_num = ${4:20}\n\textra = ${5:1}\n\traw_id_fields = ($6,)",
        "doc": null,
        "grammar": "snu",
        "label": "Stacked Inline",
        "matches": [
          "stackedinline"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "class $1Inline(admin.TabularInline):\n\t'''\n\tTabular Inline View for $1\n\t'''\n\tmodel = ${2:$1}\n\tmin_num = ${3:3}\n\tmax_num = ${4:20}\n\textra = ${5:1}\n\traw_id_fields = ($6,)",
        "doc": null,
        "grammar": "snu",
        "label": "Tabular Inline",
        "matches": [
          "tabularinline"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "class ${1:CLASS_NAME}(TemplateView):\n\ttemplate_name = \"${2:TEMPLATE_NAME}\"",
        "doc": null,
        "grammar": "snu",
        "label": "Generic Template View",
        "matches": [
          "templateview"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "class ${1:MODEL_NAME}UpdateView(UpdateView):\n\tmodel = $1\n\ttemplate_name = \"${2:TEMPLATE_NAME}\"",
        "doc": null,
        "grammar": "snu",
        "label": "Generic Update View",
        "matches": [
          "updateview"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "def dispatch(self, request, *args, **kwargs):\n\treturn super(${1:CLASS_NAME}, self).dispatch(request, *args, **kwargs)",
        "doc": null,
        "grammar": "snu",
        "label": "Dispatch View method",
        "matches": [
          "dispatch"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "def get_context_data(self, **kwargs):\n\tkwargs['extra_context'] = ${1:'New Value'}\n\treturn super(${2:CLASS_NAME}, self).get_context_data(**kwargs)",
        "doc": null,
        "grammar": "snu",
        "label": "get_context_data view method",
        "matches": [
          "context"
        ],
        "opts": [
          "b"
        ]
      }
    ],
    "dockerfile": [
      {
        "content": "# Client App\nFROM johnpapa/angular-cli as client-app\nLABEL authors=\"${1:John Papa}\"\nWORKDIR /usr/src/app\nCOPY [\"package.json\", \"npm-shrinkwrap.json*\", \"./\"]\nRUN npm install --silent\nCOPY . .\nRUN ng build --prod\n\n# Node server\nFROM ${2:node:12-alpine} as node-server\nWORKDIR /usr/src/app\nCOPY [\"package.json\", \"npm-shrinkwrap.json*\", \"./\"]\nRUN npm install --production --silent && mv node_modules ../\nCOPY ${3:server.js} .\nCOPY ${4:/server} /usr/src/app/server\n\n# Final image\nFROM ${2:node:12-alpine}\nWORKDIR /usr/src/app\nCOPY --from=node-server /usr/src /usr/src\nCOPY --from=client-app /usr/src/app/dist ./\nEXPOSE ${5:3000}\n# CMD [\"node\", \"server.js\"]\nCMD [\"npm\", \"start\"]\n$0",
        "doc": "Multi-stage Node and Angular Dockerfile",
        "grammar": "lsp",
        "label": "Multi-stage Node and Angular Dockerfile",
        "matches": [
          "docker-angular-node-multi-stage"
        ],
        "opts": []
      }
    ],
    "dosini": [
      {
        "content": "; http://editorconfig.org\nroot = true\n[*]\nindent_style = ${1:space_or_tab}\nindent_size = ${2:indent_size}\nend_of_line = lf\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = true",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ec"
        ],
        "opts": []
      }
    ],
    "dotenv": [
      {
        "content": "require('dotenv').config()",
        "doc": "As early as possible in your application, require and configure dotenv.",
        "grammar": "lsp",
        "label": "dotenv-require",
        "matches": [
          "dotenv require"
        ],
        "opts": []
      },
      {
        "content": "require('dotenv').config({ path: '${1:/full/custom/path/to/your/env/vars}' })",
        "doc": "You may specify a custom path if your file containing environment variables is located elsewhere.",
        "grammar": "lsp",
        "label": "dotenv-path",
        "matches": [
          "dotenv path"
        ],
        "opts": []
      },
      {
        "content": "require('dotenv').config({ encoding: '${1:latin1}' })",
        "doc": "You may specify the encoding of your file containing environment variables.",
        "grammar": "lsp",
        "label": "dotenv-encoding",
        "matches": [
          "dotenv encoding"
        ],
        "opts": []
      },
      {
        "content": "require('dotenv').config({ debug: ${1|true,false|} })",
        "doc": "You may turn on logging to help debug why certain keys or values are not being set as you expect.",
        "grammar": "lsp",
        "label": "dotenv-debug",
        "matches": [
          "dotenv debug"
        ],
        "opts": []
      }
    ],
    "dotenv-safe": [
      {
        "content": "require('dotenv-safe').config();",
        "doc": "As early as possible in your application, require and configure dotenv-safe. This will load environment variables from .env as usual, but will also read any variables defined in .env.example. If any variables are already defined in the environment before reading from .env, they will not be overwritten. If any variables are missing from the environment, a MissingEnvVarsError will be thrown, which lists the missing variables.",
        "grammar": "lsp",
        "label": "dotenv-safe-require",
        "matches": [
          "dotenv-safe require"
        ],
        "opts": []
      },
      {
        "content": "require('dotenv-safe').config({ path: '${1:/full/custom/path/to/your/env/vars}' })",
        "doc": "You may specify a custom path if your file containing environment variables is located elsewhere.",
        "grammar": "lsp",
        "label": "dotenv-safe-path",
        "matches": [
          "dotenv-safe path"
        ],
        "opts": []
      },
      {
        "content": "require('dotenv-safe').config({ encoding: '${1:latin1}' })",
        "doc": "You may specify the encoding of your file containing environment variables.",
        "grammar": "lsp",
        "label": "dotenv-safe-encoding",
        "matches": [
          "dotenv-safe encoding"
        ],
        "opts": []
      },
      {
        "content": "require('dotenv-safe').config({ debug: ${1|true,false|} })",
        "doc": "You may turn on logging to help debug why certain keys or values are not being set as you expect.",
        "grammar": "lsp",
        "label": "dotenv-safe-debug",
        "matches": [
          "dotenv-safe debug"
        ],
        "opts": []
      },
      {
        "content": "require('dotenv-safe').config({ allowEmptyValues: ${1|true,false|} })",
        "doc": "If a variable is defined in the example file and has an empty value in the environment, enabling this option will not throw an error after loading.",
        "grammar": "lsp",
        "label": "dotenv-safe-allowemptyvalues",
        "matches": [
          "dotenv-safe allowemptyvalues"
        ],
        "opts": []
      }
    ],
    "eelixir": [
      {
        "content": "<% ${0} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "% <% %>"
        ],
        "opts": []
      },
      {
        "content": "<%= ${0} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "= <%= %>"
        ],
        "opts": []
      },
      {
        "content": "<%# ${0} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "# <%# %>"
        ],
        "opts": []
      },
      {
        "content": "<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "end"
        ],
        "opts": []
      },
      {
        "content": "<%= for ${1:item} <- ${2:items} ${3:@conn} do %>\n\t${0}\n<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "<%= if ${1} do %>\n\t${0:${VISUAL}}\n<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "<%= if ${1} do %>\n\t${2:${VISUAL}}\n<% else %>\n\t${0}\n<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "<%= cond do %>\n\t<% ${1} -> %>\n\t\t${2:${VISUAL}}\n\t<% true -> %>\n\t\t${0}\n<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cond"
        ],
        "opts": []
      },
      {
        "content": "<%= unless ${1} do %>\n\t${0:${VISUAL}}\n<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "unless"
        ],
        "opts": []
      },
      {
        "content": "<%= form_tag(${1:\"/users\"}, method: ${2::post}) %>\n\t${0}\n</form>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ft form_tag"
        ],
        "opts": []
      },
      {
        "content": "<%= select ${1:f}, :${2:field}, ${3:[{\"key\", \"value\"}]}, prompt: ${4:\"Prompt\"} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sl select"
        ],
        "opts": []
      },
      {
        "content": "<%= submit ${1:\"Submit\"} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sb submit"
        ],
        "opts": []
      },
      {
        "content": "<%= radio_button ${1:f}, :${2:field},  ${3:\"value\"} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rb radio_button"
        ],
        "opts": []
      },
      {
        "content": "<%= error_tag ${1:f}, :${2:field} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "et error_tag"
        ],
        "opts": []
      },
      {
        "content": "<%= text_input ${1:f}, :${2:field} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ti text_input"
        ],
        "opts": []
      },
      {
        "content": "<%= label ${1:f}, :${2:field}, \"${3:Label}\" %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "la label"
        ],
        "opts": []
      },
      {
        "content": "<%= password_input ${1:f}, :${2:password} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pi password_input"
        ],
        "opts": []
      },
      {
        "content": "<%= render \"${1:index}.html\", ${2:var: @var} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "render"
        ],
        "opts": []
      },
      {
        "content": "<%= link \"${1:Submit}\", to: ${2:\"/users\"}, method: ${3::delete} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lin link"
        ],
        "opts": []
      },
      {
        "content": "<%= form_for @changeset, ${1:\"/users\"}, fn f -> %>\n\t\t${0}\n\t<%= submit \"Submit\" %>\n<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ff form_for"
        ],
        "opts": []
      },
      {
        "content": "<% require IEx; IEx.pry %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pry"
        ],
        "opts": []
      },
      {
        "content": "<% $0 %>",
        "doc": null,
        "grammar": "snu",
        "label": "<% %>",
        "matches": [
          "%"
        ],
        "opts": [
          "w"
        ]
      },
      {
        "content": "<%= $0 %>",
        "doc": null,
        "grammar": "snu",
        "label": "<%= %>",
        "matches": [
          "="
        ],
        "opts": [
          "w"
        ]
      },
      {
        "content": "<% end %>",
        "doc": null,
        "grammar": "snu",
        "label": "<% end %>",
        "matches": [
          "end"
        ],
        "opts": [
          "w"
        ]
      },
      {
        "content": "<%= for ${1:item} <- ${2:$1s} ${3:@conn} do %>\n\t$0\n<% end %>",
        "doc": null,
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "<%= form_tag(${1:\"${2:/users}\"}, method: ${3::post}) %>\n\t$0\n</form>",
        "doc": null,
        "grammar": "snu",
        "label": "form_tag",
        "matches": [
          "ft"
        ],
        "opts": [
          "w"
        ]
      },
      {
        "content": "<%= link ${1:\"${2:Submit}\"}, to: ${3:\"${4:/users}\"}, method: ${5::delete} %>",
        "doc": null,
        "grammar": "snu",
        "label": "link",
        "matches": [
          "lin"
        ],
        "opts": [
          "w"
        ]
      },
      {
        "content": "<%= form_for @changeset, ${1:\"${2:/users}\"}, fn f -> %>\n\t\t$0\n\n\t<%= submit \"Submit\" %>\n<% end %>",
        "doc": null,
        "grammar": "snu",
        "label": "form_for",
        "matches": [
          "ff"
        ],
        "opts": [
          "w"
        ]
      },
      {
        "content": "<%= gettext(\"${0:${VISUAL}}\") %>",
        "doc": null,
        "grammar": "snu",
        "label": "gettext",
        "matches": [
          "gt"
        ],
        "opts": [
          "w"
        ]
      }
    ],
    "ejs": [
      {
        "content": "<% for (let ${1:i = 0}; ${2:i<arr.length}; ${3:i++}) { %>\n\t${0:body}\n<% } %>",
        "doc": null,
        "grammar": "snu",
        "label": "ejs for loop",
        "matches": [
          "for"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "<% ${1:array}.forEach((${2:single var}) => { %>\n\t${0:body}\n<% }) %>",
        "doc": null,
        "grammar": "snu",
        "label": "ejs for Each loop",
        "matches": [
          "forE"
        ],
        "opts": [
          "b"
        ]
      }
    ],
    "elixir": [
      {
        "content": "do\n\t${0:${VISUAL}}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "do"
        ],
        "opts": []
      },
      {
        "content": "IO.puts \"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "put IO.puts"
        ],
        "opts": []
      },
      {
        "content": "IO.inspect ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ins IO.inspect"
        ],
        "opts": []
      },
      {
        "content": "IO.inspect(${0}label: \"${1:label}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "insl IO.inspect with label"
        ],
        "opts": []
      },
      {
        "content": "if ${1} do\n\t${0:${VISUAL}}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if if .. do .. end"
        ],
        "opts": []
      },
      {
        "content": "if ${1:condition}, do: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if: if .. do: .."
        ],
        "opts": []
      },
      {
        "content": "if ${1:condition} do\n\t${2:${VISUAL}}\nelse\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife if .. do .. else .. end"
        ],
        "opts": []
      },
      {
        "content": "if ${1:condition}, do: ${2}, else: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife: if .. do: .. else:"
        ],
        "opts": []
      },
      {
        "content": "unless ${1} do\n\t${0:${VISUAL}}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "unless unless .. do .. end"
        ],
        "opts": []
      },
      {
        "content": "unless ${1:condition}, do: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "unless: unless .. do: .."
        ],
        "opts": []
      },
      {
        "content": "unless ${1:condition} do\n\t${2:${VISUAL}}\nelse\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "unlesse unless .. do .. else .. end"
        ],
        "opts": []
      },
      {
        "content": "unless ${1:condition}, do: ${2}, else: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "unlesse: unless .. do: .. else:"
        ],
        "opts": []
      },
      {
        "content": "cond do\n\t${1} ->\n\t${0:${VISUAL}}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cond"
        ],
        "opts": []
      },
      {
        "content": "case ${1} do\n\t${2} ->\n\t\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case"
        ],
        "opts": []
      },
      {
        "content": "for ${1:item} <- ${2:items} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "for ${1:item} <- ${2:items}, do: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for:"
        ],
        "opts": []
      },
      {
        "content": "for ${1:item} <- ${2:items}, into: ${3} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fori"
        ],
        "opts": []
      },
      {
        "content": "with ${1:item} <- ${2:items} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wi"
        ],
        "opts": []
      },
      {
        "content": "with(\n\t${1:item} <- ${2:items}\n) do\n\t${3}\nelse\n\t${4} ->\n\t\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wie"
        ],
        "opts": []
      },
      {
        "content": "@spec ${1:name}(${2:args}) :: ${3:returns}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sp"
        ],
        "opts": []
      },
      {
        "content": "@opaque ${1:type_name} :: ${2:type}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "op"
        ],
        "opts": []
      },
      {
        "content": "@type ${1:type_name} :: ${2:type}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ty"
        ],
        "opts": []
      },
      {
        "content": "@typep ${1:type_name} :: ${2:type}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "typ"
        ],
        "opts": []
      },
      {
        "content": "@callback ${1:name}(${2:args}) :: ${3:returns}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cb"
        ],
        "opts": []
      },
      {
        "content": "def ${1:name}, do: ${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "df"
        ],
        "opts": []
      },
      {
        "content": "def ${1:name}(${2:args}) when ${3:guard}, do:",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dfw"
        ],
        "opts": []
      },
      {
        "content": "def ${1:name} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "def"
        ],
        "opts": []
      },
      {
        "content": "@doc \"\"\"\n${1:doc string}\n\"\"\"\ndef ${2:name} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defd"
        ],
        "opts": []
      },
      {
        "content": "@spec ${1:name}(${2:arg types}) :: ${3:no_return}\ndef $1(${4:args}) do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defs"
        ],
        "opts": []
      },
      {
        "content": "@doc \"\"\"\n${1:doc string}\n\"\"\"\n@spec ${2:name}(${3:arg types}) :: ${4:no_return}\ndef $2(${5:args}) do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defsd"
        ],
        "opts": []
      },
      {
        "content": "def ${1:name}(${2:args}) when ${3:guard} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defw"
        ],
        "opts": []
      },
      {
        "content": "defimpl ${1:protocol_name}, for: ${2:data_type} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defim"
        ],
        "opts": []
      },
      {
        "content": "defmacro ${1:name} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defma"
        ],
        "opts": []
      },
      {
        "content": "defmodule ${1:`substitute(vim_snippets#Filename(), '\\(_\\|^\\)\\(.\\)', '\\u\\2', 'g')`} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defmo"
        ],
        "opts": []
      },
      {
        "content": "%__MODULE__{\n\t${1:key_name}: ${2:value}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "%M"
        ],
        "opts": []
      },
      {
        "content": "@enforce_keys [:${1:key_name}]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "enfk"
        ],
        "opts": []
      },
      {
        "content": "defp ${1:name}, do: ${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dfp"
        ],
        "opts": []
      },
      {
        "content": "defp ${1:name}(${2:args}) when ${3:guard}, do: ${4}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dfpw"
        ],
        "opts": []
      },
      {
        "content": "defp ${1:name} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defp"
        ],
        "opts": []
      },
      {
        "content": "defp ${1:name}(${2:args}) when ${3:guard} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defpw"
        ],
        "opts": []
      },
      {
        "content": "defprotocol ${1:name}, [${0:function}]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defpr"
        ],
        "opts": []
      },
      {
        "content": "defrecord ${1:record_name}, ${0:fields}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defr"
        ],
        "opts": []
      },
      {
        "content": "@doc \"\"\"\n${0}\n\"\"\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doc"
        ],
        "opts": []
      },
      {
        "content": "@doc ~S\"\"\"\n${0}\n\"\"\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "docs"
        ],
        "opts": []
      },
      {
        "content": "@doc false",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "docf"
        ],
        "opts": []
      },
      {
        "content": "@impl true",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "im"
        ],
        "opts": []
      },
      {
        "content": "fn ${1:args} -> ${0} end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fn"
        ],
        "opts": []
      },
      {
        "content": "@moduledoc \"\"\"\n${0}\n\"\"\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mdoc"
        ],
        "opts": []
      },
      {
        "content": "@moduledoc ~S\"\"\"\n${0}\n\"\"\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mdocs"
        ],
        "opts": []
      },
      {
        "content": "@moduledoc false",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mdocf"
        ],
        "opts": []
      },
      {
        "content": "receive do\n\t${1} ->\n\t\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rec"
        ],
        "opts": []
      },
      {
        "content": "require ${0:Logger}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "req"
        ],
        "opts": []
      },
      {
        "content": "import ${0:module_name}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "imp"
        ],
        "opts": []
      },
      {
        "content": "alias ${0:module_name}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ali"
        ],
        "opts": []
      },
      {
        "content": "test \"${1:test name}\" do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "test"
        ],
        "opts": []
      },
      {
        "content": "test \"${1:test_name}\", ctx do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "testc"
        ],
        "opts": []
      },
      {
        "content": "test \"${1:test_name}\", %{${2:arg: arg}} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "testa"
        ],
        "opts": []
      },
      {
        "content": "describe \"${1:test group subject}\" do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "des"
        ],
        "opts": []
      },
      {
        "content": "@describetag :${1:describe tag}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "destag"
        ],
        "opts": []
      },
      {
        "content": "@moduletag :${1:module tag}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mtag"
        ],
        "opts": []
      },
      {
        "content": "doctest ${1:filename}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dt"
        ],
        "opts": []
      },
      {
        "content": "@tag :pending",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tp"
        ],
        "opts": []
      },
      {
        "content": "defmodule ${1:`substitute(vim_snippets#Filename(), '\\(_\\|^\\)\\(.\\)', '\\u\\2', 'g')`} do\n\tuse ExUnit.Case, async: true\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "exunit"
        ],
        "opts": []
      },
      {
        "content": "setup do\n\t${1}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "setup"
        ],
        "opts": []
      },
      {
        "content": "setup_all do\n\t${1}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "setupa"
        ],
        "opts": []
      },
      {
        "content": "try do\n\t${1:${VISUAL}}\nrescue\n\t${2} -> ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "try try .. rescue .. end"
        ],
        "opts": []
      },
      {
        "content": "require IEx; IEx.pry\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pry"
        ],
        "opts": []
      },
      {
        "content": "|> (fn x -> require IEx; IEx.pry; x end).()${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ppry"
        ],
        "opts": []
      },
      {
        "content": "quote do\n\t${1}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "qu"
        ],
        "opts": []
      },
      {
        "content": "@behaviour ${1:Mix.Task}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "beh"
        ],
        "opts": []
      },
      {
        "content": "|> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p"
        ],
        "opts": []
      },
      {
        "content": "|> Enum.each(fn ${1} -> ${0} end)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ">e pipe to each"
        ],
        "opts": []
      },
      {
        "content": "|> Enum.map(fn ${1} -> ${0} end)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ">m pipe to map"
        ],
        "opts": []
      },
      {
        "content": "|> Enum.filter(fn ${1} -> ${0} end)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ">f pipe to filter"
        ],
        "opts": []
      },
      {
        "content": "|> Enum.reduce(${1:acc}, fn ${2}, ${3:acc} -> ${0} end)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ">r pipe to reduce"
        ],
        "opts": []
      },
      {
        "content": "|> IO.inspect",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ">i pipe to inspect"
        ],
        "opts": []
      },
      {
        "content": "|> IO.inspect(label: \"${1:label}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ">il pipe to inspect with label"
        ],
        "opts": []
      },
      {
        "content": "@doc false\ndef child_spec(${1:_opts}) do\n\t%{\n\t\tid: __MODULE__,\n\t\tstart: {__MODULE__, :start_link, ${2:[]}},\n\t\trestart: ${3::permanent},\n\t\tshutdown: ${4:5000},\n\t\ttype: ${5::worker}\n\t}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cs"
        ],
        "opts": []
      },
      {
        "content": "use GenServer\n@doc false\ndef start_link do\n\tGenServer.start_link(__MODULE__, ${1:Map.new})\nend\n@impl true\ndef init(state) do\n\t{:ok, state}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "genserver basic genserver structure"
        ],
        "opts": []
      },
      {
        "content": "use GenServer\n@doc false\ndef start_link, do: GenServer.start_link(__MODULE__, ${1:Map.new})\n@impl true\ndef init(state), do: {:ok, state}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "genserver: basic genserver structure"
        ],
        "opts": []
      },
      {
        "content": "@impl true\ndef ${1:name} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "impl"
        ],
        "opts": []
      },
      {
        "content": "~w(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wl word list"
        ],
        "opts": []
      },
      {
        "content": "~w(${0})a",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "al atom list"
        ],
        "opts": []
      },
      {
        "content": "do\n  ${1:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "do...end",
        "matches": [
          "do"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "if ${1:true} do\n  ${2:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "if .. do .. end",
        "matches": [
          "if"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "if ${1:true} do\n  ${2:ok}\nelse\n  ${3:ok}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "if .. do .. else .. end",
        "matches": [
          "ife"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "case ${1} do\n  ${2} -> ${3}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "case .. end",
        "matches": [
          "case"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "def ${1:name} do\n  ${2:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "def .. do .. end",
        "matches": [
          "def"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "defmodule ${1:module_name} do\n  ${2:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "def module",
        "matches": [
          "defm"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "defp ${1:name} do\n  ${2:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "defp .. end",
        "matches": [
          "defp"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "@doc \"\"\"${0:TARGET}\"\"\"",
        "doc": "",
        "grammar": "snu",
        "label": "@doc \"\"\"...\"\"\"",
        "matches": [
          "doc"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "@moduledoc \"\"\"${0:TARGET}\"\"\"",
        "doc": "",
        "grammar": "snu",
        "label": "@moduledoc \"\"\"...\"\"\"",
        "matches": [
          "mdoc"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "fn(${1:args}) -> ${2:TARGET} end",
        "doc": "",
        "grammar": "snu",
        "label": "fn(..) -> .. end",
        "matches": [
          "fn"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "receive do\n${1} -> ${2}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "receive .. do .. end",
        "matches": [
          "rec"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "test \"${1:test_name}\" do\n  ${2:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "test .. do .. end",
        "matches": [
          "test"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "try do\n  ${1:TARGET}\nrescue\n  ${2} -> ${3}",
        "doc": "",
        "grammar": "snu",
        "label": "try .. rescue .. end",
        "matches": [
          "try"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "with ${1}\ndo\n  ${2:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "with .. do .. end",
        "matches": [
          "with"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "describe \"${1:describe_name}\" do\n  ${2:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "describe .. do .. end",
        "matches": [
          "describe"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "IO.puts(${1})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "puts"
        ],
        "opts": []
      },
      {
        "content": "IO.inspect(${1})",
        "doc": "",
        "grammar": "snu",
        "label": "IO.inspect()",
        "matches": [
          "p"
        ],
        "opts": []
      },
      {
        "content": "defmodule Main do\n  def main do\n    ${1:TARGET}\n  end\nend\nMain.main",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "main"
        ],
        "opts": [
          "head"
        ]
      }
    ],
    "elm": [
      {
        "content": "module `substitute(substitute(expand('%:r'), '[/\\\\]','.','g'),'^\\%(\\l*\\.\\)\\?','','')` exposing (${1})\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mod"
        ],
        "opts": []
      },
      {
        "content": "import ${0:Http}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "imp"
        ],
        "opts": []
      },
      {
        "content": "import ${1:Html} exposing (${0:..})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "impe"
        ],
        "opts": []
      },
      {
        "content": "import ${1:Json.Encode} as ${2:Encode} exposing (${0:Value})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "impae"
        ],
        "opts": []
      },
      {
        "content": "${1:fn} : ${2:a} -> ${3:a}\n$1 ${4} =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fn"
        ],
        "opts": []
      },
      {
        "content": "${1:fn} : ${2:a} -> ${3:a}\n$1 ${4} =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fn1"
        ],
        "opts": []
      },
      {
        "content": "${1:fn} : ${2:a} -> ${3:a} -> ${4:a}\n$1 ${5} =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fn2"
        ],
        "opts": []
      },
      {
        "content": "${1:fn} : ${2:a} -> ${3:a} -> ${4:a} -> ${5:a}\n$1 ${6} =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fn3"
        ],
        "opts": []
      },
      {
        "content": "${1:fn} : ${2:a}\n$1 =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fn0"
        ],
        "opts": []
      },
      {
        "content": "case ${1} of\n\t${2} ->\n\t\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case"
        ],
        "opts": []
      },
      {
        "content": "${1} ->\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "-"
        ],
        "opts": []
      },
      {
        "content": "let\n\t${1} =\n\t\t${2}\nin\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "let"
        ],
        "opts": []
      },
      {
        "content": "if ${1} then\n\t${2:${VISUAL}}\nelse\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "type ${1:Msg}\n\t= ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ty"
        ],
        "opts": []
      },
      {
        "content": "type alias ${1:Model} =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tya"
        ],
        "opts": []
      },
      {
        "content": "test \"${1}\" <| \\_ -> $0",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "test"
        ],
        "opts": []
      },
      {
        "content": "describe \"${1}\" [ $0 ]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "desc"
        ],
        "opts": []
      },
      {
        "content": "{-| ${0}\n-}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doc"
        ],
        "opts": []
      },
      {
        "content": "|> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p"
        ],
        "opts": []
      },
      {
        "content": "import Html exposing (Html)\ntype alias Model =\n\t{}\ntype Msg\n\t= Noop\nmain : Program Never Model Msg\nmain =\n\tHtml.program\n\t\t{ init = init\n\t\t, view = view\n\t\t, update = update\n\t\t, subscriptions = subscriptions\n\t\t}\ninit : ( Model, Cmd Msg )\ninit =\n\t{} ! []\nupdate : Msg -> Model -> ( Model, Cmd Msg )\nupdate msg model =\n\tcase msg of\n\t\tNoop ->\n\t\t\tmodel ! []\nsubscriptions : Model -> Sub Msg\nsubscriptions model =\n\tSub.none\nview : Model -> Html Msg\nview model =\n\tHtml.text \"Hello, sailor!\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "program Elm 0.18 program"
        ],
        "opts": []
      },
      {
        "content": "module Main exposing (Model, Msg(..), init, main, subscriptions, update, view)\nimport Browser\nimport Html exposing (..)\nimport Json.Encode\nmain : Program Flags Model Msg\nmain =\n\tBrowser.element\n\t\t{ init = init\n\t\t, update = update\n\t\t, subscriptions = subscriptions\n\t\t, view = view\n\t\t}\ntype alias Model =\n\t{}\ntype alias Flags =\n\tJson.Encode.Value\ninit : Flags -> ( Model, Cmd Msg )\ninit flags_ =\n\t( {}\n\t, Cmd.none\n\t)\ntype Msg\n\t= Noop\nupdate : Msg -> Model -> ( Model, Cmd Msg )\nupdate msg model =\n\tcase msg of\n\t\tNoop ->\n\t\t\t( model\n\t\t\t, Cmd.none\n\t\t\t)\nsubscriptions : Model -> Sub Msg\nsubscriptions model =\n\tSub.none\nview : Model -> Html Msg\nview model =\n\th1 [] [ text \"Hello, world!\" ]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "element"
        ],
        "opts": []
      },
      {
        "content": "module ${1:`substitute(substitute(expand('%:r'), '[/\\\\]','.','g'),'^\\%(\\l*\\.\\)\\?','','')} exposing (${2:...})\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "module"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "import ${1:String}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "import",
        "matches": [
          "imp",
          "import"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "import ${1} as ${2}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "import ... as ...",
        "matches": [
          "impa",
          "importAs"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "import ${1:Html} exposing (${2:..})\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "import ... exposing (..)",
        "matches": [
          "importExposing",
          "impe"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "import ${1:Html} as ${2} exposing (${2:..})\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "import ... as ... exposing (..)",
        "matches": [
          "impae",
          "importAsExposing"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "main : Program Never ${2:Model} ${3:Msg}\nmain =\n\t${4:Html.}program\n\t\t{ init: ${6:( model, Cmd.none )}\n\t\t, update: ${7:update}\n\t\t, subscriptions: ${8:subscriptions}\n\t\t${9:, view: ${10:view\\}}\n\t\t}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "main : Program",
        "matches": [
          "prog",
          "main"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "main : Program ${1:Flags} ${2:Model} ${3:Msg}\nmain =\n\t${4:Html.}programWithFlags\n\t\t{ init: ${6:initWithFlags}\n\t\t, update: ${7:update}\n\t\t, subscriptions: ${8:subscriptions}\n\t\t${9:, view: ${10:view\\}}\n\t\t}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "main : Program",
        "matches": [
          "progf mainf",
          "programWithFlags"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "main : Program Never ${2:Model} ${3:Msg}\nmain =\n\t${4:Html.}beginnerProgram\n\t\t{ init: ${6:init}\n\t\t, update: ${7:update}\n\t\t, subscriptions: ${8:subscriptions}\n\t\t${9:, view: ${10:view\\}}\n\t\t}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "main : Program",
        "matches": [
          "progb mainb",
          "basicProgram"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "case ${1:#:expression} of\n\t${2:#:value} ->\n\t\t${3:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "case ... of",
        "matches": [
          "case"
        ],
        "opts": []
      },
      {
        "content": "if ${1:#:condition} then\n\t${2}\nelse\n\t${3}",
        "doc": "",
        "grammar": "snu",
        "label": "if ... then ... else ...",
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "let\n\t${1} =\n\t\t${2}\nin\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "let ... in ...",
        "matches": [
          "let"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "\\\\${1:x} -> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "λ",
        "matches": [
          "lambda"
        ],
        "opts": []
      },
      {
        "content": "import ${1:Json.Encode} as ${0:`!p snip.rv = t[1].split(\".\")[-1]`}",
        "doc": null,
        "grammar": "snu",
        "label": "Qualified import",
        "matches": [
          "impa"
        ],
        "opts": []
      },
      {
        "content": "import ${1:Json.Encode} as ${2:`!p snip.rv = t[1].split(\".\")[-1]`} exposing (${0:Value})",
        "doc": null,
        "grammar": "snu",
        "label": "Qualified import with exposing",
        "matches": [
          "impae"
        ],
        "opts": []
      }
    ],
    "erlang": [
      {
        "content": "-module(${1:`vim_snippets#Filename()`}).",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mod"
        ],
        "opts": []
      },
      {
        "content": "-module(${1:`vim_snippets#Filename()`}).\n-compile([export_all]).\nstart() ->\n\t${0}\nstop() ->\n\tok.",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "modall"
        ],
        "opts": []
      },
      {
        "content": "erlang:display(${0}),",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d"
        ],
        "opts": []
      },
      {
        "content": "erlang:display({${1}, ${0}}),",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dt"
        ],
        "opts": []
      },
      {
        "content": "-define(${1:macro}, ${2:body}).",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "def"
        ],
        "opts": []
      },
      {
        "content": "-export([${1:function}/${0:arity}]).",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "exp"
        ],
        "opts": []
      },
      {
        "content": "-include(\"${1:file}\").",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "inc"
        ],
        "opts": []
      },
      {
        "content": "-include_lib(\"${1:lib}/include/${1}.hrl\").${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "incl"
        ],
        "opts": []
      },
      {
        "content": "-behaviour(${1:behaviour}).",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "beh"
        ],
        "opts": []
      },
      {
        "content": "-ifdef(${1:TEST}).\n${0}\n-endif.",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifd"
        ],
        "opts": []
      },
      {
        "content": "-ifndef(${1:TEST}).\n${0}\n-endif.",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifnd"
        ],
        "opts": []
      },
      {
        "content": "-undef(${1:macro}).",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "undef"
        ],
        "opts": []
      },
      {
        "content": "if\n\t${1:guard} ->\n\t\t${0:body}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "case ${1:expression} of\n\t${2:pattern} ->\n\t\t${0:body};\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case"
        ],
        "opts": []
      },
      {
        "content": "fun (${1:Parameters}) -> ${2:body} end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fun"
        ],
        "opts": []
      },
      {
        "content": "try\n\t${1:${VISUAL}}\ncatch\n\t${2:_:_} -> ${0:got_some_exception}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "try"
        ],
        "opts": []
      },
      {
        "content": "receive\n${1:\t${2:pattern}${3: when ${4:guard}} ->\n\t\t${5:body}}\n${6:after\n\t${7:expression} ->\n\t\t${8:body}}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rcv \"Receive Expression\""
        ],
        "opts": []
      },
      {
        "content": "-record(${1:record}, {${2:field}=${3:value}}).",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rec"
        ],
        "opts": []
      },
      {
        "content": "%% TODO: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "todo"
        ],
        "opts": []
      },
      {
        "content": "%% @doc ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "%d"
        ],
        "opts": []
      },
      {
        "content": "%% @end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "%e"
        ],
        "opts": []
      },
      {
        "content": "%% @spec ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "%s"
        ],
        "opts": []
      },
      {
        "content": "%% @private",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "%p"
        ],
        "opts": []
      },
      {
        "content": "-module(${1:`vim_snippets#Filename()`}).\n-behaviour(application).\n-export([start/2, stop/1]).\nstart(_Type, _StartArgs) ->\n\tcase ${0:root_supervisor}:start_link() of\n\t\t{ok, Pid} ->\n\t\t\t{ok, Pid};\n\t\tOther ->\n\t\t\t{error, Other}\n\tend.\nstop(_State) ->\n\tok.",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "application"
        ],
        "opts": []
      },
      {
        "content": "-module(${1:`vim_snippets#Filename()`}).\n-behaviour(supervisor).\n%% API\n-export([start_link/0]).\n%% Supervisor callbacks\n-export([init/1]).\n-define(SERVER, ?MODULE).\nstart_link() ->\n\t\tsupervisor:start_link({local, ?SERVER}, ?MODULE, []).\ninit([]) ->\n\tServer = {${0:my_server}, {${2}, start_link, []},\n\t\tpermanent, 2000, worker, [${2}]},\n\tChildren = [Server],\n\tRestartStrategy = {one_for_one, 0, 1},\n\t{ok, {RestartStrategy, Children}}.",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "supervisor"
        ],
        "opts": []
      },
      {
        "content": "-module(${0:`vim_snippets#Filename()`}).\n-behaviour(gen_server).\n%% API\n-export([start_link/0]).\n%% gen_server callbacks\n-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3]).\n-define(SERVER, ?MODULE).\n-record(state, {}).\n%%%===================================================================\n%%% API\n%%%===================================================================\nstart_link() ->\n\tgen_server:start_link({local, ?SERVER}, ?MODULE, [], []).\n%%%===================================================================\n%%% gen_server callbacks\n%%%===================================================================\ninit([]) ->\n\t{ok, #state{}}.\nhandle_call(_Request, _From, State) ->\n\tReply = ok,\n\t{reply, Reply, State}.\nhandle_cast(_Msg, State) ->\n\t{noreply, State}.\nhandle_info(_Info, State) ->\n\t{noreply, State}.\nterminate(_Reason, _State) ->\n\tok.\ncode_change(_OldVsn, State, _Extra) ->\n\t{ok, State}.\n%%%===================================================================\n%%% Internal functions\n%%%===================================================================",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gen_server"
        ],
        "opts": []
      },
      {
        "content": "-module(${0:`vim_snippets#Filename()`}).\n-behaviour(gen_fsm).\n%% API\n-export([start_link/0]).\n%% gen_fsm callbacks\n-export([init/1, state_name/2, state_name/3, handle_event/3, handle_sync_event/4,\n\thandle_info/3, terminate/3, code_change/4]).\n-record(state, {}).\n%%%===================================================================\n%%% API\n%%%===================================================================\n%%--------------------------------------------------------------------\n%% @doc\n%% Creates a gen_fsm process which calls Module:init/1 to\n%% initialize. To ensure a synchronized start-up procedure, this\n%% function does not return until Module:init/1 has returned.\n%%\n%% @spec start_link() -> {ok, Pid} | ignore | {error, Error}\n%% @end\n%%--------------------------------------------------------------------\nstart_link() ->\n\tgen_fsm:start_link({local, ?MODULE}, ?MODULE, [], []).\n%%%===================================================================\n%%% gen_fsm callbacks\n%%%===================================================================\n%%--------------------------------------------------------------------\n%% @private\n%% @doc\n%% Whenever a gen_fsm is started using gen_fsm:start/[3,4] or\n%% gen_fsm:start_link/[3,4], this function is called by the new\n%% process to initialize.\n%%\n%% @spec init(Args) -> {ok, StateName, State} |\n%%                     {ok, StateName, State, Timeout} |\n%%                     ignore |\n%%                     {stop, StopReason}\n%% @end\n%%--------------------------------------------------------------------\ninit([]) ->\n\t{ok, state_name, #state{}}.\n%%--------------------------------------------------------------------\n%% @private\n%% @doc\n%% There should be one instance of this function for each possible\n%% state name. Whenever a gen_fsm receives an event sent using\n%% gen_fsm:send_event/2, the instance of this function with the same\n%% name as the current state name StateName is called to handle\n%% the event. It is also called if a timeout occurs.\n%%\n%% @spec state_name(Event, State) ->\n%%                   {next_state, NextStateName, NextState} |\n%%                   {next_state, NextStateName, NextState, Timeout} |\n%%                   {stop, Reason, NewState}\n%% @end\n%%--------------------------------------------------------------------\nstate_name(_Event, State) ->\n\t{next_state, state_name, State}.\n%%--------------------------------------------------------------------\n%% @private\n%% @doc\n%% There should be one instance of this function for each possible\n%% state name. Whenever a gen_fsm receives an event sent using\n%% gen_fsm:sync_send_event/[2,3], the instance of this function with\n%% the same name as the current state name StateName is called to\n%% handle the event.\n%%\n%% @spec state_name(Event, From, State) ->\n%%                   {next_state, NextStateName, NextState} |\n%%                   {next_state, NextStateName, NextState, Timeout} |\n%%                   {reply, Reply, NextStateName, NextState} |\n%%                   {reply, Reply, NextStateName, NextState, Timeout} |\n%%                   {stop, Reason, NewState} |\n%%                   {stop, Reason, Reply, NewState}\n%% @end\n%%--------------------------------------------------------------------\nstate_name(_Event, _From, State) ->\n\tReply = ok,\n\t{reply, Reply, state_name, State}.\n%%--------------------------------------------------------------------\n%% @private\n%% @doc\n%% Whenever a gen_fsm receives an event sent using\n%% gen_fsm:send_all_state_event/2, this function is called to handle\n%% the event.\n%%\n%% @spec handle_event(Event, StateName, State) ->\n%%                   {next_state, NextStateName, NextState} |\n%%                   {next_state, NextStateName, NextState, Timeout} |\n%%                   {stop, Reason, NewState}\n%% @end\n%%--------------------------------------------------------------------\nhandle_event(_Event, StateName, State) ->\n\t{next_state, StateName, State}.\n%%--------------------------------------------------------------------\n%% @private\n%% @doc\n%% Whenever a gen_fsm receives an event sent using\n%% gen_fsm:sync_send_all_state_event/[2,3], this function is called\n%% to handle the event.\n%%\n%% @spec handle_sync_event(Event, From, StateName, State) ->\n%%                   {next_state, NextStateName, NextState} |\n%%                   {next_state, NextStateName, NextState, Timeout} |\n%%                   {reply, Reply, NextStateName, NextState} |\n%%                   {reply, Reply, NextStateName, NextState, Timeout} |\n%%                   {stop, Reason, NewState} |\n%%                   {stop, Reason, Reply, NewState}\n%% @end\n%%--------------------------------------------------------------------\nhandle_sync_event(_Event, _From, StateName, State) ->\n\tReply = ok,\n\t{reply, Reply, StateName, State}.\n%%--------------------------------------------------------------------\n%% @private\n%% @doc\n%% This function is called by a gen_fsm when it receives any\n%% message other than a synchronous or asynchronous event\n%% (or a system message).\n%%\n%% @spec handle_info(Info,StateName,State)->\n%%                   {next_state, NextStateName, NextState} |\n%%                   {next_state, NextStateName, NextState, Timeout} |\n%%                   {stop, Reason, NewState}\n%% @end\n%%--------------------------------------------------------------------\nhandle_info(_Info, StateName, State) ->\n\t{next_state, StateName, State}.\n%%--------------------------------------------------------------------\n%% @private\n%% @doc\n%% This function is called by a gen_fsm when it is about to\n%% terminate. It should be the opposite of Module:init/1 and do any\n%% necessary cleaning up. When it returns, the gen_fsm terminates with\n%% Reason. The return value is ignored.\n%%\n%% @spec terminate(Reason, StateName, State) -> void()\n%% @end\n%%--------------------------------------------------------------------\nterminate(_Reason, _StateName, _State) ->\n\tok.\n%%--------------------------------------------------------------------\n%% @private\n%% @doc\n%% Convert process state when code is changed\n%%\n%% @spec code_change(OldVsn, StateName, State, Extra) ->\n%%                   {ok, StateName, NewState}\n%% @end\n%%--------------------------------------------------------------------\ncode_change(_OldVsn, StateName, State, _Extra) ->\n\t{ok, StateName, State}.\n%%%===================================================================\n%%% Internal functions\n%%%===================================================================",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gen_fsm"
        ],
        "opts": []
      },
      {
        "content": "-module(${0:`vim_snippets#Filename()`}).\n-behaviour(gen_event).\n%% API\n-export([start_link/0,\n\tadd_handler/2]).\n%% gen_event callbacks\n-export([init/1,\n\thandle_event/2,\n\thandle_call/2,\n\thandle_info/2,\n\tterminate/2,\n\tcode_change/3]).\n-record(state, {}).\n%%%===================================================================\n%%% gen_event callbacks\n%%%===================================================================\n%%--------------------------------------------------------------------\n%% @doc\n%% Creates an event manager\n%%\n%% @spec start_link() -> {ok, Pid} | {error, Error}\n%% @end\n%%--------------------------------------------------------------------\nstart_link() ->\n\tgen_event:start_link({local, ?MODULE}).\n%%--------------------------------------------------------------------\n%% @doc\n%% Adds an event handler\n%%\n%% @spec add_handler(Handler, Args) -> ok | {'EXIT', Reason} | term()\n%% @end\n%%--------------------------------------------------------------------\nadd_handler(Handler, Args) ->\n\tgen_event:add_handler(?MODULE, Handler, Args).\n%%%===================================================================\n%%% gen_event callbacks\n%%%===================================================================\n%%--------------------------------------------------------------------\n%% @private\n%% @doc\n%% Whenever a new event handler is added to an event manager,\n%% this function is called to initialize the event handler.\n%%\n%% @spec init(Args) -> {ok, State}\n%% @end\n%%--------------------------------------------------------------------\ninit([]) ->\n\t{ok, #state{}}.\n%%--------------------------------------------------------------------\n%% @private\n%% @doc\n%% Whenever an event manager receives an event sent using\n%% gen_event:notify/2 or gen_event:sync_notify/2, this function is\n%% called for each installed event handler to handle the event.\n%%\n%% @spec handle_event(Event, State) ->\n%%                          {ok, State} |\n%%                          {swap_handler, Args1, State1, Mod2, Args2} |\n%%                          remove_handler\n%% @end\n%%--------------------------------------------------------------------\nhandle_event(_Event, State) ->\n\t{ok, State}.\n%%--------------------------------------------------------------------\n%% @private\n%% @doc\n%% Whenever an event manager receives a request sent using\n%% gen_event:call/3,4, this function is called for the specified\n%% event handler to handle the request.\n%%\n%% @spec handle_call(Request, State) ->\n%%                   {ok, Reply, State} |\n%%                   {swap_handler, Reply, Args1, State1, Mod2, Args2} |\n%%                   {remove_handler, Reply}\n%% @end\n%%--------------------------------------------------------------------\nhandle_call(_Request, State) ->\n\tReply = ok,\n\t{ok, Reply, State}.\n%%--------------------------------------------------------------------\n%% @private\n%% @doc\n%% This function is called for each installed event handler when\n%% an event manager receives any other message than an event or a\n%% synchronous request (or a system message).\n%%\n%% @spec handle_info(Info, State) ->\n%%                         {ok, State} |\n%%                         {swap_handler, Args1, State1, Mod2, Args2} |\n%%                         remove_handler\n%% @end\n%%--------------------------------------------------------------------\nhandle_info(_Info, State) ->\n\t{ok, State}.\n%%--------------------------------------------------------------------\n%% @private\n%% @doc\n%% Whenever an event handler is deleted from an event manager, this\n%% function is called. It should be the opposite of Module:init/1 and\n%% do any necessary cleaning up.\n%%\n%% @spec terminate(Reason, State) -> void()\n%% @end\n%%--------------------------------------------------------------------\nterminate(_Reason, _State) ->\n\tok.\n%%--------------------------------------------------------------------\n%% @private\n%% @doc\n%% Convert process state when code is changed\n%%\n%% @spec code_change(OldVsn, State, Extra) -> {ok, NewState}\n%% @end\n%%--------------------------------------------------------------------\ncode_change(_OldVsn, State, _Extra) ->\n\t{ok, State}.\n%%%===================================================================\n%%% Internal functions\n%%%===================================================================",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gen_event"
        ],
        "opts": []
      },
      {
        "content": "-module(${1:`vim_snippets#Filename()`}).\n-include_lib(\"eunit/include/eunit.hrl\").\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eunit"
        ],
        "opts": []
      },
      {
        "content": "-ifdef(TEST).\n-include_lib(\"eunit/include/eunit.hrl\").\n${0}\n-endif.",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ieunit"
        ],
        "opts": []
      },
      {
        "content": "-ifdef(TEST).\n${1}_test() ->\n\t${0}\n-endif.",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "itest"
        ],
        "opts": []
      },
      {
        "content": "${1}_test() ->\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "test"
        ],
        "opts": []
      },
      {
        "content": "?assert(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as"
        ],
        "opts": []
      },
      {
        "content": "?assertNot(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asn"
        ],
        "opts": []
      },
      {
        "content": "?assertEqual(${1}, ${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "aseq"
        ],
        "opts": []
      },
      {
        "content": "?assertNotEqual(${1}, ${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asneq"
        ],
        "opts": []
      },
      {
        "content": "?assertMatch(${1:Pattern}, ${0:Expression})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asmat"
        ],
        "opts": []
      },
      {
        "content": "?assertNotMatch(${1:Pattern}, ${0:Expression})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asnmat"
        ],
        "opts": []
      },
      {
        "content": "?assertError(${1:Pattern}, ${0:Expression})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "aserr"
        ],
        "opts": []
      },
      {
        "content": "?assertExit(${1:Pattern}, ${0:Expression})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asex"
        ],
        "opts": []
      },
      {
        "content": "?assertException(${1:Class}, ${2:Pattern}, ${0:Expression})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asexc"
        ],
        "opts": []
      },
      {
        "content": "-module(${0:`vim_snippets#Filename()`}).\n-include_lib(\"common_test/include/ct.hrl\").\n%% Test server callbacks\n-export([suite/0, all/0, groups/0,\n\tinit_per_suite/1, end_per_suite/1,\n\tinit_per_group/2, end_per_group/2,\n\tinit_per_testcase/2, end_per_testcase/2]).\n%% Test cases\n-export([\n\t]).\n%%--------------------------------------------------------------------\n%% COMMON TEST CALLBACK FUNCTIONS\n%%--------------------------------------------------------------------\n%%--------------------------------------------------------------------\n%% Function: suite() -> Info\n%%\n%% Info = [tuple()]\n%%   List of key/value pairs.\n%%\n%% Description: Returns list of tuples to set default properties\n%%              for the suite.\n%%\n%% Note: The suite/0 function is only meant to be used to return\n%% default data values, not perform any other operations.\n%%--------------------------------------------------------------------\nsuite() ->\n    [{timetrap,{minutes,10}}].\n%%--------------------------------------------------------------------\n%% Function: init_per_suite(Config0) ->\n%%               Config1 | {skip,Reason} | {skip_and_save,Reason,Config1}\n%%\n%% Config0 = Config1 = [tuple()]\n%%   A list of key/value pairs, holding the test case configuration.\n%% Reason = term()\n%%   The reason for skipping the suite.\n%%\n%% Description: Initialization before the suite.\n%%\n%% Note: This function is free to add any key/value pairs to the Config\n%% variable, but should NOT alter/remove any existing entries.\n%%--------------------------------------------------------------------\ninit_per_suite(Config) ->\n    Config.\n%%--------------------------------------------------------------------\n%% Function: end_per_suite(Config0) -> void() | {save_config,Config1}\n%%\n%% Config0 = Config1 = [tuple()]\n%%   A list of key/value pairs, holding the test case configuration.\n%%\n%% Description: Cleanup after the suite.\n%%--------------------------------------------------------------------\nend_per_suite(_Config) ->\n    ok.\n%%--------------------------------------------------------------------\n%% Function: init_per_group(GroupName, Config0) ->\n%%               Config1 | {skip,Reason} | {skip_and_save,Reason,Config1}\n%%\n%% GroupName = atom()\n%%   Name of the test case group that is about to run.\n%% Config0 = Config1 = [tuple()]\n%%   A list of key/value pairs, holding configuration data for the group.\n%% Reason = term()\n%%   The reason for skipping all test cases and subgroups in the group.\n%%\n%% Description: Initialization before each test case group.\n%%--------------------------------------------------------------------\ninit_per_group(_GroupName, Config) ->\n    Config.\n%%--------------------------------------------------------------------\n%% Function: end_per_group(GroupName, Config0) ->\n%%               void() | {save_config,Config1}\n%%\n%% GroupName = atom()\n%%   Name of the test case group that is finished.\n%% Config0 = Config1 = [tuple()]\n%%   A list of key/value pairs, holding configuration data for the group.\n%%\n%% Description: Cleanup after each test case group.\n%%--------------------------------------------------------------------\nend_per_group(_GroupName, _Config) ->\n    ok.\n%%--------------------------------------------------------------------\n%% Function: init_per_testcase(TestCase, Config0) ->\n%%               Config1 | {skip,Reason} | {skip_and_save,Reason,Config1}\n%%\n%% TestCase = atom()\n%%   Name of the test case that is about to run.\n%% Config0 = Config1 = [tuple()]\n%%   A list of key/value pairs, holding the test case configuration.\n%% Reason = term()\n%%   The reason for skipping the test case.\n%%\n%% Description: Initialization before each test case.\n%%\n%% Note: This function is free to add any key/value pairs to the Config\n%% variable, but should NOT alter/remove any existing entries.\n%%--------------------------------------------------------------------\ninit_per_testcase(_TestCase, Config) ->\n    Config.\n%%--------------------------------------------------------------------\n%% Function: end_per_testcase(TestCase, Config0) ->\n%%               void() | {save_config,Config1} | {fail,Reason}\n%%\n%% TestCase = atom()\n%%   Name of the test case that is finished.\n%% Config0 = Config1 = [tuple()]\n%%   A list of key/value pairs, holding the test case configuration.\n%% Reason = term()\n%%   The reason for failing the test case.\n%%\n%% Description: Cleanup after each test case.\n%%--------------------------------------------------------------------\nend_per_testcase(_TestCase, _Config) ->\n    ok.\n%%--------------------------------------------------------------------\n%% Function: groups() -> [Group]\n%%\n%% Group = {GroupName,Properties,GroupsAndTestCases}\n%% GroupName = atom()\n%%   The name of the group.\n%% Properties = [parallel | sequence | Shuffle | {RepeatType,N}]\n%%   Group properties that may be combined.\n%% GroupsAndTestCases = [Group | {group,GroupName} | TestCase]\n%% TestCase = atom()\n%%   The name of a test case.\n%% Shuffle = shuffle | {shuffle,Seed}\n%%   To get cases executed in random order.\n%% Seed = {integer(),integer(),integer()}\n%% RepeatType = repeat | repeat_until_all_ok | repeat_until_all_fail |\n%%              repeat_until_any_ok | repeat_until_any_fail\n%%   To get execution of cases repeated.\n%% N = integer() | forever\n%%\n%% Description: Returns a list of test case group definitions.\n%%--------------------------------------------------------------------\ngroups() ->\n    [].\n%%--------------------------------------------------------------------\n%% Function: all() -> GroupsAndTestCases | {skip,Reason}\n%%\n%% GroupsAndTestCases = [{group,GroupName} | TestCase]\n%% GroupName = atom()\n%%   Name of a test case group.\n%% TestCase = atom()\n%%   Name of a test case.\n%% Reason = term()\n%%   The reason for skipping all groups and test cases.\n%%\n%% Description: Returns the list of groups and test cases that\n%%              are to be executed.\n%%--------------------------------------------------------------------\nall() ->\n    [].\n%%--------------------------------------------------------------------\n%% TEST CASES\n%%--------------------------------------------------------------------\n%%--------------------------------------------------------------------\n%% Function: TestCase(Config0) ->\n%%               ok | exit() | {skip,Reason} | {comment,Comment} |\n%%               {save_config,Config1} | {skip_and_save,Reason,Config1}\n%%\n%% Config0 = Config1 = [tuple()]\n%%   A list of key/value pairs, holding the test case configuration.\n%% Reason = term()\n%%   The reason for skipping the test case.\n%% Comment = term()\n%%   A comment about the test case that will be printed in the html log.\n%%\n%% Description: Test case function. (The name of it must be specified in\n%%              the all/0 list or in a test case group for the test case\n%%              to be executed).\n%%--------------------------------------------------------------------",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "testsuite"
        ],
        "opts": []
      },
      {
        "content": "main(_) -> io:format(\"Hello, world!\\n\").",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "helloworld"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "-module(${0:module}).",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "-module"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "-export([${0:f/1}]).",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "-export"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "io:format(\"${1:~w~n}\"${2:, []})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ioformat"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "main(_) -> ${0}.",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "main"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "case ${0:TARGET} of\n    ${1}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "case",
        "matches": [
          "case"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "<<\"${0:TARGET}\">>",
        "doc": "",
        "grammar": "snu",
        "label": "<<\"...\">>",
        "matches": [
          "bs"
        ],
        "opts": []
      },
      {
        "content": "${1:pattern}${2: when ${3:guard}} ->\n\t${4:body}",
        "doc": null,
        "grammar": "snu",
        "label": "Case:Receive:Try Clause",
        "matches": [
          "pat"
        ],
        "opts": []
      },
      {
        "content": "-module(${1:`!p snip.rv = snip.basename or \"module\"`}).",
        "doc": null,
        "grammar": "snu",
        "label": "Module Directive",
        "matches": [
          "mod"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "[${1:X} || ${2:X} <- ${3:List}${4:, gen}]",
        "doc": null,
        "grammar": "snu",
        "label": "List Comprehension",
        "matches": [
          "||"
        ],
        "opts": []
      },
      {
        "content": "${1:X} <- ${2:List}${3:, gen}",
        "doc": null,
        "grammar": "snu",
        "label": "Generator Expression",
        "matches": [
          "gen"
        ],
        "opts": []
      }
    ],
    "eruby": [
      {
        "content": "<% ${0} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rc"
        ],
        "opts": []
      },
      {
        "content": "<%= ${1} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rce"
        ],
        "opts": []
      },
      {
        "content": "<% ${0} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "%"
        ],
        "opts": []
      },
      {
        "content": "<%= ${1} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "="
        ],
        "opts": []
      },
      {
        "content": "<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "end"
        ],
        "opts": []
      },
      {
        "content": "<% ${1}.each do |${2}| %>\n\t${0}\n<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ead"
        ],
        "opts": []
      },
      {
        "content": "<% for ${2:item} in ${1} %>\n\t${0}\n<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "<%= render partial: '${0:item}' %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rp"
        ],
        "opts": []
      },
      {
        "content": "<%= render partial: '${1:item}', locals: { :${2:name} => '${3:value}'${0} } %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rpl"
        ],
        "opts": []
      },
      {
        "content": "<%= render partial: '${1:item}', status: ${0:500} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rps"
        ],
        "opts": []
      },
      {
        "content": "<%= render partial: '${1:item}', collection: ${0:items} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rpc"
        ],
        "opts": []
      },
      {
        "content": "<%= link_to '${1:link text...}', action: '${0:index}' %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lia"
        ],
        "opts": []
      },
      {
        "content": "<%= link_to '${1:link text...}', action: '${2:edit}', id: ${0:@item} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "liai"
        ],
        "opts": []
      },
      {
        "content": "<%= link_to '${1:link text...}', controller: '${0:items}' %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lic"
        ],
        "opts": []
      },
      {
        "content": "<%= link_to '${1:link text...}', controller: '${2:items}', action: '${0:index}' %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lica"
        ],
        "opts": []
      },
      {
        "content": "<%= link_to '${1:link text...}', controller: '${2:items}', action: '${3:edit}', id: ${0:@item} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "licai"
        ],
        "opts": []
      },
      {
        "content": "<%= yield ${1::content_symbol} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yield"
        ],
        "opts": []
      },
      {
        "content": "<% content_for :${1:head} do %>\n\t${0}\n<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "conf"
        ],
        "opts": []
      },
      {
        "content": "<%= collection_select(:${1:object}, :${2:method}, ${3:collection}, :${4:value_method}, :${5:text_method}, options = {${0:prompt: true}}) %>        ",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cs"
        ],
        "opts": []
      },
      {
        "content": "<%= content_tag '${1:DIV}', ${2:content}${0:,options} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ct"
        ],
        "opts": []
      },
      {
        "content": "<%= form_for @${1:model} do |f| %>\n\t${0}\n<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ff"
        ],
        "opts": []
      },
      {
        "content": "<%= ${1:f}.input :${0:attribute} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ffi"
        ],
        "opts": []
      },
      {
        "content": "<%= ${1:f}.check_box :${0:attribute} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ffcb"
        ],
        "opts": []
      },
      {
        "content": "<% error_messages_for :${1:model} %>\n<%= form_for @${2:model} do |f| %>\n\t${0}\n<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ffe"
        ],
        "opts": []
      },
      {
        "content": "<%= ${1:f}.file_field :${0:attribute} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ffff"
        ],
        "opts": []
      },
      {
        "content": "<%= ${1:f}.hidden_field :${0:attribute} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ffhf"
        ],
        "opts": []
      },
      {
        "content": "<%= ${1:f}.label :${2:attribute}, '${0:$2}' %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ffl"
        ],
        "opts": []
      },
      {
        "content": "<%= ${1:f}.password_field :${0:attribute} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ffpf"
        ],
        "opts": []
      },
      {
        "content": "<%= ${1:f}.radio_button :${2:attribute}, :${0:tag_value} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ffrb"
        ],
        "opts": []
      },
      {
        "content": "<%= ${1:f}.submit \"${0:submit}\" %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ffs"
        ],
        "opts": []
      },
      {
        "content": "<%= ${1:f}.text_area :${0:attribute} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ffta"
        ],
        "opts": []
      },
      {
        "content": "<%= ${1:f}.text_field :${0:attribute} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fftf"
        ],
        "opts": []
      },
      {
        "content": "<%= ${1:f}.collection_select(:${2:method}, ${3:collection}, :${4:value_method}, :${5:text_method}, options = {${0:prompt: true}}) %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fcs"
        ],
        "opts": []
      },
      {
        "content": "<%= fields_for :${1:model}, @$1 do |${2:f}| %>\n\t${0}\n<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fields"
        ],
        "opts": []
      },
      {
        "content": "I18n.t('${1:type.key}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "i18"
        ],
        "opts": []
      },
      {
        "content": "<%= image_tag \"${1}\"${0} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "it"
        ],
        "opts": []
      },
      {
        "content": "<%= javascript_include_tag ${0::all} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jit"
        ],
        "opts": []
      },
      {
        "content": "<%= javascript_include_tag \"${0}\" %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jsit"
        ],
        "opts": []
      },
      {
        "content": "<%= link_to ${1:model}.${2:name}, ${3:$1}_path(${0:$1}) %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lim"
        ],
        "opts": []
      },
      {
        "content": "<%= link_to \"${1:Link text...}\", ${2:parent}_${3:child}_path(${4:@$2}, ${0:@$3}) %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "linp"
        ],
        "opts": []
      },
      {
        "content": "<%= link_to \"${1:Link text...}\", ${2:parent}_${3:child}_path(${0:@$2}) %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "linpp"
        ],
        "opts": []
      },
      {
        "content": "<%= link_to \"${1:Link text...}\", ${2:model}_path(${0:@$2}) %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lip"
        ],
        "opts": []
      },
      {
        "content": "<%= link_to \"${1:Link text...}\", ${0:model}s_path %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lipp"
        ],
        "opts": []
      },
      {
        "content": "<%= link_to \"${1:name}\", ${0:dest} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lt"
        ],
        "opts": []
      },
      {
        "content": "<%= number_to_currency(${1}) %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ntc"
        ],
        "opts": []
      },
      {
        "content": "<%= options_from_collection_for_select ${1:collection}, ${2:value_method}, ${3:text_method}, ${0:selected_value} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ofcfs"
        ],
        "opts": []
      },
      {
        "content": "<%= options_for_select ${1:collection}, ${2:value_method} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ofs"
        ],
        "opts": []
      },
      {
        "content": "<%= render file: \"${1:file}\"${0} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rf"
        ],
        "opts": []
      },
      {
        "content": "<%= render template: \"${1:file}\"${0} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rt"
        ],
        "opts": []
      },
      {
        "content": "<%= stylesheet_link_tag ${1::all}, cache: ${0:true} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "slt"
        ],
        "opts": []
      },
      {
        "content": "<%= stylesheet_link_tag \"${0}\" %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sslt"
        ],
        "opts": []
      },
      {
        "content": "<% if ${1} %>\n\t${0:${VISUAL}}\n<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "<% if ${1} %>\n\t${2}\n<% else %>\n\t${0}\n<% end %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "<% require 'pry'; binding.pry %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pry"
        ],
        "opts": []
      },
      {
        "content": "<%= ${1:TARGET} %>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "<%= %>",
        "matches": [
          "ruby_print"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<% ${1:TARGET} %>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "<% %>",
        "matches": [
          "ruby_code"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<%= ${1:TARGET} -%>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "<%= -%>",
        "matches": [
          "ruby_print_nonl"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<% ${1:TARGET} -%>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "<% -%>",
        "matches": [
          "ruby_code_nonl"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<%# ${1:TARGET} %>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "<%# %>",
        "matches": [
          "comment"
        ],
        "opts": [
          "word"
        ]
      }
    ],
    "falcon": [
      {
        "content": "#!/usr/bin/env falcon",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#!"
        ],
        "opts": []
      },
      {
        "content": "import ${0:module}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "imp"
        ],
        "opts": []
      },
      {
        "content": "function ${2:function_name}(${3})\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fun"
        ],
        "opts": []
      },
      {
        "content": "class ${1:class_name}(${2:class_params})\n\t${0:/* members/methods */}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "class"
        ],
        "opts": []
      },
      {
        "content": "if ${1:condition}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "if ${1:condition}\n\t${0}\nelse\n    ${1}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "elif ${1:condition}\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eif"
        ],
        "opts": []
      },
      {
        "content": "switch ${1:expression}\n\tcase ${2:item}\n\tcase ${0:item}\n\tdefault\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "switch"
        ],
        "opts": []
      },
      {
        "content": "select ${1:variable}\n\tcase ${2:TypeSpec}\n\tcase ${0:TypeSpec}\n\tdefault\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "select"
        ],
        "opts": []
      },
      {
        "content": "for ${1:element} in ${2:container}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forin"
        ],
        "opts": []
      },
      {
        "content": "for ${1:lowerbound} to ${2:upperbound}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forto"
        ],
        "opts": []
      },
      {
        "content": "while ${1:conidition}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh"
        ],
        "opts": []
      }
    ],
    "fortran": [
      {
        "content": "program ${1:main}\n\t${2}\nend program $1",
        "doc": "",
        "grammar": "snu",
        "label": "program",
        "matches": [
          "pr"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "subroutine ${1:`expand('%:r')`}(${2})\n\tuse ${3:comvar}\n\timplicit none\n\t${4}\nend subroutine $1",
        "doc": "",
        "grammar": "snu",
        "label": "subroutine",
        "matches": [
          "sua"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "subroutine ${1:`expand('%:r')`}\n\tuse ${2:comvar}\n\timplicit none\n\t${3}\nend subroutine $1",
        "doc": "",
        "grammar": "snu",
        "label": "subroutine",
        "matches": [
          "su"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "module ${1:`expand('%:r')`}\n\timplicit none\n\tsave\n\t${2}\nend module $1",
        "doc": "",
        "grammar": "snu",
        "label": "module",
        "matches": [
          "mo"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "function ${1:}(${2})\n\t${3}\nend function $1",
        "doc": "",
        "grammar": "snu",
        "label": "function",
        "matches": [
          "fu"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "integer, parameter :: ",
        "doc": "",
        "grammar": "snu",
        "label": "integer parameter",
        "matches": [
          "inp"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "integer :: ",
        "doc": "",
        "grammar": "snu",
        "label": "integer",
        "matches": [
          "in"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "integer, intent(in)  :: ",
        "doc": "",
        "grammar": "snu",
        "label": "integer intent(in)",
        "matches": [
          "ini"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "integer, intent(out) :: ",
        "doc": "",
        "grammar": "snu",
        "label": "integer intent(out)",
        "matches": [
          "ino"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "real, parameter :: ",
        "doc": "",
        "grammar": "snu",
        "label": "real parameter",
        "matches": [
          "rep"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "real :: ",
        "doc": "",
        "grammar": "snu",
        "label": "real",
        "matches": [
          "re"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "real, intent(in)  :: ",
        "doc": "",
        "grammar": "snu",
        "label": "real intent(in)",
        "matches": [
          "rei"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "real, intent(out) :: ",
        "doc": "",
        "grammar": "snu",
        "label": "real intent(out)",
        "matches": [
          "reo"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "integer, dimension(${1::})${2:#:, allocatable} :: ${3}",
        "doc": "",
        "grammar": "snu",
        "label": "integer dimension",
        "matches": [
          "ind"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "integer, dimension(${1}), intent(in)  :: ${2}",
        "doc": "",
        "grammar": "snu",
        "label": "integer dimension intent(in)",
        "matches": [
          "indi"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "integer, dimension(${1}), intent(out) :: ${2}",
        "doc": "",
        "grammar": "snu",
        "label": "integer dimension intent(out)",
        "matches": [
          "indo"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "real, dimension(${1::})${2:#:, allocatable} :: ${3}",
        "doc": "",
        "grammar": "snu",
        "label": "real dimension",
        "matches": [
          "red"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "real, dimension(${1}), intent(in)  :: ${2}",
        "doc": "",
        "grammar": "snu",
        "label": "real dimension intent(in)",
        "matches": [
          "redi"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "real, dimension(${1}), intent(out) :: ${2}",
        "doc": "",
        "grammar": "snu",
        "label": "real dimension intent(out)",
        "matches": [
          "redo"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "character(${1}) :: ${2}",
        "doc": "",
        "grammar": "snu",
        "label": "character",
        "matches": [
          "ch"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "character(${1}), dimension(${2}) :: ${3}",
        "doc": "",
        "grammar": "snu",
        "label": "character dimension",
        "matches": [
          "chd"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "logical :: ${1:fileExsit}",
        "doc": "",
        "grammar": "snu",
        "label": "logical",
        "matches": [
          "lo"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "if (${1}) ${2}",
        "doc": "",
        "grammar": "snu",
        "label": "if",
        "matches": [
          "if"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "if (${1}) then\n\t${2}\nend if",
        "doc": "",
        "grammar": "snu",
        "label": "if then",
        "matches": [
          "ift"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "read(${1:*},${2:*}) ${3}",
        "doc": "",
        "grammar": "snu",
        "label": "read",
        "matches": [
          "read"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "write(${1:*},${2:*}) ${3}",
        "doc": "",
        "grammar": "snu",
        "label": "write",
        "matches": [
          "wr"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "open(${1:11},file=${2},status=${3:#:old}${4:#:,position='append'})\n${5}\nclose($1)",
        "doc": "",
        "grammar": "snu",
        "label": "open",
        "matches": [
          "op"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "select case (${1})\n${2}\nend select",
        "doc": "",
        "grammar": "snu",
        "label": "select case",
        "matches": [
          "se"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "case(${1})\n\t${2}",
        "doc": "",
        "grammar": "snu",
        "label": "case",
        "matches": [
          "case"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "do ${1}\nend do",
        "doc": "",
        "grammar": "snu",
        "label": "do",
        "matches": [
          "do"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "type ${1:}\n\t${2}\nend type $1",
        "doc": "",
        "grammar": "snu",
        "label": "type",
        "matches": [
          "ty"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "type(${1}), dimension(${2::}), allcatable :: ${3}",
        "doc": "",
        "grammar": "snu",
        "label": "type dimension",
        "matches": [
          "tyd"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "implicit none\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "impl"
        ],
        "opts": []
      },
      {
        "content": "program ${1:main}\n\t${0}\nend program $1",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prog"
        ],
        "opts": []
      },
      {
        "content": "module ${1:modulename}\n\t${0}\nend module $1",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mod"
        ],
        "opts": []
      },
      {
        "content": "procedure ${1:name}\n\t${0}\nend procedure $1",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "proc"
        ],
        "opts": []
      },
      {
        "content": "interface ${1:name}\n\t${0}\nend interface $1",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "iface"
        ],
        "opts": []
      },
      {
        "content": "! \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n! File: ${2:`vim_snippets#Filename('$1')`}\n! Author: `g:snips_author`\n! Email: `g:snips_email`\n! Github: `g:snips_github`\n! Description: $1\n! \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doc"
        ],
        "opts": []
      },
      {
        "content": "!> @brief ${1}\n!!\n!> ${2}\n!> @author `g:snips_author`\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dox"
        ],
        "opts": []
      },
      {
        "content": "!> @param[${1}]${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doxp"
        ],
        "opts": []
      },
      {
        "content": "logical :: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bool"
        ],
        "opts": []
      },
      {
        "content": "integer :: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "int"
        ],
        "opts": []
      },
      {
        "content": "real :: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "real"
        ],
        "opts": []
      },
      {
        "content": "double precision :: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "double"
        ],
        "opts": []
      },
      {
        "content": "character(len=${1:*}) :: ${0:}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "str"
        ],
        "opts": []
      },
      {
        "content": "type(${1:name})\n\t${0}\nend type",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "type"
        ],
        "opts": []
      },
      {
        "content": "${1:type}, parameter :: $2 = ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "const"
        ],
        "opts": []
      },
      {
        "content": "${1:type}, ${2:allocatable, }dimension(${3::}) :: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "arr"
        ],
        "opts": []
      },
      {
        "content": "${1:type}, intent(inout) :: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "intent"
        ],
        "opts": []
      },
      {
        "content": "(/ $1 /) ${2:,&} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "/"
        ],
        "opts": []
      },
      {
        "content": "if (${1:condition}) then\n\t${0}\nend if",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "select case (${1:expr})\n\tcase ($2)\n\tcase default\n\t\t$3\nend select ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case"
        ],
        "opts": []
      },
      {
        "content": "do ${1:i} = ${2:start}, ${3:end}, ${4:incr}\n\t${0}\nend do",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "do"
        ],
        "opts": []
      },
      {
        "content": "do while (${1:condition})\n\t$2\nend do",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dow"
        ],
        "opts": []
      },
      {
        "content": "subroutine ${1:name}($2)\n\t${0}\nend subroutine $1",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sub"
        ],
        "opts": []
      },
      {
        "content": "function ${1:name}($2) result($3)\n\t${0}\nend function $1",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "func"
        ],
        "opts": []
      },
      {
        "content": "write(*,*) ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pr"
        ],
        "opts": []
      },
      {
        "content": "write(*,*) '$1 = ', $1",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dpr"
        ],
        "opts": []
      },
      {
        "content": "read(unit = ${1:fp}, file = ${2:filename}, iostat = ${3:ierr}) ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "read"
        ],
        "opts": []
      },
      {
        "content": "write(unit = ${1:fp}, file = ${2:filename}, iostat = ${3:ierr}) ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "write"
        ],
        "opts": []
      },
      {
        "content": "open(unit = ${1:fp}, file = ${2:filename}, status = ${3:unknown}, iostat = ${4:ierr}) ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "open"
        ],
        "opts": []
      },
      {
        "content": "close(unit = ${1:fp}) ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "close"
        ],
        "opts": []
      }
    ],
    "framer-motion": [
      {
        "content": "import { motion } from 'framer-motion'",
        "doc": null,
        "grammar": "lsp",
        "label": "framer-import",
        "matches": [
          "framer-motion import"
        ],
        "opts": []
      },
      {
        "content": "<motion.${1:div}\n  initial=\"${2:hidden}\"\n  animate=\"${3:visible}\"\n></motion.${1:div}>",
        "doc": null,
        "grammar": "lsp",
        "label": "framer-motion",
        "matches": [
          "motion",
          "framer-motion motion"
        ],
        "opts": []
      },
      {
        "content": "const ${1:variants} = {\n  ${2:hidden}: {\n    ${3:style}\n  },\n  ${4:visible}: {\n    ${5:style}\n  },\n};",
        "doc": null,
        "grammar": "lsp",
        "label": "framer-variants",
        "matches": [
          "framer-motion variants",
          "variants"
        ],
        "opts": []
      },
      {
        "content": "const ${1:sequence} = async () => {\n  await ${2:animateControls}.start({ ${5:opacity: 1} })\n}",
        "doc": "sequence for animation controls",
        "grammar": "lsp",
        "label": "framer-sequence",
        "matches": [
          "sequence",
          "framer-motion sequence"
        ],
        "opts": []
      },
      {
        "content": "const ${controls} = useAnimation()",
        "doc": "useAnimation()\nuseAnimation hook can be used to create a set of imperative AnimationControls with a start and stop method.",
        "grammar": "lsp",
        "label": "framer-use-animation",
        "matches": [
          "use-animation",
          "framer-motion use-animation"
        ],
        "opts": []
      },
      {
        "content": "${1:controls}.start({ ${2:opacity: 1} })",
        "doc": "AnimationControls with a start and stop method",
        "grammar": "lsp",
        "label": "framer-animation-controls",
        "matches": [
          "framer-motion controls",
          "controls"
        ],
        "opts": []
      },
      {
        "content": "const ${1:scale} = useMotionValue(${2:1})",
        "doc": "useMotionValue()\nCreates a MotionValue to track the state and velocity of a value.",
        "grammar": "lsp",
        "label": "framer-use-motion-value",
        "matches": [
          "framer-motion use-motion-value",
          "use-motion-value"
        ],
        "opts": []
      },
      {
        "content": "const ${1:y} = useTransform(${2:x}, ${3:value => value * 2})",
        "doc": "useTransform()\nCreate a MotionValue that transforms the output of another MotionValue through a function.",
        "grammar": "lsp",
        "label": "framer-use-transform",
        "matches": [
          "use-transform",
          "framer-motion use-transform"
        ],
        "opts": []
      },
      {
        "content": "const ${1:x} = useSpring(${2:0}, { ${3:stiffness}: ${4:300} })",
        "doc": "useSpring()\nCreates a MotionValue that, when set, will use a spring animation to animate to its new state.",
        "grammar": "lsp",
        "label": "framer-use-spring",
        "matches": [
          "use-spring",
          "framer-motion use-spring"
        ],
        "opts": []
      },
      {
        "content": "const { ${1:scrollYProgress} } = useElementScroll(${2:ref})",
        "doc": "useElementScroll(ref): Returns MotionValues that update when the provided element scrolls.",
        "grammar": "lsp",
        "label": "framer-use-element-scroll",
        "matches": [
          "framer-motion use-element-scroll",
          "use-element-scroll"
        ],
        "opts": []
      },
      {
        "content": "const { ${scrollYProgress} } = useViewportScroll()",
        "doc": "useViewportScroll(): ScrollMotionValues Returns MotionValues that update when the viewport scrolls.",
        "grammar": "lsp",
        "label": "framer-use-viewport-scroll",
        "matches": [
          "use-viewport-scroll",
          "framer-motion use-viewport-scroll"
        ],
        "opts": []
      },
      {
        "content": "const { ${1:scaleX}, ${2:scaleY} } = useInvertedScale()",
        "doc": "useInvertedScale(scale): ScaleMotionValues Returns a MotionValue each for scaleX and scaleY that update with the inverse of their respective parent scales.",
        "grammar": "lsp",
        "label": "framer-use-inverted-scale",
        "matches": [
          "framer-motion use-inverted-scale",
          "use-inverted-scale"
        ],
        "opts": []
      },
      {
        "content": "const [${1:x}, ${2:cycleX}] = useCycle(${3:0}, ${4:50}, ${5:100})",
        "doc": "useCycle(items): CycleState It works similar to useState in React. It is provided an initial array of possible states, and returns an array of two arguments.",
        "grammar": "lsp",
        "label": "framer-use-cycle",
        "matches": [
          "use-cycle",
          "framer-motion use-cycle"
        ],
        "opts": []
      },
      {
        "content": "const ${shouldReduceMotion} = useReducedMotion()",
        "doc": "A hook that returns true if we should be using reduced motion based on the current device's Reduced Motion setting.",
        "grammar": "lsp",
        "label": "framer-use-reduce-motion",
        "matches": [
          "use-reduce-motion",
          "framer-motion use-reduce-motion"
        ],
        "opts": []
      },
      {
        "content": "const [${1:isPresent}, ${2:safeToRemove}] = usePresence()",
        "doc": "usePresence()\nIf isPresent is false, it means that a component has been removed the tree, but AnimatePresence won't really remove it until safeToRemove has been called.",
        "grammar": "lsp",
        "label": "framer-use-presence",
        "matches": [
          "use-presence",
          "framer-motion use-presence"
        ],
        "opts": []
      },
      {
        "content": "const ${dragControls} = useDragControls()",
        "doc": "useDragControls()\nBy creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop.",
        "grammar": "lsp",
        "label": "framer-use-drag-controls",
        "matches": [
          "use-drag-controls",
          "framer-motion use-drag-controls"
        ],
        "opts": []
      },
      {
        "content": "import { motion, AnimatePresence } from \"framer-motion\"",
        "doc": null,
        "grammar": "lsp",
        "label": "framer-animate-presence-import",
        "matches": [
          "framer-motion import animate-presence",
          "animate-presence"
        ],
        "opts": []
      },
      {
        "content": "<AnimatePresence>\n    {${1:isVisible} && (\n      <motion.div\n        initial={{ ${3:style} }}\n        animate={{ ${4:style} }}\n        exit={{ ${5:style} }}\n      />\n    )}\n</AnimatePresence>",
        "doc": "AnimatePresence allows components to animate out when they're removed from the React tree.",
        "grammar": "lsp",
        "label": "framer-animate-presence",
        "matches": [
          "animate-presence",
          "framer-motion animate-presence"
        ],
        "opts": []
      },
      {
        "content": "import { motion, AnimateSharedLayout } from \"framer-motion\"",
        "doc": null,
        "grammar": "lsp",
        "label": "framer-import-animate-shared-layout",
        "matches": [
          "framer-motion import animate-shared-layout",
          "animate-presence"
        ],
        "opts": []
      },
      {
        "content": "<AnimateSharedLayout>\n</AnimateSharedLayout>",
        "doc": "Animate between different components that share a layout ID",
        "grammar": "lsp",
        "label": "framer-animate-shared-layout",
        "matches": [
          "animate-shared-layout",
          "framer-motion animate-shared-layout"
        ],
        "opts": []
      }
    ],
    "freemarker": [
      {
        "content": "\\${.version}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ver \"${.version}\""
        ],
        "opts": []
      },
      {
        "content": "\\${${0:interpolation${VISUAL}}\\}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "int \"${interpolation}\""
        ],
        "opts": []
      },
      {
        "content": "\\${${0:interpolation${VISUAL}}!\"${1:default_string}\"\\}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "intd \"${interpolation!\"default_string\"}\""
        ],
        "opts": []
      },
      {
        "content": "<#-- ${0:comment${VISUAL}} -->",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "com \"<#-- comment -->\""
        ],
        "opts": []
      },
      {
        "content": "<#assign ${1:variable_name} = ${0:value${VISUAL}} />",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ass \"<#assign variable_name = value />\""
        ],
        "opts": []
      },
      {
        "content": "<#assign\n\t${1:variable_name} = ${0:value${VISUAL}}\n/>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "assm \"<#assign <#-- multiple lines --> />\""
        ],
        "opts": []
      },
      {
        "content": "<#local ${1:variable_name} = ${0:value${VISUAL}} />",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "loc \"<#local variable_name = value />\""
        ],
        "opts": []
      },
      {
        "content": "<#local\n\t${1:variable_name} = ${0:value${VISUAL}}\n/>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "locm \"<#local <#-- multiple lines --> />\""
        ],
        "opts": []
      },
      {
        "content": "<#include \"${0:file.ftl${VISUAL}}\" />",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "inc \"<#include \\\"file.ftl\\\" />\""
        ],
        "opts": []
      },
      {
        "content": "<#if ${1:true}>\n\t${0:${VISUAL}}\n</#if>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if \"<#if condition>...</#if>\""
        ],
        "opts": []
      },
      {
        "content": "<#if ${1:true}>\n\t${0:${VISUAL}}\n<#else>\n\t${2}\n</#if>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife \"<#if condition>...<#else>...</#if>\""
        ],
        "opts": []
      },
      {
        "content": "<#list ${1:sequence} as ${2:element}>\n\t${0:${VISUAL}}\n</#list>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lis \"<#list sequence as element>...</#list>\""
        ],
        "opts": []
      },
      {
        "content": "<#list ${1:hashmap}?keys as ${2:key}>\n\t\\${$2\\}: \\${$1[$2]\\}${0:${VISUAL}}\n</#list>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lish \"<#list hashmap?keys as element>...</#list>\""
        ],
        "opts": []
      },
      {
        "content": "<#macro ${1:macro_name} ${2:param1}>\n\t${0:${VISUAL}}\n</#macro>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mac \"<#macro macro_name param1>...</#macro>\""
        ],
        "opts": []
      },
      {
        "content": "<#function ${1:function_name} ${2:param1}>\n\t${0:${VISUAL}}\n</#function>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fun \"<#function function_name param1>...</#function>\""
        ],
        "opts": []
      },
      {
        "content": "<#attempt>\n\t${0:${VISUAL}}\n<#recover>\n</#attempt>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "att \"<#attempt>...<#recover></#attempt>\""
        ],
        "opts": []
      },
      {
        "content": "?then(${1:true}, ${0:false${VISUAL}})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "?th \"?then(true, false)\""
        ],
        "opts": []
      }
    ],
    "fsharp": [
      {
        "content": "/// ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doc"
        ],
        "opts": []
      },
      {
        "content": "// ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "comment"
        ],
        "opts": []
      },
      {
        "content": "let ${1} = ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "let"
        ],
        "opts": []
      },
      {
        "content": "[<Literal>]\nlet ${1} = ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lit"
        ],
        "opts": []
      },
      {
        "content": "type ${1} = { ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rec"
        ],
        "opts": []
      },
      {
        "content": "{| ${0} |}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "arec"
        ],
        "opts": []
      },
      {
        "content": "let ${1} =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fn"
        ],
        "opts": []
      },
      {
        "content": "let rec ${1} =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fnr"
        ],
        "opts": []
      },
      {
        "content": "(fun ${1} -> ${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lam"
        ],
        "opts": []
      },
      {
        "content": "module ${1} =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mod"
        ],
        "opts": []
      },
      {
        "content": "for ${1} in ${2} do\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "if ${1} then\n\t${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "if ${1} then\n\t${2}\nelse\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "if ${1} then\n\t${2}\nelif ${3} then\n\t${4}\nelse\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifee"
        ],
        "opts": []
      },
      {
        "content": "elif ${1} then\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eif"
        ],
        "opts": []
      },
      {
        "content": "else\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "el"
        ],
        "opts": []
      },
      {
        "content": "try\n\t${1}\nwith ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "try"
        ],
        "opts": []
      },
      {
        "content": "match ${1} with\n| ${2} -> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "match"
        ],
        "opts": []
      },
      {
        "content": "| ${1} -> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "|"
        ],
        "opts": []
      },
      {
        "content": "|> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p"
        ],
        "opts": []
      },
      {
        "content": "printfn \"${1}\" ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pr"
        ],
        "opts": []
      },
      {
        "content": "printfn \\$\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pri"
        ],
        "opts": []
      },
      {
        "content": "|> Array.map (fun ${1} -> ${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "amap"
        ],
        "opts": []
      },
      {
        "content": "|> List.map (fun ${1} -> ${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lmap"
        ],
        "opts": []
      },
      {
        "content": "|> Seq.map (fun ${1} -> ${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "smap"
        ],
        "opts": []
      },
      {
        "content": "|> Array.map (fun x -> printfn \"%A\" x; x) // tap",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "atap"
        ],
        "opts": []
      },
      {
        "content": "|> List.map (fun x -> printfn \"%A\" x; x) // tap",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ltap"
        ],
        "opts": []
      },
      {
        "content": "|> Seq.map (fun x -> printfn \"%A\" x; x) // tap",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "stap"
        ],
        "opts": []
      },
      {
        "content": "[<EntryPoint>]\nlet main argv =\n\t${0}\n\t0",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "main"
        ],
        "opts": []
      },
      {
        "content": "if ${1:TARGET}\nthen ${2}\nelse ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "if..then..else",
        "matches": [
          "If"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "if ${1:TARGET} then ${2} else ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "if..then..else - oneline",
        "matches": [
          "if"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "match ${1:TARGET} with\n| ${2} -> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "match",
        "matches": [
          "match"
        ],
        "opts": []
      },
      {
        "content": "(fun ${1:x} -> ${2:x})",
        "doc": "",
        "grammar": "snu",
        "label": "(fun x -> ..)",
        "matches": [
          "fun"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "[| ${0:TARGET} |]",
        "doc": "",
        "grammar": "snu",
        "label": "array literal [| |]",
        "matches": [
          "arl"
        ],
        "opts": []
      },
      {
        "content": "[<${0:TARGET}>]",
        "doc": "",
        "grammar": "snu",
        "label": "attribute [<..>]",
        "matches": [
          "att"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "#if ${1}\n  ${2:TARGET}\n#endif",
        "doc": "",
        "grammar": "snu",
        "label": "#if .. #endif",
        "matches": [
          "#if"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "#if ${1}\n  ${2}\nelse\n  #{3}\n#endif",
        "doc": "",
        "grammar": "snu",
        "label": "#if .. else .. #endif",
        "matches": [
          "#ife"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "__SOURCE_DIRECTORY__",
        "doc": "",
        "grammar": "snu",
        "label": "__SOURCE_DIRECTORY__",
        "matches": [
          "sourced"
        ],
        "opts": []
      },
      {
        "content": "__LINE__",
        "doc": "",
        "grammar": "snu",
        "label": "__LINE__",
        "matches": [
          "line"
        ],
        "opts": []
      },
      {
        "content": "__SOURCE_FILE__",
        "doc": "",
        "grammar": "snu",
        "label": "__FILE__",
        "matches": [
          "sourcef"
        ],
        "opts": []
      }
    ],
    "gatsby": [
      {
        "content": "import { graphql } from 'gatsby';",
        "doc": null,
        "grammar": "lsp",
        "label": "gatsby-graphql-import",
        "matches": [
          "gatsby import graphql"
        ],
        "opts": []
      },
      {
        "content": "import { useStaticQuery, graphql } from \"gatsby\"",
        "doc": null,
        "grammar": "lsp",
        "label": "gatsby-usestaticquery-import",
        "matches": [
          "gatsby import usestaticquery"
        ],
        "opts": []
      },
      {
        "content": "const {${1:site}} = useStaticQuery(\n  graphql`${2:query}`\n);",
        "doc": null,
        "grammar": "lsp",
        "label": "gatsby-usestatic-query",
        "matches": [
          "gatsby usestaticquery"
        ],
        "opts": []
      },
      {
        "content": "export const query = graphql`${1:query}`;",
        "doc": "Gatsby uses the concept of a page query, which is a query for a specific page in a site.Note that you can only have one page query per file.",
        "grammar": "lsp",
        "label": "gatsby-export-query",
        "matches": [
          "gatsby export query"
        ],
        "opts": []
      },
      {
        "content": "<Link to=\"${1:/blog}\">${2:Text}</Link>",
        "doc": null,
        "grammar": "lsp",
        "label": "gatsby-link",
        "matches": [
          "gatsby link"
        ],
        "opts": []
      },
      {
        "content": "<Link to=\"${1:/blog}\" activeStyle={{ ${2:color}: \"${3:red}\" }} >Text</Link>",
        "doc": null,
        "grammar": "lsp",
        "label": "gatsby-link-activestyle",
        "matches": [
          "gatsby link activestyle"
        ],
        "opts": []
      },
      {
        "content": "<Link to=\"${1:/blog}\" activeClassName={\"${2:myActiveClassName}\"} >Text</Link>",
        "doc": null,
        "grammar": "lsp",
        "label": "gatsby-link-activeclassname",
        "matches": [
          "gatsby link activeclassname"
        ],
        "opts": []
      },
      {
        "content": "import { Link } from \"gatsby\"",
        "doc": null,
        "grammar": "lsp",
        "label": "gatsby-link-import",
        "matches": [
          "gatsby link import"
        ],
        "opts": []
      }
    ],
    "gatsby-image": [
      {
        "content": "const {\n  ${1:queryName}: { childImageSharp: {fluid: ${2:imageFluid}}}\n} = useStaticQuery(graphql`\n  query {\n    ${1:queryName}: file(relativePath: { eq: \"${3:imagePath.png}\" }) {\n      childImageSharp {\n        fluid(maxWidth: ${4:300}) {\n          ...${5|GatsbyImageSharpFluid,GatsbyImageSharpFluid_noBase64,GatsbyImageSharpFluid_tracedSVG,GatsbyImageSharpFluid_withWebp,GatsbyImageSharpFluid_withWebp_noBase64,GatsbyImageSharpFluid_withWebp_tracedSVG|}\n        }\n      }\n    }\n  }\n`)",
        "doc": null,
        "grammar": "lsp",
        "label": "gatsby-image-usestaticquery-fluid",
        "matches": [
          "gatsby-image usestaticquery fluid"
        ],
        "opts": []
      },
      {
        "content": "const {\n  ${1:queryName}: { childImageSharp: {fixed: ${2:imageFixed}}}\n} = useStaticQuery(graphql`\n  query {\n    ${1:queryName}: file(relativePath: { eq: \"${3:imagePath.png}\" }) {\n      childImageSharp {\n        fixed(width: ${4:300}) {\n          ...${5|GatsbyImageSharpFixed,GatsbyImageSharpFixed_noBase64,GatsbyImageSharpFixed_tracedSVG,GatsbyImageSharpFixed_withWebp,GatsbyImageSharpFixed_withWebp_noBase64,GatsbyImageSharpFixed_withWebp_tracedSVG|}\n        }\n      }\n    }\n  }\n`)",
        "doc": null,
        "grammar": "lsp",
        "label": "gatsby-image-usestaticquery-fixed",
        "matches": [
          "gatsby-image usestaticquery fixed"
        ],
        "opts": []
      },
      {
        "content": "import ${1:Img} from 'gatsby-image';",
        "doc": null,
        "grammar": "lsp",
        "label": "gatsby-image-import",
        "matches": [
          "gatsby-image import"
        ],
        "opts": []
      },
      {
        "content": "import ${1:Img} from \"gatsby-image/withIEPolyfill\"",
        "doc": null,
        "grammar": "lsp",
        "label": "gatsby-image-import-withiepolyfill",
        "matches": [
          "gatsby-image import withiepolyfill"
        ],
        "opts": []
      }
    ],
    "gitcommit": [
      {
        "content": "Co-authored-by: ${1} <${2}>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "co"
        ],
        "opts": []
      },
      {
        "content": "fix(${1:scope}): ${2:title}\n\n${0:${VISUAL}}",
        "doc": null,
        "grammar": "snu",
        "label": "fix conventional commit",
        "matches": [
          "fix"
        ],
        "opts": []
      },
      {
        "content": "feat(${1:scope}): ${2:title}\n\n${0:${VISUAL}}",
        "doc": null,
        "grammar": "snu",
        "label": "feat conventional commit",
        "matches": [
          "feat"
        ],
        "opts": []
      },
      {
        "content": "chore(${1:scope}): ${2:title}\n\n${0:${VISUAL}}",
        "doc": null,
        "grammar": "snu",
        "label": "chore conventional commit",
        "matches": [
          "chore"
        ],
        "opts": []
      },
      {
        "content": "docs(${1:scope}): ${2:title}\n\n${0:${VISUAL}}",
        "doc": null,
        "grammar": "snu",
        "label": "docs conventional commit",
        "matches": [
          "docs"
        ],
        "opts": []
      },
      {
        "content": "improvement(${1:scope}): ${2:title}\n\n${0:${VISUAL}}",
        "doc": null,
        "grammar": "snu",
        "label": "improvement conventional commit",
        "matches": [
          "improvement"
        ],
        "opts": []
      },
      {
        "content": "perf(${1:scope}): ${2:title}\n\n${0:${VISUAL}}",
        "doc": null,
        "grammar": "snu",
        "label": "perf conventional commit",
        "matches": [
          "perf"
        ],
        "opts": []
      },
      {
        "content": "refactor(${1:scope}): ${2:title}\n\n${0:${VISUAL}}",
        "doc": null,
        "grammar": "snu",
        "label": "refactor conventional commit",
        "matches": [
          "refactor"
        ],
        "opts": []
      },
      {
        "content": "test(${1:scope}): ${2:title}\n\n${0:${VISUAL}}",
        "doc": null,
        "grammar": "snu",
        "label": "test conventional commit",
        "matches": [
          "test"
        ],
        "opts": []
      },
      {
        "content": "ci(${1:scope}): ${2:title}\n\n${0:${VISUAL}}",
        "doc": null,
        "grammar": "snu",
        "label": "ci conventional commit",
        "matches": [
          "ci"
        ],
        "opts": []
      },
      {
        "content": "build(${1:scope}): ${2:title}\n\n${0:${VISUAL}}",
        "doc": null,
        "grammar": "snu",
        "label": "build conventional commit",
        "matches": [
          "build"
        ],
        "opts": []
      }
    ],
    "gnuplot": [
      {
        "content": "set ${1:#:axis}range [${2:*}:${3:*}]",
        "doc": "",
        "grammar": "snu",
        "label": "set x/y range.",
        "matches": [
          "range"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "set xrange [${1:*}:${2:*}]",
        "doc": "",
        "grammar": "snu",
        "label": "set xrange [X1:X2]",
        "matches": [
          "xrange"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "set yrange [${1:*}:${2:*}]",
        "doc": "",
        "grammar": "snu",
        "label": "set yrange [Y1:Y2]",
        "matches": [
          "yrange"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "set title ${1:#:title}",
        "doc": "",
        "grammar": "snu",
        "label": "set title '...'",
        "matches": [
          "title"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "set ${1:#:axis}label ${2:#:label}",
        "doc": "",
        "grammar": "snu",
        "label": "set title '...'",
        "matches": [
          "labelaxis"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "set ${1:#:axis}tics ${2:#:start}, ${3:#:incr}, ${4:#:end}",
        "doc": "",
        "grammar": "snu",
        "label": "set x/y tics start, incr, end",
        "matches": [
          "tics"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "set xtics ${1:#:start}, ${2:#:incr}, ${3:#:end}",
        "doc": "",
        "grammar": "snu",
        "label": "set xtics start, incr, end",
        "matches": [
          "xtics"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "set ytics ${1:#:start}, ${2:#:incr}, ${3:#:end}",
        "doc": "",
        "grammar": "snu",
        "label": "set ytics start, incr, end",
        "matches": [
          "ytics"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "set datafile separator '${1:#:separator}'",
        "doc": "",
        "grammar": "snu",
        "label": "set datafile separator 'separator'",
        "matches": [
          "datasep"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "set terminal ${1:#:terminal}",
        "doc": "",
        "grammar": "snu",
        "label": "set terminal",
        "matches": [
          "term"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "set output '${1:#:filename}'",
        "doc": "",
        "grammar": "snu",
        "label": "set output 'filename'",
        "matches": [
          "out"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "set key",
        "doc": "",
        "grammar": "snu",
        "label": "set key",
        "matches": [
          "key"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "unset key",
        "doc": "",
        "grammar": "snu",
        "label": "unset key",
        "matches": [
          "key!"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "set grid",
        "doc": "",
        "grammar": "snu",
        "label": "set grid",
        "matches": [
          "grid"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "unset grid",
        "doc": "",
        "grammar": "snu",
        "label": "unset grid",
        "matches": [
          "grid!"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "set border",
        "doc": "",
        "grammar": "snu",
        "label": "set border",
        "matches": [
          "border"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "print(${1:#:string}}",
        "doc": "",
        "grammar": "snu",
        "label": "print",
        "matches": [
          "print"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "sprintf('${1:#:format}', ${2:#:vars})",
        "doc": "",
        "grammar": "snu",
        "label": "sprintf",
        "matches": [
          "sprintf"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "set multiplot\n${1:#:plot code}\nunset multiplot",
        "doc": "",
        "grammar": "snu",
        "label": "set multiplot ... unset multiplot",
        "matches": [
          "multiplot"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "if (${1:#:condition}) {\n    ${2:#:commands}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if (...) {...}",
        "matches": [
          "if"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "else {\n    ${1:#:commands}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "else {...}",
        "matches": [
          "else"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "if (${1:#:condition}) {\n    ${2:#:commands}\n} else {\n    ${3:#:commands}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if (...) {...} else {...}",
        "matches": [
          "ifelse"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "while (${1:#:expression}) {\n    ${2:#:commands}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "while (...) {...}",
        "matches": [
          "while"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "do for ${1:#:iter} {\n    ${2:#:commands}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "do for <iter> {...}",
        "matches": [
          "do"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "for [${1:str} in '${2:#:string list}']",
        "doc": "",
        "grammar": "snu",
        "label": "for [string in \"A B C...\"]",
        "matches": [
          "fors"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "for [${1:i} = ${2:#:start}, ${3:#:end}, ${4:1}",
        "doc": "",
        "grammar": "snu",
        "label": "for [intvar = start, end, incr]",
        "matches": [
          "fori"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "set logscale ${1:#:axis}",
        "doc": "",
        "grammar": "snu",
        "label": "set logscale <axis>",
        "matches": [
          "logscale"
        ],
        "opts": [
          "head"
        ]
      }
    ],
    "go": [
      {
        "content": "${1} := ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "v := value",
        "matches": [
          ":"
        ],
        "opts": []
      },
      {
        "content": "${1:fn} := func() {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "fn := func() { ... }",
        "matches": [
          "anon"
        ],
        "opts": []
      },
      {
        "content": "append(${1:slice}, ${0:value})",
        "doc": "",
        "grammar": "snu",
        "label": "append(slice, value)",
        "matches": [
          "ap"
        ],
        "opts": []
      },
      {
        "content": "${1:slice} = append($1, ${0:value})",
        "doc": "",
        "grammar": "snu",
        "label": "slice = append(slice, value)",
        "matches": [
          "ap="
        ],
        "opts": []
      },
      {
        "content": "break",
        "doc": "",
        "grammar": "snu",
        "label": "break",
        "matches": [
          "br"
        ],
        "opts": []
      },
      {
        "content": "chan ${0:int}",
        "doc": "",
        "grammar": "snu",
        "label": "chan Type",
        "matches": [
          "ch"
        ],
        "opts": []
      },
      {
        "content": "case ${1:value}:\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "case ...:",
        "matches": [
          "case"
        ],
        "opts": []
      },
      {
        "content": "const ${1:NAME} ${2:Type} = ${0:0}",
        "doc": "",
        "grammar": "snu",
        "label": "const XXX Type = ...",
        "matches": [
          "con"
        ],
        "opts": []
      },
      {
        "content": "const (\n\t${1:NAME} ${2:Type} = ${3:value}\n\t${0}\n)",
        "doc": "",
        "grammar": "snu",
        "label": "const ( ... )",
        "matches": [
          "cons"
        ],
        "opts": []
      },
      {
        "content": "const (\n\t${1:NAME} ${2:Type} = iota\n\t${0}\n)",
        "doc": "",
        "grammar": "snu",
        "label": "const ( ... = iota )",
        "matches": [
          "iota"
        ],
        "opts": []
      },
      {
        "content": "continue",
        "doc": "",
        "grammar": "snu",
        "label": "continue",
        "matches": [
          "cn"
        ],
        "opts": []
      },
      {
        "content": "default:\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": "default: ...",
        "matches": [
          "default"
        ],
        "opts": []
      },
      {
        "content": "defer ${1:func}(${2})\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "defer someFunction()",
        "matches": [
          "df"
        ],
        "opts": []
      },
      {
        "content": "defer func() {\n\t${0}\n}()",
        "doc": "",
        "grammar": "snu",
        "label": "defer func() { ... }",
        "matches": [
          "def"
        ],
        "opts": []
      },
      {
        "content": "defer func() {\n\tif err := recover(); err != nil {\n\t\t${0}\n\t}\n}()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defr"
        ],
        "opts": []
      },
      {
        "content": "/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n *\n * Copyright (C) ${1:Author}, `strftime(\"%Y\")`\n */\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gpl"
        ],
        "opts": []
      },
      {
        "content": "import (\n\t\"${1:package}\"\n)",
        "doc": "",
        "grammar": "snu",
        "label": "import ( ... )",
        "matches": [
          "import"
        ],
        "opts": []
      },
      {
        "content": "type ${1:Interface} interface {\n\t${2:/* TODO: add methods */}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "interface I { ... }",
        "matches": [
          "interface"
        ],
        "opts": []
      },
      {
        "content": "if ${1:condition} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "else { ... }",
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "else {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "else"
        ],
        "opts": []
      },
      {
        "content": "if err := ${1:condition}; err != nil {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if err := ...; err != nil { ... }",
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "if err != nil {\n\treturn err\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "if err != nil { return err }",
        "matches": [
          "errn"
        ],
        "opts": []
      },
      {
        "content": "if err != nil {\n\tt.Fatal(err)\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if err != nil { t.Fatal(err) }",
        "matches": [
          "errt"
        ],
        "opts": []
      },
      {
        "content": "if err != nil {\n\tlog.Fatal(err)\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if err != nil { log.Fatal(err) }",
        "matches": [
          "errl"
        ],
        "opts": []
      },
      {
        "content": "if err != nil {\n\treturn ${1:nil}, err\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "if err != nil { return [...], err }",
        "matches": [
          "errn,"
        ],
        "opts": []
      },
      {
        "content": "if err != nil {\n\t${1}\n\treturn\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "if err != nil { ... return }",
        "matches": [
          "errh"
        ],
        "opts": []
      },
      {
        "content": "if err != nil {\n\tpanic(${1})\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "if err != nil { panic(...) }",
        "matches": [
          "errp"
        ],
        "opts": []
      },
      {
        "content": "\\`json:\"${1:keyName}\"\\`",
        "doc": "",
        "grammar": "snu",
        "label": "\\`json:key\\`",
        "matches": [
          "json"
        ],
        "opts": []
      },
      {
        "content": "\\`yaml:\"${1:keyName}\"\\`",
        "doc": "",
        "grammar": "snu",
        "label": "\\`yaml:key\\`",
        "matches": [
          "yaml"
        ],
        "opts": []
      },
      {
        "content": "fallthrough",
        "doc": "",
        "grammar": "snu",
        "label": "fallthrough",
        "matches": [
          "ft"
        ],
        "opts": []
      },
      {
        "content": "for ${1} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "for ... { ... }",
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "for ${1:i} := 0; $1 < ${2:N}; $1++ {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "for 0..N-1 { ... }",
        "matches": [
          "fori"
        ],
        "opts": []
      },
      {
        "content": "for ${2:k}, ${3:v} := range ${1} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "for k, v := range items { ... }",
        "matches": [
          "forr"
        ],
        "opts": []
      },
      {
        "content": "func ${1:function}(${2}) ${3:error }{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "func function(...) [error] { ... }",
        "matches": [
          "func"
        ],
        "opts": []
      },
      {
        "content": "fmt.Printf(\"${1} = %+v\\n\", $1)\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "fmt.Printf(...)",
        "matches": [
          "ff"
        ],
        "opts": []
      },
      {
        "content": "fmt.Println(\"${1}\")",
        "doc": "",
        "grammar": "snu",
        "label": "fmt.Println(...)",
        "matches": [
          "fn"
        ],
        "opts": []
      },
      {
        "content": "fmt.Errorf(\"${1}\")",
        "doc": "",
        "grammar": "snu",
        "label": "fmt.Errorf(...)",
        "matches": [
          "fe"
        ],
        "opts": []
      },
      {
        "content": "log.Printf(\"${1} = %+v\\n\", $1)",
        "doc": "",
        "grammar": "snu",
        "label": "log.Printf(...)",
        "matches": [
          "lf"
        ],
        "opts": []
      },
      {
        "content": "log.Println(\"${1}\")",
        "doc": "",
        "grammar": "snu",
        "label": "log.Println(...)",
        "matches": [
          "ln"
        ],
        "opts": []
      },
      {
        "content": "make(${1:[]string}, ${2:0})${0}",
        "doc": "",
        "grammar": "snu",
        "label": "make(Type, size)",
        "matches": [
          "make"
        ],
        "opts": []
      },
      {
        "content": "map[${1:string}]${0:int}",
        "doc": "",
        "grammar": "snu",
        "label": "map[Type]Type",
        "matches": [
          "map"
        ],
        "opts": []
      },
      {
        "content": "func main() {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "func main() { ... }",
        "matches": [
          "main"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "func (${1:self} ${2:Type}) ${3:Do}(${4}) ${5:error }{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "func (self Type) Method(...) [error] { ... }",
        "matches": [
          "meth"
        ],
        "opts": []
      },
      {
        "content": "if !ok {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if !ok { ... }",
        "matches": [
          "ok"
        ],
        "opts": []
      },
      {
        "content": "// Package $1 provides ${2:...}\npackage ${1:main}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "package ...",
        "matches": [
          "package"
        ],
        "opts": []
      },
      {
        "content": "panic(\"${0}\")",
        "doc": "",
        "grammar": "snu",
        "label": "panic(\"...\")",
        "matches": [
          "panic",
          "pn"
        ],
        "opts": []
      },
      {
        "content": "return ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "return ...",
        "matches": [
          "return",
          "rt"
        ],
        "opts": []
      },
      {
        "content": "select {\ncase ${1:v1} := <-${2:chan1}\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "select { case a := <-chan: ... }",
        "matches": [
          "select"
        ],
        "opts": []
      },
      {
        "content": "type ${1:Type} struct {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "type T struct { ... }",
        "matches": [
          "st"
        ],
        "opts": []
      },
      {
        "content": "switch ${1:var} {\ncase ${2:value1}:\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "switch x { ... }",
        "matches": [
          "switch"
        ],
        "opts": []
      },
      {
        "content": "fmt.Sprintf(\"%${1:s}\", ${2:var})",
        "doc": "",
        "grammar": "snu",
        "label": "fmt.Sprintf(...)",
        "matches": [
          "sp"
        ],
        "opts": []
      },
      {
        "content": "go ${1:funcName}(${0})",
        "doc": "",
        "grammar": "snu",
        "label": "go someFunc(...)",
        "matches": [
          "go"
        ],
        "opts": []
      },
      {
        "content": "go func(${1}) {\n\t${3:/* TODO */}\n}(${2})",
        "doc": "",
        "grammar": "snu",
        "label": "go func(...) { ... }(...)",
        "matches": [
          "gof"
        ],
        "opts": []
      },
      {
        "content": "func Test${1:Function}(t *testing.T) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "func TestXYZ(t *testing.T) { ... }",
        "matches": [
          "test"
        ],
        "opts": []
      },
      {
        "content": "t.Run(\"${0}\", func(t *testing.T){\n})",
        "doc": "",
        "grammar": "snu",
        "label": "t.Run(\"test name\", func(t *testing.T){ ... })",
        "matches": [
          "tr"
        ],
        "opts": []
      },
      {
        "content": "var tests = []struct {\n    name string\n    expected string\n    given string\n}{\n    {\"${2}\", \"${3}\", \"${4}\",},\n}\nfor _, tt := range tests {\n    tt := tt\n    t.Run(tt.name, func(t *testing.T){\n        actual := ${1:Function}(tt.given)\n        if actual != tt.expected {\n            t.Errorf(\"given(%s): expected %s, actual %s\", tt.given, tt.expected, actual)\n        }\n    })\n}",
        "doc": "",
        "grammar": "snu",
        "label": "var test = {...}{...} for {t.Run(){...}}",
        "matches": [
          "tt"
        ],
        "opts": []
      },
      {
        "content": "ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n  fmt.Fprintln(w, ${1:`response`})\n}))\ndefer ts.Close()\n//Use testing server url (type string) somewhere\n${0:someUrl} = ts.URL",
        "doc": "",
        "grammar": "snu",
        "label": "ts := httptest.NewServer(...)",
        "matches": [
          "tsrv"
        ],
        "opts": []
      },
      {
        "content": "if err != nil {\n  t.Errorf(\"${1}\")\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if err != nil { t.Errorf(...) }",
        "matches": [
          "ter"
        ],
        "opts": []
      },
      {
        "content": "if err != nil {\n  t.Fatalf(\"${1}\")\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if err != nil { t.Fatalf(...) }",
        "matches": [
          "terf"
        ],
        "opts": []
      },
      {
        "content": "func Example${1:Method}() {\n\t${0}\n\t// Output:\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "example"
        ],
        "opts": []
      },
      {
        "content": "func Benchmark${1:Method}(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\t${0}\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "benchmark"
        ],
        "opts": []
      },
      {
        "content": "var ${1:x} ${2:Type}${3: = ${0:value\\}}",
        "doc": "",
        "grammar": "snu",
        "label": "var x Type [= ...]",
        "matches": [
          "var"
        ],
        "opts": []
      },
      {
        "content": "var (\n\t${1:x} ${2:Type}${3: = ${0:value\\}}\n)",
        "doc": "",
        "grammar": "snu",
        "label": "var ( ... )",
        "matches": [
          "vars"
        ],
        "opts": []
      },
      {
        "content": "if !reflect.DeepEqual(${1:expected}, ${2:actual}) {\n\t_, file, line, _ := runtime.Caller(0)\n\tfmt.Printf(\"%s:%d:\\n\\n\\texp: %#v\\n\\n\\tgot: %#v\\n\\n\", filepath.Base(file), line, $1, $2)\n\tt.FailNow()\n}",
        "doc": "",
        "grammar": "snu",
        "label": "equals: test two identifiers with DeepEqual",
        "matches": [
          "eq"
        ],
        "opts": []
      },
      {
        "content": "func ${1:handler}(w http.ResponseWriter, r *http.Request) {\n  ${0:fmt.Fprintf(w, \"hello world\")}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "http.HandlerFunc",
        "matches": [
          "hf"
        ],
        "opts": []
      },
      {
        "content": "${1:http}.HandleFunc(\"${2:/}\", func(w http.ResponseWriter, r *http.Request) {\n  ${0:fmt.Fprintf(w, \"hello world\")}\n})",
        "doc": "",
        "grammar": "snu",
        "label": "mux.HandleFunc(...)",
        "matches": [
          "hhf"
        ],
        "opts": []
      },
      {
        "content": "${1} := ${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "v \"shorthand variable declaration\""
        ],
        "opts": []
      },
      {
        "content": "var ${1:t} ${0:string}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vr \"variable initialization\""
        ],
        "opts": []
      },
      {
        "content": "var ${1} ${2} = ${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "var \"variable declaration\""
        ],
        "opts": []
      },
      {
        "content": "var (\n\t${1} ${2} = ${3}\n)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vars \"variables declaration\""
        ],
        "opts": []
      },
      {
        "content": "append(${1:slice}, ${0:value})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ap \"append\""
        ],
        "opts": []
      },
      {
        "content": "bool",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bl \"bool\""
        ],
        "opts": []
      },
      {
        "content": "byte",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bt \"byte\""
        ],
        "opts": []
      },
      {
        "content": "break",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "br \"break\""
        ],
        "opts": []
      },
      {
        "content": "chan ${0:int}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ch \"channel\""
        ],
        "opts": []
      },
      {
        "content": "case ${1:value}:\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cs \"case\""
        ],
        "opts": []
      },
      {
        "content": "const (\n\t${1:NAME1} = iota\n\t${0:NAME2}\n)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "co \"constants with iota\""
        ],
        "opts": []
      },
      {
        "content": "continue",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cn \"continue\""
        ],
        "opts": []
      },
      {
        "content": "defer ${0:func}()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "df \"defer\""
        ],
        "opts": []
      },
      {
        "content": "defer func() {\n\tif err := recover(); err != nil {\n\t\t${0:${VISUAL}}\n\t}\n}()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dfr \"defer recover\""
        ],
        "opts": []
      },
      {
        "content": "import (\n\t\"${1:package}\"\n)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "im \"import\""
        ],
        "opts": []
      },
      {
        "content": "interface{}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "in \"interface\""
        ],
        "opts": []
      },
      {
        "content": "interface ${1:name} {\n\t${2:/* methods */}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "inf \"full interface \""
        ],
        "opts": []
      },
      {
        "content": "if ${1:/* condition */} {\n\t${2:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if \"if condition\""
        ],
        "opts": []
      },
      {
        "content": "if ${1:/* condition */} {\n\t${2:${VISUAL}}\n} else {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife \"if else condition\""
        ],
        "opts": []
      },
      {
        "content": "else {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "el \"else\""
        ],
        "opts": []
      },
      {
        "content": "if err != nil {\n\treturn err\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ir \"if error not nil, return err\""
        ],
        "opts": []
      },
      {
        "content": "false",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "f \"false\""
        ],
        "opts": []
      },
      {
        "content": "fallthrough",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ft \"fallthrough\""
        ],
        "opts": []
      },
      {
        "content": "float32",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fl \"float\""
        ],
        "opts": []
      },
      {
        "content": "float32",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "f3 \"float32\""
        ],
        "opts": []
      },
      {
        "content": "float64",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "f6 \"float64\""
        ],
        "opts": []
      },
      {
        "content": "for ${1}{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for \"for loop\""
        ],
        "opts": []
      },
      {
        "content": "for ${2:i} := 0; $2 < ${1:count}; $2${3:++} {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fori \"for int loop\""
        ],
        "opts": []
      },
      {
        "content": "for ${1:e} := range ${2:collection} {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forr \"for range loop\""
        ],
        "opts": []
      },
      {
        "content": "func ${1:funcName}(${2}) ${3:error} {\n\t${4}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fun \"function\""
        ],
        "opts": []
      },
      {
        "content": "func (${1:receiver} ${2:type}) ${3:funcName}(${4}) ${5:error} {\n\t${6}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fum \"method\""
        ],
        "opts": []
      },
      {
        "content": "func (${1:receiver} ${2:type}) ${3:funcName}(${4:w} http.ResponseWriter, ${5:r} *http.Request) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fumh \"http handler function on receiver\""
        ],
        "opts": []
      },
      {
        "content": "log.Printf(\"%${1:s}\", ${2:var})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lf \"log printf\""
        ],
        "opts": []
      },
      {
        "content": "log.Println(\"${1}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lp \"log println\""
        ],
        "opts": []
      },
      {
        "content": "make(${1:[]string}, ${0:0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mk \"make\""
        ],
        "opts": []
      },
      {
        "content": "map[${1:string}]${0:int}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mp \"map\""
        ],
        "opts": []
      },
      {
        "content": "func main() {\n\t${1}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "main \"func main()\""
        ],
        "opts": []
      },
      {
        "content": "new(${0:type})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nw \"new\""
        ],
        "opts": []
      },
      {
        "content": "package ${1:main}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pa \"package\""
        ],
        "opts": []
      },
      {
        "content": "panic(\"${0:msg}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pn \"panic\""
        ],
        "opts": []
      },
      {
        "content": "fmt.Printf(\"%${1:s}\\n\", ${2:var})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pf \"fmt.Printf()\""
        ],
        "opts": []
      },
      {
        "content": "fmt.Println(\"${1:s}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pl \"fmt.Println()\""
        ],
        "opts": []
      },
      {
        "content": "range ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rn \"range\""
        ],
        "opts": []
      },
      {
        "content": "return ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rt \"return\""
        ],
        "opts": []
      },
      {
        "content": "result",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rs \"result\""
        ],
        "opts": []
      },
      {
        "content": "select {\ncase ${1:v1} := <-${2:chan1}\n\t${3}\ndefault:\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sl \"select\""
        ],
        "opts": []
      },
      {
        "content": "string",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sr \"string\""
        ],
        "opts": []
      },
      {
        "content": "struct ${1:name} {\n\t${2:/* data */}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "st \"struct\""
        ],
        "opts": []
      },
      {
        "content": "switch ${1:var} {\ncase ${2:value1}:\n\t${3}\ncase ${4:value2}:\n\t${5}\ndefault:\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sw \"switch\""
        ],
        "opts": []
      },
      {
        "content": "fmt.Sprintf(\"%${1:s}\", ${2:var})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ps \"fmt.Sprintf\""
        ],
        "opts": []
      },
      {
        "content": "true",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "t \"true\""
        ],
        "opts": []
      },
      {
        "content": "go ${1:funcName}(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "g \"goroutine named function\""
        ],
        "opts": []
      },
      {
        "content": "go func(${1} ${2:type}) {\n\t${3:/* code */}\n}(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ga \"goroutine anonymous function\""
        ],
        "opts": []
      },
      {
        "content": "func Test${1:name}(t *testing.T) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "test \"test function\""
        ],
        "opts": []
      },
      {
        "content": "func Test${1:name}(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t}{\n\t\t{\n\t\t\tname: \"${2:test name}\",\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t${0:${VISUAL}}\n\t\t})\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "testt \"table test function\""
        ],
        "opts": []
      },
      {
        "content": "func Benchmark${1:name}(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\t${2}\n\t}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bench \"benchmark function\""
        ],
        "opts": []
      },
      {
        "content": "type ${1:name} struct {\n\t${2:attrName} ${3:attrType}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cl \"composite literals\""
        ],
        "opts": []
      },
      {
        "content": "if ${1:value}, ok := ${2:map}[${3:key}]; ok == true {\n\t${4:/* code */}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "om \"if key in a map\""
        ],
        "opts": []
      },
      {
        "content": "var ${1:var} = struct{\n\t${2:name} ${3:type}\n}{\n\t$2: ${4:value},\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gg \"Grouped globals with anonymous struct\""
        ],
        "opts": []
      },
      {
        "content": "type ${1:parentType}Alias $1\nfunc (p *$1) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(&struct{ *$1Alias }{(*$1Alias)(p)})\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ja \"Marshalable json alias\""
        ],
        "opts": []
      },
      {
        "content": "if ${1}err != nil {\n\treturn errors.Wrap(err, \"${2}\")\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "errwr \"Error handling with errors.Wrap\""
        ],
        "opts": []
      },
      {
        "content": "package main\nimport (\n  \"fmt\"\n)\nfunc main() {\n  fmt.Printf(\"Hello, world\\n\")\n}",
        "doc": "",
        "grammar": "snu",
        "label": "package main\\nimport fmt...",
        "matches": [
          "helloworld"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "func ${1:fname}(${2}) ${3:int }{\n  ${0:TARGET:return }\n}",
        "doc": "",
        "grammar": "snu",
        "label": "func ...() { ... }",
        "matches": [
          "func",
          "fn"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "import (\n  \"${1:fmt}\"\n)\n${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "im",
          "import"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "package ${1:main}\n${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pk",
          "package"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "fmt.Printf(\"${1}\\n\"${2:})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pf",
          "printf"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "fmt.Println(${0:TARGET})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "println",
          "pl"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "type ${1} struct {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ts",
          "struct"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "type ${1} interface {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "interface",
          "ti"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "for ${1} {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "for ${1:v} := range ${2:#:iterator} {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "for range",
        "matches": [
          "range"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "if ${1:#:condition} {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "if err != nil {\n  return `g:NeosnippetSnippets_Goiferr()`\n}\n${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife",
          "iferr"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "switch ${1:#:v} {\ncase ${2:#:condition}:\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "switch {}",
        "matches": [
          "switch"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "select {\ncase ${1:#:condition}:\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "select {}",
        "matches": [
          "select"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "case ${1:#:condition}:\n  ${2:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "func Test${1} (${2:t *testing.T}) {\n  for i := 0; i < ${3:t.N}; i++ {\n    ${4}\n  }\n}",
        "doc": "",
        "grammar": "snu",
        "label": "func Test... (t *testing.T) { ... }",
        "matches": [
          "funcTest"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "func Benchmark${1} (${2:b *testing.B}) {\n  for i := 0; i < ${3:b.N}; i++ {\n    ${4}\n  }\n}",
        "doc": "",
        "grammar": "snu",
        "label": "func Benchmark... (b *testing.B) { ... }",
        "matches": [
          "funcbench"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "var tests = []struct {\n    name string\n    expected string\n    given string\n}{\n    {\"${2}\", \"${3}\", \"${4}\",},\n}\nfor _, tt := range tests {\n    tt := tt\n    t.Run(tt.name, func(t *testing.T){\n        actual := ${1:Function}(tt.given)\n        if actual != tt.expected {\n            t.Errorf(\"given(%s): expected %s, actual %s\", tt.given, tt.expected, actual)\n        }\n    })\n}",
        "doc": "",
        "grammar": "snu",
        "label": "var test = {...}{...} for {t.Run(){...}}",
        "matches": [
          "testtable"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "${1} := ${0}",
        "doc": null,
        "grammar": "snu",
        "label": "v := value",
        "matches": [
          ":"
        ],
        "opts": []
      },
      {
        "content": "${1:fn} := func() {\n\t${2:${VISUAL}}\n}\n${0}",
        "doc": null,
        "grammar": "snu",
        "label": "fn := func() { ... }",
        "matches": [
          "anon"
        ],
        "opts": []
      },
      {
        "content": "append(${1:slice}, ${0:value})",
        "doc": null,
        "grammar": "snu",
        "label": "append(slice, value)",
        "matches": [
          "ap"
        ],
        "opts": []
      },
      {
        "content": "${1:slice} = append($1, ${0:value})",
        "doc": null,
        "grammar": "snu",
        "label": "a = append(a, value)",
        "matches": [
          "ap="
        ],
        "opts": []
      },
      {
        "content": "break",
        "doc": null,
        "grammar": "snu",
        "label": "break",
        "matches": [
          "br"
        ],
        "opts": []
      },
      {
        "content": "chan ${0:int}",
        "doc": null,
        "grammar": "snu",
        "label": "chan Type",
        "matches": [
          "ch"
        ],
        "opts": []
      },
      {
        "content": "case ${1:value}:\n\t${0:${VISUAL}}",
        "doc": null,
        "grammar": "snu",
        "label": "case ...:",
        "matches": [
          "case"
        ],
        "opts": []
      },
      {
        "content": "const ${1:NAME} ${2:Type} = ${0:0}",
        "doc": null,
        "grammar": "snu",
        "label": "const XXX Type = ...",
        "matches": [
          "con"
        ],
        "opts": []
      },
      {
        "content": "const (\n\t${1:NAME} ${2:Type} = ${3:value}\n\t${0}\n)",
        "doc": null,
        "grammar": "snu",
        "label": "const ( ... )",
        "matches": [
          "cons"
        ],
        "opts": []
      },
      {
        "content": "const (\n\t${1:NAME} ${2:Type} = iota\n\t${0}\n)",
        "doc": null,
        "grammar": "snu",
        "label": "const ( ... = iota )",
        "matches": [
          "iota"
        ],
        "opts": []
      },
      {
        "content": "continue",
        "doc": null,
        "grammar": "snu",
        "label": "continue",
        "matches": [
          "cn"
        ],
        "opts": []
      },
      {
        "content": "default:\n\t${0:${VISUAL}}",
        "doc": null,
        "grammar": "snu",
        "label": "default: ...",
        "matches": [
          "default"
        ],
        "opts": []
      },
      {
        "content": "defer ${1:func}(${2})\n${0}",
        "doc": null,
        "grammar": "snu",
        "label": "defer someFunction()",
        "matches": [
          "df"
        ],
        "opts": []
      },
      {
        "content": "defer func() {\n\t${0:${VISUAL}}\n}()",
        "doc": null,
        "grammar": "snu",
        "label": "defer func() { ... }",
        "matches": [
          "def"
        ],
        "opts": []
      },
      {
        "content": "defer func() {\n\tif err := recover(); err != nil {\n\t\t${0:${VISUAL}}\n\t}\n}()",
        "doc": null,
        "grammar": "snu",
        "label": null,
        "matches": [
          "defr"
        ],
        "opts": []
      },
      {
        "content": "/*\n* This program is free software; you can redistribute it and/or modify\n* it under the terms of the GNU General Public License as published by\n* the Free Software Foundation; either version 2 of the License, or\n* (at your option) any later version.\n*\n* This program is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n* GNU General Public License for more details.\n*\n* You should have received a copy of the GNU General Public License\n* along with this program; if not, see <http://www.gnu.org/licenses/>.\n*\n* Copyright (C) ${1:Author}, `!v strftime(\"%Y\")`\n*/\n${0}",
        "doc": null,
        "grammar": "snu",
        "label": null,
        "matches": [
          "gpl"
        ],
        "opts": []
      },
      {
        "content": "import (\n\t\"${1:package}\"\n)",
        "doc": null,
        "grammar": "snu",
        "label": "import ( ... )",
        "matches": [
          "import"
        ],
        "opts": []
      },
      {
        "content": "type ${1:Interface} interface {\n\t${2:/* TODO: add methods */}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "interface I { ... }",
        "matches": [
          "interface"
        ],
        "opts": []
      },
      {
        "content": "if ${1:condition} {\n\t${0:${VISUAL}}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "if ... { ... }",
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "else {\n\t${0:${VISUAL}}\n}",
        "doc": null,
        "grammar": "snu",
        "label": null,
        "matches": [
          "else"
        ],
        "opts": []
      },
      {
        "content": "if err := ${1:condition}; err != nil {\n\t${0:${VISUAL}}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "If with inline error",
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "errors.Wrap(${1:err}, \"${2:message}\")",
        "doc": null,
        "grammar": "snu",
        "label": "errors.Wrap",
        "matches": [
          "ew"
        ],
        "opts": []
      },
      {
        "content": "errors.Wrapf(${1:err}, \"${2:message %v}\", ${3:args...})",
        "doc": null,
        "grammar": "snu",
        "label": "errors.Wrapf",
        "matches": [
          "ewf"
        ],
        "opts": []
      },
      {
        "content": "if err != nil {\n\treturn err\n}\n${0}",
        "doc": null,
        "grammar": "snu",
        "label": "Error return",
        "matches": [
          "errn"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "if err != nil {\n\treturn errors.Wrap(err, \"${1:message}\")\n}\n${0}",
        "doc": null,
        "grammar": "snu",
        "label": "Error return wrap",
        "matches": [
          "errnw"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "if err != nil {\n\treturn errors.Wrapf(err, \"${1:message %v}\", ${2:args...})\n}\n${0}",
        "doc": null,
        "grammar": "snu",
        "label": "Error return wrapf",
        "matches": [
          "errnwf"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "if err != nil {\n\tlog.Fatal(err)\n}\n${0}",
        "doc": null,
        "grammar": "snu",
        "label": "Error with log.Fatal(err)",
        "matches": [
          "errl"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "if err != nil {\n\treturn ${1:nil}, ${2:err}\n}\n${0}",
        "doc": null,
        "grammar": "snu",
        "label": "Error return with two return values",
        "matches": [
          "errn,"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "if err != nil {\n\treturn nil, errors.Wrap(err, \"${1:message}\")\n}\n${0}",
        "doc": null,
        "grammar": "snu",
        "label": "Error return wrap with two return values",
        "matches": [
          "errn,w"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "if err != nil {\n\treturn nil, errors.Wrapf(err, \"${1:message %v}\", ${2:args...})\n}\n${0}",
        "doc": null,
        "grammar": "snu",
        "label": "Error return wrapf with two return values",
        "matches": [
          "errn,wf"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "if err != nil {\n\tpanic(${1})\n}\n${0}",
        "doc": null,
        "grammar": "snu",
        "label": "Error panic",
        "matches": [
          "errp"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "if err != nil {\n\tt.Fatal(err)\n}\n${0}",
        "doc": null,
        "grammar": "snu",
        "label": "Error test fatal ",
        "matches": [
          "errt"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "if err != nil {\n\t${1}\n\treturn\n}\n${0}",
        "doc": null,
        "grammar": "snu",
        "label": "Error handle and return",
        "matches": [
          "errh"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "\\`json:\"${1:`!v  go#util#snippetcase(matchstr(getline(\".\"), '\\w\\+'))`}\"\\`",
        "doc": null,
        "grammar": "snu",
        "label": "\\`json:key\\`",
        "matches": [
          "json"
        ],
        "opts": []
      },
      {
        "content": "\\`yaml:\"${1:`!v  go#util#snippetcase(matchstr(getline(\".\"), '\\w\\+'))`}\"\\`",
        "doc": null,
        "grammar": "snu",
        "label": "\\`yaml:key\\`",
        "matches": [
          "yaml"
        ],
        "opts": []
      },
      {
        "content": "fallthrough",
        "doc": null,
        "grammar": "snu",
        "label": "fallthrough",
        "matches": [
          "ft"
        ],
        "opts": []
      },
      {
        "content": "for ${1} {\n\t${0:${VISUAL}}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "for ... { ... }",
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "for ${1:i} := 0; $1 < ${2:N}; $1++ {\n\t${0:${VISUAL}}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "for 0..N-1 { ... }",
        "matches": [
          "fori"
        ],
        "opts": []
      },
      {
        "content": "for ${2:k}, ${3:v} := range ${1} {\n\t${0:${VISUAL}}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "for k, v := range items { ... }",
        "matches": [
          "forr"
        ],
        "opts": []
      },
      {
        "content": "for {\n\tselect {\n\t\tcase ${2:${1:result} := }<- ${3:channel}:\n\t\t\t${0}\n\t}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "for select",
        "matches": [
          "forsel"
        ],
        "opts": []
      },
      {
        "content": "case ${1:${2:var} := }<-${3:channel}:\n  ${0}",
        "doc": null,
        "grammar": "snu",
        "label": "select case",
        "matches": [
          "selc"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "func ${1:name}(${2:params})${3/(.+)/ /}`!p opening_par(snip, 3)`$3`!p closing_par(snip, 3)` {\n\t${0:${VISUAL}}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "func Function(...) [error] { ... }",
        "matches": [
          "func"
        ],
        "opts": []
      },
      {
        "content": "fmt.Printf(\"$1 = %+v\\n\", ${1:${VISUAL}})",
        "doc": null,
        "grammar": "snu",
        "label": "fmt.Printf(...)",
        "matches": [
          "ff"
        ],
        "opts": []
      },
      {
        "content": "fmt.Printf(\"$1 = %#v\\n\", ${1:${VISUAL}})",
        "doc": null,
        "grammar": "snu",
        "label": "fmt.Printf(#...) hash",
        "matches": [
          "ffh"
        ],
        "opts": []
      },
      {
        "content": "fmt.Println(\"${1:${VISUAL}}\")",
        "doc": null,
        "grammar": "snu",
        "label": "fmt.Println(...)",
        "matches": [
          "fn"
        ],
        "opts": []
      },
      {
        "content": "fmt.Errorf(\"${1:${VISUAL}}\")",
        "doc": null,
        "grammar": "snu",
        "label": "fmt.Errorf(...)",
        "matches": [
          "fe"
        ],
        "opts": []
      },
      {
        "content": "fmt.Errorf(\"${1:message}: %w\", ${2:${VISUAL:err}})",
        "doc": null,
        "grammar": "snu",
        "label": "fmt.Errorf(%w, err)",
        "matches": [
          "few"
        ],
        "opts": []
      },
      {
        "content": "if ${1:${VISUAL:err}} != nil {\n\treturn fmt.Errorf(\"${2:message}: %w\", $1)\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Error return fmt.Errorf(%w, err)",
        "matches": [
          "errnfw"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "log.Printf(\"${1:${VISUAL}} = %+v\\n\", $1)",
        "doc": null,
        "grammar": "snu",
        "label": "log.Printf(...)",
        "matches": [
          "lf"
        ],
        "opts": []
      },
      {
        "content": "log.Println(\"${1:${VISUAL}}\")",
        "doc": null,
        "grammar": "snu",
        "label": "log.Println(...)",
        "matches": [
          "ln"
        ],
        "opts": []
      },
      {
        "content": "make(${1:[]string}, ${2:0})${0}",
        "doc": null,
        "grammar": "snu",
        "label": "make(Type, size)",
        "matches": [
          "make"
        ],
        "opts": []
      },
      {
        "content": "map[${1:string}]${0:int}",
        "doc": null,
        "grammar": "snu",
        "label": "map[Type]Type",
        "matches": [
          "map"
        ],
        "opts": []
      },
      {
        "content": "func main() {\n\t${0:${VISUAL}}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "func main() { ... }",
        "matches": [
          "main"
        ],
        "opts": []
      },
      {
        "content": "func (${1:receiver} ${2:type}) ${3:name}(${4:params})${5/(.+)/ /}`!p opening_par(snip, 5)`$5`!p closing_par(snip, 5)` {\n\t${0:${VISUAL}}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "func (self Type) Method(...) [error] { ... }",
        "matches": [
          "meth"
        ],
        "opts": []
      },
      {
        "content": "if !ok {\n\t${0:${VISUAL}}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "if !ok { ... }",
        "matches": [
          "ok"
        ],
        "opts": []
      },
      {
        "content": "// Package $1 provides ${2:...}\npackage ${1:main}\n${0}",
        "doc": null,
        "grammar": "snu",
        "label": "package ...",
        "matches": [
          "package"
        ],
        "opts": []
      },
      {
        "content": "panic(\"${0:msg}\")",
        "doc": null,
        "grammar": "snu",
        "label": "panic()",
        "matches": [
          "pn"
        ],
        "opts": []
      },
      {
        "content": "return ${0:${VISUAL}}",
        "doc": null,
        "grammar": "snu",
        "label": "return",
        "matches": [
          "rt"
        ],
        "opts": []
      },
      {
        "content": "select {\ncase ${1:v1} := <-${2:chan1}:\n\t${0}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "select { case a := <-chan: ... }",
        "matches": [
          "select"
        ],
        "opts": []
      },
      {
        "content": "type ${1:Type} struct {\n\t${0}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "type T struct { ... }",
        "matches": [
          "st"
        ],
        "opts": []
      },
      {
        "content": "switch ${1:var} {\ncase ${2:value1}:\n\t${0}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "switch x { ... }",
        "matches": [
          "switch"
        ],
        "opts": []
      },
      {
        "content": "switch ${2:$1 := }${1:v}.(type) {\n\t${0}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "type switch x { ... }",
        "matches": [
          "tswitch"
        ],
        "opts": []
      },
      {
        "content": "fmt.Sprintf(\"%${1:s}\", ${2:var})",
        "doc": null,
        "grammar": "snu",
        "label": "fmt.Sprintf(...)",
        "matches": [
          "sp"
        ],
        "opts": []
      },
      {
        "content": "go ${1:funcName}(${0})",
        "doc": null,
        "grammar": "snu",
        "label": "go someFunc(...)",
        "matches": [
          "go"
        ],
        "opts": []
      },
      {
        "content": "go func() {\n\t${1:${VISUAL}}\n}()\n${0}",
        "doc": null,
        "grammar": "snu",
        "label": "go func() { ... }()",
        "matches": [
          "gof"
        ],
        "opts": []
      },
      {
        "content": "func Test${1:Function}(t *testing.T) {\n\t${0:${VISUAL}}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "func TestXYZ(t *testing.T) { ... }",
        "matches": [
          "test"
        ],
        "opts": []
      },
      {
        "content": "t.Run(\"${0}\", func(t *testing.T){\n\n})",
        "doc": null,
        "grammar": "snu",
        "label": "t.Run(XYZ, func(t *testing.T){ ... })",
        "matches": [
          "tr"
        ],
        "opts": []
      },
      {
        "content": "var tests = []struct {\n\tname string\n\texpected string\n\tgiven string\n}{\n\t{\"${1}\", \"${2}\", \"${3}\",},\n}\nfor _, tt := range tests {\n\ttt := tt\n\tt.Run(tt.name, func(t *testing.T){\n\t\tactual := ${0:${VISUAL}}(tt.given)\n\t\tif actual != tt.expected {\n\t\t\t\tt.Errorf(\"$0(%s): expected %s, actual %s\", tt.given, tt.expected, actual)\n\t\t}\n\n\t})\n}",
        "doc": null,
        "grammar": "snu",
        "label": null,
        "matches": [
          "tt"
        ],
        "opts": []
      },
      {
        "content": "func ${1:handler}(w http.ResponseWriter, r *http.Request) {\n\t${0:fmt.Fprintf(w, \"hello world\")}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "http.HandlerFunc",
        "matches": [
          "hf"
        ],
        "opts": []
      },
      {
        "content": "${1:http}.HandleFunc(\"${2:/}\", func(w http.ResponseWriter, r *http.Request) {\n\t${0:fmt.Fprintf(w, \"hello world\")}\n})",
        "doc": null,
        "grammar": "snu",
        "label": "mux.HandleFunc",
        "matches": [
          "hhf"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintln(w, ${1:`response`})\n}))\ndefer ts.Close()\n\n${0:someUrl} = ts.URL",
        "doc": null,
        "grammar": "snu",
        "label": "httptest.NewServer",
        "matches": [
          "tsrv"
        ],
        "opts": []
      },
      {
        "content": "if err != nil {\n\tt.Errorf(\"${0:message}\")\n}",
        "doc": null,
        "grammar": "snu",
        "label": "if err != nil { t.Errorf(...) }",
        "matches": [
          "ter"
        ],
        "opts": []
      },
      {
        "content": "if err != nil {\n\tt.Fatalf(\"${0:message}\")\n}",
        "doc": null,
        "grammar": "snu",
        "label": "if err != nil { t.Fatalf(...) }",
        "matches": [
          "terf"
        ],
        "opts": []
      },
      {
        "content": "func Example${1:Method}() {\n\t${0:${VISUAL}}\n\t// Output:\n}",
        "doc": null,
        "grammar": "snu",
        "label": "func ExampleXYZ() { ... }",
        "matches": [
          "example"
        ],
        "opts": []
      },
      {
        "content": "func Benchmark${1:Method}(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\t${0:${VISUAL}}\n\t}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "func BenchmarkXYZ(b *testing.B) { ... }",
        "matches": [
          "benchmark"
        ],
        "opts": []
      },
      {
        "content": "var ${1:x} ${2:Type}${3: = ${0:value}}",
        "doc": null,
        "grammar": "snu",
        "label": "var x Type [= ...]",
        "matches": [
          "var"
        ],
        "opts": []
      },
      {
        "content": "var (\n\t${1:x} ${2:Type}${3: = ${0:value}}\n)",
        "doc": null,
        "grammar": "snu",
        "label": "var ( ... )",
        "matches": [
          "vars"
        ],
        "opts": []
      },
      {
        "content": "if !reflect.DeepEqual(${1:expected}, ${2:actual}) {\n\t_, file, line, _ := runtime.Caller(0)\n\tfmt.Printf(\"%s:%d:\\n\\n\\texp: %#v\\n\\n\\tgot: %#v\\n\\n\", filepath.Base(file), line, $1, $2)\n\tt.FailNow()\n}",
        "doc": null,
        "grammar": "snu",
        "label": "equals: test two identifiers with DeepEqual",
        "matches": [
          "eq"
        ],
        "opts": []
      },
      {
        "content": "import (\n\t\"${1:package}\"\n)",
        "doc": null,
        "grammar": "snu",
        "label": "Import declaration",
        "matches": [
          "/^import/"
        ],
        "opts": [
          "r"
        ]
      },
      {
        "content": "// Package $1 provides ...\npackage ${1:main}",
        "doc": null,
        "grammar": "snu",
        "label": "Package declaration",
        "matches": [
          "/^package/"
        ],
        "opts": [
          "r"
        ]
      },
      {
        "content": "const (\n\t${1:constant}${2/(.+)/ /}${2:type} = ${0:value}\n)",
        "doc": null,
        "grammar": "snu",
        "label": "Constants declaration",
        "matches": [
          "/^cons/"
        ],
        "opts": [
          "r"
        ]
      },
      {
        "content": "const ${1:name}${2/(.+)/ /}${2:type} = ${0:value}",
        "doc": null,
        "grammar": "snu",
        "label": "Constant declaration",
        "matches": [
          "/^con/"
        ],
        "opts": [
          "r"
        ]
      },
      {
        "content": "const (\n\t${1:constant}${2/(.+)/ /}${2:type} = iota\n)",
        "doc": null,
        "grammar": "snu",
        "label": "Iota constant generator",
        "matches": [
          "iota"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "type ${1:Struct} struct {\n\t${0:${VISUAL}}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Struct declaration",
        "matches": [
          "struct"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "type ${1:Interface} interface {\n\t${0:${VISUAL}}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Interface declaration",
        "matches": [
          "interface"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "if ${1:condition}${1/(.+)/ /}{\n\t${0:${VISUAL}}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "If statement",
        "matches": [
          "if"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "switch ${1:expression}${1/(.+)/ /}{\ncase$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Switch statement",
        "matches": [
          "switch"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "func main() {\n\t${0:${VISUAL}}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Main function",
        "matches": [
          "/^main/"
        ],
        "opts": [
          "r"
        ]
      },
      {
        "content": "func (${1:receiver} ${2:type}) ${3:name}(${4:params})${5/(.+)/ /}${5:type} {\n\t${0:${VISUAL}}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Method",
        "matches": [
          "/^meth/"
        ],
        "opts": [
          "r"
        ]
      },
      {
        "content": "func ${1:name}(${2:params})${3/(.+)/ /}${3:type} {\n\t${0:${VISUAL}}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Function",
        "matches": [
          "func"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "func ${1:handler}(${2:w} http.ResponseWriter, ${3:r} *http.Request) {\n\t${0:${VISUAL}}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "HTTP handler",
        "matches": [
          "funch"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "map[${1:keytype}]${2:valtype}",
        "doc": null,
        "grammar": "snu",
        "label": "Map type",
        "matches": [
          "map"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${1:name} := ${0:value}",
        "doc": null,
        "grammar": "snu",
        "label": "Variable declaration :=",
        "matches": [
          ":"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "var ${1:name}${2/(.+)/ /}${2:type}${3: = ${0:value}}",
        "doc": null,
        "grammar": "snu",
        "label": "Variable declaration",
        "matches": [
          "var"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "var (\n\t${1:name}${2/(.+)/ /}${2:type}${3: = ${0:value} }\n)",
        "doc": null,
        "grammar": "snu",
        "label": "Variables declaration",
        "matches": [
          "vars"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "\\`json:\"${1:displayName}\"\\`",
        "doc": null,
        "grammar": "snu",
        "label": "JSON field",
        "matches": [
          "json"
        ],
        "opts": []
      },
      {
        "content": "if err != nil {\n\tlog.${1:Fatal}(err)\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Basic error handling",
        "matches": [
          "err"
        ],
        "opts": [
          "b"
        ]
      }
    ],
    "graphql-request": [
      {
        "content": "import { request } from 'graphql-request';",
        "doc": null,
        "grammar": "lsp",
        "label": "graphql-request-import-request",
        "matches": [
          "graphql-request import request"
        ],
        "opts": []
      },
      {
        "content": "const { GraphQLClient } = require('graphql-request');",
        "doc": null,
        "grammar": "lsp",
        "label": "graphql-request-require-client",
        "matches": [
          "graphql-request require client"
        ],
        "opts": []
      },
      {
        "content": "const { request } = require('graphql-request');",
        "doc": null,
        "grammar": "lsp",
        "label": "graphql-request-require-request",
        "matches": [
          "graphql-request require request"
        ],
        "opts": []
      },
      {
        "content": "import { GraphQLClient } from 'graphql-request';",
        "doc": null,
        "grammar": "lsp",
        "label": "graphql-request-import-client",
        "matches": [
          "graphql-request import client"
        ],
        "opts": []
      },
      {
        "content": "const ${1:client} = new GraphQLClient(\n  ${2:url},\n  {\n    headers: {\n      ${3:key}: ${4:value}\n    },\n  }\n);",
        "doc": null,
        "grammar": "lsp",
        "label": "graphql-request-client",
        "matches": [
          "graphql-request client"
        ],
        "opts": []
      },
      {
        "content": "const ${1:results} = await request(\n  ${2:url},\n  ${3:query}\n);",
        "doc": null,
        "grammar": "lsp",
        "label": "graphql-request-request",
        "matches": [
          "graphql-request request"
        ],
        "opts": []
      },
      {
        "content": "const ${1:results} = await request(\n  ${2:url},\n  ${3:query},\n  ${4:variables}\n);",
        "doc": null,
        "grammar": "lsp",
        "label": "graphql-request-request-variables",
        "matches": [
          "graphql-request request variables"
        ],
        "opts": []
      },
      {
        "content": "const ${1:queryName} = `query ${1:queryName} {\n  ${2:query}\n}\n`;",
        "doc": null,
        "grammar": "lsp",
        "label": "graphql-request-query",
        "matches": [
          "graphql-request query"
        ],
        "opts": []
      },
      {
        "content": "const ${1:results} = await ${2:client}.request(\n  ${3:query}\n);",
        "doc": null,
        "grammar": "lsp",
        "label": "graphql-request-client-request",
        "matches": [
          "graphql-request client request"
        ],
        "opts": []
      },
      {
        "content": "const ${1:results} = await ${2:client}.request(\n  ${3:query},\n  ${4:variables}\n);",
        "doc": null,
        "grammar": "lsp",
        "label": "graphql-request-client-request-variables",
        "matches": [
          "graphql-request client request variables"
        ],
        "opts": []
      }
    ],
    "groovy": [
      {
        "content": "package ${1:com.github.ujihisa}\nclass ${2:TARGET} {\n  public static void main(String[] args) {\n    println(\"Hello world!\")\n  }\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "helloworld"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "apply plugin: 'groovy'\napply plugin: 'maven'\nrepositories {\n    mavenCentral()\n    ${2:mavenLocal()}\n}\ndependencies {\n    compile 'org.codehaus.groovy:groovy-all:2.1.1'\n    //testCompile group: 'junit', name: 'junit', version: '4.+'\n}\njar {\n    from configurations.compile.collect { it.isDirectory() ? it : zipTree(it) }\n}\nmanifest.mainAttributes(\"Main-Class\": \"${1:com.github.`$USER`.}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gradle"
        ],
        "opts": [
          "head"
        ]
      }
    ],
    "haml": [
      {
        "content": "%table\n\t%tr\n\t\t%th\n\t\t\t${1:headers}\n\t%tr\n\t\t%td\n\t\t\t${0:headers}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "t"
        ],
        "opts": []
      },
      {
        "content": "%ul\n\t%li\n\t\t${0:item}\n\t%li",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ul"
        ],
        "opts": []
      },
      {
        "content": "= render :partial => \"${0:item}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rp"
        ],
        "opts": []
      },
      {
        "content": "= render :partial => \"${1:item}\", :collection => ${0:@$1s}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rpc"
        ],
        "opts": []
      },
      {
        "content": "= render :partial => \"${1:item}\", :locals => { :${2:$1} => ${0:@$1} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rpl"
        ],
        "opts": []
      },
      {
        "content": "= render :partial => \"${1:item}\", :object => ${0:@$1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rpo"
        ],
        "opts": []
      },
      {
        "content": "= link_to ${1:name}, ${2:dest}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lt"
        ],
        "opts": []
      },
      {
        "content": "= mail_to ${1:email_address}, ${2:name}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mt"
        ],
        "opts": []
      },
      {
        "content": "= mail_to ${1:email_address}, ${2:name}, :subject => ${3}, :body => ${4}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mts"
        ],
        "opts": []
      },
      {
        "content": "- if ${1:condition}\n\t${2:${VISUAL}}\n- else\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "- if ${1:condition}.presence?\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifp"
        ],
        "opts": []
      },
      {
        "content": "= number_to_currency(${1})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ntc"
        ],
        "opts": []
      }
    ],
    "handlebars": [
      {
        "content": "{{#if ${1:value}}}\n${0:${VISUAL}}\n{{/if}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if # {{#if value}} ... {{/if}}"
        ],
        "opts": []
      },
      {
        "content": "{{#unless ${1:value}}}\n${0:${VISUAL}}\n{{/unless}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifn # {{#unless value}} ... {{/unless}}"
        ],
        "opts": []
      },
      {
        "content": "{{#if ${1:value}}}\n${2:${VISUAL}}\n{{else}}\n${3}\n{{/if}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife # {{#if value}} ... {{else}} .. {{/if}}"
        ],
        "opts": []
      }
    ],
    "haskell": [
      {
        "content": "import qualified ${1} as ${2}",
        "doc": "",
        "grammar": "snu",
        "label": "import qualified ... as ...",
        "matches": [
          "import"
        ],
        "opts": []
      },
      {
        "content": "import ${1} (${2})",
        "doc": "",
        "grammar": "snu",
        "label": "import ... (...)",
        "matches": [
          "importOnly"
        ],
        "opts": []
      },
      {
        "content": "{-# LANGUAGE ${1} #-}",
        "doc": "",
        "grammar": "snu",
        "label": "{-# LANGUAGE ... #-}",
        "matches": [
          "language"
        ],
        "opts": []
      },
      {
        "content": "case ${1} of\n\t${2} -> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "case ... of",
        "matches": [
          "case"
        ],
        "opts": []
      },
      {
        "content": "main = do\n  ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "main = do",
        "matches": [
          "main"
        ],
        "opts": []
      },
      {
        "content": "class ${1:Class} ${2:a} where\n  ${3:function} :: ${4:Type}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "class"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "instance ${1:Class} ${2:Type} where\n  ${3:function} ${4:self} = ${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "instance"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "\\ ${1:x} -> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "λ",
        "matches": [
          "lambda"
        ],
        "opts": []
      },
      {
        "content": "{-# LANGUAGE ${0:OverloadedStrings} #-}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lang"
        ],
        "opts": []
      },
      {
        "content": "{-# OPTIONS_HADDOCK ${0:hide} #-}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "haddock"
        ],
        "opts": []
      },
      {
        "content": "{-# OPTIONS_GHC ${0:-fno-warn-unused-imports} #-}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ghc"
        ],
        "opts": []
      },
      {
        "content": "{-# INLINE ${0:name} #-}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "inline"
        ],
        "opts": []
      },
      {
        "content": "-- |\n-- Module      :  ${1:`substitute(substitute(expand('%:r'), '[/\\\\]','.','g'),'^\\%(\\l*\\.\\)\\?','','')`}\n-- Copyright   :  ${2:Author} ${3:2011-2012}\n-- License     :  ${4:BSD3}\n--\n-- Maintainer  :  ${5:email@something.com}\n-- Stability   :  ${6:experimental}\n-- Portability :  ${7:unknown}\n--\n-- ${0:Description}\n--",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "info"
        ],
        "opts": []
      },
      {
        "content": "import ${0:Data.Text}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "imp"
        ],
        "opts": []
      },
      {
        "content": "import ${0:Data.Text}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "import"
        ],
        "opts": []
      },
      {
        "content": "import ${1:Data.Text} (${0:head})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "import2"
        ],
        "opts": []
      },
      {
        "content": "import qualified ${1:Data.Text} as ${0:T}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "impq"
        ],
        "opts": []
      },
      {
        "content": "import qualified ${1:Data.Text} as ${0:T}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "importq"
        ],
        "opts": []
      },
      {
        "content": "instance ${1:Monoid} ${2:Type} where\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "inst"
        ],
        "opts": []
      },
      {
        "content": "type ${1:Type} = ${0:Type}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ty"
        ],
        "opts": []
      },
      {
        "content": "type ${1:Type} = ${0:Type}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "type"
        ],
        "opts": []
      },
      {
        "content": "data ${1:Type} = ${2:$1} ${0:Int}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "da"
        ],
        "opts": []
      },
      {
        "content": "data ${1:Type} = ${2:$1} ${0:Int}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "data"
        ],
        "opts": []
      },
      {
        "content": "newtype ${1:Type} = ${2:$1} ${0:Int}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "newtype"
        ],
        "opts": []
      },
      {
        "content": "class ${1:Class} a where\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "class"
        ],
        "opts": []
      },
      {
        "content": "module `substitute(substitute(expand('%:r'), '[/\\\\]','.','g'),'^\\%(\\l*\\.\\)\\?','','')` (\n) where\n`expand('%') =~ 'Main' ? \"\\nmain :: IO ()\\nmain = undefined\" : \"\"`",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "module"
        ],
        "opts": []
      },
      {
        "content": "module `substitute(substitute(expand('%:r'), '[/\\\\]','.','g'),'^\\%(\\l*\\.\\)\\?','','')`\n\t( ${1}\n\t) where\n`expand('%') =~ 'Main' ? \"\\nmain :: IO ()\\nmain = undefined\" : \"\"`",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mod"
        ],
        "opts": []
      },
      {
        "content": "main :: IO ()\nmain = ${0:undefined}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "main"
        ],
        "opts": []
      },
      {
        "content": "${1:name} :: ${2:a}\n$1 = ${0:undefined}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "const"
        ],
        "opts": []
      },
      {
        "content": "${1:fn} :: ${2:a} -> ${3:a}\n$1 ${4} = ${0:undefined}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fn"
        ],
        "opts": []
      },
      {
        "content": "${1:fn} :: ${2:a}\n$1 = ${0:undefined}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fn0"
        ],
        "opts": []
      },
      {
        "content": "${1:fn} :: ${2:a} -> ${3:a}\n$1 ${4} = ${0:undefined}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fn1"
        ],
        "opts": []
      },
      {
        "content": "${1:fn} :: ${2:a} -> ${3:a} -> ${4:a}\n$1 ${5} = ${0:undefined}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fn2"
        ],
        "opts": []
      },
      {
        "content": "${1:fn} :: ${2:a} -> ${3:a} -> ${4:a} -> ${5:a}\n$1 ${6} = ${0:undefined}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fn3"
        ],
        "opts": []
      },
      {
        "content": "(${1:Class} ${2:a}) => $2",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "=> \"Type constraint\""
        ],
        "opts": []
      },
      {
        "content": "${1:map} ${2:fn} ${0:list}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ap"
        ],
        "opts": []
      },
      {
        "content": "\\\\${1:x} -> ${0:expression}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\"
        ],
        "opts": []
      },
      {
        "content": "(\\\\${1:x} -> ${0:expression})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "(\\"
        ],
        "opts": []
      },
      {
        "content": "${1:a} <- ${0:m a}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "<-"
        ],
        "opts": []
      },
      {
        "content": "${1:m a} -> ${0:a}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "->"
        ],
        "opts": []
      },
      {
        "content": "(${1:a}, ${0:b})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tup"
        ],
        "opts": []
      },
      {
        "content": "(${1:a}, ${2:b}, ${0:c})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tup2"
        ],
        "opts": []
      },
      {
        "content": "(${1:a}, ${2:b}, ${3:c}, ${0:d})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tup3"
        ],
        "opts": []
      },
      {
        "content": "${1:Record} { ${2:recFieldA} = ${3:undefined}\n\t\t\t, ${4:recFieldB} = ${0:undefined}\n\t\t\t}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rec"
        ],
        "opts": []
      },
      {
        "content": "case ${1:something} of\n\t${2} -> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case"
        ],
        "opts": []
      },
      {
        "content": "let ${1} = ${2}\nin ${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "let"
        ],
        "opts": []
      },
      {
        "content": "where\n\t${1:fn} = ${0:undefined}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "where"
        ],
        "opts": []
      },
      {
        "content": "module `substitute(substitute(expand('%:r'), '[/\\\\]','.','g'),'^\\%(\\l*\\.\\)\\?','','')` (main, spec) where\nimport Test.Hspec\nimport Test.QuickCheck\nmain :: IO ()\nmain = hspec spec\nspec :: Spec\nspec =\n\tdescribe \"${1}\" $ do\n\t\tit \"${2}\" $\n\t\t\t$0",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "spec"
        ],
        "opts": []
      },
      {
        "content": "module `substitute(substitute(expand('%:r'), '[/\\\\]','.','g'),'^\\%(\\l*\\.\\)\\?','','')` (main, spec) where\nimport Test.Hspec\nimport Test.Hspec.Runner (configFastFail, defaultConfig, hspecWith)\nmain :: IO ()\nmain = hspecWith defaultConfig {configFastFail = True} spec\nspec :: Spec\nspec =\n\tdescribe \"${1}\" $ do\n\t\tit \"${2}\" $\n\t\t\t$0",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "specf"
        ],
        "opts": []
      },
      {
        "content": "describe \"${1}\" $ do\n\t$0",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "desc"
        ],
        "opts": []
      },
      {
        "content": "it \"${1}\" $\n\t$0",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "it"
        ],
        "opts": []
      },
      {
        "content": "it \"${1}\" $ property $\n\t$0",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "itp"
        ],
        "opts": []
      },
      {
        "content": "\\`shouldBe\\` $0",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sb"
        ],
        "opts": []
      },
      {
        "content": "{-| ${0}\n-}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doc"
        ],
        "opts": []
      },
      {
        "content": "import ${1:${2:Data}.${0:Text}}",
        "doc": null,
        "grammar": "snu",
        "label": "Simple import",
        "matches": [
          "imp"
        ],
        "opts": []
      },
      {
        "content": "import ${1:${2:Data}.${3:Text}} (${4})${0}",
        "doc": null,
        "grammar": "snu",
        "label": "Selective import",
        "matches": [
          "imp2"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "import qualified ${1:${2:Data}.${3:Text}} as ${0:`!p snip.rv = t[1].split(\".\")[-1]`}",
        "doc": null,
        "grammar": "snu",
        "label": "Qualified import",
        "matches": [
          "impq"
        ],
        "opts": []
      }
    ],
    "helm": [
      {
        "content": "apiVersion: v1\nkind: Service\nmetadata:\n{{- if .Values.$1.service.annotations }}\n  annotations:\n{{ toYaml .Values.$1.service.annotations | indent 4 }}\n{{- end }}\n  labels:\n{{- if .Values.$1.service.labels }}\n{{ toYaml .Values.$1.service.labels | indent 4 }}\n{{- end }}\n\tapp: {{ template \"$2.name\" . }}\n\tchart: {{ .Chart.Name }}-{{ .Chart.Version }}\n\tcomponent: \"{{ .Values.$1.name }}\"\n\theritage: {{ .Release.Service }}\n\trelease: {{ .Release.Name }}\n  name: {{ template \"$2.$1.fullname\" . }}\nspec:\n  clusterIP: \"{{ .Values.$1.service.clusterIP }}\"\n{{- if .Values.$1.service.externalIPs }}\n  externalIPs:\n{{ toYaml .Values.$1.service.externalIPs | indent 4 }}\n{{- end }}\n{{- if .Values.$1.service.loadBalancerIP }}\n  loadBalancerIP: \"{{ .Values.$1.service.loadBalancerIP }}\"\n{{- end }}\n{{- if .Values.$1.service.loadBalancerSourceRanges }}\n  loadBalancerSourceRanges:\n{{ toYaml .Values.$1.service.loadBalancerSourceRanges | indent 4 }}\n{{- end }}\n  healthCheckNodePort: {{ .Values.$1.service.healthCheckNodePort }}\n  ports:\n\t- name: http\n\t  port: 80\n\t  protocol: TCP\n\t  targetPort: {{ .Values.$1.service.targetPorts.http }}\n\t  {{- if (and (eq .Values.$1.service.type \"NodePort\") (not (empty .Values.$1.service.nodePorts.http))) }}\n\t  nodePort: {{ .Values.$1.service.nodePorts.http }}\n\t  {{- end }}\n\t- name: https\n\t  port: 443\n\t  protocol: TCP\n\t  targetPort: {{ .Values.$1.service.targetPorts.https }}\n\t  {{- if (and (eq .Values.$1.service.type \"NodePort\") (not (empty .Values.$1.service.nodePorts.https))) }}\n\t  nodePort: {{ .Values.$1.service.nodePorts.https }}\n\t  {{- end }}\n  {{- range $key, $value := .Values.tcp }}\n\t- name: \"{{ $key }}-tcp\"\n\t  port: {{ $key }}\n\t  protocol: TCP\n\t  targetPort: \"{{ $key }}-tcp\"\n  {{- end }}\n  {{- range $key, $value := .Values.udp }}\n\t- name: \"{{ $key }}-udp\"\n\t  port: {{ $key }}\n\t  protocol: UDP\n\t  targetPort: \"{{ $key }}-udp\"\n  {{- end }}\n  selector:\n\tapp: {{ template \"${2:chartName}.name\" . }}\n\tcomponent: \"{{ .Values.$1.name }}\"\n\trelease: {{ .Release.Name }}\n  type: \"{{ .Values.${1:value_key}.service.type }}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "service_sample_spec"
        ],
        "opts": []
      },
      {
        "content": "apiVersion: v1\nkind: Service\nmetadata:\n{{- if .Values.$1.service.annotations }}\n  annotations:\n{{ toYaml .Values.$1.service.annotations | indent 4 }}\n{{- end }}\n  labels:\n{{- if .Values.$1.service.labels }}\n{{ toYaml .Values.$1.service.labels | indent 4 }}\n{{- end }}\n\tapp: {{ template \"$2.name\" . }}\n\tchart: {{ .Chart.Name }}-{{ .Chart.Version }}\n\tcomponent: \"{{ .Values.$1.name }}\"\n\theritage: {{ .Release.Service }}\n\trelease: {{ .Release.Name }}\n  name: {{ template \"${2:chartName}.${1:value_key}.fullname\" . }}\n# spec\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "service_spec"
        ],
        "opts": []
      },
      {
        "content": "{{- if .Values.$1.service.annotations }}\n  annotations:\n{{ toYaml .Values.${1:value_key}.service.annotations | indent 4 }}\n{{- end }}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "annotations_spec"
        ],
        "opts": []
      },
      {
        "content": " labels:\n{{- if .Values.$1.service.labels }}\n{{ toYaml .Values.$1.service.labels | indent 4 }}\n{{- end }}\n\tapp: {{ template \"$2.name\" . }}\n\tchart: {{ .Chart.Name }}-{{ .Chart.Version }}\n\tcomponent: \"{{ .Values.$1.name }}\"\n\theritage: {{ .Release.Service }}\n\trelease: {{ .Release.Name }}\n  name: {{ template \"${2:chartName}.${1:value_key}.fullname\" . }}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "labels_spec"
        ],
        "opts": []
      },
      {
        "content": "spec:\n  type: \"{{ .Values.$1.service.type }}\"\n  clusterIP: \"{{ .Values.$1.service.clusterIP }}\"\n{{- if .Values.$1.service.externalIPs }}\n  externalIPs:\n{{ toYaml .Values.$1.service.externalIPs | indent 4 }}\n{{- end }}\n{{- if .Values.$1.service.loadBalancerIP }}\n  loadBalancerIP: \"{{ .Values.$1.service.loadBalancerIP }}\"\n{{- end }}\n{{- if .Values.$1.service.loadBalancerSourceRanges }}\n  loadBalancerSourceRanges:\n{{ toYaml .Values.$1.service.loadBalancerSourceRanges | indent 4 }}\n{{- end }}\n{{- if and (semverCompare \">=1.7-0\" .Capabilities.KubeVersion.GitVersion) (.Values.$1.service.externalTrafficPolicy) }}\n  externalTrafficPolicy: \"{{ .Values.$1.service.externalTrafficPolicy }}\"\n{{- end }}\n{{- if and (semverCompare \">=1.7-0\" .Capabilities.KubeVersion.GitVersion) (.Values.$1.service.healthCheckNodePort) }}\n  healthCheckNodePort: {{ .Values.${1:value_key}.service.healthCheckNodePort }}\n{{- end }}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "service_spec"
        ],
        "opts": []
      },
      {
        "content": "ports:\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ports_spec"
        ],
        "opts": []
      },
      {
        "content": "- name: http\n  port: 80\n  protocol: TCP\n  targetPort: {{ .Values.$1.service.targetPorts.http }}\n  {{- if (and (eq .Values.$1.service.type \"NodePort\") (not (empty .Values.$1.service.nodePorts.http))) }}\n  nodePort: {{ .Values.${1:value_key}.service.nodePorts.http }}\n  {{- end }}\n  ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "portHTTP_spec"
        ],
        "opts": []
      },
      {
        "content": "- name: https\n  port: 443\n  protocol: TCP\n  targetPort: {{ .Values.$1.service.targetPorts.https }}\n  {{- if (and (eq .Values.$1.service.type \"NodePort\") (not (empty .Values.$1.service.nodePorts.https))) }}\n  nodePort: {{ .Values.${1:value_key}.service.nodePorts.https }}\n  {{- end }}\n  ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "portHTTPS_spec"
        ],
        "opts": []
      },
      {
        "content": "{{- range $key, $value := .Values.tcp }}\n  - name: \"{{ $key }}-tcp\"\n\tport: {{ $key }}\n\tprotocol: TCP\n\ttargetPort: \"{{ $key }}-tcp\"\n{{- end }}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "portTCP_spec"
        ],
        "opts": []
      },
      {
        "content": "{{- range $key, $value := .Values.udp }}\n  - name: \"{{ $key }}-udp\"\n\tport: {{ $key }}\n\tprotocol: UDP\n\ttargetPort: \"{{ $key }}-udp\"\n{{- end }}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "portUDP_spec"
        ],
        "opts": []
      },
      {
        "content": "selector:\n  app: {{ template \"${2:chartName}.name\" . }}\n  component: \"{{ .Values.${1:value_key}.name }}\"\n  release: {{ .Release.Name }}\n  ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "selector_spec"
        ],
        "opts": []
      },
      {
        "content": "{{- if .Values.$1.enabled }}\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  labels:\n\tapp: {{ template \"$2.name\" . }}\n\tchart: {{ .Chart.Name }}-{{ .Chart.Version }}\n\tcomponent: \"{{ .Values.$1.name }}\"\n\theritage: {{ .Release.Service }}\n\trelease: {{ .Release.Name }}\n  name: {{ template \"$2.$1.fullname\" . }}\nspec:\n  replicas: {{ .Values.$1.replicaCount }}\n  revisionHistoryLimit: {{ .Values.revisionHistoryLimit }}\n  template:\n\tmetadata:\n\t{{- if .Values.$1.podAnnotations }}\n\t  annotations:\n{{ toYaml .Values.$1.podAnnotations | indent 8 }}\n\t{{- end }}\n\t  labels:\n\t\tapp: {{ template \"$2.name\" . }}\n\t\tcomponent: \"{{ .Values.$1.name }}\"\n\t\trelease: {{ .Release.Name }}\n\t\t{{- if .Values.$1.podLabels }}\n{{ toYaml .Values.$1.podLabels | indent 8 }}\n\t\t{{- end }}\n\tspec:\n\t  {{- if .Values.imagePullSecrets }}\n\t  imagePullSecrets:\n{{ toYaml .Values.imagePullSecrets | indent 8 }}\n\t  {{- end }}\n\t  containers:\n\t\t- name: {{ template \"${2:chartName}.name\" . }}-{{ .Values.$1.name }}\n\t\t  image: \"{{ .Values.$1.image.repository }}:{{ .Values.$1.image.tag }}\"\n\t\t  imagePullPolicy: \"{{ .Values.$1.image.pullPolicy }}\"\n\t\t  args:\n\t\t  {{- range $key, $value := .Values.$1.extraArgs }}\n\t\t\t{{- if $value }}\n\t\t\t- --{{ $key }}={{ $value }}\n\t\t\t{{- else }}\n\t\t\t- --{{ $key }}\n\t\t\t{{- end }}\n\t\t  {{- end }}\n\t\t  livenessProbe:\n\t\t\thttpGet:\n\t\t\t  path: /healthz\n\t\t\t  port: 8080\n\t\t\t  scheme: HTTP\n\t\t\tinitialDelaySeconds: 30\n\t\t\ttimeoutSeconds: 5\n\t\t  ports:\n\t\t\t- name: http\n\t\t\t  containerPort: 8080\n\t\t\t  protocol: TCP\n\t\t  resources:\n{{ toYaml .Values.$1.resources | indent 12 }}\n\t{{- if .Values.$1.nodeSelector }}\n\t  nodeSelector:\n{{ toYaml .Values.$1.nodeSelector | indent 8 }}\n\t{{- end }}\n\t{{- if .Values.$1.tolerations }}\n\t  tolerations:\n{{ toYaml .Values.$1.tolerations | indent 8 }}\n\t{{- end }}\n\t{{- if .Values.$1.affinity }}\n\t  affinity:\n{{ toYaml .Values.${1:value_key}.affinity | indent 8 }}\n\t{{- end }}\n\t  terminationGracePeriodSeconds: 60\n{{- end }}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "deploy_sample_spec"
        ],
        "opts": []
      },
      {
        "content": "{{- if .Values.$1.enabled }}\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  labels:\n\tapp: {{ template \"$2.name\" . }}\n\tchart: {{ .Chart.Name }}-{{ .Chart.Version }}\n\tcomponent: \"{{ .Values.$1.name }}\"\n\theritage: {{ .Release.Service }}\n\trelease: {{ .Release.Name }}\n  name: {{ template \"${2:chartName}.${1:value_key}.fullname\" . }}\n# spec\n\t# containers_spec\n\t# livenessProbe_spec\n\t# PersistentVolumeClaim_spec\n\t# initContainers_spec\n\t# resources_spec\n\t# nodeselector_spec\n\t# tolerations_spec\n\t# affinity_spec\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "deploy_spec"
        ],
        "opts": []
      },
      {
        "content": "spec:\n  replicas: {{ .Values.$1.replicaCount }}\n  revisionHistoryLimit: {{ .Values.revisionHistoryLimit }}\n  template:\n\tmetadata:\n\t{{- if .Values.$1.podAnnotations }}\n\t  annotations:\n{{ toYaml .Values.$1.podAnnotations | indent 8 }}\n\t{{- end }}\n\t  labels:\n\t\tapp: {{ template \"${2:chartName}.name\" . }}\n\t\tcomponent: \"{{ .Values.$1.name }}\"\n\t\trelease: {{ .Release.Name }}\n\t\t{{- if .Values.$1.podLabels }}\n{{ toYaml .Values.${1:value_key}.podLabels | indent 8 }}\n\t\t{{- end }}\n\tspec:\n\t  {{- if .Values.imagePullSecrets }}\n\t  imagePullSecrets:\n{{ toYaml .Values.imagePullSecrets | indent 8 }}\n\t  {{- end }}\n\t  ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "spec_spec"
        ],
        "opts": []
      },
      {
        "content": "\t  {{- if .Values.imagePullSecrets }}\n\t  imagePullSecrets:\n{{ toYaml .Values.imagePullSecrets | indent 8 }}\n\t  {{- end }}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "imagePullSecrets_spec"
        ],
        "opts": []
      },
      {
        "content": "imagePullPolicy: ${1:imagePullPolicy}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "imagePullPolicy_spec"
        ],
        "opts": []
      },
      {
        "content": "containers:\n  - name: {{ template \"${2:chartName}.name\" . }}-{{ .Values.$1.name }}\n\timage: \"{{ .Values.$1.image.repository }}:{{ .Values.$1.image.tag }}\"\n\timagePullPolicy: \"{{ .Values.${1:value_key}.image.pullPolicy }}\"\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "containers_spec"
        ],
        "opts": []
      },
      {
        "content": "args:\n{{- range $key, $value := .Values.${1:value_key}.extraArgs }}\n  {{- if $value }}\n  - --{{ $key }}={{ $value }}\n  {{- else }}\n  - --{{ $key }}\n  {{- end }}\n{{- end }}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "args_spec"
        ],
        "opts": []
      },
      {
        "content": "livenessProbe:\n  httpGet:\n\tpath: /healthz\n\tport: 8080\n\tscheme: HTTP\n  initialDelaySeconds: 30\n  timeoutSeconds: 5\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "livenessProbe_spec"
        ],
        "opts": []
      },
      {
        "content": "readinessProbe:\n  httpGet:\n\tpath: /go/api/v1/health\n\tport: 8153\n  initialDelaySeconds: {{ .Values.$1.healthCheck.initialDelaySeconds }}\n  periodSeconds: {{ .Values.$1.healthCheck.periodSeconds }}\n  failureThreshold: {{ .Values.$1.healthCheck.failureThreshold }}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "readinessProbe_spec"
        ],
        "opts": []
      },
      {
        "content": "resources:\n{{ toYaml .Values.${1:value_key}.resources | indent 12 }}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "resources_spec"
        ],
        "opts": []
      },
      {
        "content": "{{- if .Values.$1.nodeSelector }}\n  nodeSelector:\n{{ toYaml .Values.${1:value_key}.nodeSelector | indent 8 }}\n{{- end }}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nodeselector_spec"
        ],
        "opts": []
      },
      {
        "content": "{{- if .Values.$1.tolerations }}\n  tolerations:\n{{ toYaml .Values.${1:value_key}.tolerations | indent 8 }}\n{{- end }}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tolerations_spec"
        ],
        "opts": []
      },
      {
        "content": "{{- if .Values.$1.affinity }}\n  affinity:\n{{ toYaml .Values.${1:value_key}.affinity | indent 8 }}\n{{- end }}\n  terminationGracePeriodSeconds: 60\n{{- end }}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "affinity_spec"
        ],
        "opts": []
      },
      {
        "content": "kind: PersistentVolumeClaim\napiVersion: v1\nmetadata:\n  name: {{ template \"${2}.$1.fullname\" . }}\n  labels:\n\tapp: {{ template \"${2:chartName}.name\" . }}\n\tchart: \"{{ .Chart.Name }}-{{ .Chart.Version }}\"\n\trelease: \"{{ .Release.Name }}\"\n\theritage: \"{{ .Release.Service }}\"\nspec:\n  accessModes:\n\t- {{ .Values.$1.persistence.accessMode | quote }}\n  resources:\n\trequests:\n\t  storage: {{ .Values.$1.persistence.size | quote }}\n{{- if .Values.$1.persistence.storageClass }}\n{{- if (eq \"-\" .Values.$1.persistence.storageClass) }}\n  storageClassName: \"\"\n{{- else }}\n  storageClassName: \"{{ .Values.${1:value_key}.persistence.storageClass }}\"\n{{- end }}\n{{- end }}\n{{- end }}\n{{- end }}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "PersistentVolumeClaim_spec"
        ],
        "opts": []
      },
      {
        "content": "{{- if .Values.artifactory.enabled -}}\n  apiVersion: v1\n  kind: ConfigMap\n  metadata:\n\tname: {{ template \"${2:chartName}.fullname\" . }}-${1:value_key}-config\n\tlabels:\n\t  app: {{ template \"${2}.name\" . }}\n\t  chart: {{ .Chart.Name }}-{{ .Chart.Version }}\n\t  heritage: {{ .Release.Service }}\n\t  release: {{ .Release.Name }}\n  data:\n\t${3:nameOfConfigFile}.conf: |\n\t  # data goes here\n{{- end -}}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "configMap_spec"
        ],
        "opts": []
      },
      {
        "content": "{{- if .Values.$1.initContainers }}\n\t  initContainers:\n\t  - name: wait-workers\n\t\timage: \"{{ .Values.$1.image.repository }}:{{ .Values.$1.image.tag }}\"\n\t\timagePullPolicy: {{ .Values.${1:value_key}.image.pullPolicy }}\n\t\t# env\n\t\tcommand:\n\t\t  - sh\n\t\t  - -c\n\t\t  - |\n\t\t\tuntil printf \".\" && nc -z -w 2 {{ template \"${2:chartName}.fullname\" . }} {{ .Values.postgresql.service.port }}; do\n\t\t\t\tsleep 2;\n\t\t\tdone;\n\t\t\techo 'PostgreSQL OK ✓'\n\t\t# args\n{{- end }}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "initContainers_spec"
        ],
        "opts": []
      },
      {
        "content": "kind: PersistentVolumeClaim\napiVersion: v1\nmetadata:\n  name: {{ template \"$2.fullname\" . }}\n  labels:\n\tchart: \"{{ .Chart.Name }}-{{ .Chart.Version }}\"\n\trelease: \"{{ .Release.Name }}\"\n\theritage: \"{{ .Release.Service }}\"\n\tapp: {{ template \"${2:chartName}.fullname\" . }}\nspec:\n  accessModes:\n\t- {{ .Values.persistence.accessMode | quote }}\n  resources:\n\trequests:\n\t  storage: {{ .Values.persistence.size | quote }}\n{{- if .Values.persistence.storageClass }}\n{{- if (eq \"-\" .Values.persistence.storageClass) }}\n  storageClassName: \"\"\n{{- else }}\n  storageClassName: \"{{ .Values.persistence.storageClass }}\"\n{{- end }}\n{{- end }}\n{{- end }}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pvc_spec"
        ],
        "opts": []
      },
      {
        "content": "apiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: {{ template \"$2.fullname\" . }}-data-pv\n  labels:\n\tapp: {{ template \"$2.name\" . }}\n\tchart: {{ .Chart.Name }}-{{ .Chart.Version }}\n\theritage: {{ .Release.Service }}\n\trelease: {{ .Release.Name }}\n\tid: {{ template \"${2:chartName}.name\" . }}-data-pv\n\ttype: nfs-volume\nspec:\n  capacity:\n\tstorage: {{ .Values.$1.persistence.nfs.capacity }}\n  accessModes:\n  - ReadWriteOnce\n  persistentVolumeReclaimPolicy: Retain\n  nfs:\n\tserver: {{ .Values.$1.persistence.nfs.ip }}\n\tpath: \"{{ .Values.${1:value_key}.persistence.nfs.haDataMount }}\"\n\treadOnly: false\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pv_nfs_spec"
        ],
        "opts": []
      },
      {
        "content": "{{- if and .Values.persistence.enabled .Values.persistence.$1.hostPath (not\n.Values.persistence.$1.existingClaim) -}}\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: {{ template \"${2:chartName}.fullname\" . }}-$1\nspec:\n  accessModes:\n\t- {{ .Values.persistence.$1.accessMode | quote }}\n  capacity:\n\tstorage: {{ .Values.persistence.$1.size | quote }}\n  hostPath:\n\tpath: {{ .Values.persistence.${1:value_key}.hostPath | quote }}\n{{- end -}}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pvc_hostpath_spec"
        ],
        "opts": []
      },
      {
        "content": "$1:\n  name: ${1:value_key}\n  image:\n\trepository: \n\ttag: \n\tpullPolicy: IfNotPresent\n  hostNetwork: false\n  dnsPolicy: ClusterFirst\n  daemonset:\n\tuseHostPort: false\n  podLabels: {}\n  scope:\n\tenabled: false\n\tnamespace: \"\"   # defaults to .Release.Namespace\n  extraArgs: {}\n  extraEnvs: []\n  kind: Deployment\n  updateStrategy: {}\n  minReadySeconds: 0\n  tolerations: []\n  affinity: {}\n  nodeSelector: {}\n  podAnnotations: {}\n  replicaCount: 1\n  minAvailable: 1\n  resources: {}\n  autoscaling:\n\tenabled: false\n  extraContainers: {}\n  extraVolumeMounts: {}\n  extraVolumes: {}\n  extraInitContainers: []\n  lifecycle: {}\nrevisionHistoryLimit: 10\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "deploy_values"
        ],
        "opts": []
      },
      {
        "content": "${1:value_key}:\nrbac:\n  create: true\nserviceAccount:\n  create: true\n  name:\nimagePullSecrets: []\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rbac_values"
        ],
        "opts": []
      },
      {
        "content": "${1:value_key}:\n  service:\n\tannotations: {}\n\tlabels: {}\n\tclusterIP: \"\"\n\texternalIPs: []\n\tloadBalancerIP: \"\"\n\tloadBalancerSourceRanges: []\n\texternalTrafficPolicy: \"\"\n\thealthCheckNodePort: 0\n\ttargetPorts:\n\t  http: http\n\t  https: https\n\ttype: LoadBalancer\n\tnodePorts:\n\t  http: \"\"\n\t  https: \"\"\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "service_values"
        ],
        "opts": []
      },
      {
        "content": "${1:value_key}:\n  readinessProbe:\n\tfailureThreshold: 3\n\tinitialDelaySeconds: 10\n\tperiodSeconds: 10\n\tsuccessThreshold: 1\n\ttimeoutSeconds: 1\n\tport: 10254\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "readinessProbe_values"
        ],
        "opts": []
      },
      {
        "content": "${1:value_key}:\n  livenessProbe:\n\tfailureThreshold: 3\n\tinitialDelaySeconds: 10\n\tperiodSeconds: 10\n\tsuccessThreshold: 1\n\ttimeoutSeconds: 1\n\tport: 10254\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "livenessProbe_values"
        ],
        "opts": []
      }
    ],
    "help": [],
    "html": [
      {
        "content": "[class]=\"${1:expression}\"",
        "doc": "Angular [class] binding",
        "grammar": "lsp",
        "label": "class",
        "matches": [
          "a-class"
        ],
        "opts": []
      },
      {
        "content": "[style.${1:property}]=\"${2:expression}\"",
        "doc": "Angular [style] binding",
        "grammar": "lsp",
        "label": "style",
        "matches": [
          "a-style"
        ],
        "opts": []
      },
      {
        "content": "[ngClass]=\"{${1:cssClass}: ${2:expression}}\"",
        "doc": "Angular ngClass",
        "grammar": "lsp",
        "label": "ngClass",
        "matches": [
          "a-ngClass"
        ],
        "opts": []
      },
      {
        "content": "*ngFor=\"let ${1:item} of ${2:list}\"${0}",
        "doc": "Angular *ngFor",
        "grammar": "lsp",
        "label": "ngFor",
        "matches": [
          "a-ngFor"
        ],
        "opts": []
      },
      {
        "content": "*ngFor=\"let ${1:item} of ${2:list}; trackBy:${1:item}.id\"${0}",
        "doc": "Angular *ngFor with trackBy",
        "grammar": "lsp",
        "label": "ngFor with trackBy",
        "matches": [
          "a-ngFor-trackBy"
        ],
        "opts": []
      },
      {
        "content": "*ngFor=\"let ${1:item} of ${2:stream} | async as ${3:list}\"${0}",
        "doc": "Angular *ngForAsync",
        "grammar": "lsp",
        "label": "ngForAsync",
        "matches": [
          "a-ngForAsync"
        ],
        "opts": []
      },
      {
        "content": "<form (ngSubmit)=\"onSubmit()\" #${1:form}=\"ngForm\">\n</form>",
        "doc": "Form with ngSubmit and form attributes",
        "grammar": "lsp",
        "label": "ngForm",
        "matches": [
          "a-form"
        ],
        "opts": []
      },
      {
        "content": "formArrayName=\"${1:control}\"",
        "doc": "Angular formArrayName",
        "grammar": "lsp",
        "label": "ngFormArrayName",
        "matches": [
          "a-formArrayName"
        ],
        "opts": []
      },
      {
        "content": "formControlName=\"${1:control}\"",
        "doc": "Angular formControlName",
        "grammar": "lsp",
        "label": "ngFormControlName",
        "matches": [
          "a-formControlName"
        ],
        "opts": []
      },
      {
        "content": "[formGroup]=\"${1:form}\"",
        "doc": "Angular formGroup",
        "grammar": "lsp",
        "label": "ngFormGroup",
        "matches": [
          "a-formGroup"
        ],
        "opts": []
      },
      {
        "content": "[formGroupName]=\"${1:name}\"",
        "doc": "Angular formGroupName",
        "grammar": "lsp",
        "label": "ngFormGroupName",
        "matches": [
          "a-formGroupName"
        ],
        "opts": []
      },
      {
        "content": "<button type=\"submit\" [disabled]=\"!${1:form}.form.valid\">\n\tSave\n</button>",
        "doc": "Angular form submit",
        "grammar": "lsp",
        "label": "ngFormSubmit",
        "matches": [
          "a-form-submit"
        ],
        "opts": []
      },
      {
        "content": "*ngIf=\"${1:expression}\"",
        "doc": "Angular *ngIf",
        "grammar": "lsp",
        "label": "ngIf",
        "matches": [
          "a-ngIf"
        ],
        "opts": []
      },
      {
        "content": "*ngIf=\"${1:expression};else ${2:templateName}\"",
        "doc": "Angular *ngIfElse",
        "grammar": "lsp",
        "label": "ngIfElse",
        "matches": [
          "a-ngIfElse"
        ],
        "opts": []
      },
      {
        "content": "[(ngModel)]=\"${1:binding}\"",
        "doc": "Angular ngModel",
        "grammar": "lsp",
        "label": "ngModel",
        "matches": [
          "a-ngModel"
        ],
        "opts": []
      },
      {
        "content": "[routerLink]=\"['/${1:routePath}']\" routerLinkActive=\"${2:router-link-active}\" $0",
        "doc": "Angular routerLink",
        "grammar": "lsp",
        "label": "ngRouterLink",
        "matches": [
          "a-routerLink"
        ],
        "opts": []
      },
      {
        "content": "[routerLink]=\"['${1:routePath}', ${2:routeParameterValue}]\"\nrouterLinkActive=\"${3:router-link-active}\"$0",
        "doc": "Angular routerLink with a route parameter",
        "grammar": "lsp",
        "label": "ngRouterLinkWithParameter",
        "matches": [
          "a-routerLink-param"
        ],
        "opts": []
      },
      {
        "content": "<select [(ngModel)]=\"${1:model}\">\n\t<option *ngFor=\"let ${2:item} of ${3:list}\" [value]=\"${2:item}\">{{${2:item}}}</option>\n</select>",
        "doc": "<select> control with ngModel",
        "grammar": "lsp",
        "label": "ngSelect",
        "matches": [
          "a-select"
        ],
        "opts": []
      },
      {
        "content": "[ngStyle]=\"{${1:style}: ${2:expression}}\"",
        "doc": "Angular ngStyle",
        "grammar": "lsp",
        "label": "ngStyle",
        "matches": [
          "a-ngStyle"
        ],
        "opts": []
      },
      {
        "content": "<div [ngSwitch]=\"${1:conditionExpression}\">\n\t<div *ngSwitchCase=\"${2:expression}\">${3:output}</div>\n\t<div *ngSwitchDefault>${4:output2}</div>\n</div>",
        "doc": "Angular ngSwitch",
        "grammar": "lsp",
        "label": "ngSwitch",
        "matches": [
          "a-ngSwitch"
        ],
        "opts": []
      },
      {
        "content": "<pre>{{${1:model} | json}}</pre>$0",
        "doc": "Angular pre debug | json",
        "grammar": "lsp",
        "label": "pre w/ json",
        "matches": [
          "a-prej"
        ],
        "opts": []
      },
      {
        "content": "<pre>{{${1:model} | async | json}}</pre>$0",
        "doc": "Angular pre debug | async | json",
        "grammar": "lsp",
        "label": "pre w/ async json",
        "matches": [
          "a-preja"
        ],
        "opts": []
      },
      {
        "content": "<ng-container $0></ng-container>",
        "doc": "Angular ng-container",
        "grammar": "lsp",
        "label": "ng-container",
        "matches": [
          "a-ng-container"
        ],
        "opts": []
      },
      {
        "content": "<ng-template [ngTemplateOutlet]=\"${1:outlet}\" [ngOutletContext]=\"${2:context}\"></ng-template>",
        "doc": "Angular ng-template",
        "grammar": "lsp",
        "label": "ng-template",
        "matches": [
          "a-ng-template"
        ],
        "opts": []
      },
      {
        "content": "<ng-content select=\"${0:selector}\"></ng-content>",
        "doc": "Angular ng-content",
        "grammar": "lsp",
        "label": "ng-content",
        "matches": [
          "a-ng-content"
        ],
        "opts": []
      },
      {
        "content": "&nbsp;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nbs"
        ],
        "opts": []
      },
      {
        "content": "&#x2190;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "left"
        ],
        "opts": []
      },
      {
        "content": "&#x2192;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "right"
        ],
        "opts": []
      },
      {
        "content": "&#x2191;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "up"
        ],
        "opts": []
      },
      {
        "content": "&#x2193;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "down"
        ],
        "opts": []
      },
      {
        "content": "&#x21A9;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "return"
        ],
        "opts": []
      },
      {
        "content": "&#x21E4;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "backtab"
        ],
        "opts": []
      },
      {
        "content": "&#x21E5;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tab"
        ],
        "opts": []
      },
      {
        "content": "&#x21E7;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "shift"
        ],
        "opts": []
      },
      {
        "content": "&#x2303;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ctrl"
        ],
        "opts": []
      },
      {
        "content": "&#x2305;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "enter"
        ],
        "opts": []
      },
      {
        "content": "&#x2318;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cmd"
        ],
        "opts": []
      },
      {
        "content": "&#x2325;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "option"
        ],
        "opts": []
      },
      {
        "content": "&#x2326;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "delete"
        ],
        "opts": []
      },
      {
        "content": "&#x232B;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "backspace"
        ],
        "opts": []
      },
      {
        "content": "&#x238B;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "esc"
        ],
        "opts": []
      },
      {
        "content": "<!-- ${1} -->${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "//"
        ],
        "opts": []
      },
      {
        "content": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\"\n\"http://www.w3.org/TR/html4/strict.dtd\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "docts"
        ],
        "opts": []
      },
      {
        "content": "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n\"http://www.w3.org/TR/html4/loose.dtd\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doct"
        ],
        "opts": []
      },
      {
        "content": "<!DOCTYPE HTML>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doct5"
        ],
        "opts": []
      },
      {
        "content": "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\"\n\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "docxf"
        ],
        "opts": []
      },
      {
        "content": "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\n\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "docxs"
        ],
        "opts": []
      },
      {
        "content": "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "docxt"
        ],
        "opts": []
      },
      {
        "content": "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\"\n\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "docx"
        ],
        "opts": []
      },
      {
        "content": "${1:attribute}=\"${0:property}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "attr"
        ],
        "opts": []
      },
      {
        "content": "${1:attribute}=\"${2:property}\" attr+",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "attr+"
        ],
        "opts": []
      },
      {
        "content": "class=\"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "."
        ],
        "opts": []
      },
      {
        "content": "id=\"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#"
        ],
        "opts": []
      },
      {
        "content": "alt=\"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "alt"
        ],
        "opts": []
      },
      {
        "content": "charset=\"${1:utf-8}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "charset"
        ],
        "opts": []
      },
      {
        "content": "data-${1}=\"${2:$1}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "data"
        ],
        "opts": []
      },
      {
        "content": "for=\"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "height=\"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "height"
        ],
        "opts": []
      },
      {
        "content": "href=\"${1:#}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "href"
        ],
        "opts": []
      },
      {
        "content": "lang=\"${1:en}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lang"
        ],
        "opts": []
      },
      {
        "content": "media=\"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "media"
        ],
        "opts": []
      },
      {
        "content": "name=\"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "name"
        ],
        "opts": []
      },
      {
        "content": "rel=\"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rel"
        ],
        "opts": []
      },
      {
        "content": "scope=\"${1:row}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "scope"
        ],
        "opts": []
      },
      {
        "content": "src=\"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "src"
        ],
        "opts": []
      },
      {
        "content": "title=\"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "title="
        ],
        "opts": []
      },
      {
        "content": "type=\"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "type"
        ],
        "opts": []
      },
      {
        "content": "value=\"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "value"
        ],
        "opts": []
      },
      {
        "content": "width=\"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "width"
        ],
        "opts": []
      },
      {
        "content": "<a href=\"${1:#}\">${0:$1}</a>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "a"
        ],
        "opts": []
      },
      {
        "content": "<a class=\"${1}\" href=\"${2:#}\">${0:$1}</a>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "a."
        ],
        "opts": []
      },
      {
        "content": "<a id=\"${1}\" href=\"${2:#}\">${0:$1}</a>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "a#"
        ],
        "opts": []
      },
      {
        "content": "<a href=\"http://${1:example.com}\">${0:$1}</a>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "a:ext"
        ],
        "opts": []
      },
      {
        "content": "<a href=\"mailto:${1:joe@example.com}?subject=${2:feedback}\">${0:email me}</a>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "a:mail"
        ],
        "opts": []
      },
      {
        "content": "<a href=\"`@+`\">${0:`@+`}</a>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac"
        ],
        "opts": []
      },
      {
        "content": "<abbr title=\"${1}\">${0}</abbr>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "abbr"
        ],
        "opts": []
      },
      {
        "content": "<address>\n\t${0}\n</address>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "address"
        ],
        "opts": []
      },
      {
        "content": "<area shape=\"${1:rect}\" coords=\"${2}\" href=\"${3}\" alt=\"${0}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "area"
        ],
        "opts": []
      },
      {
        "content": "<area shape=\"${1:rect}\" coords=\"${2}\" href=\"${3}\" alt=\"${4}\">\narea+",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "area+"
        ],
        "opts": []
      },
      {
        "content": "<area shape=\"circle\" coords=\"${1}\" href=\"${2}\" alt=\"${0}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "area:c"
        ],
        "opts": []
      },
      {
        "content": "<area shape=\"default\" coords=\"${1}\" href=\"${2}\" alt=\"${0}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "area:d"
        ],
        "opts": []
      },
      {
        "content": "<area shape=\"poly\" coords=\"${1}\" href=\"${2}\" alt=\"${0}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "area:p"
        ],
        "opts": []
      },
      {
        "content": "<area shape=\"rect\" coords=\"${1}\" href=\"${2}\" alt=\"${0}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "area:r"
        ],
        "opts": []
      },
      {
        "content": "<article>\n\t${0}\n</article>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "article"
        ],
        "opts": []
      },
      {
        "content": "<article class=\"${1}\">\n\t${0}\n</article>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "article."
        ],
        "opts": []
      },
      {
        "content": "<article id=\"${1}\">\n\t${0}\n</article>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "article#"
        ],
        "opts": []
      },
      {
        "content": "<aside>\n\t${0}\n</aside>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "aside"
        ],
        "opts": []
      },
      {
        "content": "<aside class=\"${1}\">\n\t${0}\n</aside>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "aside."
        ],
        "opts": []
      },
      {
        "content": "<aside id=\"${1}\">\n\t${0}\n</aside>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "aside#"
        ],
        "opts": []
      },
      {
        "content": "<audio src=\"${1}\">${0}</audio>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "audio"
        ],
        "opts": []
      },
      {
        "content": "<b>${0}</b>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "b"
        ],
        "opts": []
      },
      {
        "content": "<base href=\"${1}\" target=\"${0}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "base"
        ],
        "opts": []
      },
      {
        "content": "<bdi>${0}</bdo>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdi"
        ],
        "opts": []
      },
      {
        "content": "<bdo dir=\"${1}\">${0}</bdo>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdo"
        ],
        "opts": []
      },
      {
        "content": "<bdo dir=\"ltr\">${0}</bdo>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdo:l"
        ],
        "opts": []
      },
      {
        "content": "<bdo dir=\"rtl\">${0}</bdo>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdo:r"
        ],
        "opts": []
      },
      {
        "content": "<blockquote>\n\t${0}\n</blockquote>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "blockquote"
        ],
        "opts": []
      },
      {
        "content": "<body>\n\t${0}\n</body>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "body"
        ],
        "opts": []
      },
      {
        "content": "<br>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "br"
        ],
        "opts": []
      },
      {
        "content": "<button type=\"${1:submit}\">${0}</button>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "button"
        ],
        "opts": []
      },
      {
        "content": "<button class=\"${1:button}\" type=\"${2:submit}\">${0}</button>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "button."
        ],
        "opts": []
      },
      {
        "content": "<button id=\"${1}\" type=\"${2:submit}\">${0}</button>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "button#"
        ],
        "opts": []
      },
      {
        "content": "<button type=\"submit\">${0}</button>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "button:s"
        ],
        "opts": []
      },
      {
        "content": "<button type=\"reset\">${0}</button>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "button:r"
        ],
        "opts": []
      },
      {
        "content": "<canvas>\n\t${0}\n</canvas>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "canvas"
        ],
        "opts": []
      },
      {
        "content": "<caption>${0}</caption>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "caption"
        ],
        "opts": []
      },
      {
        "content": "<cite>${0}</cite>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cite"
        ],
        "opts": []
      },
      {
        "content": "<code>${0}</code>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "code"
        ],
        "opts": []
      },
      {
        "content": "<col>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "col"
        ],
        "opts": []
      },
      {
        "content": "<colgroup>\n\t${0}\n</colgroup>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "colgroup"
        ],
        "opts": []
      },
      {
        "content": "<colgroup>\n\t<col>\n\tcol+${0}\n</colgroup>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "colgroup+"
        ],
        "opts": []
      },
      {
        "content": "<command type=\"command\" label=\"${1}\" icon=\"${0}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "command"
        ],
        "opts": []
      },
      {
        "content": "<command type=\"checkbox\" label=\"${1}\" icon=\"${0}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "command:c"
        ],
        "opts": []
      },
      {
        "content": "<command type=\"radio\" radiogroup=\"${1}\" label=\"${2}\" icon=\"${0}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "command:r"
        ],
        "opts": []
      },
      {
        "content": "<datagrid>\n\t${0}\n</datagrid>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "datagrid"
        ],
        "opts": []
      },
      {
        "content": "<datalist>\n\t${0}\n</datalist>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "datalist"
        ],
        "opts": []
      },
      {
        "content": "<datatemplate>\n\t${0}\n</datatemplate>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "datatemplate"
        ],
        "opts": []
      },
      {
        "content": "<dd>${0}</dd>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dd"
        ],
        "opts": []
      },
      {
        "content": "<dd class=\"${1}\">${0}</dd>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dd."
        ],
        "opts": []
      },
      {
        "content": "<dd id=\"${1}\">${0}</dd>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dd#"
        ],
        "opts": []
      },
      {
        "content": "<del>${0}</del>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "del"
        ],
        "opts": []
      },
      {
        "content": "<details>${0}</details>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "details"
        ],
        "opts": []
      },
      {
        "content": "<dfn>${0}</dfn>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dfn"
        ],
        "opts": []
      },
      {
        "content": "<dialog>\n\t${0}\n</dialog>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dialog"
        ],
        "opts": []
      },
      {
        "content": "<div>\n\t${0}\n</div>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "div"
        ],
        "opts": []
      },
      {
        "content": "<div class=\"${1}\">\n\t${0}\n</div>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "div."
        ],
        "opts": []
      },
      {
        "content": "<div id=\"${1}\">\n\t${0}\n</div>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "div#"
        ],
        "opts": []
      },
      {
        "content": "<dl>\n\t${0}\n</dl>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dl"
        ],
        "opts": []
      },
      {
        "content": "<dl class=\"${1}\">\n\t${0}\n</dl>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dl."
        ],
        "opts": []
      },
      {
        "content": "<dl id=\"${1}\">\n\t${0}\n</dl>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dl#"
        ],
        "opts": []
      },
      {
        "content": "<dl>\n\t<dt>${1}</dt>\n\t<dd>${2}</dd>\n\tdt+${0}\n</dl>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dl+"
        ],
        "opts": []
      },
      {
        "content": "<dt>${0}</dt>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dt"
        ],
        "opts": []
      },
      {
        "content": "<dt class=\"${1}\">${0}</dt>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dt."
        ],
        "opts": []
      },
      {
        "content": "<dt id=\"${1}\">${0}</dt>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dt#"
        ],
        "opts": []
      },
      {
        "content": "<dt>${1}</dt>\n<dd>${2}</dd>\ndt+${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dt+"
        ],
        "opts": []
      },
      {
        "content": "<em>${0}</em>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "em"
        ],
        "opts": []
      },
      {
        "content": "<embed src=\"${1}\" type=\"${0}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "embed"
        ],
        "opts": []
      },
      {
        "content": "<fieldset>\n\t${0}\n</fieldset>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fieldset"
        ],
        "opts": []
      },
      {
        "content": "<fieldset class=\"${1}\">\n\t${0}\n</fieldset>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fieldset."
        ],
        "opts": []
      },
      {
        "content": "<fieldset id=\"${1}\">\n\t${0}\n</fieldset>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fieldset#"
        ],
        "opts": []
      },
      {
        "content": "<fieldset>\n\t<legend><span>${1}</span></legend>\n\t${2}\n</fieldset>\nfieldset+${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fieldset+"
        ],
        "opts": []
      },
      {
        "content": "<figcaption>${0}</figcaption>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "figcaption"
        ],
        "opts": []
      },
      {
        "content": "<figure>${0}</figure>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "figure"
        ],
        "opts": []
      },
      {
        "content": "<figure id=\"${1}\">\n\t${0}\n</figure>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "figure#"
        ],
        "opts": []
      },
      {
        "content": "<figure class=\"${1}\">\n\t${0}\n</figure>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "figure."
        ],
        "opts": []
      },
      {
        "content": "<footer>\n\t${0}\n</footer>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "footer"
        ],
        "opts": []
      },
      {
        "content": "<footer class=\"${1}\">\n\t${0}\n</footer>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "footer."
        ],
        "opts": []
      },
      {
        "content": "<footer id=\"${1}\">\n\t${0}\n</footer>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "footer#"
        ],
        "opts": []
      },
      {
        "content": "<form action=\"${1}\" method=\"${2:post}\">\n\t${0}\n</form>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "form"
        ],
        "opts": []
      },
      {
        "content": "<form class=\"${1}\" action=\"${2}\" method=\"${3:post}\">\n\t${0}\n</form>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "form."
        ],
        "opts": []
      },
      {
        "content": "<form id=\"${1}\" action=\"${2}\" method=\"${3:post}\">\n\t${0}\n</form>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "form#"
        ],
        "opts": []
      },
      {
        "content": "<h1>${0}</h1>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "h1"
        ],
        "opts": []
      },
      {
        "content": "<h1 class=\"${1}\">${0}</h1>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "h1."
        ],
        "opts": []
      },
      {
        "content": "<h1 id=\"${1}\">${0}</h1>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "h1#"
        ],
        "opts": []
      },
      {
        "content": "<h2>${0}</h2>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "h2"
        ],
        "opts": []
      },
      {
        "content": "<h2 class=\"${1}\">${0}</h2>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "h2."
        ],
        "opts": []
      },
      {
        "content": "<h2 id=\"${1}\">${0}</h2>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "h2#"
        ],
        "opts": []
      },
      {
        "content": "<h3>${0}</h3>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "h3"
        ],
        "opts": []
      },
      {
        "content": "<h3 class=\"${1}\">${0}</h3>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "h3."
        ],
        "opts": []
      },
      {
        "content": "<h3 id=\"${1}\">${0}</h3>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "h3#"
        ],
        "opts": []
      },
      {
        "content": "<h4>${0}</h4>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "h4"
        ],
        "opts": []
      },
      {
        "content": "<h4 class=\"${1}\">${0}</h4>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "h4."
        ],
        "opts": []
      },
      {
        "content": "<h4 id=\"${1}\">${0}</h4>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "h4#"
        ],
        "opts": []
      },
      {
        "content": "<h5>${0}</h5>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "h5"
        ],
        "opts": []
      },
      {
        "content": "<h5 class=\"${1}\">${0}</h5>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "h5."
        ],
        "opts": []
      },
      {
        "content": "<h5 id=\"${1}\">${0}</h5>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "h5#"
        ],
        "opts": []
      },
      {
        "content": "<h6>${0}</h6>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "h6"
        ],
        "opts": []
      },
      {
        "content": "<h6 class=\"${1}\">${0}</h6>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "h6."
        ],
        "opts": []
      },
      {
        "content": "<h6 id=\"${1}\">${0}</h6>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "h6#"
        ],
        "opts": []
      },
      {
        "content": "<head>\n\t<meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\">\n\t<title>${1:`substitute(vim_snippets#Filename('', 'Page Title'), '^.', '\\u&', '')`}</title>\n\t${0}\n</head>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "head"
        ],
        "opts": []
      },
      {
        "content": "<header>\n\t${0}\n</header>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "header"
        ],
        "opts": []
      },
      {
        "content": "<header class=\"${1}\">\n\t${0}\n</header>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "header."
        ],
        "opts": []
      },
      {
        "content": "<header id=\"${1}\">\n\t${0}\n</header>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "header#"
        ],
        "opts": []
      },
      {
        "content": "<hgroup>\n\t${0}\n</hgroup>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "hgroup"
        ],
        "opts": []
      },
      {
        "content": "<hgroup class=\"${1}>\n\t${0}\n</hgroup>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "hgroup."
        ],
        "opts": []
      },
      {
        "content": "<hr>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "hr"
        ],
        "opts": []
      },
      {
        "content": "<html>\n${0}\n</html>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "html"
        ],
        "opts": []
      },
      {
        "content": "<html xmlns=\"http://www.w3.org/1999/xhtml\">\n${0}\n</html>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "xhtml"
        ],
        "opts": []
      },
      {
        "content": "<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<meta charset=\"utf-8\">\n\t\t<meta name=\"viewport\" content=\"width=device-width\">\n\t\t<title>${1:`substitute(vim_snippets#Filename('', 'Page Title'), '^.', '\\u&', '')`}</title>\n\t\t${2:link}\n\t</head>\n\t<body>\n\t\t${0:body}\n\t</body>\n</html>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "html5"
        ],
        "opts": []
      },
      {
        "content": "<!DOCTYPE html>\n<html lang=\"${1:en}\">\n\t<head>\n\t\t<meta charset=\"utf-8\">\n\t\t<meta name=\"viewport\" content=\"width=device-width\">\n\t\t<title>${2:`substitute(vim_snippets#Filename('', 'Page Title'), '^.', '\\u&', '')`}</title>\n\t\t${3:link}\n\t</head>\n\t<body>\n\t\t${0:body}\n\t</body>\n</html>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "html5l"
        ],
        "opts": []
      },
      {
        "content": "<i>${0}</i>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "i"
        ],
        "opts": []
      },
      {
        "content": "<iframe src=\"${1}\" frameborder=\"0\"></iframe>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "iframe"
        ],
        "opts": []
      },
      {
        "content": "<iframe class=\"${1}\" src=\"${2}\" frameborder=\"0\"></iframe>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "iframe."
        ],
        "opts": []
      },
      {
        "content": "<iframe id=\"${1}\" src=\"${2}\" frameborder=\"0\"></iframe>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "iframe#"
        ],
        "opts": []
      },
      {
        "content": "<img src=\"${1}\" alt=\"${2}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "img"
        ],
        "opts": []
      },
      {
        "content": "<img class=\"${1}\" src=\"${2}\" alt=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "img."
        ],
        "opts": []
      },
      {
        "content": "<img id=\"${1}\" src=\"${2}\" alt=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "img#"
        ],
        "opts": []
      },
      {
        "content": "<input type=\"${1:text/submit/hidden/button/image}\" name=\"${2}\" id=\"${3:$2}\" value=\"${4}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "input"
        ],
        "opts": []
      },
      {
        "content": "<input class=\"${1}\" type=\"${2:text/submit/hidden/button/image}\" name=\"${3}\" id=\"${4:$3}\" value=\"${5}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "input."
        ],
        "opts": []
      },
      {
        "content": "<input type=\"text\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "input:text"
        ],
        "opts": []
      },
      {
        "content": "<input type=\"submit\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "input:submit"
        ],
        "opts": []
      },
      {
        "content": "<input type=\"hidden\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "input:hidden"
        ],
        "opts": []
      },
      {
        "content": "<input type=\"button\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "input:button"
        ],
        "opts": []
      },
      {
        "content": "<input type=\"image\" name=\"${1}\" id=\"${2:$1}\" src=\"${3}\" alt=\"${4}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "input:image"
        ],
        "opts": []
      },
      {
        "content": "<input type=\"checkbox\" name=\"${1}\" id=\"${2:$1}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "input:checkbox"
        ],
        "opts": []
      },
      {
        "content": "<input type=\"radio\" name=\"${1}\" id=\"${2:$1}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "input:radio"
        ],
        "opts": []
      },
      {
        "content": "<input type=\"color\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "input:color"
        ],
        "opts": []
      },
      {
        "content": "<input type=\"date\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "input:date"
        ],
        "opts": []
      },
      {
        "content": "<input type=\"datetime\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "input:datetime"
        ],
        "opts": []
      },
      {
        "content": "<input type=\"datetime-local\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "input:datetime-local"
        ],
        "opts": []
      },
      {
        "content": "<input type=\"email\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "input:email"
        ],
        "opts": []
      },
      {
        "content": "<input type=\"file\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "input:file"
        ],
        "opts": []
      },
      {
        "content": "<input type=\"month\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "input:month"
        ],
        "opts": []
      },
      {
        "content": "<input type=\"number\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "input:number"
        ],
        "opts": []
      },
      {
        "content": "<input type=\"password\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "input:password"
        ],
        "opts": []
      },
      {
        "content": "<input type=\"range\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "input:range"
        ],
        "opts": []
      },
      {
        "content": "<input type=\"reset\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "input:reset"
        ],
        "opts": []
      },
      {
        "content": "<input type=\"search\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "input:search"
        ],
        "opts": []
      },
      {
        "content": "<input type=\"time\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "input:time"
        ],
        "opts": []
      },
      {
        "content": "<input type=\"url\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "input:url"
        ],
        "opts": []
      },
      {
        "content": "<input type=\"week\" name=\"${1}\" id=\"${2:$1}\" value=\"${3}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "input:week"
        ],
        "opts": []
      },
      {
        "content": "<ins>${0}</ins>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ins"
        ],
        "opts": []
      },
      {
        "content": "<kbd>${0}</kbd>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "kbd"
        ],
        "opts": []
      },
      {
        "content": "<label for=\"${0:$1}\">${1}</label>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "label"
        ],
        "opts": []
      },
      {
        "content": "<label for=\"${2:$1}\">${1}</label>\n<input type=\"${3:text/submit/hidden/button}\" name=\"${4:$2}\" id=\"${5:$2}\" value=\"${6}\" />",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "label:i"
        ],
        "opts": []
      },
      {
        "content": "<label for=\"${2:$1}\">${1}</label>\n<select name=\"${3:$2}\" id=\"${4:$2}\">\n\t<option value=\"${5}\">${0:$5}</option>\n</select>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "label:s"
        ],
        "opts": []
      },
      {
        "content": "<legend>${0}</legend>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "legend"
        ],
        "opts": []
      },
      {
        "content": "<legend><span>${0}</span></legend>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "legend+"
        ],
        "opts": []
      },
      {
        "content": "<li>${0}</li>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "li"
        ],
        "opts": []
      },
      {
        "content": "<li class=\"${1}\">${0}</li>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "li."
        ],
        "opts": []
      },
      {
        "content": "<li>${1}</li>\nli+",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "li+"
        ],
        "opts": []
      },
      {
        "content": "<li><a href=\"${0:#}\">${1}</a></li>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lia"
        ],
        "opts": []
      },
      {
        "content": "<li><a href=\"${2:#}\">${1}</a></li>\nlia+",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lia+"
        ],
        "opts": []
      },
      {
        "content": "<link rel=\"${1}\" href=\"${2}\" title=\"${3}\" type=\"${4}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "link"
        ],
        "opts": []
      },
      {
        "content": "<link rel=\"alternate\" href=\"${1:atom.xml}\" title=\"Atom\" type=\"application/atom+xml\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "link:atom"
        ],
        "opts": []
      },
      {
        "content": "<link rel=\"stylesheet\" href=\"${1:style.css}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "link:s"
        ],
        "opts": []
      },
      {
        "content": "<link rel=\"stylesheet\" href=\"${1:style.css}\" type=\"text/css\" media=\"${2:all}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "link:css"
        ],
        "opts": []
      },
      {
        "content": "<link rel=\"shortcut icon\" href=\"${1:favicon.ico}\" type=\"image/x-icon\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "link:favicon"
        ],
        "opts": []
      },
      {
        "content": "<link rel=\"alternate\" href=\"${1:rss.xml}\" title=\"RSS\" type=\"application/atom+xml\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "link:rss"
        ],
        "opts": []
      },
      {
        "content": "<link rel=\"apple-touch-icon\" href=\"${1:favicon.png}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "link:touch"
        ],
        "opts": []
      },
      {
        "content": "<main role=\"main\">\n\t${0}\n</main>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "main"
        ],
        "opts": []
      },
      {
        "content": "<map name=\"${1}\">\n\t${0}\n</map>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "map"
        ],
        "opts": []
      },
      {
        "content": "<map class=\"${1}\" name=\"${2}\">\n\t${0}\n</map>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "map."
        ],
        "opts": []
      },
      {
        "content": "<map name=\"${1}\" id=\"${2:$1}>\n\t${0}\n</map>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "map#"
        ],
        "opts": []
      },
      {
        "content": "<map name=\"${1}\">\n\t<area shape=\"${2}\" coords=\"${3}\" href=\"${4}\" alt=\"${5}\" />${6}\n</map>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "map+"
        ],
        "opts": []
      },
      {
        "content": "<mark>${0}</mark>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mark"
        ],
        "opts": []
      },
      {
        "content": "<menu>\n\t${0}\n</menu>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "menu"
        ],
        "opts": []
      },
      {
        "content": "<menu type=\"context\">\n\t${0}\n</menu>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "menu:c"
        ],
        "opts": []
      },
      {
        "content": "<menu type=\"toolbar\">\n\t${0}\n</menu>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "menu:t"
        ],
        "opts": []
      },
      {
        "content": "<meta http-equiv=\"${1}\" content=\"${2}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "meta"
        ],
        "opts": []
      },
      {
        "content": "<meta ${0}>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "meta:s"
        ],
        "opts": []
      },
      {
        "content": "<meta name=\"description\" content=\"${0}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "meta:d"
        ],
        "opts": []
      },
      {
        "content": "<meta http-equiv=\"X-UA-Compatible\" content=\"IE=${1:7,8,edge}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "meta:compat"
        ],
        "opts": []
      },
      {
        "content": "<meta http-equiv=\"refresh\" content=\"text/html;charset=UTF-8\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "meta:refresh"
        ],
        "opts": []
      },
      {
        "content": "<meta http-equiv=\"content-type\" content=\"text/html;charset=UTF-8\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "meta:utf"
        ],
        "opts": []
      },
      {
        "content": "<meter>${0}</meter>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "meter"
        ],
        "opts": []
      },
      {
        "content": "<nav>\n\t${0}\n</nav>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nav"
        ],
        "opts": []
      },
      {
        "content": "<nav class=\"${1}\">\n\t${0}\n</nav>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nav."
        ],
        "opts": []
      },
      {
        "content": "<nav id=\"${1}\">\n\t${0}\n</nav>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nav#"
        ],
        "opts": []
      },
      {
        "content": "<noscript>\n\t${0}\n</noscript>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "noscript"
        ],
        "opts": []
      },
      {
        "content": "<object data=\"${1}\" type=\"${2}\">\n\t${3}\n</object>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "object"
        ],
        "opts": []
      },
      {
        "content": "<object width=\"$2\" height=\"$3\" classid=\"clsid:02BF25D5-8C17-4B23-BC80-D3488ABDDC6B\"\ncodebase=\"http://www.apple.com/qtactivex/qtplugin.cab\">\n\t<param name=\"src\" value=\"$1\">\n\t<param name=\"controller\" value=\"$4\">\n\t<param name=\"autoplay\" value=\"$5\">\n\t<embed src=\"${1:movie.mov}\"\n\t\twidth=\"${2:320}\" height=\"${3:240}\"\n\t\tcontroller=\"${4:true}\" autoplay=\"${5:true}\"\n\t\tscale=\"tofit\" cache=\"true\"\n\t\tpluginspage=\"http://www.apple.com/quicktime/download/\">\n</object>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "movie"
        ],
        "opts": []
      },
      {
        "content": "<ol>\n\t${0}\n</ol>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ol"
        ],
        "opts": []
      },
      {
        "content": "<ol class=\"${1}\">\n\t${0}\n</ol>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ol."
        ],
        "opts": []
      },
      {
        "content": "<ol id=\"${1}\">\n\t${0}\n</ol>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ol#"
        ],
        "opts": []
      },
      {
        "content": "<ol>\n\t<li>${1}</li>\n\tli+${0}\n</ol>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ol+"
        ],
        "opts": []
      },
      {
        "content": "<option value=\"${1}\">${0:$1}</option>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "opt"
        ],
        "opts": []
      },
      {
        "content": "<option value=\"${1}\">${2:$1}</option>\nopt+${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "opt+"
        ],
        "opts": []
      },
      {
        "content": "<option>${0}</option>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "optt"
        ],
        "opts": []
      },
      {
        "content": "<optgroup>\n\t<option value=\"${1}\">${2:$1}</option>\n\topt+${0}\n</optgroup>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "optgroup"
        ],
        "opts": []
      },
      {
        "content": "<output>${0}</output>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "output"
        ],
        "opts": []
      },
      {
        "content": "<p>${0}</p>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p"
        ],
        "opts": []
      },
      {
        "content": "<p class=\"${1}\">${0}</p>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p."
        ],
        "opts": []
      },
      {
        "content": "<p id=\"${1}\">${0}</p>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p#"
        ],
        "opts": []
      },
      {
        "content": "<param name=\"${1}\" value=\"${2}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "param"
        ],
        "opts": []
      },
      {
        "content": "<pre>\n\t${0}\n</pre>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pre"
        ],
        "opts": []
      },
      {
        "content": "<progress>${0}</progress>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "progress"
        ],
        "opts": []
      },
      {
        "content": "<q>${0}</q>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "q"
        ],
        "opts": []
      },
      {
        "content": "<rp>${0}</rp>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rp"
        ],
        "opts": []
      },
      {
        "content": "<rt>${0}</rt>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rt"
        ],
        "opts": []
      },
      {
        "content": "<ruby>\n\t<rp><rt>${0}</rt></rp>\n</ruby>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ruby"
        ],
        "opts": []
      },
      {
        "content": "<s>${0}</s>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "s"
        ],
        "opts": []
      },
      {
        "content": "<samp>\n\t${0}\n</samp>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "samp"
        ],
        "opts": []
      },
      {
        "content": "<script>\n\t${0}\n</script>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "script"
        ],
        "opts": []
      },
      {
        "content": "<script src=\"${0}.js\"></script>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "scripts"
        ],
        "opts": []
      },
      {
        "content": "<script type=\"${1}\" id=\"${2}\">\n\t${0}\n</script>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "scriptt"
        ],
        "opts": []
      },
      {
        "content": "<script src=\"${0}.js\" charset=\"utf-8\"></script>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "scriptsrc"
        ],
        "opts": []
      },
      {
        "content": "<section>\n\t${0}\n</section>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "section"
        ],
        "opts": []
      },
      {
        "content": "<section class=\"${1}\">\n\t${0}\n</section>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "section."
        ],
        "opts": []
      },
      {
        "content": "<section id=\"${1}\">\n\t${0}\n</section>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "section#"
        ],
        "opts": []
      },
      {
        "content": "<select name=\"${1}\" id=\"${2:$1}\">\n\t${0}\n</select>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "select"
        ],
        "opts": []
      },
      {
        "content": "<select name=\"${1}\" id=\"${2:$1}\" class=\"${3}>\n\t${0}\n</select>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "select."
        ],
        "opts": []
      },
      {
        "content": "<select name=\"${1}\" id=\"${2:$1}\">\n\t<option value=\"${3}\">${4:$3}</option>\n\topt+${0}\n</select>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "select+"
        ],
        "opts": []
      },
      {
        "content": "<small>${0}</small>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "small"
        ],
        "opts": []
      },
      {
        "content": "<source src=\"${1}\" type=\"${2}\" media=\"${0}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "source"
        ],
        "opts": []
      },
      {
        "content": "<span>${0}</span>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "span"
        ],
        "opts": []
      },
      {
        "content": "<span class=\"${1}\">${0}</span>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "span."
        ],
        "opts": []
      },
      {
        "content": "<span id=\"${1}\">${0}</span>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "span#"
        ],
        "opts": []
      },
      {
        "content": "<strong>${0}</strong>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "strong"
        ],
        "opts": []
      },
      {
        "content": "<style type=\"text/css\" media=\"${1:all}\">\n\t${0}\n</style>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "style"
        ],
        "opts": []
      },
      {
        "content": "<sub>${0}</sub>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sub"
        ],
        "opts": []
      },
      {
        "content": "<summary>\n\t${0}\n</summary>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "summary"
        ],
        "opts": []
      },
      {
        "content": "<sup>${0}</sup>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sup"
        ],
        "opts": []
      },
      {
        "content": "<table>\n\t${0}\n</table>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "table"
        ],
        "opts": []
      },
      {
        "content": "<table class=\"${1}\">\n\t${0}\n</table>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "table."
        ],
        "opts": []
      },
      {
        "content": "<table id=\"${1}\">\n\t${0}\n</table>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "table#"
        ],
        "opts": []
      },
      {
        "content": "<tbody>\n\t${0}\n</tbody>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tbody"
        ],
        "opts": []
      },
      {
        "content": "<td>${0}</td>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "td"
        ],
        "opts": []
      },
      {
        "content": "<td class=\"${1}\">${0}</td>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "td."
        ],
        "opts": []
      },
      {
        "content": "<td id=\"${1}\">${0}</td>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "td#"
        ],
        "opts": []
      },
      {
        "content": "<td>${1}</td>\ntd+${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "td+"
        ],
        "opts": []
      },
      {
        "content": "<textarea name=\"${1}\" id=\"${2:$1}\" rows=\"${3:8}\" cols=\"${4:40}\">${5}</textarea>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "textarea"
        ],
        "opts": []
      },
      {
        "content": "<tfoot>\n\t${0}\n</tfoot>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tfoot"
        ],
        "opts": []
      },
      {
        "content": "<th>${0}</th>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "th"
        ],
        "opts": []
      },
      {
        "content": "<th class=\"${1}\">${0}</th>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "th."
        ],
        "opts": []
      },
      {
        "content": "<th id=\"${1}\">${0}</th>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "th#"
        ],
        "opts": []
      },
      {
        "content": "<th>${1}</th>\nth+${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "th+"
        ],
        "opts": []
      },
      {
        "content": "<thead>\n\t${0}\n</thead>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "thead"
        ],
        "opts": []
      },
      {
        "content": "<time datetime=\"${1}\" pubdate=\"${2:$1}\">${0:$1}</time>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "time"
        ],
        "opts": []
      },
      {
        "content": "<title>${0:`substitute(vim_snippets#Filename('', 'Page Title'), '^.', '\\u&', '')`}</title>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "title"
        ],
        "opts": []
      },
      {
        "content": "<tr>\n\t${0}\n</tr>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tr"
        ],
        "opts": []
      },
      {
        "content": "<tr>\n\t<td>${1}</td>\n\ttd+${0}\n</tr>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tr+"
        ],
        "opts": []
      },
      {
        "content": "<track src=\"${1}\" srclang=\"${2}\" label=\"${3}\" default=\"${4:default}>${5}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "track"
        ],
        "opts": []
      },
      {
        "content": "<ul>\n\t${0}\n</ul>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ul"
        ],
        "opts": []
      },
      {
        "content": "<ul class=\"${1}\">\n\t${0}\n</ul>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ul."
        ],
        "opts": []
      },
      {
        "content": "<ul id=\"${1}\">\n\t${0}\n</ul>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ul#"
        ],
        "opts": []
      },
      {
        "content": "<ul>\n\t<li>${1}</li>\n\tli+${0}\n</ul>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ul+"
        ],
        "opts": []
      },
      {
        "content": "<var>${0}</var>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "var"
        ],
        "opts": []
      },
      {
        "content": "<video src=\"${1}\" height=\"${2}\" width=\"${3}\" preload=\"${4:none}\" autoplay=\"${5:autoplay}\">${6}</video>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "video"
        ],
        "opts": []
      },
      {
        "content": "<video class=\"${1}\" src=\"${2}\" height=\"${3}\" width=\"${4}\" preload=\"${5:none}\" autoplay=\"${6:autoplay}\">${7}</video>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "video."
        ],
        "opts": []
      },
      {
        "content": "<wbr>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wbr"
        ],
        "opts": []
      },
      {
        "content": "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "viewport"
        ],
        "opts": []
      },
      {
        "content": "<!DOCTYPE html\nPUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\n\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doctypetransitional"
        ],
        "opts": []
      },
      {
        "content": "<!DOCTYPE html\nPUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\n\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doctypeframeset"
        ],
        "opts": []
      },
      {
        "content": "<!DOCTYPE html\nPUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\n\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doctypestrict"
        ],
        "opts": []
      },
      {
        "content": "<!doctype html>\n<html lang=\"${1:en}\">\n    <head>\n        <meta charset=\"${2:utf-8}\">\n        <meta name=\"viewport\" content=\"${3:width=device-width, initial-scale=1}\">\n        <title>${4}</title>\n    </head>\n    <body>\n        ${5}\n    </body>\n</html>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "html5"
        ],
        "opts": []
      },
      {
        "content": "<head>\n    <meta charset=\"${1:utf-8}\">\n    <title>${2}</title>\n<style>\n    ${3}\n</style>\n    ${4}\n</head>${5}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "head"
        ],
        "opts": []
      },
      {
        "content": "<meta name=\"author\" content=\"${1}\">${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "metaauthor"
        ],
        "opts": []
      },
      {
        "content": "<meta name=\"keywords\" content=\"${1}\">${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "keywords"
        ],
        "opts": []
      },
      {
        "content": "<meta name=\"others\" content=\"${1}\">${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "metaothers"
        ],
        "opts": []
      },
      {
        "content": "<meta name=\"generator\" content=\"${1}\">${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "metagenerator"
        ],
        "opts": []
      },
      {
        "content": "<meta name=\"description\" content=\"${1}\">${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "metadescription"
        ],
        "opts": []
      },
      {
        "content": "<meta name=\"viewport\" content=\"${1:width=device-width, initial-scale=1}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "metaviewport"
        ],
        "opts": []
      },
      {
        "content": "<meta name=\"theme-color\" content=\"#${1}\">",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "metatheme"
        ],
        "opts": []
      },
      {
        "content": "<script charset=\"${1:UTF-8}\">\n${2:TARGET}\n</script>${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "scriptcharset"
        ],
        "opts": []
      },
      {
        "content": "<script>\n${1:TARGET}\n</script>${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "script"
        ],
        "opts": []
      },
      {
        "content": "<script src=\"${1}\"${2: defer}></script>${3}",
        "doc": "",
        "grammar": "snu",
        "label": "js",
        "matches": [
          "scriptsrc"
        ],
        "opts": []
      },
      {
        "content": "<body>\n   ${1:TARGET}\n</body>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "body"
        ],
        "opts": []
      },
      {
        "content": "<h${1:1}>${2}</h$1>${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "h"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<p>${1}</p>${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<br>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "br"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<hr>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "hr"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<!--${1:TARGET}-->${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "comment"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<b>${1:TARGET}</b>${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "b"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<small>${1:TARGET}</small>${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "small"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<strong>${1:TARGET}</strong>${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "strong"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<sub>${1:TARGET}</sub>${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sub"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<sup>${1:TARGET}</sup>${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sup"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<ins>${1:TARGET}</ins>${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ins"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<del>${1:TARGET}</del>${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "del"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<em>${1:TARGET}</em>${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "em"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<bdo dir=\"${1:rtl}\">${2:TARGET}</bdo>${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdo"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<pre>\n${1:TARGET}\n</pre>${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pre"
        ],
        "opts": []
      },
      {
        "content": "<blockquote>\n${1}\n</blockquote>\n${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "blockquote"
        ],
        "opts": []
      },
      {
        "content": "<link rel=\"${1:stylesheet}\" href=\"${2}.css\"${3}>${4}",
        "doc": "",
        "grammar": "snu",
        "label": "link stylesheet css",
        "matches": [
          "link"
        ],
        "opts": []
      },
      {
        "content": "<link rel=\"manifest\" href=\"${1:manifest.json}\">${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "manifest"
        ],
        "opts": []
      },
      {
        "content": "text-align=\"left\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "alignl"
        ],
        "opts": []
      },
      {
        "content": "text-align=\"right\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "alignr"
        ],
        "opts": []
      },
      {
        "content": "text-align=\"center\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "alignc"
        ],
        "opts": []
      },
      {
        "content": "bgcolor=\"${1}\"${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgcolor"
        ],
        "opts": []
      },
      {
        "content": "<a href=\"${1}\">${2:TARGET}</a>${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ahref"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<a href=\"${1}\" target=\"_blank\" rel=\"noopener\">${2:TARGET}</a>${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ahref_blank"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<a href=\"${1}\" target=\"_parent\">${2:TARGET}</a>${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ahref_parent"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<a href=\"${1}\" target=\"_top\">${2:TARGET}</a>${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ahref_top"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<a name=\"${1}\">${2:TARGET}</a>${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "aname"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<frameset cols=\"${1}\">\n${2:TARGET}\n</frameset>${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "framesetcols"
        ],
        "opts": []
      },
      {
        "content": "<frameset rows=\"${1}\"\n${2:TARGET}\n</frameset>${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "framesetrows"
        ],
        "opts": []
      },
      {
        "content": "<iframe src=\"${1}\"></iframe>${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "iframe"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<table border=\"${1}\">\n${2:TARGET}\n</table>${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "table"
        ],
        "opts": []
      },
      {
        "content": "<th>${1:TARGET}</th>${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "th"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<ul type=\"square\">${1:TARGET}</ul>${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ulsquare"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<ul type=\"circle\">${1:TARGET}</ul>${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ulcircle"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<ul type=\"disc\">${1:TARGET}</ul>${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "uldisc"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<ol>${1:TARGET}</ol>${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ol"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<ol type=\"A\">${1:TARGET}</ol>${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "olA"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<ol type=\"a\">${1:TARGET}</ol>${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ola"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<ol type=\"I\">${1:TARGET}</ol>${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "olI"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<ol type=\"i\">${1:TARGET}</ol>${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "oli"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<li>${1:TARGET}</li>${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "li"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<dl>${1:TARGET}</dl>${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dl"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<dt>${1:TARGET}</dt>${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dt"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<dd>${1:TARGET}</dd>${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dd"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<form>\n${1:TARGET}\n</form>${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "form"
        ],
        "opts": []
      },
      {
        "content": "<input type=\"text\" name=\"${1:user}\">${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "inputtext"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<input type=\"password\" name=\"${1:password}\">${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "inputpassword"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<input type=\"radio\" name=\"${1}\" value=\"value\">${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "inputradio"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<input type=\"checkbox\" name=\"${1}\">${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "inputcheckbox"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<textarea rows=\"${1}\" cols=\"${2}\">\n${3:TARGET}\n</textarea>\n${4}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "textarea"
        ],
        "opts": []
      },
      {
        "content": "<button>${1:TARGET}</button>${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "button"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<button type=\"submit\">${1:TARGET}</button>${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "buttonsubmit"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<select>${1:TARGET}</select>${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "select"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<optgroup label=\"${1}\">\n${2:TARGET}\n<optgroup>${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "optgroup"
        ],
        "opts": []
      },
      {
        "content": "<option value=\"${1}\">${2:TARGET}</option>${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "option"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<label>${1}: <input type=\"${2:TARGET}\" /></label>${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "label"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<label for=\"${1}:id\">${2:TARGET}</label>${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "labelfor"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<fieldset>${1:TARGET}</fieldset>${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fieldset"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<legend>${1:TARGET}</legend>${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "legend"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "id=\"${1}\"${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "id"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "class=\"${1}\"${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "class"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<p class=\"${1}\">${2:TARGET}</p>${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pclass"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<p id=\"${1}\">${2:TARGET}</p>${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pid"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<div id=\"${1}\">${2:TARGET}</div>${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "divid"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<div class=\"${1}\">${2:TARGET}</div>${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "divclass"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<img src=\"${1}\" alt=\"${2}\">${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "img"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<div ${1:id=\"${2:someid\\}\"}>${3:TARGET}</div>${4}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "div"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<header>\n    ${1}\n</header>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "header"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<nav>\n    ${1}\n</nav>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nav"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<main>\n    ${1}\n</main>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "main"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<footer>\n    ${1}\n</footer>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "footer"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<details${2}>\n    <summary>${1}</summary>\n    ${3}\n</details>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "details"
        ],
        "opts": []
      }
    ],
    "html_minimal": [
      {
        "content": "id=\"$1\"$2",
        "doc": null,
        "grammar": "snu",
        "label": null,
        "matches": [
          "id"
        ],
        "opts": []
      },
      {
        "content": "id=\"$1\" name=\"${2:$1}\"",
        "doc": null,
        "grammar": "snu",
        "label": null,
        "matches": [
          "idn"
        ],
        "opts": []
      },
      {
        "content": "<label for=\"${2:$1}\">$1</label>\n<input type=\"${3:text}\" name=\"${4:$2}\"${5: id=\"${6:$2}\"} value=\"$7\" />$8",
        "doc": null,
        "grammar": "snu",
        "label": null,
        "matches": [
          "label_and_input"
        ],
        "opts": []
      },
      {
        "content": "<input type=\"${1:text}\" value=\"$2\" name=\"$3\"${4: id=\"${5:$3}\"}/>$7",
        "doc": null,
        "grammar": "snu",
        "label": null,
        "matches": [
          "input"
        ],
        "opts": []
      },
      {
        "content": "<input type=\"submit\" value=\"$2\" $3/>$7",
        "doc": null,
        "grammar": "snu",
        "label": null,
        "matches": [
          "submit"
        ],
        "opts": []
      },
      {
        "content": "<textarea name=\"$2\"${3: id=\"$4\"}>$5</textarea>",
        "doc": null,
        "grammar": "snu",
        "label": null,
        "matches": [
          "textarea"
        ],
        "opts": []
      },
      {
        "content": "<img src=\"$1\"${2: alt=\"$3\"}/>",
        "doc": null,
        "grammar": "snu",
        "label": null,
        "matches": [
          "img"
        ],
        "opts": []
      }
    ],
    "htmldjango": [
      {
        "content": "{% ${1} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "%"
        ],
        "opts": []
      },
      {
        "content": "{% ${1:tag_name} %}\n${0}\n{% end$1 %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "%%"
        ],
        "opts": []
      },
      {
        "content": "{{ ${1} }}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "{"
        ],
        "opts": []
      },
      {
        "content": "{% autoescape ${1:off} %}\n\t${0}\n{% endautoescape %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "autoescape"
        ],
        "opts": []
      },
      {
        "content": "{% block ${1} %}\n\t${0}\n{% endblock %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "block"
        ],
        "opts": []
      },
      {
        "content": "{# ${0:comment} #}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#"
        ],
        "opts": []
      },
      {
        "content": "{% comment %}\n\t${0}\n{% endcomment %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "comment"
        ],
        "opts": []
      },
      {
        "content": "{% cycle ${1:val1} ${2:val2} ${3:as ${4}} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cycle"
        ],
        "opts": []
      },
      {
        "content": "{% debug %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "debug"
        ],
        "opts": []
      },
      {
        "content": "{% extends \"${0:base.html}\" %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "extends"
        ],
        "opts": []
      },
      {
        "content": "{% filter ${1} %}\n\t${0}\n{% endfilter %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "filter"
        ],
        "opts": []
      },
      {
        "content": "{% firstof ${1} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "firstof"
        ],
        "opts": []
      },
      {
        "content": "{% for ${1} in ${2} %}\n\t${0}\n{% endfor %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "{% empty %}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "empty"
        ],
        "opts": []
      },
      {
        "content": "{% if ${1} %}\n\t${0}\n{% endif %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "{% else %}\n\t${1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "el"
        ],
        "opts": []
      },
      {
        "content": "{% elif ${1} %}\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eif"
        ],
        "opts": []
      },
      {
        "content": "{% ifchanged %}${1}{% endifchanged %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifchanged"
        ],
        "opts": []
      },
      {
        "content": "{% ifequal ${1} ${2} %}\n\t${0}\n{% endifequal %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifequal"
        ],
        "opts": []
      },
      {
        "content": "{% ifnotequal ${1} ${2} %}\n\t${0}\n{% endifnotequal %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifnotequal"
        ],
        "opts": []
      },
      {
        "content": "{% include \"${0}\" %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "include"
        ],
        "opts": []
      },
      {
        "content": "{% load ${0} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "load"
        ],
        "opts": []
      },
      {
        "content": "{% now \"${0:jS F Y H:i}\" %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "now"
        ],
        "opts": []
      },
      {
        "content": "{% regroup ${1} by ${2} as ${0} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "regroup"
        ],
        "opts": []
      },
      {
        "content": "{% spaceless %}${0}{% endspaceless %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "spaceless"
        ],
        "opts": []
      },
      {
        "content": "{% ssi ${0} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ssi"
        ],
        "opts": []
      },
      {
        "content": "{% trans \"${0:string}\" %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "trans"
        ],
        "opts": []
      },
      {
        "content": "{% url ${1} as ${0} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "url"
        ],
        "opts": []
      },
      {
        "content": "{% widthratio ${1:this_value} ${2:max_value} ${0:100} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "widthratio"
        ],
        "opts": []
      },
      {
        "content": "{% with ${1} as ${2} %}\n\t${0}\n{% endwith %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "with"
        ],
        "opts": []
      },
      {
        "content": "add:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "add"
        ],
        "opts": []
      },
      {
        "content": "center:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "center"
        ],
        "opts": []
      },
      {
        "content": "cut:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cut"
        ],
        "opts": []
      },
      {
        "content": "date:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "date"
        ],
        "opts": []
      },
      {
        "content": "default:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "default"
        ],
        "opts": []
      },
      {
        "content": "default_if_none:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defaultifnone"
        ],
        "opts": []
      },
      {
        "content": "dictsort:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dictsort"
        ],
        "opts": []
      },
      {
        "content": "dictsortreversed:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dictsortrev"
        ],
        "opts": []
      },
      {
        "content": "divisibleby:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "divisibleby"
        ],
        "opts": []
      },
      {
        "content": "floatformat:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "floatformat"
        ],
        "opts": []
      },
      {
        "content": "get_digit:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "getdigit"
        ],
        "opts": []
      },
      {
        "content": "join:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "join"
        ],
        "opts": []
      },
      {
        "content": "length_is:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lengthis"
        ],
        "opts": []
      },
      {
        "content": "pluralize:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pluralize"
        ],
        "opts": []
      },
      {
        "content": "removetags:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "removetags"
        ],
        "opts": []
      },
      {
        "content": "slice:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "slice"
        ],
        "opts": []
      },
      {
        "content": "stringformat:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "stringformat"
        ],
        "opts": []
      },
      {
        "content": "time:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "time"
        ],
        "opts": []
      },
      {
        "content": "truncatewords:${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "truncatewords"
        ],
        "opts": []
      },
      {
        "content": "truncatewords_html:${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "truncatewordshtml"
        ],
        "opts": []
      },
      {
        "content": "urlizetrunc:${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "urlizetrunc"
        ],
        "opts": []
      },
      {
        "content": "wordwrap:${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wordwrap"
        ],
        "opts": []
      },
      {
        "content": "{% $1 %}$2",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "%"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% ${1:tag_name} %}\n\t$2\n{% end$1 %}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "%%"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{{ $1 }}$2",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "{"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% autoescape ${1:off} %}\n\t$2\n{% endautoescape %}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "autoescape"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% block $1 %}\n\t$2\n{% endblock $1 %}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "block"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{# ${1:comment} #}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "#"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% comment %}\n\t$1\n{% endcomment %}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "comment"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% cycle ${1:val1} ${2:val2} ${3:as $4} %}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "cycle"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% debug %}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "debug"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% extends \"${1:base.html}\" %}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "extends"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% filter $1 %}\n\t$2\n{% endfilter %}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "filter"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% firstof $1 %}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "firstof"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% for $1 in $2 %}\n\t$3\n{% endfor %}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "for"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% empty %}\n\t$1",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "empty"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% if $1 %}\n\t$2\n{% endif %}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "if"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% if $1 %}$2{% endif %}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "iif"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% else %}$1",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "ielse"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% else %}\n\t$1",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "else"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% elif %}$1",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "ielif"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% elif %}\n\t$1",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "elif"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% ifchanged %}$1{% endifchanged %}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "ifchanged"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% ifequal $1 $2 %}\n\t$3\n{% endifequal %}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "ifequal"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% ifnotequal $1 $2 %}\n\t$3\n{% endifnotequal %}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "ifnotequal"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% include \"$1\" %}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "include"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% load $1 %}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "load"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% now \"${1:jS F Y H:i}\" %}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "now"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% regroup $1 by $2 as $3 %}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "regroup"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% spaceless %}$1{% endspaceless %}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "spaceless"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% ssi $1 %}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "ssi"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% trans \"${1:string}\" %}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "trans"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% url $1 as $2 %}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "url"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% widthratio ${1:this_value} ${2:max_value} ${3:100} %}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "widthratio"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% with $1 as $2 %}\n\t${VISUAL}\n{% endwith %}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "with"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% verbatim %}\n\t${VISUAL}\n{% endverbatim %}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "verbatim"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{{ block.super }}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "super"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{{ STATIC_URL }}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "staticu"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% static \"${VISUAL}\" %}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "static"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{{ MEDIA_URL }}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "mediau"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% block ${1:blockname} %}${VISUAL}{% endblock $1 %}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "iblock"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% csrf_token %}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "csrf"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% blocktrans %}\n    ${VISUAL}\n{% endblocktrans %}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "blocktrans"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "{% lorem $1 %}",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "lorem"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "add:\"$1\"",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "add"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "center:\"$1\"",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "center"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "cut:\"$1\"",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "cut"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "date:\"$1\"",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "date"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "default:\"$1\"",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "default"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "default_if_none:\"$1\"",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "defaultifnone"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "dictsort:\"$1\"",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "dictsort"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "dictsortreversed:\"$1\"",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "dictsortrev"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "divisibleby:\"$1\"",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "divisibleby"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "floatformat:\"$1\"",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "floatformat"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "get_digit:\"$1\"",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "getdigit"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "join:\"$1\"",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "join"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "length_is:\"$1\"",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "lengthis"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "pluralize:\"$1\"",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "pluralize"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "removetags:\"$1\"",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "removetags"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "slice:\"$1\"",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "slice"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "stringformat:\"$1\"",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "stringformat"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "time:\"$1\"",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "time"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "truncatewords:$1",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "truncatewords"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "truncatewords_html:$1",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "truncatewordshtml"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "urlizetrunc:$1",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "urlizetrunc"
        ],
        "opts": [
          "b",
          "i"
        ]
      },
      {
        "content": "wordwrap:$1",
        "doc": null,
        "grammar": "snu",
        "label": "",
        "matches": [
          "wordwrap"
        ],
        "opts": [
          "b",
          "i"
        ]
      }
    ],
    "htmljinja": [],
    "htmltornado": [
      {
        "content": "{{ ${0} }}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "{"
        ],
        "opts": []
      },
      {
        "content": "{% extends \"${0:base.html}\" %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "extends"
        ],
        "opts": []
      },
      {
        "content": "{% autoescape ${0:xhtml_escape | None} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "autoescape"
        ],
        "opts": []
      },
      {
        "content": "{% apply ${1:function} %}\n  ${0}\n{% end %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "apply"
        ],
        "opts": []
      },
      {
        "content": "{% block ${1} %}\n  ${0}\n{% end %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "block"
        ],
        "opts": []
      },
      {
        "content": "{% for ${1:item} in ${2} %}\n  ${0}\n{% end %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "{% from ${1:x} import ${0:y} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "from"
        ],
        "opts": []
      },
      {
        "content": "{% if ${1:condition} %}\n  ${0}\n{% end %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "{% elif ${0:condition} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eif"
        ],
        "opts": []
      },
      {
        "content": "{% else %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "el"
        ],
        "opts": []
      },
      {
        "content": "{% import ${0:module} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "import"
        ],
        "opts": []
      },
      {
        "content": "{% include \"${0:filename}\" %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "include"
        ],
        "opts": []
      },
      {
        "content": "{% module ${0:expression} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "module"
        ],
        "opts": []
      },
      {
        "content": "{% raw ${0:expression} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "raw"
        ],
        "opts": []
      },
      {
        "content": "{% set ${1:x} = ${0:y} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "set"
        ],
        "opts": []
      },
      {
        "content": "{% try %}\n  ${1:${VISUAL}}\n{% except %}\n  ${2}\n{% finallly %}\n  ${0}\n{% end %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "try"
        ],
        "opts": []
      },
      {
        "content": "{% while ${1:condition} %}\n  ${0}\n{% end %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh"
        ],
        "opts": []
      }
    ],
    "idris": [
      {
        "content": "module `substitute(substitute(expand('%:r'), '[/\\\\]','.','g'),'^\\%(\\l*\\.\\)\\?','','')`\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mod"
        ],
        "opts": []
      },
      {
        "content": "import ${0:List}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "imp"
        ],
        "opts": []
      },
      {
        "content": "${1:fn} : ${2:a} -> ${3:a}\n$1 ${4} =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fn"
        ],
        "opts": []
      },
      {
        "content": "${1:fn} : ${2:a} -> ${3:a}\n$1 ${4} =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fn1"
        ],
        "opts": []
      },
      {
        "content": "${1:fn} : ${2:a} -> ${3:a} -> ${4:a}\n$1 ${5} =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fn2"
        ],
        "opts": []
      },
      {
        "content": "${1:fn} : ${2:a} -> ${3:a} -> ${4:a} -> ${5:a}\n$1 ${6} =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fn3"
        ],
        "opts": []
      },
      {
        "content": "${1:fn} : ${2:a}\n$1 =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fn0"
        ],
        "opts": []
      },
      {
        "content": "case ${1} of\n\t${2} =>\n\t\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case"
        ],
        "opts": []
      },
      {
        "content": "let\n\t${1} =\n\t\t${2}\nin\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "let"
        ],
        "opts": []
      },
      {
        "content": "where\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh"
        ],
        "opts": []
      },
      {
        "content": "if ${1} then\n\t${2:${VISUAL}}\nelse\n\t${0}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "(\\\\${1:_} => ${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\ \"Lambda function (\\x => ...)\""
        ],
        "opts": []
      }
    ],
    "ignore": [
      {
        "content": "### OSX ###\n*.DS_Store\n.AppleDouble\n.LSOverride\n\n# Icon must end with two \r\nIcon\n# Thumbnails\n._*\n# Files that might appear in the root of a volume\n.DocumentRevisions-V100\n.fseventsd\n.Spotlight-V100\n.TemporaryItems\n.Trashes\n.VolumeIcon.icns\n.com.apple.timemachine.donotpresent\n# Directories potentially created on remote AFP share\n.AppleDB\n.AppleDesktop\nNetwork Trash Folder\nTemporary Items\n.apdisk\n\n### Node ###\n# Logs\nlogs\n*.log\nnpm-debug.log*\n\n# Runtime data\npids\n*.pid\n*.seed\n*.pid.lock\n\n# Directory for instrumented libs generated by jscoverage/JSCover\nlib-cov\n\n# Coverage directory used by tools like istanbul\ncoverage\n\n# nyc test coverage\n.nyc_output\n\n# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)\n.grunt\n\n# node-waf configuration\n.lock-wscript\n\n# Compiled binary addons (http://nodejs.org/api/addons.html)\nbuild/Release\n\n# Dependency directories\nnode_modules\njspm_packages\n\n# Optional npm cache directory\n.npm\n\n# Optional eslint cache\n.eslintcache\n\n# Optional REPL history\n.node_repl_history\n\n# Output of 'npm pack'\n*.tgz\n\n# Yarn Integrity file\n.yarn-integrity\n\n# Nuxt build\n.nuxt\n\n# Nuxt generate\ndist",
        "doc": "gitignore file",
        "grammar": "lsp",
        "label": "Gitignore",
        "matches": [
          "gitignore"
        ],
        "opts": []
      }
    ],
    "jade": [
      {
        "content": "div(ng-repeat='${1} in ${2}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rep"
        ],
        "opts": []
      },
      {
        "content": "div(ng-repeat='${1} in ${2}' | ${3})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "repf"
        ],
        "opts": []
      },
      {
        "content": "div(ng-repeat='${1} in ${2}' track by $index)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "repi"
        ],
        "opts": []
      },
      {
        "content": "div(ng-hide='${1}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "hide"
        ],
        "opts": []
      },
      {
        "content": "div(ng-show='${1}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "show"
        ],
        "opts": []
      },
      {
        "content": "div(ng-if='${1}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      }
    ],
    "java": [
      {
        "content": "protected ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "po"
        ],
        "opts": []
      },
      {
        "content": "public ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pu"
        ],
        "opts": []
      },
      {
        "content": "private ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pr"
        ],
        "opts": []
      },
      {
        "content": "@Before\nstatic void ${1:intercept}(${2:args}) { ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "before"
        ],
        "opts": []
      },
      {
        "content": "@ManyToMany\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mm"
        ],
        "opts": []
      },
      {
        "content": "@ManyToOne\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mo"
        ],
        "opts": []
      },
      {
        "content": "@OneToMany${1:(cascade=CascadeType.ALL)}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "om"
        ],
        "opts": []
      },
      {
        "content": "@OneToOne\n${1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "oo"
        ],
        "opts": []
      },
      {
        "content": "import ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "im"
        ],
        "opts": []
      },
      {
        "content": "java.beans.",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "j.b"
        ],
        "opts": []
      },
      {
        "content": "java.io.",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "j.i"
        ],
        "opts": []
      },
      {
        "content": "java.math.",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "j.m"
        ],
        "opts": []
      },
      {
        "content": "java.net.",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "j.n"
        ],
        "opts": []
      },
      {
        "content": "java.util.",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "j.u"
        ],
        "opts": []
      },
      {
        "content": "class ${1:`vim_snippets#Filename(\"$1\", \"untitled\")`} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cl"
        ],
        "opts": []
      },
      {
        "content": "public class ${1:`vim_snippets#Filename(\"$1\", \"untitled\")`} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pcl"
        ],
        "opts": []
      },
      {
        "content": "interface ${1:`vim_snippets#Filename(\"$1\", \"untitled\")`} ${2:extends Parent}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "in"
        ],
        "opts": []
      },
      {
        "content": "public class ${1:`vim_snippets#Filename(\"$1\")`} extends ${0:TestCase}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tc"
        ],
        "opts": []
      },
      {
        "content": "extends ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ext"
        ],
        "opts": []
      },
      {
        "content": "implements ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "imp"
        ],
        "opts": []
      },
      {
        "content": "/*\n * ${0}\n */",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "/*"
        ],
        "opts": []
      },
      {
        "content": "static public final ${1:String} ${2:var} = ${3};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "co"
        ],
        "opts": []
      },
      {
        "content": "static public final String ${1:var} = \"${2}\";",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cos"
        ],
        "opts": []
      },
      {
        "content": "case ${1}:\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case"
        ],
        "opts": []
      },
      {
        "content": "default:\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "def"
        ],
        "opts": []
      },
      {
        "content": "else",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "el"
        ],
        "opts": []
      },
      {
        "content": "else if (${1}) ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eif"
        ],
        "opts": []
      },
      {
        "content": "if (${1}) ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "switch (${1}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sw"
        ],
        "opts": []
      },
      {
        "content": "${1:void} ${2:method}(${3}) ${4:throws }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "m"
        ],
        "opts": []
      },
      {
        "content": "${1:String} ${2:var}${3: = null}${4};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "v"
        ],
        "opts": []
      },
      {
        "content": "List<${1:Object}> ${2:list} = new ArrayList<$1>();${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d.al"
        ],
        "opts": []
      },
      {
        "content": "Map<${1:Object}, ${2:Object}> ${3:map} = new HashMap<$1, $2>();${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d.hm"
        ],
        "opts": []
      },
      {
        "content": "Set<${1:Object}> ${2:set} = new HashSet<$1>();${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d.hs"
        ],
        "opts": []
      },
      {
        "content": "Stack<${1:Object}> ${2:stack} = new Stack<$1>();${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d.st"
        ],
        "opts": []
      },
      {
        "content": "private static class Holder {\n\tprivate static final ${1:`vim_snippets#Filename(\"$1\")`} INSTANCE = new $1();\n}\nprivate $1() { }\npublic static $1 getInstance() {\n\treturn Holder.INSTANCE;\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "singlet"
        ],
        "opts": []
      },
      {
        "content": "abstract ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ab"
        ],
        "opts": []
      },
      {
        "content": "final ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fi"
        ],
        "opts": []
      },
      {
        "content": "static ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "st"
        ],
        "opts": []
      },
      {
        "content": "synchronized ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sy"
        ],
        "opts": []
      },
      {
        "content": "System.err.print(\"${0:Message}\");",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "err"
        ],
        "opts": []
      },
      {
        "content": "System.err.printf(\"${1:Message}\", ${0:exception});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "errf"
        ],
        "opts": []
      },
      {
        "content": "System.err.println(\"${0:Message}\");",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "errln"
        ],
        "opts": []
      },
      {
        "content": "assert ${1:test} : \"${2:Failure message}\";",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as"
        ],
        "opts": []
      },
      {
        "content": "assertEquals(\"${1:Failure message}\", ${2:expected}, ${3:actual});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ae"
        ],
        "opts": []
      },
      {
        "content": "assertArrayEquals(\"${1:Failure message}\", ${2:expecteds}, ${3:actuals});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "aae"
        ],
        "opts": []
      },
      {
        "content": "assertFalse(\"${1:Failure message}\", ${2:condition});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "af"
        ],
        "opts": []
      },
      {
        "content": "assertTrue(\"${1:Failure message}\", ${2:condition});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "at"
        ],
        "opts": []
      },
      {
        "content": "assertNull(\"${1:Failure message}\", ${2:object});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "an"
        ],
        "opts": []
      },
      {
        "content": "assertNotNull(\"${1:Failure message}\", ${2:object});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ann"
        ],
        "opts": []
      },
      {
        "content": "assertSame(\"${1:Failure message}\", ${2:expected}, ${3:actual});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ass"
        ],
        "opts": []
      },
      {
        "content": "assertNotSame(\"${1:Failure message}\", ${2:expected}, ${3:actual});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asns"
        ],
        "opts": []
      },
      {
        "content": "fail(\"${1:Failure message}\");",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fa"
        ],
        "opts": []
      },
      {
        "content": "catch(${1:Exception} ${2:e}) ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ca"
        ],
        "opts": []
      },
      {
        "content": "throw ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "thr"
        ],
        "opts": []
      },
      {
        "content": "throws ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ths"
        ],
        "opts": []
      },
      {
        "content": "try {\n\t${0:${VISUAL}}\n} catch(${1:Exception} ${2:e}) {\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "try"
        ],
        "opts": []
      },
      {
        "content": "try {\n\t${0:${VISUAL}}\n} catch(${1:Exception} ${2:e}) {\n} finally {\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tryf"
        ],
        "opts": []
      },
      {
        "content": "List<${1:listName}> ${2:items} = $1.findAll();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "findall"
        ],
        "opts": []
      },
      {
        "content": "${1:var} ${2:item} = $1.findById(${3});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "findbyid"
        ],
        "opts": []
      },
      {
        "content": "/**\n * ${0}\n */",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "/**"
        ],
        "opts": []
      },
      {
        "content": "@author `system(\"grep \\`id -un\\` /etc/passwd | cut -d \\\":\\\" -f5 | cut -d \\\",\\\" -f1\")`",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@au"
        ],
        "opts": []
      },
      {
        "content": "@brief ${0:Description}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@br"
        ],
        "opts": []
      },
      {
        "content": "@file ${0:`vim_snippets#Filename(\"$1\")`}.java",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@fi"
        ],
        "opts": []
      },
      {
        "content": "@param ${0:param}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@pa"
        ],
        "opts": []
      },
      {
        "content": "@return ${0:param}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@re"
        ],
        "opts": []
      },
      {
        "content": "Logger.debug(${1:param});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "debug"
        ],
        "opts": []
      },
      {
        "content": "Logger.error(${1:param});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "error"
        ],
        "opts": []
      },
      {
        "content": "Logger.info(${1:param});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "info"
        ],
        "opts": []
      },
      {
        "content": "Logger.warn(${1:param});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "warn"
        ],
        "opts": []
      },
      {
        "content": "for (${1} : ${2}) ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "enfor"
        ],
        "opts": []
      },
      {
        "content": "for (${1}; ${2}; ${3}) ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "while (${1}) ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh"
        ],
        "opts": []
      },
      {
        "content": "public static void main (String[] args) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "psvm"
        ],
        "opts": []
      },
      {
        "content": "public static void main (String[] args) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "main"
        ],
        "opts": []
      },
      {
        "content": "System.out.println(${0});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sout"
        ],
        "opts": []
      },
      {
        "content": "System.err.println(${0});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "serr"
        ],
        "opts": []
      },
      {
        "content": "System.out.print(\"${0:Message}\");",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "print"
        ],
        "opts": []
      },
      {
        "content": "System.out.printf(\"${1:Message}\", ${0:args});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "printf"
        ],
        "opts": []
      },
      {
        "content": "System.out.println(${0});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "println"
        ],
        "opts": []
      },
      {
        "content": "System.out.println(Arrays.toString(${0}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "printlna"
        ],
        "opts": []
      },
      {
        "content": "render(${1:param});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ren"
        ],
        "opts": []
      },
      {
        "content": "renderArgs.put(\"${1}\", ${2});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rena"
        ],
        "opts": []
      },
      {
        "content": "renderBinary(${1:param});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "renb"
        ],
        "opts": []
      },
      {
        "content": "renderJSON(${1:param});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "renj"
        ],
        "opts": []
      },
      {
        "content": "renderXml(${1:param});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "renx"
        ],
        "opts": []
      },
      {
        "content": "${1:public} void set${3:}(${2:String} ${0:}){\n\tthis.$4 = $4;\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "set"
        ],
        "opts": []
      },
      {
        "content": "${1:public} ${2:String} get${3:}(){\n\treturn this.${0:};\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "get"
        ],
        "opts": []
      },
      {
        "content": "return ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "re"
        ],
        "opts": []
      },
      {
        "content": "break;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "br"
        ],
        "opts": []
      },
      {
        "content": "public void test${1:Name}() throws Exception {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "t"
        ],
        "opts": []
      },
      {
        "content": "@Test\npublic void test${1:Name}() throws Exception {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "test"
        ],
        "opts": []
      },
      {
        "content": "Scanner",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Sc"
        ],
        "opts": []
      },
      {
        "content": "public static void ${1:index}(${2:args}) { ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "action"
        ],
        "opts": []
      },
      {
        "content": "notFound(${1:param});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rnf"
        ],
        "opts": []
      },
      {
        "content": "notFoundIfNull(${1:param});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rnfin"
        ],
        "opts": []
      },
      {
        "content": "redirect(${1:param});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rr"
        ],
        "opts": []
      },
      {
        "content": "unauthorized(${1:param});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ru"
        ],
        "opts": []
      },
      {
        "content": "(unless=${1:param});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "unless"
        ],
        "opts": []
      },
      {
        "content": "class ${1} ${2:#:extends_or_implements}{\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "class"
        ],
        "opts": []
      },
      {
        "content": "interface ${1} ${2:#:extends}{\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "interface"
        ],
        "opts": []
      },
      {
        "content": "${1:void} ${2:#:method}(${3}) ${4:throws} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "method"
        ],
        "opts": []
      },
      {
        "content": "enum ${1:#:name} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "enum {}",
        "matches": [
          "enum"
        ],
        "opts": []
      },
      {
        "content": "public void set${1:Name}(${2:String} ${3:name}) {\nthis.$3 = $3;\n}${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "set"
        ],
        "opts": []
      },
      {
        "content": "public ${1:String} get${2:Name}() {\nreturn $2;\n}${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "get"
        ],
        "opts": []
      },
      {
        "content": "public void set${1:Name}(${2:String} ${3:name}) {\nthis.$3 = $3;\n}\npublic $2 get$1() {\nreturn $1;\n}${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "setget"
        ],
        "opts": []
      },
      {
        "content": "${1:#:type} ${2:#:var}${3};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "var"
        ],
        "opts": []
      },
      {
        "content": "static public final ${1:#:type} ${2:#:var} = ${3};${4}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "const"
        ],
        "opts": []
      },
      {
        "content": "static public final String ${1:var} = \"${2}\";${4}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "const_string"
        ],
        "opts": []
      },
      {
        "content": "public final ${1:#:type} ${2:#:var} = ${3};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "final"
        ],
        "opts": []
      },
      {
        "content": "assert ${1:#:test} : ${2:#:Failure message};${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "assert"
        ],
        "opts": []
      },
      {
        "content": "if (${1}) {\n    ${2:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "else {\n    ${1:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "else"
        ],
        "opts": []
      },
      {
        "content": "else if (${1}) {\n    ${2:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "elseif",
          "elif"
        ],
        "opts": []
      },
      {
        "content": "while (${1}) {\n    ${2:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "while"
        ],
        "opts": []
      },
      {
        "content": "for (${1}; ${2}; ${3}) {\n    ${4:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "for (${1} : ${2}) {\n    ${3:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fore",
          "foreach"
        ],
        "opts": []
      },
      {
        "content": "switch (${1}) {\n    ${2:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "switch"
        ],
        "opts": []
      },
      {
        "content": "case ${1}:\n    ${2:TARGET}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case"
        ],
        "opts": []
      },
      {
        "content": "break;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "br"
        ],
        "opts": []
      },
      {
        "content": "default:\n    ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "default",
          "de"
        ],
        "opts": []
      },
      {
        "content": "try {\n    ${0:TARGET}\n} catch (${1:Exception} ${2:e}) {\n    ${3:e.printStackTrace();}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "try"
        ],
        "opts": []
      },
      {
        "content": "try (${1:#:Resources}) {\n    ${0:TARGET}\n} catch (${2:Exception} ${3:e}) {\n    ${4:e.printStackTrace();}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "try_resources"
        ],
        "opts": []
      },
      {
        "content": "try {\n    ${0:TARGET}\n} catch (${1:Exception} ${2:e}) {\n    ${3:e.printStackTrace();}\n} finally {\n    ${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "try_finally"
        ],
        "opts": []
      },
      {
        "content": "catch (${1:Exception} ${2:e}) {\n    ${0:e.printStackTrace();}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "catch"
        ],
        "opts": []
      },
      {
        "content": "finally {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "finally"
        ],
        "opts": []
      },
      {
        "content": "throw ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "th"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "synchronized",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sy"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "public class ${1} extends ${2:TestCase} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tc",
          "testclass"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "public void test${1:#:Name}() throws Exception {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "test"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "import ${1};\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "imt",
          "import"
        ],
        "opts": []
      },
      {
        "content": "java.util.",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "j.u"
        ],
        "opts": []
      },
      {
        "content": "java.io.",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "j.i"
        ],
        "opts": []
      },
      {
        "content": "java.beans.",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "j.b"
        ],
        "opts": []
      },
      {
        "content": "java.net",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "j.n"
        ],
        "opts": []
      },
      {
        "content": "java.math.",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "j.m"
        ],
        "opts": []
      },
      {
        "content": "class `expand('%:p:t:r')` {\n    public static void main(String args[]) {\n        ${0:#:body}\n    }\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "main"
        ],
        "opts": []
      },
      {
        "content": "System.out.println(${1});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sout",
          "println"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "System.out.printf(\"${1}\", ${2});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "souf",
          "printf"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "System.out.print(${1});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "print"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "System.out.format(${1});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "format"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "/**\n * ${0:TARGET}\n */",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "comment"
        ],
        "opts": []
      },
      {
        "content": "@author ${0:$TM_FULLNAME}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "author"
        ],
        "opts": []
      },
      {
        "content": "{@code ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "{code"
        ],
        "opts": []
      },
      {
        "content": "@deprecated ${0:#:description}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "deprecated"
        ],
        "opts": []
      },
      {
        "content": "{@docRoot",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "{docRoot"
        ],
        "opts": []
      },
      {
        "content": "{@inheritDoc",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "{inheritDoc"
        ],
        "opts": []
      },
      {
        "content": "{@link ${1:#:target} ${0:#:label}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "{link"
        ],
        "opts": []
      },
      {
        "content": "{@linkplain ${1:#:target} ${0:#:label}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "{linkplain"
        ],
        "opts": []
      },
      {
        "content": "{@literal ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "{literal"
        ],
        "opts": []
      },
      {
        "content": "@param ${1:#:var} ${0:#:description}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "param"
        ],
        "opts": []
      },
      {
        "content": "@return ${0:#:description}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "return"
        ],
        "opts": []
      },
      {
        "content": "@see ${0:#:reference}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "see"
        ],
        "opts": []
      },
      {
        "content": "@serial ${0:#:description}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "serial"
        ],
        "opts": []
      },
      {
        "content": "@serialField ${0:#:description}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sd"
        ],
        "opts": []
      },
      {
        "content": "@serialField ${1:#:name} ${2:#:type} ${0:#:description}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sf"
        ],
        "opts": []
      },
      {
        "content": "@since ${0:#:version}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "since"
        ],
        "opts": []
      },
      {
        "content": "@throws ${1:#:class} ${0:#:description}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "throws"
        ],
        "opts": []
      },
      {
        "content": "{@value ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "{value"
        ],
        "opts": []
      },
      {
        "content": "@version ${0:#:version}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "version",
          "ver"
        ],
        "opts": []
      },
      {
        "content": "public class ${1:Hello} {\n  static public void main(String args[]) {\n    System.out.println(\"Hello, world!\");\n  }\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "helloworld"
        ],
        "opts": [
          "head"
        ]
      }
    ],
    "javascript": [
      {
        "content": "const express = require('express');\nconst app = express();\nconst port = process.env.PORT || ${1:port};\nconst www = process.env.WWW || '${2:./}';\napp.use(express.static(www));\nconsole.log(`serving \\${www}`);\napp.get('*', (req, res) => {\n\tres.sendFile(`index.html`, { root: www });\n});\napp.listen(port, () => console.log(`listening on http://localhost:\\${port}`));\n$0",
        "doc": "Node.js Express Server",
        "grammar": "lsp",
        "label": "Node.js Express Server",
        "matches": [
          "ex-node-server-simple"
        ],
        "opts": []
      },
      {
        "content": "${1:class_name}.prototype.${2:method_name} = function(${3}) {\n\t${0:${VISUAL}}\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "proto"
        ],
        "opts": []
      },
      {
        "content": "function ${1:function_name}(${2}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fun \"function\""
        ],
        "opts": []
      },
      {
        "content": "async function ${1:function_name}(${2}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asf \"async function\""
        ],
        "opts": []
      },
      {
        "content": "function(${1}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "anf \"\" w"
        ],
        "opts": []
      },
      {
        "content": "var ${1:function_name} = function(${2}) {\n\t${0:${VISUAL}}\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vaf"
        ],
        "opts": []
      },
      {
        "content": "var ${1:function_name} = function $1(${2}) {\n\t${0:${VISUAL}}\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vf"
        ],
        "opts": []
      },
      {
        "content": "(function(${1}) {\n\t${0:${VISUAL}}\n}(${2}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "(f"
        ],
        "opts": []
      },
      {
        "content": ";(function(${1}) {\n\t${0:${VISUAL}}\n}(${2}))",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ";fe"
        ],
        "opts": []
      },
      {
        "content": "var ${1:function_name} = function (${2:argument}) {\n\t${3}\n\t$1 = function ($2) {\n\t\t${0:${VISUAL}}\n\t};\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sdf"
        ],
        "opts": []
      },
      {
        "content": "if (${1:true}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if \"if (condition) { ... }\""
        ],
        "opts": []
      },
      {
        "content": "if (${1:true}) {\n\t${0:${VISUAL}}\n} else {\n\t${2}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife \"if (condition) { ... } else { ... }\""
        ],
        "opts": []
      },
      {
        "content": "${1:/* condition */} ? ${2:/* if true */} : ${0:/* if false */}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ter"
        ],
        "opts": []
      },
      {
        "content": "switch (${1:expression}) {\n\tcase '${3:case}':\n\t\t${4}\n\t\tbreak;\n\t${0}\n\tdefault:\n\t\t${2}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "switch"
        ],
        "opts": []
      },
      {
        "content": "case '${1:case}':\n\t${0:${VISUAL}}\n\tbreak;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case \"case 'xyz': ... break\""
        ],
        "opts": []
      },
      {
        "content": "try {\n\t${0:${VISUAL}}\n} catch (${1:e}) {\n\t${2:/* handle error */}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "try \"try { ... } catch(e) { ... }\""
        ],
        "opts": []
      },
      {
        "content": "try {\n\t${0:${VISUAL}}\n} catch (${1:e}) {\n\t${2:/* handle error */}\n} finally {\n\t${3:/* be executed regardless of the try / catch result*/}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tryf \"try { ... } catch(e) { ... } finally { ... }\""
        ],
        "opts": []
      },
      {
        "content": "throw new Error('${1:error message}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "terr"
        ],
        "opts": []
      },
      {
        "content": "return ${0:result};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ret"
        ],
        "opts": []
      },
      {
        "content": "for (let ${1:i} = 0, ${2:len} = ${3:Things.length}; $1 < $2; $1++) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for \"for (...) {...}\""
        ],
        "opts": []
      },
      {
        "content": "for (let ${2:i} = ${1:Things.length} - 1; $2 >= 0; $2--) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forr \"reversed for (...) {...}\""
        ],
        "opts": []
      },
      {
        "content": "while (${1:/* condition */}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh \"(condition) { ... }\""
        ],
        "opts": []
      },
      {
        "content": "do {\n\t${0:${VISUAL}}\n} while (${1:/* condition */});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "do \"do { ... } while (condition)\""
        ],
        "opts": []
      },
      {
        "content": "for (let ${1:prop} in ${2:object}) {\n\t${0:$2[$1]}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fori"
        ],
        "opts": []
      },
      {
        "content": "${1:method_name}: function (${2:attribute}) {\n\t${0:${VISUAL}}\n},",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ":f"
        ],
        "opts": []
      },
      {
        "content": "hasOwnProperty(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "has"
        ],
        "opts": []
      },
      {
        "content": "function ${1:Singleton} (${2:argument}) {\n\t// the cached instance\n\tvar instance;\n\t// rewrite the constructor\n\t$1 = function $1($2) {\n\t\treturn instance;\n\t};\n\t// carry over the prototype properties\n\t$1.prototype = this;\n\t// the instance\n\tinstance = new $1();\n\t// reset the constructor pointer\n\tinstance.constructor = $1;\n\t${0}\n\treturn instance;\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sing"
        ],
        "opts": []
      },
      {
        "content": "function object(o) {\n\tfunction F() {}\n\tF.prototype = o;\n\treturn new F();\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "obj"
        ],
        "opts": []
      },
      {
        "content": "var ${1:my_object} = Object.defineProperties(\n\t${2:new Object()},\n\t{\n\t\t${3:property} : {\n\t\t\tget : function $1_$3_getter() {\n\t\t\t\t// getter code\n\t\t\t},\n\t\t\tset : function $1_$3_setter(value) {\n\t\t\t\t// setter code\n\t\t\t},\n\t\t\tvalue        : ${4:value},\n\t\t\twriteable    : ${5:boolean},\n\t\t\tenumerable   : ${6:boolean},\n\t\t\tconfigurable : ${0:boolean}\n\t\t}\n\t}\n);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "props"
        ],
        "opts": []
      },
      {
        "content": "Object.defineProperty(\n\t${1:object},\n\t'${2:property}',\n\t{\n\t\tget : function $1_$2_getter() {\n\t\t\t// getter code\n\t\t},\n\t\tset : function $1_$2_setter(value) {\n\t\t\t// setter code\n\t\t},\n\t\tvalue        : ${3:value},\n\t\twriteable    : ${4:boolean},\n\t\tenumerable   : ${5:boolean},\n\t\tconfigurable : ${0:boolean}\n\t}\n);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prop"
        ],
        "opts": []
      },
      {
        "content": "/**\n * ${0:description}\n *\n */",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "/**"
        ],
        "opts": []
      },
      {
        "content": "@param {${1:type}} ${2:name} ${0:description}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@par"
        ],
        "opts": []
      },
      {
        "content": "@return {${1:type}} ${0:description}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@ret"
        ],
        "opts": []
      },
      {
        "content": "JSON.parse(${0:jstr});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jsonp"
        ],
        "opts": []
      },
      {
        "content": "JSON.stringify(${0:object});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jsons"
        ],
        "opts": []
      },
      {
        "content": "getElementsBy${1:TagName}('${0}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "get"
        ],
        "opts": []
      },
      {
        "content": "getElementBy${1:Id}('${0}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gett"
        ],
        "opts": []
      },
      {
        "content": "${1:document}.getElementsByClassName('${0:class}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "by."
        ],
        "opts": []
      },
      {
        "content": "${1:document}.getElementById('${0:element ID}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "by#"
        ],
        "opts": []
      },
      {
        "content": "${1:document}.querySelector('${0:CSS selector}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "qs"
        ],
        "opts": []
      },
      {
        "content": "${1:document}.querySelectorAll('${0:CSS selector}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "qsa"
        ],
        "opts": []
      },
      {
        "content": "debugger;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "de"
        ],
        "opts": []
      },
      {
        "content": "console.log(${0});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cl \"console.log\""
        ],
        "opts": []
      },
      {
        "content": "console.debug(${0});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cd \"console.debug\""
        ],
        "opts": []
      },
      {
        "content": "console.error(${0});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ce \"console.error\""
        ],
        "opts": []
      },
      {
        "content": "console.warn(${0});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cw \"console.warn\""
        ],
        "opts": []
      },
      {
        "content": "console.info(${0});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ci \"console.info\""
        ],
        "opts": []
      },
      {
        "content": "console.trace(${0:label});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ct \"console.trace\""
        ],
        "opts": []
      },
      {
        "content": "console.time(\"${1:label}\");\n${0:${VISUAL}}\nconsole.timeEnd(\"$1\");",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ctime \"console.time ... console.timeEnd\""
        ],
        "opts": []
      },
      {
        "content": "console.timeStamp(\"${1:label}\");",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ctimestamp \"console.timeStamp\""
        ],
        "opts": []
      },
      {
        "content": "console.assert(${1:expression}, ${0:obj});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ca \"console.assert\""
        ],
        "opts": []
      },
      {
        "content": "console.clear();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cclear \"console.clear\""
        ],
        "opts": []
      },
      {
        "content": "console.dir(${0:obj});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cdir \"console.dir\""
        ],
        "opts": []
      },
      {
        "content": "console.dirxml(${1:object});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cdirx \"console.dirxml\""
        ],
        "opts": []
      },
      {
        "content": "console.group(\"${1:label}\");\n${0:${VISUAL}}\nconsole.groupEnd();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cgroup \"console.group\""
        ],
        "opts": []
      },
      {
        "content": "console.groupCollapsed(\"${1:label}\");\n${0:${VISUAL}}\nconsole.groupEnd();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cgroupc \"console.groupCollapsed\""
        ],
        "opts": []
      },
      {
        "content": "console.profile(\"${1:label}\");\n${0:${VISUAL}}\nconsole.profileEnd();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cprof \"console.profile\""
        ],
        "opts": []
      },
      {
        "content": "console.table(${1:\"${2:value}\"});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ctable \"console.table\""
        ],
        "opts": []
      },
      {
        "content": "console.log(JSON.stringify(${0}, null, 2));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "clstr \"console.log stringified\""
        ],
        "opts": []
      },
      {
        "content": "'use strict';",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "us"
        ],
        "opts": []
      },
      {
        "content": "setTimeout(function () {${0}}${2}, ${1:10});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "timeout"
        ],
        "opts": []
      },
      {
        "content": "const ${1} = ${0};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "const"
        ],
        "opts": []
      },
      {
        "content": "const ${1} = new ${0};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "constn"
        ],
        "opts": []
      },
      {
        "content": "let ${1} = ${0};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "let"
        ],
        "opts": []
      },
      {
        "content": "import ${1} from '${2:$1}';",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "im \"import xyz from 'xyz'\""
        ],
        "opts": []
      },
      {
        "content": "import * as ${1} from '${2:$1}';",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "imas \"import * as xyz from 'xyz'\""
        ],
        "opts": []
      },
      {
        "content": "import { ${1} } from '${2}';",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "imm \"import { member } from 'xyz'\""
        ],
        "opts": []
      },
      {
        "content": "class ${1} {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cla"
        ],
        "opts": []
      },
      {
        "content": "class ${1} extends ${2} {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "clax"
        ],
        "opts": []
      },
      {
        "content": "class ${1} {\n\tconstructor(${2}) {\n\t\t${0:${VISUAL}}\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "clac"
        ],
        "opts": []
      },
      {
        "content": "for (const ${1:prop} of ${2:object}) {\n\t${0:$1}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "foro \"for (const prop of object}) { ... }\""
        ],
        "opts": []
      },
      {
        "content": "for (let ${1:prop} of ${2:object}) {\n\t${0:$1}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forl \"for (let prop of object}) { ... }\""
        ],
        "opts": []
      },
      {
        "content": "function* ${1:function_name}(${2}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fun*"
        ],
        "opts": []
      },
      {
        "content": "const ${1:function_name} = (${2}) => {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "c=>"
        ],
        "opts": []
      },
      {
        "content": "const ${1:function_name} = async (${2}) => {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ca=>"
        ],
        "opts": []
      },
      {
        "content": "const ${1:function_name} = (${2}) => {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "caf"
        ],
        "opts": []
      },
      {
        "content": "const ${1:function_name} = async (${2}) => {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "casf"
        ],
        "opts": []
      },
      {
        "content": "(${1}) => {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "=>"
        ],
        "opts": []
      },
      {
        "content": "(${1}) => ${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "af \"() =>\""
        ],
        "opts": []
      },
      {
        "content": "(${1}) => {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "afb \"() => {}\""
        ],
        "opts": []
      },
      {
        "content": "const ${1} = Symbol('${0}');",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sym"
        ],
        "opts": []
      },
      {
        "content": "export default ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ed"
        ],
        "opts": []
      },
      {
        "content": "${${1}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "${"
        ],
        "opts": []
      },
      {
        "content": "async ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as \"async\""
        ],
        "opts": []
      },
      {
        "content": "await ${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "aw \"await\""
        ],
        "opts": []
      },
      {
        "content": "${1:#:method_name}: function(${2:#:attribute}) {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ":f"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "function ${1:#:function_name}(${2:#:argument}) {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "func",
        "matches": [
          "function"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "function ${1:function_name}(${2:argument}) {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "func2",
        "matches": [
          "function2"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "${1:#:class_name}.prototype.${2:#:method_name} = function(${3:#:first_argument}) {\n  ${0:TARGET}\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "proto"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "function(${1}) { ${0:TARGET} };",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "f"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "if (${1:true}) {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "if (${1:#:condition}) {\n  ${2:TARGET}\n} else {\n  ${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "ife",
        "matches": [
          "if-else"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "for (let ${1:i} = 0; $1 < ${2:#:Things}.length; ++$1) {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "for (let ${1:i} in ${2:#:Things}) {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forin"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "for (let ${1:i} of ${2:#:Things}) {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forof"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "while (${1:true}) {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "while"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "switch (${1:#:let}) {\n  case ${2:#:val}:\n    ${0:TARGET}\n    break;\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "switch"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "try {\n  ${1:TARGET}\n} catch (${2:e}) {\n  ${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "try"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "try {\n  ${1:TARGET}\n} catch (${2:e}) {\n  ${3}\n} finally {\n  ${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "try_finally"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "${1:#:value_name}: ${0:#:value},",
        "doc": "",
        "grammar": "snu",
        "label": ":,",
        "matches": [
          "key-value"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "setTimeout(function() { ${0} }, ${1:10});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "setTimeout-function"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "debugger;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "debugger",
          "db"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "console.log(${0:TARGET});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "console-log",
          "cl"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "console.trace();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "console-trace",
          "ct"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "console.error(${0:TARGET});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "console-error",
          "ce"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "console.warn(${0:TARGET});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "console-warn",
          "cw"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "console.info(${0:TARGET});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "console-info",
          "ci"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "(function(${1}) {\n  'use strict';\n  ${0:TARGET}\n})(${2});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "iife"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "JSON.stringify(${1:TARGET}, null, 2);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "js"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "console.log(JSON.stringify(${1:TARGET}, null, 2));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jsc"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "class ${1:#:NAME} {\n  constructor(${2:#:ARGS}) {\n    ${0:TARGET}\n  }\n}",
        "doc": "",
        "grammar": "snu",
        "label": "class {...}",
        "matches": [
          "class"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "class ${1:#:NAME} extends ${2:#:SuperClass} {\n  constructor(${3:#:ARGS}) {\n    ${0:TARGET}\n  }\n}",
        "doc": "",
        "grammar": "snu",
        "label": "class extends {...}",
        "matches": [
          "class-extends"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "static ${1:#:NAME}(${2:#:ARGS}) {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "static"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "set ${1:#:NAME}(${2:#:ARGS}) {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "set"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "get ${1:#:NAME}() {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "get"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "import { ${1:MEMBERS} } from \"${0:TARGET}\";",
        "doc": "",
        "grammar": "snu",
        "label": "import { member, ... } from \"module-name\";",
        "matches": [
          "import"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "import ${1:defaultMember} from \"${0:TARGET}\";",
        "doc": "",
        "grammar": "snu",
        "label": "import defaultMember from \"module-name\";",
        "matches": [
          "import-default"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "import * as ${1:NAME} from \"${0:TARGET}\";",
        "doc": "",
        "grammar": "snu",
        "label": "import * as NAME from \"...\";",
        "matches": [
          "import-all"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "import ${1:defaultMember}, { ${2:MEMBERS} } from \"${0:TARGET}\";",
        "doc": "",
        "grammar": "snu",
        "label": "import defaultMember, { member, ... } from \"module-name\";",
        "matches": [
          "import-default-member"
        ],
        "opts": [
          "head"
        ]
      }
    ],
    "javascript-angular": [
      {
        "content": "it('${1:description}', inject(function($2) {\n\t$0\n}));",
        "doc": null,
        "grammar": "snu",
        "label": "it (js, inject)",
        "matches": [
          "iti"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "beforeEach(inject(function($1) {\n\t$0\n}));",
        "doc": null,
        "grammar": "snu",
        "label": "before each (js, inject)",
        "matches": [
          "befi"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "config(function($1) {\n\t$0\n});",
        "doc": null,
        "grammar": "snu",
        "label": "angular config",
        "matches": [
          "aconf"
        ],
        "opts": [
          "i"
        ]
      },
      {
        "content": "controller('${1:name}', [$2function(${2/('|\")([A-Z_$]+)?\\1?((, ?)$)?/$2(?3::$4)/ig}) {\n\t$0\n}]);",
        "doc": null,
        "grammar": "snu",
        "label": "angular controller",
        "matches": [
          "acont"
        ],
        "opts": [
          "i"
        ]
      },
      {
        "content": "controller('${1:name}', [${2:'$scope', }function(${2/('|\")([A-Z_$]+)?\\1?((, ?)$)?/$2(?3::$4)/ig}) {\n\t$0\n}]);",
        "doc": null,
        "grammar": "snu",
        "label": "angular controller with scope",
        "matches": [
          "aconts"
        ],
        "opts": [
          "i"
        ]
      },
      {
        "content": "directive('$1', [$2function(${2/('|\")([A-Z_$]+)?\\1?((, ?)$)?/$2(?3::$4)/ig}) {\n\treturn {\n\t\trestrict: '${3:EA}',\n\t\tlink: function(scope, element, attrs) {\n\t\t\t$0\n\t\t}\n\t};\n}]);",
        "doc": null,
        "grammar": "snu",
        "label": "angular directive",
        "matches": [
          "adir"
        ],
        "opts": [
          "i"
        ]
      },
      {
        "content": "directive('$1', [${2:'$scope', }function(${2/('|\")([A-Z_$]+)?\\1?((, ?)$)?/$2(?3::$4)/ig}) {\n\treturn {\n\t\trestrict: '${3:EA}',\n\t\tlink: function(scope, element, attrs) {\n\t\t\t$0\n\t\t}\n\t};\n}]);",
        "doc": null,
        "grammar": "snu",
        "label": "angular directive with scope",
        "matches": [
          "adirs"
        ],
        "opts": [
          "i"
        ]
      },
      {
        "content": "factory('${1:name}', [$2function(${2/('|\")([A-Z_$]+)?\\1?((, ?)$)?/$2(?3::$4)/ig}) {\n\t$0\n}]);",
        "doc": null,
        "grammar": "snu",
        "label": "angular factory",
        "matches": [
          "afact"
        ],
        "opts": [
          "i"
        ]
      },
      {
        "content": "factory('${1:name}', [${2:'$scope', }function(${2/('|\")([A-Z_$]+)?\\1?((, ?)$)?/$2(?3::$4)/ig}) {\n\t$0\n}]);",
        "doc": null,
        "grammar": "snu",
        "label": "angular factory with scope",
        "matches": [
          "afacts"
        ],
        "opts": [
          "i"
        ]
      },
      {
        "content": "service('${1:name}', [$2function(${2/('|\")([A-Z_$]+)?\\1?((, ?)$)?/$2(?3::$4)/ig}) {\n\t$0\n}]);",
        "doc": null,
        "grammar": "snu",
        "label": "angular service",
        "matches": [
          "aserv"
        ],
        "opts": [
          "i"
        ]
      },
      {
        "content": "service('${1:name}', [${2:'$scope', }function(${2/('|\")([A-Z_$]+)?\\1?((, ?)$)?/$2(?3::$4)/ig}) {\n\t$0\n}]);",
        "doc": null,
        "grammar": "snu",
        "label": "angular service",
        "matches": [
          "aservs"
        ],
        "opts": [
          "i"
        ]
      }
    ],
    "javascript-bemjson": [
      {
        "content": "{\n\tblock : '${1:name}',\n\tcontent : [\n\t\t'${2:content}'\n\t]\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "b"
        ],
        "opts": []
      },
      {
        "content": "{\n\t block : '${1:name}',\n\t content: '${2:content}'\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "btc"
        ],
        "opts": []
      },
      {
        "content": "{\n\tblock : '${1:name}',\n\tmods: { ${2:modName}: '${3:modVal}' },\n\tcontent : [\n\t\t'${4:content}'\n\t]\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bwm"
        ],
        "opts": []
      },
      {
        "content": "{\n\telem : '${1:name}',\n\tcontent : [\n\t\t'${2:content}'\n\t]\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "e"
        ],
        "opts": []
      },
      {
        "content": "mods : { ${1:modName} : '${2:modVal}' },",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mo"
        ],
        "opts": []
      },
      {
        "content": "mix : [ { ${1:block} : '${2:block}' } ],",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mi"
        ],
        "opts": []
      },
      {
        "content": "attrs : { ${1:attr} : '${2:val}' },",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "a"
        ],
        "opts": []
      }
    ],
    "javascript-d3": [
      {
        "content": ".attr(\"${1}\", ${2})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ".attr"
        ],
        "opts": []
      },
      {
        "content": ".style(\"${1}\", ${2})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ".style"
        ],
        "opts": []
      },
      {
        "content": "d3.svg.axis()\n  .orient(${1})\n  .scale(${2})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "axis"
        ],
        "opts": []
      },
      {
        "content": "function(d) { ${1} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fd"
        ],
        "opts": []
      },
      {
        "content": "function(d, i) { ${1} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fdi"
        ],
        "opts": []
      },
      {
        "content": "var ${1:margin} = { top: ${2:10}, right: ${3:10}, bottom: ${4:10}, left: ${5:10} };\nvar ${6:width} = ${7:970} - $1.left - $1.right;\nvar ${8:height} = ${9:500} - $1.top - $1.bottom;\nvar ${10:svg} = d3.select(\"${11}\").append(\"svg\")\n  .attr(\"width\", $6 + $1.left + $1.right)\n  .attr(\"height\", $8 + $1.top + $1.bottom)\n    .append(\"g\")\n  .attr(\"transform\", \"translate(\" + $1.left + \",\" + $1.top + \")\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "marginconvention"
        ],
        "opts": []
      },
      {
        "content": "d3.nest()\n  .key(${1})\n  .entries(${2})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nest"
        ],
        "opts": []
      },
      {
        "content": "d3.scale.linear()\n  .domain(${1})\n  .range(${2})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "scale"
        ],
        "opts": []
      }
    ],
    "javascript-ember": [
      {
        "content": "import Application from '@ember/application';\n\nexport default Application.extend({\n\t${0://Properties here...}\n});",
        "doc": null,
        "grammar": "snu",
        "label": "App.Name = Ember.Application.create({});",
        "matches": [
          "eapp"
        ],
        "opts": []
      },
      {
        "content": "import DS from 'ember-data';\n\nexport default DS.Model.extend({\n\t${0://Properties here...}\n});",
        "doc": null,
        "grammar": "snu",
        "label": "import DS from 'ember-data';",
        "matches": [
          "emod"
        ],
        "opts": []
      },
      {
        "content": "import Controller from '@ember/controller';\n\nexport default Controller.extend({\n\t${0://Properties here...}\n});",
        "doc": null,
        "grammar": "snu",
        "label": "import Controller from '@ember/controller';",
        "matches": [
          "econtroller"
        ],
        "opts": []
      },
      {
        "content": "import Route from '@ember/routing/route';\n\nexport default Route.extend({\n\t${0://Properties here...}\n});",
        "doc": null,
        "grammar": "snu",
        "label": "import Route from '@ember/routing/route';",
        "matches": [
          "eroute"
        ],
        "opts": []
      },
      {
        "content": "import Component from '@ember/component';\n\nexport default Component.extend({\n\t${0://Properties here...}\n});",
        "doc": null,
        "grammar": "snu",
        "label": "import Component from '@ember/component';",
        "matches": [
          "ecomponent"
        ],
        "opts": []
      },
      {
        "content": "import EmberObject from '@ember/object';\n\nexport default EmberObject.extend({\n\t${0://Properties here...}\n});",
        "doc": null,
        "grammar": "snu",
        "label": "import EmberObject from '@ember/object';",
        "matches": [
          "eobj"
        ],
        "opts": []
      },
      {
        "content": "import Mixin from '@ember/object/mixin';\n\nexport default Mixin.create({\n\t${0://Properties here...}\n});",
        "doc": null,
        "grammar": "snu",
        "label": "App.MixinName = Ember.Model.extend({...});",
        "matches": [
          "emix"
        ],
        "opts": []
      },
      {
        "content": "${1:this}.get('${2:property}');",
        "doc": null,
        "grammar": "snu",
        "label": "this.get('property');",
        "matches": [
          "eget"
        ],
        "opts": []
      },
      {
        "content": "${1:this}.set('${2:property}', ${3:value});",
        "doc": null,
        "grammar": "snu",
        "label": "this.set('property', value);",
        "matches": [
          "eset"
        ],
        "opts": []
      },
      {
        "content": "import { computed } from '@ember/object';",
        "doc": null,
        "grammar": "snu",
        "label": "import { computed } from '@ember/object';",
        "matches": [
          "cproimport"
        ],
        "opts": []
      },
      {
        "content": "${1:property_name}: computed('${3:argument}', function() {\n\t${0://body...}\n}),",
        "doc": null,
        "grammar": "snu",
        "label": "property_name: computed('...', function() {...}),",
        "matches": [
          "cpro"
        ],
        "opts": []
      },
      {
        "content": "import { observer } from '@ember/object';",
        "doc": null,
        "grammar": "snu",
        "label": "import { observer } from '@ember/object';",
        "matches": [
          "prooimport"
        ],
        "opts": []
      },
      {
        "content": "${1:property_name}: observer('${3:argument}', function() {\n\t${0://body...}\n}),",
        "doc": null,
        "grammar": "snu",
        "label": "property_name: observer('...', function() {...}),",
        "matches": [
          "proo"
        ],
        "opts": []
      }
    ],
    "javascript-jasmine": [
      {
        "content": "describe('${1:description}', function() {\n\t$0\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "des \"Describe (js)\""
        ],
        "opts": []
      },
      {
        "content": "it('${1:description}', function() {\n\t$0\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "it \"it (js)\""
        ],
        "opts": []
      },
      {
        "content": "beforeEach(function() {\n\t$0\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bef \"before each (js)\""
        ],
        "opts": []
      },
      {
        "content": "afterEach(function() {\n\t$0\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "aft \"after each (js)\""
        ],
        "opts": []
      },
      {
        "content": "beforeAll(function() {\n\t$0\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "befa \"before all (js)\""
        ],
        "opts": []
      },
      {
        "content": "afterAll(function() {\n\t$0\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "afta \"after all (js)\""
        ],
        "opts": []
      },
      {
        "content": "jasmine.any($1)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "any \"any (js)\""
        ],
        "opts": []
      },
      {
        "content": "jasmine.anything()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "anyt \"anything (js)\""
        ],
        "opts": []
      },
      {
        "content": "jasmine.objectContaining({\n\t${VISUAL}$0\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "objc \"object containing (js)\""
        ],
        "opts": []
      },
      {
        "content": "jasmine.arrayContaining([${1:value1}]);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "arrc \"array containing (js)\""
        ],
        "opts": []
      },
      {
        "content": "jasmine.stringMatching(\"${1:matcher}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "strm \"string matching (js)\""
        ],
        "opts": []
      },
      {
        "content": "runs(function() {\n\t$0\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ru \"runs (js)\""
        ],
        "opts": []
      },
      {
        "content": "waits($1);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wa \"waits (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target})$0;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ex \"expect (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).toEqual(${2:value});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ee \"expect to equal (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).toBeLessThan(${2:value});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "el \"expect to be less than (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).toBeGreaterThan(${2:value});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eg \"expect to be greater than (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).toBe(${2:value});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eb \"expect to be (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).toMatch(${2:pattern});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "em \"expect to match (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).toHaveAttr('${2:attr}'${3:, '${4:value}'});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eha \"expect to have attribute (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).toBeTruthy();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "et \"expect to be truthy (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).toBeFalsy();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ef \"expect to be falsy (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).toBeDefined();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "etbd \"expect to be defined (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).toBeUndefined();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eud \"expect to be defined (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).toBeNull();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "en \"expect to be null (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).toContain(${2:value});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ec \"expect to contain (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).toBeVisible();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ev \"expect to be visible (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).toBeHidden();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eh \"expect to be hidden (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).toThrow(${2:value});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eth \"expect to throw (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).toThrowError(${2:value});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ethe \"expect to throw error (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).not$0;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "notx \"expect not (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).not.toEqual(${2:value});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "note \"expect not to equal (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).not.toBeLessThan(${2:value});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "notl \"expect to not be less than (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).not.toBeGreaterThan(${2:value});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "notg \"expect to not be greater than (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).not.toMatch(${2:pattern});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "notm \"expect not to match (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).not.toHaveAttr('${2:attr}'${3:, '${4:value}'});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "notha \"expect to not have attribute (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).not.toBeTruthy();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nott \"expect not to be truthy (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).not.toBeFalsy();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "notf \"expect not to be falsy (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).not.toBeDefined();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "notd \"expect not to be defined (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).not.toBeNull();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "notn \"expect not to be null (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).not.toContain(${2:value});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "notc \"expect not to contain (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).not.toBeVisible();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "notv \"expect not to be visible (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).not.toBeHidden();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "noth \"expect not to be hidden (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).not.toThrow(${2:value});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "notth \"expect not to throw (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).not.toThrowError(${2:value});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "notthe \"expect not to throw error (js)\""
        ],
        "opts": []
      },
      {
        "content": "spyOn(${1:object}, '${2:method}')$0;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "s \"spy on (js)\""
        ],
        "opts": []
      },
      {
        "content": "spyOn(${1:object}, '${2:method}').and.returnValue(${3:arguments});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sr \"spy on and return (js)\""
        ],
        "opts": []
      },
      {
        "content": "spyOn(${1:object}, '${2:method}').and.throwError(${3:exception});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "st \"spy on and throw (js)\""
        ],
        "opts": []
      },
      {
        "content": "spyOn(${1:object}, '${2:method}').and.callThrough();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sct \"spy on and call through (js)\""
        ],
        "opts": []
      },
      {
        "content": "spyOn(${1:object}, '${2:method}').and.callFake(${3:function});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "scf \"spy on and call fake (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).toHaveBeenCalled();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ethbc \"expect to have been called (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).not.toHaveBeenCalled();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nthbc \"expect not to have been called (js)\""
        ],
        "opts": []
      },
      {
        "content": "expect(${1:target}).toHaveBeenCalledWith(${2:arguments});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ethbcw \"expect to have been called with (js)\""
        ],
        "opts": []
      }
    ],
    "javascript-jasmine-arrow": [
      {
        "content": "describe('${1:description}', () => {\n\t$0\n});",
        "doc": null,
        "grammar": "snu",
        "label": "Describe (js)",
        "matches": [
          "des"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "it('${1:description}', () => {\n\t$0\n});",
        "doc": null,
        "grammar": "snu",
        "label": "it (js)",
        "matches": [
          "it"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "beforeEach(() => {\n\t$0\n});",
        "doc": null,
        "grammar": "snu",
        "label": "before each (js)",
        "matches": [
          "bef"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "afterEach(() => {\n\t$0\n});",
        "doc": null,
        "grammar": "snu",
        "label": "after each (js)",
        "matches": [
          "aft"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "beforeAll(() => {\n\t$0\n});",
        "doc": null,
        "grammar": "snu",
        "label": "before all (js)",
        "matches": [
          "befa"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "afterAll(() => {\n\t$0\n});",
        "doc": null,
        "grammar": "snu",
        "label": "after all (js)",
        "matches": [
          "afta"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "runs(() => {\n\t$0\n});",
        "doc": null,
        "grammar": "snu",
        "label": "runs (js)",
        "matches": [
          "ru"
        ],
        "opts": [
          "b"
        ]
      }
    ],
    "javascript-jquery": [
      {
        "content": "${1:obj}.add('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "add"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.addClass('${2:class name}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "addClass"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.after('${2:Some text <b>and bold!</b>}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "after"
        ],
        "opts": []
      },
      {
        "content": "$.ajax({\n\turl: '${1:mydomain.com/url}',\n\ttype: '${2:POST}',\n\tdataType: '${3:xml/html/script/json}',\n\tdata: $.param( $('${4:Element or Expression}') ),\n\tcomplete: function (jqXHR, textStatus) {\n\t\t${5:// callback}\n\t},\n\tsuccess: function (data, textStatus, jqXHR) {\n\t\t${6:// success callback}\n\t},\n\terror: function (jqXHR, textStatus, errorThrown) {\n\t\t${0:// error callback}\n\t}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ajax"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.ajaxComplete(function (${1:e}, xhr, settings) {\n\t${0:// callback}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ajaxcomplete"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.ajaxError(function (${1:e}, xhr, settings, thrownError) {\n\t${2:// error callback}\n});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ajaxerror"
        ],
        "opts": []
      },
      {
        "content": "$.get('${1:mydomain.com/url}',\n\t${2:{ param1: value1 },}\n\tfunction (data, textStatus, jqXHR) {\n\t\t${0:// success callback}\n\t}\n);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ajaxget"
        ],
        "opts": []
      },
      {
        "content": "$.post('${1:mydomain.com/url}',\n\t${2:{ param1: value1 },}\n\tfunction (data, textStatus, jqXHR) {\n\t\t${0:// success callback}\n\t}\n);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ajaxpost"
        ],
        "opts": []
      },
      {
        "content": "$.ajaxPrefilter(function (${1:options}, ${2:originalOptions}, jqXHR) {\n\t${0: // Modify options, control originalOptions, store jqXHR, etc}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ajaxprefilter"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.ajaxSend(function (${1:request, settings}) {\n\t${2:// error callback}\n});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ajaxsend"
        ],
        "opts": []
      },
      {
        "content": "$.ajaxSetup({\n\turl: \"${1:mydomain.com/url}\",\n\ttype: \"${2:POST}\",\n\tdataType: \"${3:xml/html/script/json}\",\n\tdata: $.param( $(\"${4:Element or Expression}\") ),\n\tcomplete: function (jqXHR, textStatus) {\n\t\t${5:// callback}\n\t},\n\tsuccess: function (data, textStatus, jqXHR) {\n\t\t${6:// success callback}\n\t},\n\terror: function (jqXHR, textStatus, errorThrown) {\n\t\t${0:// error callback}\n\t}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ajaxsetup"
        ],
        "opts": []
      },
      {
        "content": "$.ajaxStart(function () {\n\t${1:// handler for when an AJAX call is started and no other AJAX calls are in progress};\n});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ajaxstart"
        ],
        "opts": []
      },
      {
        "content": "$.ajaxStop(function () {\n\t${1:// handler for when all AJAX calls have been completed};\n});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ajaxstop"
        ],
        "opts": []
      },
      {
        "content": "$.ajaxSuccess(function (${1:e}, xhr, settings) {\n\t${2:// handler for when any AJAX call is successfully completed};\n});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ajaxsuccess"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.andSelf()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "andself"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.animate({${2:param1: value1, param2: value2}}, ${3:speed})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "animate"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.append('${2:Some text <b>and bold!</b>}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "append"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.appendTo('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "appendTo"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.attr('${2:attribute}', '${3:value}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "attr"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.attr({'${2:attr1}': '${3:value1}', '${4:attr2}': '${5:value2}'})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "attrm"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.before('${2:Some text <b>and bold!</b>}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "before"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.bind('${2:event name}', function (${3:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bind"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.blur(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "blur"
        ],
        "opts": []
      },
      {
        "content": "$.Callbacks()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "C"
        ],
        "opts": []
      },
      {
        "content": "${1:callbacks}.add(${2:callbacks})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Cadd"
        ],
        "opts": []
      },
      {
        "content": "${1:callbacks}.disable()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Cdis"
        ],
        "opts": []
      },
      {
        "content": "${1:callbacks}.empty()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Cempty"
        ],
        "opts": []
      },
      {
        "content": "${1:callbacks}.fire(${2:args})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Cfire"
        ],
        "opts": []
      },
      {
        "content": "${1:callbacks}.fired()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Cfired"
        ],
        "opts": []
      },
      {
        "content": "${1:callbacks}.fireWith(${2:this}, ${3:args})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Cfirew"
        ],
        "opts": []
      },
      {
        "content": "${1:callbacks}.has(${2:callback})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Chas"
        ],
        "opts": []
      },
      {
        "content": "${1:callbacks}.lock()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Clock"
        ],
        "opts": []
      },
      {
        "content": "${1:callbacks}.locked()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Clocked"
        ],
        "opts": []
      },
      {
        "content": "${1:callbacks}.remove(${2:callbacks})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Crem"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.change(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "change"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.children('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "children"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.clearQueue(${2:'queue name'})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "clearq"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.click(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "click"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.clone()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "clone"
        ],
        "opts": []
      },
      {
        "content": "$.contains(${1:container}, ${0:contents});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "contains"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.css('${2:attribute}', '${3:value}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "css"
        ],
        "opts": []
      },
      {
        "content": "$.cssHooks['${1:CSS prop}'] = {\n\tget: function (elem, computed, extra) {\n\t\t${2: // handle getting the CSS property}\n\t},\n\tset: function (elem, value) {\n\t\t${0: // handle setting the CSS value}\n\t}\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "csshooks"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.css({${2:attribute1}: '${3:value1}', ${4:attribute2}: '${5:value2}'})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cssm"
        ],
        "opts": []
      },
      {
        "content": "$.Deferred()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "D"
        ],
        "opts": []
      },
      {
        "content": "${1:deferred}.always(${2:callbacks})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Dalways"
        ],
        "opts": []
      },
      {
        "content": "${1:deferred}.done(${2:callbacks})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Ddone"
        ],
        "opts": []
      },
      {
        "content": "${1:deferred}.fail(${2:callbacks})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Dfail"
        ],
        "opts": []
      },
      {
        "content": "${1:deferred}.isRejected()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Disrej"
        ],
        "opts": []
      },
      {
        "content": "${1:deferred}.isResolved()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Disres"
        ],
        "opts": []
      },
      {
        "content": "${1:deferred}.notify(${2:args})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Dnotify"
        ],
        "opts": []
      },
      {
        "content": "${1:deferred}.notifyWith(${2:this}, ${3:args})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Dnotifyw"
        ],
        "opts": []
      },
      {
        "content": "${1:deferred}.then(${2:doneFilter}, ${3:failFilter}, ${4:progressFilter})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Dpipe"
        ],
        "opts": []
      },
      {
        "content": "${1:deferred}.progress(${2:callbacks})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Dprog"
        ],
        "opts": []
      },
      {
        "content": "${1:deferred}.promise(${2:target})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Dprom"
        ],
        "opts": []
      },
      {
        "content": "${1:deferred}.reject(${2:args})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Drej"
        ],
        "opts": []
      },
      {
        "content": "${1:deferred}.rejectWith(${2:this}, ${3:args})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Drejw"
        ],
        "opts": []
      },
      {
        "content": "${1:deferred}.resolve(${2:args})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Dres"
        ],
        "opts": []
      },
      {
        "content": "${1:deferred}.resolveWith(${2:this}, ${3:args})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Dresw"
        ],
        "opts": []
      },
      {
        "content": "${1:deferred}.state()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Dstate"
        ],
        "opts": []
      },
      {
        "content": "${1:deferred}.then(${2:doneCallbacks}, ${3:failCallbacks}, ${4:progressCallbacks})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Dthen"
        ],
        "opts": []
      },
      {
        "content": "$.when(${1:deferreds})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Dwhen"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.data(${2:obj})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "data"
        ],
        "opts": []
      },
      {
        "content": "$.data('${1:selector expression}', '${2:key}'${3:, 'value'})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dataa"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.dblclick(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dblclick"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.delay('${2:slow/400/fast}'${3:, 'queue name'})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "delay"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.delegate('${2:selector expression}', '${3:event name}', function (${4:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dele"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.dequeue(${2:'queue name'})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "deq"
        ],
        "opts": []
      },
      {
        "content": "$.dequeue('${1:selector expression}'${2:, 'queue name'})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "deqq"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.detach('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "detach"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.die(${2:event}, ${3:handler})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "die"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.each(function (index) {\n\t${0:this.innerHTML = this + \" is the element, \" + index + \" is the position\";}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "each"
        ],
        "opts": []
      },
      {
        "content": "$('<${1}/>'${2:, {}})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "el"
        ],
        "opts": []
      },
      {
        "content": "$.trim('${1:string}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eltrim"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.empty()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "empty"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.end()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "end"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.eq(${2:element index})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eq"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.error(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "error"
        ],
        "opts": []
      },
      {
        "content": "{\n\t:f${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eventsmap"
        ],
        "opts": []
      },
      {
        "content": "$.extend(${1:true, }${2:target}, ${3:obj})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "extend"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.fadeIn('${2:slow/400/fast}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fadein"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.fadeIn('slow/400/fast', function () {\n\t${0:// callback};\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fadeinc"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.fadeOut('${2:slow/400/fast}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fadeout"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.fadeOut('slow/400/fast', function () {\n\t${0:// callback};\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fadeoutc"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.fadeTo('${2:slow/400/fast}', ${3:0.5})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fadeto"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.fadeTo('slow/400/fast', ${2:0.5}, function () {\n\t${0:// callback};\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fadetoc"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.filter('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "filter"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.filter(function (${2:index}) {\n\t${3}\n})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "filtert"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.find('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "find"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.focus(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "focus"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.focusIn(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "focusin"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.focusOut(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "focusout"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.get(${2:element index})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "get"
        ],
        "opts": []
      },
      {
        "content": "$.getJSON('${1:mydomain.com/url}',\n\t${2:{ param1: value1 },}\n\tfunction (data, textStatus, jqXHR) {\n\t\t${0:// success callback}\n\t}\n);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "getjson"
        ],
        "opts": []
      },
      {
        "content": "$.getScript('${1:mydomain.com/url}', function (script, textStatus, jqXHR) {\n\t${0:// callback}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "getscript"
        ],
        "opts": []
      },
      {
        "content": "$.grep(${1:array}, function (item, index) {\n\t${2}\n}${0:, true});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "grep"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.hasClass('${2:className}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "hasc"
        ],
        "opts": []
      },
      {
        "content": "$.hasData('${0:selector expression}');",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "hasd"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.height(${2:integer})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "height"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.hide('${2:slow/400/fast}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "hide"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.hide('${2:slow/400/fast}', function () {\n\t${0:// callback}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "hidec"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.hover(function (${2:e}) {\n\t${3:// event handler}\n}, function ($2) {\n\t${4:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "hover"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.html('${2:Some text <b>and bold!</b>}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "html"
        ],
        "opts": []
      },
      {
        "content": "$.inArray(${1:value}, ${0:array});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "inarr"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.insertAfter('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "insa"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.insertBefore('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "insb"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.is('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "is"
        ],
        "opts": []
      },
      {
        "content": "$.isArray(${1:obj})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isarr"
        ],
        "opts": []
      },
      {
        "content": "$.isEmptyObject(${1:obj})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isempty"
        ],
        "opts": []
      },
      {
        "content": "$.isFunction(${1:obj})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isfunc"
        ],
        "opts": []
      },
      {
        "content": "$.isNumeric(${1:value})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isnum"
        ],
        "opts": []
      },
      {
        "content": "$.isPlainObject(${1:obj})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isobj"
        ],
        "opts": []
      },
      {
        "content": "$.isWindow(${1:obj})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "iswin"
        ],
        "opts": []
      },
      {
        "content": "$.isXMLDoc(${1:node})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isxml"
        ],
        "opts": []
      },
      {
        "content": "$('${1:selector}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jj"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.keydown(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "kdown"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.keypress(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "kpress"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.keyup(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "kup"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.last('${1:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "last"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.live('${2:events}', function (${3:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "live"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.load(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "load"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.load('${2:mydomain.com/url}',\n\t${2:{ param1: value1 },}\n\tfunction (responseText, textStatus, xhr) {\n\t\t${0:// success callback}\n\t}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "loadf"
        ],
        "opts": []
      },
      {
        "content": "$.makeArray(${0:obj});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "makearray"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.map(function (${2:index}, ${3:element}) {\n\t${0:// callback}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "map"
        ],
        "opts": []
      },
      {
        "content": "$.map(${1:arrayOrObject}, function (${2:value}, ${3:indexOrKey}) {\n\t${0:// callback}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mapp"
        ],
        "opts": []
      },
      {
        "content": "$.merge(${1:target}, ${0:original});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "merge"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.mousedown(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mdown"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.mouseenter(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "menter"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.mouseleave(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mleave"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.mousemove(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mmove"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.mouseout(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mout"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.mouseover(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mover"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.mouseup(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mup"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.next('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "next"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.nextAll('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nexta"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.nextUntil('${2:selector expression}'${3:, 'filter expression'})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nextu"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.not('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "not"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.off('${2:events}', '${3:selector expression}'${4:, handler})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "off"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.offset()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "offset"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.offsetParent()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "offsetp"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.on('${2:events}', '${3:selector expression}', function (${4:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "on"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.one('${2:event name}', function (${3:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "one"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.outerHeight()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "outerh"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.outerWidth()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "outerw"
        ],
        "opts": []
      },
      {
        "content": "$.param(${1:obj})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "param"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.parent('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "parent"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.parents('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "parents"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.parentsUntil('${2:selector expression}'${3:, 'filter expression'})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "parentsu"
        ],
        "opts": []
      },
      {
        "content": "$.parseJSON(${1:data})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "parsejson"
        ],
        "opts": []
      },
      {
        "content": "$.parseXML(${1:data})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "parsexml"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.position()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pos"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.prepend('${2:Some text <b>and bold!</b>}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prepend"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.prependTo('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prependto"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.prev('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prev"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.prevAll('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "preva"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.prevUntil('${2:selector expression}'${3:, 'filter expression'})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prevu"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.promise(${2:'fx'}, ${3:target})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "promise"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.prop('${2:property name}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prop"
        ],
        "opts": []
      },
      {
        "content": "$.proxy(${1:function}, ${2:this})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "proxy"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.pushStack(${2:elements})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pushstack"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.queue(${2:name}${3:, newQueue})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "queue"
        ],
        "opts": []
      },
      {
        "content": "$.queue(${1:element}${2:, name}${3:, newQueue})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "queuee"
        ],
        "opts": []
      },
      {
        "content": "$(function () {\n\t${0}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ready"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.remove()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rem"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.removeAttr('${2:attribute name}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rema"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.removeClass('${2:class name}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "remc"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.removeData('${2:key name}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "remd"
        ],
        "opts": []
      },
      {
        "content": "$.removeData(${1:element}${2:, 'key name}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "remdd"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.removeProp('${2:property name}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "remp"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.replaceAll(${2:target})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "repa"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.replaceWith(${2:content})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "repw"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.reset(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "reset"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.resize(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "resize"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.scroll(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "scroll"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.scrollLeft(${2:value})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "scrolll"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.scrollTop(${2:value})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "scrollt"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.slideDown('${2:slow/400/fast}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sdown"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.slideDown('${2:slow/400/fast}', function () {\n\t${0:// callback};\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sdownc"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.select(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "select"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.serialize()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "serialize"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.serializeArray()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "serializea"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.show('${2:slow/400/fast}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "show"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.show('${2:slow/400/fast}', function () {\n\t${0:// callback}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "showc"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.siblings('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sib"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.size()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "size"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.slice(${2:start}${3:, end})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "slice"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.slideToggle('${2:slow/400/fast}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "stoggle"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.stop('${2:queue}', ${3:false}, ${4:false})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "stop"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.submit(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "submit"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.slideUp('${2:slow/400/fast}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sup"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.slideUp('${2:slow/400/fast}', function () {\n\t${0:// callback};\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "supc"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.text(${2:'some text'})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "text"
        ],
        "opts": []
      },
      {
        "content": "$(this)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "this"
        ],
        "opts": []
      },
      {
        "content": "${0:obj}.toArray()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "toarr"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.toggle(function (${2:e}) {\n\t${3:// event handler}\n}, function ($2) {\n\t${4:// event handler}\n});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tog"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.toggleClass('${2:class name}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "togclass"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.toggle('${2:slow/400/fast}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "togsh"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.trigger('${2:event name}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "trig"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.triggerHandler('${2:event name}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "trigh"
        ],
        "opts": []
      },
      {
        "content": "$.trim(${1:str})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "$trim"
        ],
        "opts": []
      },
      {
        "content": "$.type(${1:obj})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "$type"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.unbind('${2:event name}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "unbind"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.undelegate(${2:selector expression}, ${3:event}, ${4:handler})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "undele"
        ],
        "opts": []
      },
      {
        "content": "$.unique(${1:array})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "uniq"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.unload(function (${2:e}) {\n\t${0:// event handler}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "unload"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.unwrap()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "unwrap"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.val('${2:text}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "val"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.width(${2:integer})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "width"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.wrap('${2:&lt;div class=\"extra-wrapper\"&gt;&lt;/div&gt;}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wrap"
        ],
        "opts": []
      }
    ],
    "javascript-jsdoc": [
      {
        "content": "/**\n * ${1:${VISUAL}}$0\n */",
        "doc": null,
        "grammar": "snu",
        "label": "A JSDoc comment",
        "matches": [
          "/*"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "@author ${1:`!v g:snips_author`} [${2:`!v g:snips_author_email`}]",
        "doc": null,
        "grammar": "snu",
        "label": "@author email (First Last)",
        "matches": [
          "@au"
        ],
        "opts": []
      },
      {
        "content": "@license ${1:MIT}$0",
        "doc": null,
        "grammar": "snu",
        "label": "@license Description",
        "matches": [
          "@li"
        ],
        "opts": []
      },
      {
        "content": "@version ${1:0.1.0}$0",
        "doc": null,
        "grammar": "snu",
        "label": "@version Semantic version",
        "matches": [
          "@ver"
        ],
        "opts": []
      },
      {
        "content": "/**\n * @fileoverview ${1:${VISUAL:A description of the file}}$0\n */",
        "doc": null,
        "grammar": "snu",
        "label": "@fileoverview Description",
        "matches": [
          "@fileo"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "@constructor",
        "doc": null,
        "grammar": "snu",
        "label": "@constructor",
        "matches": [
          "@constr"
        ],
        "opts": []
      },
      {
        "content": "@param {${1:Type}} ${2:varname} ${3:Description}",
        "doc": null,
        "grammar": "snu",
        "label": "@param {Type} varname Description",
        "matches": [
          "@p"
        ],
        "opts": []
      },
      {
        "content": "@return {${1:Type}} ${2:Description}",
        "doc": null,
        "grammar": "snu",
        "label": "@return {Type} Description",
        "matches": [
          "@ret"
        ],
        "opts": []
      },
      {
        "content": "@private",
        "doc": null,
        "grammar": "snu",
        "label": "@private",
        "matches": [
          "@pri"
        ],
        "opts": []
      },
      {
        "content": "@override",
        "doc": null,
        "grammar": "snu",
        "label": "@override",
        "matches": [
          "@over"
        ],
        "opts": []
      },
      {
        "content": "@protected",
        "doc": null,
        "grammar": "snu",
        "label": "@protected",
        "matches": [
          "@pro"
        ],
        "opts": []
      }
    ],
    "javascript-mocha": [
      {
        "content": "describe('${1:}', () => {\n\t${0:${VISUAL}}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "des \"describe('thing', () => { ... })\" b"
        ],
        "opts": []
      },
      {
        "content": "it('${1:}', () => {\n\t${0:${VISUAL}}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "it \"it('should do', () => { ... })\" b"
        ],
        "opts": []
      },
      {
        "content": "xit('${1:}', () => {\n\t${0:${VISUAL}}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "xit \"xit('should do', () => { ... })\" b"
        ],
        "opts": []
      },
      {
        "content": "before(() => {\n\t${0:${VISUAL}}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bef \"before(() => { ... })\" b"
        ],
        "opts": []
      },
      {
        "content": "beforeEach(() => {\n\t${0:${VISUAL}}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "befe \"beforeEach(() => { ... })\" b"
        ],
        "opts": []
      },
      {
        "content": "after(() => {\n\t${0:${VISUAL}}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "aft \"after(() => { ... })\" b"
        ],
        "opts": []
      },
      {
        "content": "afterEach(() => {\n\t${0:${VISUAL}}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "afte \"afterEach(() => { ... })\" b"
        ],
        "opts": []
      },
      {
        "content": "expect(${1:})${0};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "exp \"expect(...)\" b"
        ],
        "opts": []
      },
      {
        "content": "expect(${1:}).to.equal(${0});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "expe \"expect(...).to.equal(...)\" b"
        ],
        "opts": []
      },
      {
        "content": "expect(${1:}).to.deep.equal(${0});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "expd \"expect(...).to.deep.equal(...)\" b"
        ],
        "opts": []
      }
    ],
    "javascript-node": [
      {
        "content": "#!/usr/bin/env node",
        "doc": null,
        "grammar": "snu",
        "label": "#!/usr/bin/env node",
        "matches": [
          "#!"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "var ${0:${1/(.+\\/)*(\\w+)(-|\\b|$)(\\..+$)?/\\u$2/g}} = require('$1');",
        "doc": null,
        "grammar": "snu",
        "label": "assign a CommonJS-style module to a var",
        "matches": [
          "vreq"
        ],
        "opts": []
      },
      {
        "content": "module.exports = $1;",
        "doc": null,
        "grammar": "snu",
        "label": "module.exports",
        "matches": [
          "ex"
        ],
        "opts": []
      },
      {
        "content": "http.createServer($1).listen($2);",
        "doc": null,
        "grammar": "snu",
        "label": "http.createServer",
        "matches": [
          "hcs"
        ],
        "opts": []
      },
      {
        "content": "net.createServer(function(${1:socket}){\n\t$1.on('data', function(${3:data}){\n\t\t$4\n\t});\n\t$1.on('end', function(){\n\t\t$5\n\t});\n}).listen(${6:8124});",
        "doc": null,
        "grammar": "snu",
        "label": "net.createServer",
        "matches": [
          "ncs"
        ],
        "opts": []
      },
      {
        "content": "pipe(${1:stream})$2",
        "doc": null,
        "grammar": "snu",
        "label": "pipe",
        "matches": [
          "pipe"
        ],
        "opts": []
      },
      {
        "content": "${1:app}.get('$2', $3);",
        "doc": null,
        "grammar": "snu",
        "label": "express GET",
        "matches": [
          "eget"
        ],
        "opts": []
      },
      {
        "content": "${1:app}.post('$2', $3);",
        "doc": null,
        "grammar": "snu",
        "label": "express POST",
        "matches": [
          "epost"
        ],
        "opts": []
      },
      {
        "content": "${1:app}.put('$2', $3);",
        "doc": null,
        "grammar": "snu",
        "label": "express PUT",
        "matches": [
          "eput"
        ],
        "opts": []
      },
      {
        "content": "${1:app}.delete('$2', $3);",
        "doc": null,
        "grammar": "snu",
        "label": "express DELETE",
        "matches": [
          "edelete"
        ],
        "opts": []
      },
      {
        "content": "process.stdout",
        "doc": null,
        "grammar": "snu",
        "label": "stdout",
        "matches": [
          "stdout"
        ],
        "opts": []
      },
      {
        "content": "process.stdin",
        "doc": null,
        "grammar": "snu",
        "label": "stdin",
        "matches": [
          "stdin"
        ],
        "opts": []
      },
      {
        "content": "process.stderr",
        "doc": null,
        "grammar": "snu",
        "label": "stderr",
        "matches": [
          "stderr"
        ],
        "opts": []
      }
    ],
    "javascript-openui5": [
      {
        "content": "var $1 = new sap.m.Label({\n\t\t\tdesign : $2,\n\t\t\ttext : $3,\n\t\t\tvisible : $4,\n\t\t\ttextAlign : $5,\n\t\t\ttextDirection : $6,\n\t\t\twidth : $7,\n\t\t\trequired : $7\n\t\t});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sapmlabel"
        ],
        "opts": []
      },
      {
        "content": "var $1 = new sap.m.Text({\n\t\t\ttext :$2,\n\t\t\ttextDirection :$3,\n\t\t\tvisible :$4,\n\t\t\twrapping : $5,\n\t\t\ttextAlign : $6,\n\t\t\twidth :$7,\n\t\t\tmaxLines :$8\n\t\t});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sapmtext"
        ],
        "opts": []
      },
      {
        "content": "var $1 = new sap.m.Button({\n\t\t\ttext : $2,\n\t\t\ttype : $3,\n\t\t\twidth : $4,\n\t\t\tenabled :$5,\n\t\t\tvisible :$6,\n\t\t\ticon : $7,\n\t\t\ticonFirst : $8,\n\t\t\tactiveIcon :$9,\n\t\t\ticonDensityAware : $10,\n\t\t});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sapmbutton"
        ],
        "opts": []
      },
      {
        "content": "var $1 = new sap.m.FlexBox({\n\t\t\tvisible : $2,\n\t\t\theight : $3,\n\t\t\twidth : $4,\n\t\t\tdisplayInline :$5,\n\t\t\tdirection :$6,\n\t\t\tfitContainer : $7,\n\t\t\trenderType : $8,\n\t\t\tjustifyContent :$9,\n\t\t\talignItems : $10,\n\t\t\titems:[]\n\t\t});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sapmflexbox"
        ],
        "opts": []
      },
      {
        "content": "var $1 = new sap.m.HBox({\n\t\t\tvisible : $2,\n\t\t\theight : $3,\n\t\t\twidth : $4,\n\t\t\tdisplayInline :$5,\n\t\t\tdirection :$6,\n\t\t\tfitContainer : $7,\n\t\t\trenderType : $8,\n\t\t\tjustifyContent :$9,\n\t\t\talignItems : $10,\n\t\t\titems:[]\n\t\t});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sapmhbox"
        ],
        "opts": []
      },
      {
        "content": "var $1 = new sap.m.VBox({\n\t\t\tvisible : $2,\n\t\t\theight : $3,\n\t\t\twidth : $4,\n\t\t\tdisplayInline :$5,\n\t\t\tdirection :$6,\n\t\t\tfitContainer : $7,\n\t\t\trenderType : $8,\n\t\t\tjustifyContent :$9,\n\t\t\talignItems : $10,\n\t\t\titems:[]\n\t\t});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sapmvbox"
        ],
        "opts": []
      },
      {
        "content": "sap.ui.controller(\"$1\", {\n   onInit: function(){\n   },\n   onAfterRendering: function() {\n   },\n   onAfterRendering: function() {\n   },\n   onExit: function() {\n   },\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sapcomponent"
        ],
        "opts": []
      },
      {
        "content": "var $1 = new sap.m.Input({\n\tvalue :$2,\n\twidth : $3,\n\tenabled :$4,\n\tvisible :$5,\n\tvalueState :$6,\n\tname : $7,\n\tplaceholder : $8,\n\teditable : $9,\n\ttype : $10,\n\tmaxLength :$11,\n\tvalueStateText :$12,\n\tshowValueStateMessage :$13,\n\tdateFormat :$14,\n\tshowValueHelp :$15,\n\tshowSuggestion :$16,\n\tvalueHelpOnly :$17,\n\tfilterSuggests :$18,\n\tmaxSuggestionWidth :$19,\n\tstartSuggestion : $20,\n\tshowTableSuggestionValueHelp : $21,\n\tdescription : $22,\n\tfieldWidth : $23,\n\tvalueLiveUpdate :$24,\n\tsuggestionItems  :[$25],\n\tsuggestionColumns : [$26],\n\tsuggestionRows : [$27],\n\tliveChange : $28,\n\tvalueHelpRequest :$29,\n\tsuggest : $30,\n\tsuggestionItemSelected : $31\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sapminput"
        ],
        "opts": []
      },
      {
        "content": "var _self = this;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "_sthis"
        ],
        "opts": []
      },
      {
        "content": "var $1 = new sap.m.ResponsivePopover({\n\t\t\tplacement :$2 ,//sap.m.PlacementType (default: sap.m.PlacementType.Right)\n\t\t\tshowHeader :$3 ,//boolean (default: true)\n\t\t\ttitle : $4,//string\n\t\t\ticon :$5 ,//sap.ui.core.URI\n\t\t\tmodal :$6 ,// boolean\n\t\t\toffsetX :$7, //int\n\t\t\toffsetY :$8, //int\n\t\t\tcontentWidth : $9,//sap.ui.core.CSSSize\n\t\t\tcontentHeight :$10, //sap.ui.core.CSSSize\n\t\t\thorizontalScrolling :$11, //boolean\n\t\t\tverticalScrolling :$12, //boolean\n\t\t\tshowCloseButton :$13, //boolean (default: true)\n\t\t\t//Aggregations\n\t\t\tcontent :$14,  //sap.ui.core.Control[]\n\t\t\tcustomHeader :$15,  //sap.m.IBar\n\t\t\tsubHeader : $16, //sap.m.IBar\n\t\t\tbeginButton :$17,  //sap.m.Button\n\t\t\tendButton : $18, //sap.m.Button\n\t\t\t//Associations\n\t\t\tinitialFocus : $19, //string | sap.ui.core.Control\n\t\t\t//Events\n\t\t\tbeforeOpen :$20,  //fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]\n\t\t\tafterOpen : $21, //fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]\n\t\t\tbeforeClose : $22, //fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]\n\t\t\tafterClose : $23 //fnList\n\t\t});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sapmresponsivepopup"
        ],
        "opts": []
      },
      {
        "content": "var $1 = new sap.ui.core.Icon({\n\t\t\t\tsrc :$2 , //sap.ui.core.URI\n\t\t\t\tsize :$3 , //sap.ui.core.CSSSize\n\t\t\t\tcolor :$4 , //sap.ui.core.CSSColor\n\t\t\t\thoverColor : $5 ,  // sap.ui.core.CSSColor\n\t\t\t\tactiveColor :$6 , //sap.ui.core.CSSColor\n\t\t\t\twidth :$7 , //sap.ui.core.CSSSize\n\t\t\t\theight : $8 ,//sap.ui.core.CSSSize\n\t\t\t\tbackgroundColor :$8 , //sap.ui.core.CSSColor\n\t\t\t\thoverBackgroundColor :$9 , //sap.ui.core.CSSColor\n\t\t\t\tactiveBackgroundColor :$10 , //sap.ui.core.CSSColor\n\t\t\t\tvisible :$11 , //boolean (default: true)\n\t\t\t\tdecorative : $12 ,//boolean (default: true)\n\t\t\t});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sapicon"
        ],
        "opts": []
      },
      {
        "content": "sap.ui.layout.VerticalLayout.extend(\"$1\", {\n    metadata: {\n\tproperties: {\n\t  \t$2\n\t},\n\taggregations: {\n\t\t$3\n\t},\n\tevents: {\n\t\t$4\n\t}\n    },\n   init: function(){\n\t$5\n    },\n    renderer: \"$6\"\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "extendVerticalL"
        ],
        "opts": []
      },
      {
        "content": "sap.ui.layout.HorizontalLayout.extend(\"$1\", {\n    metadata: {\n\tproperties: {\n\t  \t$2\n\t},\n\taggregations: {\n\t\t$3\n\t},\n\tevents: {\n\t\t$4\n\t}\n    },\n   init: function(){\n\t$5\n    },\n    renderer: \"$6\"\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "extendHorizontalL"
        ],
        "opts": []
      }
    ],
    "javascript-react": [
      {
        "content": "import React from 'react';",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ir import React"
        ],
        "opts": []
      },
      {
        "content": "import React, { Component } from 'react';",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "irc import React and Component"
        ],
        "opts": []
      },
      {
        "content": "import { use$1 } from 'react';",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "irh import React hooks"
        ],
        "opts": []
      },
      {
        "content": "import ReactDOM from 'react-dom';",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ird import ReactDOM"
        ],
        "opts": []
      },
      {
        "content": "import PropTypes from 'prop-types';",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "irp import PropTypes"
        ],
        "opts": []
      },
      {
        "content": "componentDidMount() {\n\t${1}\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cdm componentDidMount"
        ],
        "opts": []
      },
      {
        "content": "componentDidUpdate(prevProps, prevState) {\n\t${1}\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cdup componentDidUpdate"
        ],
        "opts": []
      },
      {
        "content": "componentWillMount() {\n\t${1}\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cwm componentWillMount"
        ],
        "opts": []
      },
      {
        "content": "componentWillReceiveProps(nextProps) {\n\t${1}\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cwr componentWillReceiveProps"
        ],
        "opts": []
      },
      {
        "content": "componentWillUnmount() {\n\t${1}\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cwun componentWillUnmount"
        ],
        "opts": []
      },
      {
        "content": "componentWillUpdate(nextProps, nextState) {\n\t${1}\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cwu componentWillUpdate"
        ],
        "opts": []
      },
      {
        "content": "shouldComponentUpdate(nextProps, nextState) {\n\t${1}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "scu shouldComponentUpdate"
        ],
        "opts": []
      },
      {
        "content": "static propTypes = {\n\t${1}: PropTypes.${2}\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "spt static propTypes"
        ],
        "opts": []
      },
      {
        "content": "${1}.propTypes = {\n\t${2}: PropTypes.${2}\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pt propTypes"
        ],
        "opts": []
      },
      {
        "content": "static defaultProps = {\n\t${1}: ${2}\t\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sdp static defaultProps"
        ],
        "opts": []
      },
      {
        "content": "${1}.defaultProps = {\n\t${2}: ${3}\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dp defaultProps"
        ],
        "opts": []
      },
      {
        "content": "props.${1};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pp props"
        ],
        "opts": []
      },
      {
        "content": "this.props.${1};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tp this props"
        ],
        "opts": []
      },
      {
        "content": "state = {\n\t${1}: ${2},\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "st"
        ],
        "opts": []
      },
      {
        "content": "this.setState({\n\t${1}: ${2}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sst"
        ],
        "opts": []
      },
      {
        "content": "this.state.${1};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tst"
        ],
        "opts": []
      },
      {
        "content": "const ${1:ComponentName} = (${2:props}) => {\n\t${3:state}\n\treturn (\n\t\t<>\n\t\t\t${4}\n\t\t</>\n\t);\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "raf"
        ],
        "opts": []
      },
      {
        "content": "class ${1:ClassName} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<>\n\t\t\t\t${2}\n\t\t\t</>\n\t\t);\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rcla"
        ],
        "opts": []
      },
      {
        "content": "export default class ${1:ClassName} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<>\n\t\t\t\t${2}\n\t\t\t</>\n\t\t);\n\t};\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ercla"
        ],
        "opts": []
      },
      {
        "content": "constructor() {\n\tsuper();\n\t${1:state}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ctor"
        ],
        "opts": []
      },
      {
        "content": "render() {\n\treturn (\n\t\t<>\n\t\t\t${2}\n\t\t</>\n\t);\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ren"
        ],
        "opts": []
      },
      {
        "content": "forceUpdate(${1:callback});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fup"
        ],
        "opts": []
      },
      {
        "content": "const [${1:state}, set${2}] = useState(${3:initialState});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "uses useState"
        ],
        "opts": []
      },
      {
        "content": "useEffect(() => {\n\t${1}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "usee useEffect"
        ],
        "opts": []
      },
      {
        "content": "const [${1:state}, ${2:dispatch}] = useReducer(${3:reducer});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "userd useReducer"
        ],
        "opts": []
      },
      {
        "content": "const ${1:refContainer} = useRef(${2:initialValue});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "userf useRef"
        ],
        "opts": []
      },
      {
        "content": "const ${1:value} = useContext(${2:MyContext});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "usect useContext"
        ],
        "opts": []
      },
      {
        "content": "const ${1:memoizedCallback} = useCallback(\n() => {\n\t${2}(${3})\n},\n[$3]\n);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "usecb useCallback"
        ],
        "opts": []
      },
      {
        "content": "const ${1:memoizedCallback} = useMemo(() => ${2}(${3}), [$3]);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "usem useMemo"
        ],
        "opts": []
      },
      {
        "content": "useImperativeHandle(${1:ref}, ${2:createHandle});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "usei useImperativeHandle"
        ],
        "opts": []
      },
      {
        "content": "useDebugValue(${1:value});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "used useDebugValue"
        ],
        "opts": []
      },
      {
        "content": "ReactDOM.render(${1}, ${2});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rdr ReactDOM.render"
        ],
        "opts": []
      },
      {
        "content": "ReactDOM.hydrate(${1:element}, ${2:container}[, ${3:callback}]);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rdh ReactDOM.hydrate"
        ],
        "opts": []
      },
      {
        "content": "ReactDOM.createPortal(${1:child}, ${2:container});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rdcp ReactDOM.createPortal"
        ],
        "opts": []
      }
    ],
    "javascript-redux": [
      {
        "content": "import { createStore } from 'redux';",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ist"
        ],
        "opts": []
      },
      {
        "content": "connect(${1:mapStateToProps}, ${2:mapDispatchToProps})(<${3:VISUAL}/>);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "con"
        ],
        "opts": []
      },
      {
        "content": "const ${1:actionName} = (${2:arg}) => {\n\treturn {\n\t\ttype: ${3:VISUAL},\n\t\t$2\n\t};\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "act"
        ],
        "opts": []
      },
      {
        "content": "const ${1:reducerName} = (state={}, action) => {\n\tswitch(action.type) {\n\t\tcase ${1:action}:\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\t$2\n\t\t\t};\n\t\tdefault:\n\t\t\treturn state;\n\t};\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rdc"
        ],
        "opts": []
      },
      {
        "content": "const mapStateToProps = (state) => {\n\treturn {\n\t\t${1:propName}: state.$1,\n\t};\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mstp"
        ],
        "opts": []
      },
      {
        "content": "const mapDispatchToProps = (dispatch) => {\n\treturn {\n\t\t${1:propName}: () => {\n\t\t\tdispatch(${2:actionName}());\n\t\t},\n\t};\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mdtp"
        ],
        "opts": []
      }
    ],
    "javascript-requirejs": [
      {
        "content": "define([\"${1:#dependencies1}\"], function (${2:#dependencies2}) {\n\treturn ${0:TARGET};\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "def"
        ],
        "opts": []
      },
      {
        "content": "define(\"${1:#name}\", [\"${2:#dependencies1}\"], function (${3:#dependencies2}) {\n\treturn ${0:TARGET};\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defn"
        ],
        "opts": []
      },
      {
        "content": "require([\"${1:#dependencies1}\"], function (${2:#dependencies2}) {\n\treturn ${0:TARGET};\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "reqjs"
        ],
        "opts": []
      }
    ],
    "javascript.node": [
      {
        "content": "#!/usr/bin/env node",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#!"
        ],
        "opts": []
      },
      {
        "content": "module.exports = ${1};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ex"
        ],
        "opts": []
      },
      {
        "content": "${1:const} ${2} = require('${3:module_name}');",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "re"
        ],
        "opts": []
      },
      {
        "content": "on('${1:event_name}', function(${2:stream}) {\n  ${3}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "on"
        ],
        "opts": []
      },
      {
        "content": "emit('${1:event_name}', ${2:args});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "emit"
        ],
        "opts": []
      },
      {
        "content": "once('${1:event_name}', function(${2:stream}) {\n  ${3}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "once"
        ],
        "opts": []
      },
      {
        "content": "http.createServer(${1:handler}).listen(${2:port_number});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "http"
        ],
        "opts": []
      },
      {
        "content": "net.createServer(function(${1:socket}){\n\t${1}.on('data', function('data'){\n\t  ${2}\n\t]});\n\t${1}.on('end', function(){\n\t  ${3}\n\t});\n}).listen(${4:8124});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "net"
        ],
        "opts": []
      },
      {
        "content": "pipe(${1:stream})${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pipe"
        ],
        "opts": []
      },
      {
        "content": "${1:app}.get('${2:route}', ${3:handler});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eget"
        ],
        "opts": []
      },
      {
        "content": "${1:app}.post('${2:route}', ${3:handler});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "epost"
        ],
        "opts": []
      },
      {
        "content": "${1:app}.put('${2:route}', ${3:handler});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eput"
        ],
        "opts": []
      },
      {
        "content": "${1:app}.delete('${2:route}', ${3:handler});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "edel"
        ],
        "opts": []
      },
      {
        "content": "process.stdin",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "stdin"
        ],
        "opts": []
      },
      {
        "content": "process.stdout",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "stdout"
        ],
        "opts": []
      },
      {
        "content": "process.stderr",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "stderr"
        ],
        "opts": []
      }
    ],
    "javascript_react": [],
    "jenkins": [
      {
        "content": "steps {\n\tsh '${1:make check}'\n\tjunit '${2:reports/**/*.xml}' \n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "steps"
        ],
        "opts": []
      },
      {
        "content": "stage('${1:Test}'){\n\tsteps {\n\t\tsh '${2:make check}'\n\t\tjunit '${3:reports/**/*.xml}' \n\t}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "stage"
        ],
        "opts": []
      },
      {
        "content": "pipeline {\n\tagent any \n\tstages {\n\t\tstage('${1:Build}') { \n\t\t\tsteps { \n\t\t\t\tsh '${2:make}' \n\t\t\t}\n\t\t}\n\t}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pipeline"
        ],
        "opts": []
      },
      {
        "content": "pipeline {\n\tagent any \n\tstages {\n\t\tstage('${1:Build}') { \n\t\t\tsteps { \n\t\t\t\tsh '${2:make}' \n\t\t\t}\n\t\t}\n\t\tstage('${3:Test}'){\n\t\t\tsteps {\n\t\t\t\tsh '${4:make check}'\n\t\t\t\tjunit '${5:reports/**/*.xml}' \n\t\t\t}\n\t\t}\n\t\tstage('${6:Deploy}') {\n\t\t\tsteps {\n\t\t\t\tsh '${7:make publish}'\n\t\t\t}\n\t\t}\n\t}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pipeline_sample"
        ],
        "opts": []
      },
      {
        "content": "docker {\n\timage '${1:myregistry.com/node'}'\n\tlabel '${2:my-defined-label'}'\n\tregistryUrl '${3:https://myregistry.com/'}'\n\tregistryCredentialsId '${4:myPredefinedCredentialsInJenkins'}'\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d"
        ],
        "opts": []
      },
      {
        "content": "dockerfile {\n\tfilename '${1:Dockerfile.build}'\n\tdir '${2:build}'\n\tlabel '${3:my-defined-label}'\n\tregistryUrl '${4:https://myregistry.com/}'\n\tregistryCredentialsId '${5:myPredefinedCredentialsInJenkins}'\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "df"
        ],
        "opts": []
      },
      {
        "content": "post { \n\talways { \n\t\t${1}\n\t}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pa"
        ],
        "opts": []
      },
      {
        "content": "post { \n\tchanged { \n\t\t${1}\n\t}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc"
        ],
        "opts": []
      },
      {
        "content": "post { \n\tfixed { \n\t\t${1}\n\t}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pf"
        ],
        "opts": []
      },
      {
        "content": "post { \n\tregression { \n\t\t${1}\n\t}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pr"
        ],
        "opts": []
      },
      {
        "content": "post { \n\taborted { \n\t\t${1}\n\t}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pab"
        ],
        "opts": []
      },
      {
        "content": "post { \n\tfailure { \n\t\t${1}\n\t}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pfa"
        ],
        "opts": []
      },
      {
        "content": "post { \n\tsuccess { \n\t\t${1}\n\t}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ps"
        ],
        "opts": []
      },
      {
        "content": "post { \n\tunstable { \n\t\t${1}\n\t}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pu"
        ],
        "opts": []
      },
      {
        "content": "post { \n\tcleanup { \n\t\t${1}\n\t}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc"
        ],
        "opts": []
      },
      {
        "content": "pipeline {\n\tagent any \n\tstages {\n\t\tstage('${1:Build}') { \n\t\t\tsteps { \n\t\t\t\tsh '${2:make}' \n\t\t\t}\n\t\t}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "psss"
        ],
        "opts": []
      },
      {
        "content": "stages {\n\tstage('${1:Build}') { \n\t\tsteps { \n\t\t\tsh '${2:make}' \n\t\t}\n\t}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sss"
        ],
        "opts": []
      },
      {
        "content": "parameters{ \n\t${1}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "parameters"
        ],
        "opts": []
      },
      {
        "content": "text(name: \"${1:BIOGRAPHY}\" , defaultValue: \"${2:default}\" , description: \"${3:Enter some information about the person}\")\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "paramtext"
        ],
        "opts": []
      },
      {
        "content": "booleanParam(name: \"${1:TOGGLE}\" , defaultValue: ${2:default}, description: \"${3:Toggle this value}\")\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "parambool"
        ],
        "opts": []
      },
      {
        "content": "choice(name: \"${1:CHOICE}\" , choices: [\"${2:Choices}\",] , description: \"${3:Pick something}\") \n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "paramchoice"
        ],
        "opts": []
      },
      {
        "content": "password(name: \"${1:PASSWORD}\" , defaultValue: \"${2:SECRET}\" , description: \"${3:Enter a password}\")\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "parampassword"
        ],
        "opts": []
      },
      {
        "content": "file(name: \"${1:FILE}\" , description: \"${2:Choose a file to upload}\")${0}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "paramfile"
        ],
        "opts": []
      },
      {
        "content": "triggers {\n\tcron('${1:H */4 * * 1-5}')\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "triggers"
        ],
        "opts": []
      },
      {
        "content": "input {\n\tmessage '${1:Should we continue?}'\n\tok '${2:Yes, we should.}'\n\tsubmitter '${3:alice,bob}'\n\tparameters { \n\t\tstring(name: '${4:PERSON}' , defaultValue: '${5:Mr Jenkins}' , description: '${6:Who should I say hello to?}')\n\t}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "input"
        ],
        "opts": []
      },
      {
        "content": "when {\n\tbranch '${1:branch}'\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whenbranch"
        ],
        "opts": []
      },
      {
        "content": "when {\n\tbuildingTag '${1:tag}'\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whenbuildingTag"
        ],
        "opts": []
      },
      {
        "content": "when {\n\tchangelog '${1:changelog}'\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whenchangelog"
        ],
        "opts": []
      },
      {
        "content": "when {\n\tchangeset '${1:changeSet}'\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whenchangeset"
        ],
        "opts": []
      },
      {
        "content": "when {\n\tchangeRequest '${1:changeRequest}'\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whenchangeRequest"
        ],
        "opts": []
      },
      {
        "content": "when {\n\tenvironment '${1:environment}'\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whenenvironment"
        ],
        "opts": []
      },
      {
        "content": "when {\n\tequals '${1:equals}'\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whenequals"
        ],
        "opts": []
      },
      {
        "content": "when {\n\texpression '${1:expression}'\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whenexpression"
        ],
        "opts": []
      },
      {
        "content": "when {\n\ttag '${1:tag}'\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whentag"
        ],
        "opts": []
      },
      {
        "content": "when {\n\tnot '${1:not}'\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whennot"
        ],
        "opts": []
      },
      {
        "content": "when {\n\tallOf '${1:allOf}'\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whenallOf"
        ],
        "opts": []
      },
      {
        "content": "when {\n\tanyOf '${1:anyOf}'\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whenanyOf"
        ],
        "opts": []
      }
    ],
    "jest": [
      {
        "content": "afterAll(() => {\n\t$0\n});",
        "doc": "afterAll function is called once after all specs",
        "grammar": "lsp",
        "label": "jest-afterall",
        "matches": [
          "aa",
          "jest afterall"
        ],
        "opts": []
      },
      {
        "content": "afterEach(() => {\n\t$0\n});",
        "doc": "afterEach function is called once after each spec",
        "grammar": "lsp",
        "label": "jest-aftereach",
        "matches": [
          "ae",
          "jest aftereach"
        ],
        "opts": []
      },
      {
        "content": "beforeAll(() => {\n\t$0\n});",
        "doc": "beforeAll function is called once before all specs",
        "grammar": "lsp",
        "label": "jest-beforeall",
        "matches": [
          "ba",
          "jest beforeall"
        ],
        "opts": []
      },
      {
        "content": "beforeEach(() => {\n\t$0\n});",
        "doc": "beforeEach function is called once before each spec",
        "grammar": "lsp",
        "label": "jest-beforeeach",
        "matches": [
          "be",
          "jest beforeeach"
        ],
        "opts": []
      },
      {
        "content": "describe('${1:Name of the group}', () => {\n\t$0\n});",
        "doc": "creates a describe block",
        "grammar": "lsp",
        "label": "jest-describe",
        "matches": [
          "jest describe",
          "desc"
        ],
        "opts": []
      },
      {
        "content": "describe.each([${1:[1, 2], [2, 4]}])(\n\t'${2:double(%d)}',\n\t(${3:input, expected}) => {\n\t\ttest(`returns \\${expected}`, () => {\n\t\t\t${4:expect(double(input)).toBe(expected);}\n\t\t});\n\t}\n);",
        "doc": "creates a describe block with different test data sets",
        "grammar": "lsp",
        "label": "jest-describe-each",
        "matches": [
          "jest describe each",
          "desce"
        ],
        "opts": []
      },
      {
        "content": "describe.only('${1:Name of the group}', () => {\n\t$0\n});",
        "doc": "creates a describe block that runs only",
        "grammar": "lsp",
        "label": "jest-describe-only",
        "matches": [
          "desco",
          "jest describe only"
        ],
        "opts": []
      },
      {
        "content": "describe.skip('${1:Name of the group}', () => {\n\t$0\n});",
        "doc": "creates a describe block that will be skipped",
        "grammar": "lsp",
        "label": "jest-describe-skip",
        "matches": [
          "jest describe skip",
          "descs"
        ],
        "opts": []
      },
      {
        "content": "expect($0)",
        "doc": "expect actual value",
        "grammar": "lsp",
        "label": "jest-expect",
        "matches": [
          "exp",
          "jest expect"
        ],
        "opts": []
      },
      {
        "content": "expect.assertions($0);",
        "doc": "expects the test to make the indicated number of assertions (useful for async)",
        "grammar": "lsp",
        "label": "jest-expect-assertions",
        "matches": [
          "expas",
          "jest expect assertions"
        ],
        "opts": []
      },
      {
        "content": "expect.hasAssertions();$0",
        "doc": "expects the test to make at least one assertion (useful for async)",
        "grammar": "lsp",
        "label": "jest-expect-hasassertions",
        "matches": [
          "expha",
          "jest expect hasassertions"
        ],
        "opts": []
      },
      {
        "content": "expect($1).rejects$0",
        "doc": "expect promise rejects to",
        "grammar": "lsp",
        "label": "jest-expect-rejects",
        "matches": [
          "jest expect rejects",
          "exprj"
        ],
        "opts": []
      },
      {
        "content": "expect($1).resolves$0",
        "doc": "expect promise resolves to",
        "grammar": "lsp",
        "label": "jest-expect-resolves",
        "matches": [
          "expr",
          "jest expect resolves"
        ],
        "opts": []
      },
      {
        "content": "it('${1:should }', () => {\n\t$0\n});",
        "doc": "creates an it block",
        "grammar": "lsp",
        "label": "jest-it",
        "matches": [
          "jest it",
          "it"
        ],
        "opts": []
      },
      {
        "content": "it.each([${1:[1, 2], [2, 4]}])(\n\t'${2:double(%d)}',\n\t(${3:input, expected}) => {\n\t\t${0:expect(double(input)).toBe(expected);}\n\t}\n);",
        "doc": "creates an it block with different test data sets",
        "grammar": "lsp",
        "label": "jest-it-each",
        "matches": [
          "ite",
          "jest it each"
        ],
        "opts": []
      },
      {
        "content": "it.only('${1:should }', () => {\n\t$0\n});",
        "doc": "creates an it block that runs only",
        "grammar": "lsp",
        "label": "jest-it-only",
        "matches": [
          "ito",
          "jest it only"
        ],
        "opts": []
      },
      {
        "content": "it.skip('${1:should }', () => {\n\t$0\n});",
        "doc": "creates an it block that will be skipped",
        "grammar": "lsp",
        "label": "jest-it-skip",
        "matches": [
          "its",
          "jest it skip"
        ],
        "opts": []
      },
      {
        "content": "it.todo('${1:should }');",
        "doc": "creates a test placeholder",
        "grammar": "lsp",
        "label": "jest-it-todo",
        "matches": [
          "itt",
          "jest it todo"
        ],
        "opts": []
      },
      {
        "content": "it('${1:should }', async () => {\n\t$0\n});",
        "doc": "creates an it block with async callback function",
        "grammar": "lsp",
        "label": "jest-it-async",
        "matches": [
          "ita",
          "jest it async"
        ],
        "opts": []
      },
      {
        "content": "jest.fn($0)",
        "doc": "creates jest.fn()",
        "grammar": "lsp",
        "label": "jest-jest-fn",
        "matches": [
          "jest fn",
          "jfn"
        ],
        "opts": []
      },
      {
        "content": "describe('${1:Name of the group}', () => {\n\n\tlet ${2:cut};\n\n\tbeforeEach(() => {\n\t\t$2 = $3;\n\t});\n\n\ttest('${1:should }', () => {\n\t\texpect($2).toBe($0);\n\t});\n\n});",
        "doc": "creates a template to test a class under test",
        "grammar": "lsp",
        "label": "jest-template-cut",
        "matches": [
          "jest template cut",
          "cut"
        ],
        "opts": []
      },
      {
        "content": "test('${1:should }', () => {\n\t$0\n});",
        "doc": "creates a test block",
        "grammar": "lsp",
        "label": "jest-test",
        "matches": [
          "test",
          "jest test"
        ],
        "opts": []
      },
      {
        "content": "test.each([${1:[1, 2], [2, 4]}])(\n\t'${2:double(%d)}',\n\t(${3:input, expected}) => {\n\t\t${0:expect(double(input)).toBe(expected);}\n\t}\n);",
        "doc": "creates an test block with different test data sets",
        "grammar": "lsp",
        "label": "jest-test-each",
        "matches": [
          "jest test each",
          "teste"
        ],
        "opts": []
      },
      {
        "content": "test.only('${1:should }', () => {\n\t$0\n});",
        "doc": "creates a test block  that runs only",
        "grammar": "lsp",
        "label": "jest-test-only",
        "matches": [
          "jest test only",
          "testo"
        ],
        "opts": []
      },
      {
        "content": "test.skip('${1:should }', () => {\n\t$0\n});",
        "doc": "creates a test block that will be skipped",
        "grammar": "lsp",
        "label": "jest-test-skip",
        "matches": [
          "tests",
          "jest test skip"
        ],
        "opts": []
      },
      {
        "content": "test.todo('${1:should }');",
        "doc": "creates a test placeholder",
        "grammar": "lsp",
        "label": "jest-test-todo",
        "matches": [
          "jest test todo",
          "testt"
        ],
        "opts": []
      },
      {
        "content": "test('${1:should }', async () => {\n\t$0\n});",
        "doc": "creates an test block with async callback function",
        "grammar": "lsp",
        "label": "jest-test-async",
        "matches": [
          "jest test async",
          "testa"
        ],
        "opts": []
      },
      {
        "content": "expect($1).toBe($0);",
        "doc": "expects the first argument to be equal with the second one",
        "grammar": "lsp",
        "label": "jest-tobe",
        "matches": [
          "jest expect tobe",
          "tb"
        ],
        "opts": []
      },
      {
        "content": "expect($1).toBeCloseTo(${2:number}, ${3:delta});$0",
        "doc": "expects the first argument to be close to the second one base on the delta",
        "grammar": "lsp",
        "label": "jest-tobecloseto",
        "matches": [
          "tbct",
          "jest expect tobecloseto"
        ],
        "opts": []
      },
      {
        "content": "expect($1).toBeDefined();$0",
        "doc": "expects the argument is defined",
        "grammar": "lsp",
        "label": "jest-tobedefined",
        "matches": [
          "tbd",
          "jest expect tobedefined"
        ],
        "opts": []
      },
      {
        "content": "expect($1).toBeFalsy();$0",
        "doc": "expects the argument is falsy",
        "grammar": "lsp",
        "label": "jest-tobefalsy",
        "matches": [
          "tbf",
          "jest expect tobefalsy"
        ],
        "opts": []
      },
      {
        "content": "expect($1).toBeGreaterThan($0);",
        "doc": "expects the argument is greater than or equal",
        "grammar": "lsp",
        "label": "jest-tobegreaterthan",
        "matches": [
          "jest expect tobegreaterthan",
          "tbgt"
        ],
        "opts": []
      },
      {
        "content": "expect($1).toBeGreaterThanOrEqual($0);",
        "doc": "expects the argument is greater than",
        "grammar": "lsp",
        "label": "jest-tobegreaterthanorequal",
        "matches": [
          "tbgte",
          "jest expect tobegreaterthanorequal"
        ],
        "opts": []
      },
      {
        "content": "expect($1).toBeInstanceOf($0);",
        "doc": "expects the argument is less than",
        "grammar": "lsp",
        "label": "jest-tobeinstanceof",
        "matches": [
          "tbi",
          "jest expect tobeinstanceof"
        ],
        "opts": []
      },
      {
        "content": "expect($1).toBeLessThan($0);",
        "doc": "expects the argument is less than",
        "grammar": "lsp",
        "label": "jest-tobelessthan",
        "matches": [
          "tblt",
          "jest expect tobelessthan"
        ],
        "opts": []
      },
      {
        "content": "expect($1).toBeLessThanOrEqual($0);",
        "doc": "expects the argument is less than or equal",
        "grammar": "lsp",
        "label": "jest-tobelessthanorequal",
        "matches": [
          "jest expect tobelessthanorequal",
          "tblte"
        ],
        "opts": []
      },
      {
        "content": "expect($1).toBeNull();$0",
        "doc": "expects the argument is null",
        "grammar": "lsp",
        "label": "jest-tobenull",
        "matches": [
          "tbn",
          "jest expect tobenull"
        ],
        "opts": []
      },
      {
        "content": "expect($1).toBeTruthy();$0",
        "doc": "expects the argument is truthy",
        "grammar": "lsp",
        "label": "jest-tobetruthy",
        "matches": [
          "tbt",
          "jest expect tobetruthy"
        ],
        "opts": []
      },
      {
        "content": "expect($1).toBeUndefined();$0",
        "doc": "expects the argument is undefined",
        "grammar": "lsp",
        "label": "jest-tobeundefined",
        "matches": [
          "jest expect tobeundefined",
          "tbu"
        ],
        "opts": []
      },
      {
        "content": "expect(${1:list}).toContain($0);",
        "doc": "expects the list contains the item (===)",
        "grammar": "lsp",
        "label": "jest-tocontain",
        "matches": [
          "jest expect tocontain",
          "tc"
        ],
        "opts": []
      },
      {
        "content": "expect(${1:list}).toContainEqual($0);",
        "doc": "expects the list contains the item (equals)",
        "grammar": "lsp",
        "label": "jest-tocontainequal",
        "matches": [
          "jest expect tocontainequal",
          "tce"
        ],
        "opts": []
      },
      {
        "content": "expect($1).toEqual($0);",
        "doc": "expects the first argument to be equal with the second one",
        "grammar": "lsp",
        "label": "jest-toequal",
        "matches": [
          "te",
          "jest expect toequal"
        ],
        "opts": []
      },
      {
        "content": "expect($1).toHaveBeenCalled();$0",
        "doc": "returns true if the spy was called",
        "grammar": "lsp",
        "label": "jest-tohavebeencalled",
        "matches": [
          "thbc",
          "jest expect tohavebeencalled"
        ],
        "opts": []
      },
      {
        "content": "expect($1).toHaveBeenCalledTimes($0);",
        "doc": "returns true if the spy has been called given times",
        "grammar": "lsp",
        "label": "jest-tohavebeencalledtimes",
        "matches": [
          "jest expect tohavebeencalledtimes",
          "thbct"
        ],
        "opts": []
      },
      {
        "content": "expect($1).toHaveBeenCalledWith($0);",
        "doc": "returns true if the spy has been called with",
        "grammar": "lsp",
        "label": "jest-tohavebeencalledwith",
        "matches": [
          "thbcw",
          "jest expect tohavebeencalledwith"
        ],
        "opts": []
      },
      {
        "content": "expect($1).toHaveBeenLastCalledWith($0);",
        "doc": "returns true if the spy has been last called with",
        "grammar": "lsp",
        "label": "jest-tohavebeenlastcalledwith",
        "matches": [
          "thblcw",
          "jest expect tohavebeenlastcalledwith"
        ],
        "opts": []
      },
      {
        "content": "expect($1).toHaveLength($0);",
        "doc": "expects the object to have length",
        "grammar": "lsp",
        "label": "jest-tohavelength",
        "matches": [
          "thl",
          "jest expect tohavelength"
        ],
        "opts": []
      },
      {
        "content": "expect($1).toHaveProperty(${2:keyPath}, ${3:value});$0",
        "doc": "returns true if the argument matches the second object",
        "grammar": "lsp",
        "label": "jest-tohaveproperty",
        "matches": [
          "jest expect tohaveproperty",
          "thp"
        ],
        "opts": []
      },
      {
        "content": "expect($1).toMatch($0);",
        "doc": "returns true if the argument matches the second value",
        "grammar": "lsp",
        "label": "jest-tomatch",
        "matches": [
          "tm",
          "jest expect tomatch"
        ],
        "opts": []
      },
      {
        "content": "expect($1).toMatchInlineSnapshot($0);",
        "doc": "returns true if the argument matches the most recent inline snapshot",
        "grammar": "lsp",
        "label": "jest-tomatchinlinesnapshot",
        "matches": [
          "tmis",
          "jest expect tomatchinlinesnapshot"
        ],
        "opts": []
      },
      {
        "content": "expect($1).toMatchObject($0);",
        "doc": "returns true if the argument matches the second object",
        "grammar": "lsp",
        "label": "jest-tomatchobject",
        "matches": [
          "jest expect tomatchobject",
          "tmo"
        ],
        "opts": []
      },
      {
        "content": "expect($1).toMatchSnapshot($0);",
        "doc": "returns true if the argument matches the most recent snapshot",
        "grammar": "lsp",
        "label": "jest-tomatchsnapshot",
        "matches": [
          "tms",
          "jest expect tomatchsnapshot"
        ],
        "opts": []
      },
      {
        "content": "expect($1).toStrictEqual($0);",
        "doc": "expects the first argument to be strictly equal with the second one",
        "grammar": "lsp",
        "label": "jest-tostrictequal",
        "matches": [
          "tse",
          "jest expect tostrictequal"
        ],
        "opts": []
      },
      {
        "content": "expect(() => {\n\t$0\n}).toThrow($1);",
        "doc": "expects that the method will throw an error",
        "grammar": "lsp",
        "label": "jest-tothrow",
        "matches": [
          "jest expect tothrow",
          "tt"
        ],
        "opts": []
      },
      {
        "content": "expect(() => {\n\t$0\n}).toThrowError($1);",
        "doc": "expects that the method will throw an error",
        "grammar": "lsp",
        "label": "jest-tothrowerror",
        "matches": [
          "tte",
          "jest expect tothrowerror"
        ],
        "opts": []
      },
      {
        "content": "expect(() => {\n\t$0\n}).toThrowErrorMatchingInlineSnapshot();",
        "doc": "expects that the method will throw an error matching the inline snapshot",
        "grammar": "lsp",
        "label": "jest-tothrowerrormatchinginlinesnapshot",
        "matches": [
          "ttemis",
          "jest expect tothrowerrormatchinginlinesnapshot"
        ],
        "opts": []
      },
      {
        "content": "expect(() => {\n\t$0\n}).toThrowErrorMatchingSnapshot();",
        "doc": "expects that the method will throw an error mathing the snapshpot",
        "grammar": "lsp",
        "label": "jest-tothrowerrormatchingsnapshot",
        "matches": [
          "ttems",
          "jest expect tothrowerrormatchingsnapshot"
        ],
        "opts": []
      }
    ],
    "jinja": [
      {
        "content": "{% ${1} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "%"
        ],
        "opts": []
      },
      {
        "content": "{% ${1:tag_name} %}\n${0}\n{% end$1 %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "%%"
        ],
        "opts": []
      },
      {
        "content": "{{ ${1} }}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "{"
        ],
        "opts": []
      },
      {
        "content": "{% autoescape ${1:off} %}\n\t${0}\n{% endautoescape %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "autoescape"
        ],
        "opts": []
      },
      {
        "content": "{% block ${1} %}\n\t${0}\n{% endblock %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "block"
        ],
        "opts": []
      },
      {
        "content": "{# ${0:comment} #}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#"
        ],
        "opts": []
      },
      {
        "content": "{% comment %}\n\t${0}\n{% endcomment %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "comment"
        ],
        "opts": []
      },
      {
        "content": "{% cycle ${1:val1} ${2:val2} ${3:as ${4}} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cycle"
        ],
        "opts": []
      },
      {
        "content": "{% debug %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "debug"
        ],
        "opts": []
      },
      {
        "content": "{% extends \"${0:base.html}\" %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "extends"
        ],
        "opts": []
      },
      {
        "content": "{% filter ${1} %}\n\t${0}\n{% endfilter %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "filter"
        ],
        "opts": []
      },
      {
        "content": "{% firstof ${1} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "firstof"
        ],
        "opts": []
      },
      {
        "content": "{% for ${1} in ${2} %}\n\t${0}\n{% endfor %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "{% empty %}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "empty"
        ],
        "opts": []
      },
      {
        "content": "{% if ${1} %}\n\t${0}\n{% endif %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "{% else %}\n\t${1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "el"
        ],
        "opts": []
      },
      {
        "content": "{% elif ${1} %}\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eif"
        ],
        "opts": []
      },
      {
        "content": "{% ifchanged %}${1}{% endifchanged %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifchanged"
        ],
        "opts": []
      },
      {
        "content": "{% ifequal ${1} ${2} %}\n\t${0}\n{% endifequal %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifequal"
        ],
        "opts": []
      },
      {
        "content": "{% ifnotequal ${1} ${2} %}\n\t${0}\n{% endifnotequal %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifnotequal"
        ],
        "opts": []
      },
      {
        "content": "{% include \"${0}\" %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "include"
        ],
        "opts": []
      },
      {
        "content": "{% load ${0} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "load"
        ],
        "opts": []
      },
      {
        "content": "{% now \"${0:jS F Y H:i}\" %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "now"
        ],
        "opts": []
      },
      {
        "content": "{% regroup ${1} by ${2} as ${0} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "regroup"
        ],
        "opts": []
      },
      {
        "content": "{% spaceless %}${0}{% endspaceless %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "spaceless"
        ],
        "opts": []
      },
      {
        "content": "{% ssi ${0} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ssi"
        ],
        "opts": []
      },
      {
        "content": "{% trans %}${0}{% endtrans %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "trans"
        ],
        "opts": []
      },
      {
        "content": "{% url ${1} as ${0} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "url"
        ],
        "opts": []
      },
      {
        "content": "{% widthratio ${1:this_value} ${2:max_value} ${0:100} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "widthratio"
        ],
        "opts": []
      },
      {
        "content": "{% with ${1} as ${2} %}\n\t${0}\n{% endwith %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "with"
        ],
        "opts": []
      },
      {
        "content": "add:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "add"
        ],
        "opts": []
      },
      {
        "content": "center:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "center"
        ],
        "opts": []
      },
      {
        "content": "cut:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cut"
        ],
        "opts": []
      },
      {
        "content": "date:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "date"
        ],
        "opts": []
      },
      {
        "content": "default:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "default"
        ],
        "opts": []
      },
      {
        "content": "default_if_none:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defaultifnone"
        ],
        "opts": []
      },
      {
        "content": "dictsort:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dictsort"
        ],
        "opts": []
      },
      {
        "content": "dictsortreversed:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dictsortrev"
        ],
        "opts": []
      },
      {
        "content": "divisibleby:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "divisibleby"
        ],
        "opts": []
      },
      {
        "content": "floatformat:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "floatformat"
        ],
        "opts": []
      },
      {
        "content": "get_digit:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "getdigit"
        ],
        "opts": []
      },
      {
        "content": "join:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "join"
        ],
        "opts": []
      },
      {
        "content": "length_is:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lengthis"
        ],
        "opts": []
      },
      {
        "content": "pluralize:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pluralize"
        ],
        "opts": []
      },
      {
        "content": "removetags:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "removetags"
        ],
        "opts": []
      },
      {
        "content": "slice:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "slice"
        ],
        "opts": []
      },
      {
        "content": "stringformat:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "stringformat"
        ],
        "opts": []
      },
      {
        "content": "time:\"${0}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "time"
        ],
        "opts": []
      },
      {
        "content": "truncatewords:${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "truncatewords"
        ],
        "opts": []
      },
      {
        "content": "truncatewords_html:${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "truncatewordshtml"
        ],
        "opts": []
      },
      {
        "content": "urlizetrunc:${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "urlizetrunc"
        ],
        "opts": []
      },
      {
        "content": "wordwrap:${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wordwrap"
        ],
        "opts": []
      }
    ],
    "jinja2": [
      {
        "content": "{% block ${1:name} %}\n\t\t$2\n{% endblock $1 %}",
        "doc": null,
        "grammar": "snu",
        "label": "block",
        "matches": [
          "block"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "{{ $1 }}",
        "doc": null,
        "grammar": "snu",
        "label": "variable",
        "matches": [
          "{{"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "{# $1 #}",
        "doc": null,
        "grammar": "snu",
        "label": "comment",
        "matches": [
          "{#"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "{# $1 #}",
        "doc": null,
        "grammar": "snu",
        "label": "comment",
        "matches": [
          "#"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "{% raw %}\n\t\t$1\n{% endraw %}",
        "doc": null,
        "grammar": "snu",
        "label": "escaped block",
        "matches": [
          "raw"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "{% extends \"${1:template}\" %}",
        "doc": null,
        "grammar": "snu",
        "label": "extends",
        "matches": [
          "extends"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "{% include \"${1:template}\" %}",
        "doc": null,
        "grammar": "snu",
        "label": "include",
        "matches": [
          "include"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "{% import \"${1:template}\" %}",
        "doc": null,
        "grammar": "snu",
        "label": "import",
        "matches": [
          "import"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "{% from \"${1:template}\" import ${2:name}${3: as ${4:$2}} %}",
        "doc": null,
        "grammar": "snu",
        "label": "from/import/as",
        "matches": [
          "from"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "{% filter ${1:filter} %}\n\t$2\n{% endfilter %}",
        "doc": null,
        "grammar": "snu",
        "label": "filter",
        "matches": [
          "filter"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "{% for ${1:item} in ${2:sequence} %}\n\t$3\n{% endfor %}",
        "doc": null,
        "grammar": "snu",
        "label": "for",
        "matches": [
          "for"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "{% for ${1:item} in ${2:sequence} %}\n\t$3\n{% else %}\n\t$4\n{% endfor %}",
        "doc": null,
        "grammar": "snu",
        "label": "for/else",
        "matches": [
          "for"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "{% if ${1:expr} %}\n\t$2\n{% endif %}",
        "doc": null,
        "grammar": "snu",
        "label": "if",
        "matches": [
          "if"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "{% if ${1:expr} %}\n\t$2\n{% else %}\n\t$3\n{% endif %}",
        "doc": null,
        "grammar": "snu",
        "label": "if/else",
        "matches": [
          "if"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "{% if ${1:expr} %}\n\t$2\n{% elif %}\n\t$3\n{% else %}\n\t$4\n{% endif %}",
        "doc": null,
        "grammar": "snu",
        "label": "if/elif/else",
        "matches": [
          "if"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "{% macro ${1:name}(${2:args}) %}\n\t$3\n{% endmacro %}",
        "doc": null,
        "grammar": "snu",
        "label": "macro",
        "matches": [
          "macro"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "{% call ${1:name}(${2:args}) %}\n\t$3\n{% endcall %}",
        "doc": null,
        "grammar": "snu",
        "label": "call",
        "matches": [
          "call"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "{% set ${1:name} = ${2:'value'} %}",
        "doc": null,
        "grammar": "snu",
        "label": "set",
        "matches": [
          "set"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "{% trans %}\n\t$1\n{% endtrans %}",
        "doc": null,
        "grammar": "snu",
        "label": "translation",
        "matches": [
          "trans"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "{% with %}\n\t$1\n{% endwith %}",
        "doc": null,
        "grammar": "snu",
        "label": "with",
        "matches": [
          "with"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "{% autoescape ${1:true} %}\n\t$2\n{% endautoescape %}",
        "doc": null,
        "grammar": "snu",
        "label": "autoescape",
        "matches": [
          "autoescape"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "batch(linecount=$1, fill_with=${2:None})",
        "doc": null,
        "grammar": "snu",
        "label": "batch items",
        "matches": [
          "batch"
        ],
        "opts": [
          "w"
        ]
      },
      {
        "content": "dictsort(case_sensitive=${1:False}, by=${2:'key'})",
        "doc": null,
        "grammar": "snu",
        "label": "sort and yield (key, value) pairs",
        "matches": [
          "dictsort"
        ],
        "opts": [
          "w"
        ]
      },
      {
        "content": "round(precision=${1:0}, method=${2:'common|ceil|floor'})",
        "doc": null,
        "grammar": "snu",
        "label": "round number",
        "matches": [
          "round"
        ],
        "opts": [
          "w"
        ]
      },
      {
        "content": "urlize(trim_url_limit=${1:None}, nofollow=${2:False})",
        "doc": null,
        "grammar": "snu",
        "label": "convert plain-text url to <a/>",
        "matches": [
          "urlize"
        ],
        "opts": [
          "w"
        ]
      },
      {
        "content": "wordwrap(width=${1:79}, break_long_words=${2:True})",
        "doc": null,
        "grammar": "snu",
        "label": "wordwrap",
        "matches": [
          "wordwrap"
        ],
        "opts": [
          "w"
        ]
      },
      {
        "content": "truncate(lenght=${1:79}, killwords=${2:False}, end=${3:'...''})",
        "doc": null,
        "grammar": "snu",
        "label": "truncate",
        "matches": [
          "truncate"
        ],
        "opts": [
          "w"
        ]
      },
      {
        "content": "sum(attribute=${1:None}, start=${2:0})",
        "doc": null,
        "grammar": "snu",
        "label": "sum of sequence of numbers + start",
        "matches": [
          "sum"
        ],
        "opts": [
          "w"
        ]
      },
      {
        "content": "sort(reverse=${1:False}, case_sensitive=${2:False}, attribute=${3:None})",
        "doc": null,
        "grammar": "snu",
        "label": "sort an iterable",
        "matches": [
          "sort"
        ],
        "opts": [
          "w"
        ]
      },
      {
        "content": "indent(width=${1:4}, indentfirst=${2:False})",
        "doc": null,
        "grammar": "snu",
        "label": "indent",
        "matches": [
          "indent"
        ],
        "opts": [
          "w"
        ]
      }
    ],
    "jquery_coffee": [
      {
        "content": "${1:obj}.add('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "add"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.addClass('${2:class name}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "addClass"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.after('${2:Some text <b>and bold!</b>}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "after"
        ],
        "opts": []
      },
      {
        "content": "$.ajax\n  url: \"${1:mydomain.com/url}\"\n  type: \"${2:POST}\"\n  dataType: \"${3:xml/html/script/json}\"\n  data: ${4:data}\n  complete: (jqXHR, textStatus) ->\n\t${5:// callback}\n  success: (data, textStatus, jqXHR) ->\n\t${6:// success callback}\n  error: (jqXHR, textStatus, errorThrown) ->\n\t${0:// error callback}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ajax"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.ajaxComplete (${1:e}, xhr, settings) ->\n\t${0:// callback}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ajaxcomplete"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.ajaxError (${1:e}, xhr, settings, thrownError) ->\n\t${2:// error callback}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ajaxerror"
        ],
        "opts": []
      },
      {
        "content": "$.get '${1:mydomain.com/url}',\n\t${2:{ param1: value1 },}\n\t(data, textStatus, jqXHR) ->\n\t\t${0:// success callback}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ajaxget"
        ],
        "opts": []
      },
      {
        "content": "$.post '${1:mydomain.com/url}',\n\t${2:{ param1: value1 },}\n\t(data, textStatus, jqXHR) ->\n\t\t${0:// success callback}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ajaxpost"
        ],
        "opts": []
      },
      {
        "content": "$.ajaxPrefilter (${1:options}, ${2:originalOptions}, jqXHR) ->\n\t${0: // Modify options, control originalOptions, store jqXHR, etc}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ajaxprefilter"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.ajaxSend (${1:request, settings}) ->\n\t${2:// error callback}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ajaxsend"
        ],
        "opts": []
      },
      {
        "content": "$.ajaxSetup({\n\turl: \"${1:mydomain.com/url}\",\n\ttype: \"${2:POST}\",\n\tdataType: \"${3:xml/html/script/json}\",\n\tdata: $.param( $(\"${4:Element or Expression}\") ),\n\tcomplete: (jqXHR, textStatus) ->\n\t\t${5:// callback}\n\t,\n\tsuccess: (data, textStatus, jqXHR) ->\n\t\t${6:// success callback}\n\t,\n\terror: (jqXHR, textStatus, errorThrown) ->\n\t\t${0:// error callback}\n})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ajaxsetup"
        ],
        "opts": []
      },
      {
        "content": "$.ajaxStart ->\n\t${1:// handler for when an AJAX call is started and no other AJAX calls are in progress}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ajaxstart"
        ],
        "opts": []
      },
      {
        "content": "$.ajaxStop ->\n\t${1:// handler for when all AJAX calls have been completed}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ajaxstop"
        ],
        "opts": []
      },
      {
        "content": "$.ajaxSuccess (${1:e}, xhr, settings) ->\n\t${2:// handler for when any AJAX call is successfully completed}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ajaxsuccess"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.andSelf()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "andself"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.animate({${2:param1: value1, param2: value2}}, ${3:speed})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "animate"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.append('${2:Some text <b>and bold!</b>}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "append"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.appendTo('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "appendTo"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.attr('${2:attribute}', '${3:value}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "attr"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.attr({'${2:attr1}': '${3:value1}', '${4:attr2}': '${5:value2}'})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "attrm"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.before('${2:Some text <b>and bold!</b>}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "before"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.bind('${2:event name}', (${3:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bind"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.blur (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "blur"
        ],
        "opts": []
      },
      {
        "content": "$.Callbacks()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "C"
        ],
        "opts": []
      },
      {
        "content": "${1:callbacks}.add(${2:callbacks})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Cadd"
        ],
        "opts": []
      },
      {
        "content": "${1:callbacks}.disable()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Cdis"
        ],
        "opts": []
      },
      {
        "content": "${1:callbacks}.empty()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Cempty"
        ],
        "opts": []
      },
      {
        "content": "${1:callbacks}.fire(${2:args})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Cfire"
        ],
        "opts": []
      },
      {
        "content": "${1:callbacks}.fired()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Cfired"
        ],
        "opts": []
      },
      {
        "content": "${1:callbacks}.fireWith(${2:this}, ${3:args})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Cfirew"
        ],
        "opts": []
      },
      {
        "content": "${1:callbacks}.has(${2:callback})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Chas"
        ],
        "opts": []
      },
      {
        "content": "${1:callbacks}.lock()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Clock"
        ],
        "opts": []
      },
      {
        "content": "${1:callbacks}.locked()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Clocked"
        ],
        "opts": []
      },
      {
        "content": "${1:callbacks}.remove(${2:callbacks})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Crem"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.change (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "change"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.children('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "children"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.clearQueue(${2:'queue name'})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "clearq"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.click (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "click"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.clone()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "clone"
        ],
        "opts": []
      },
      {
        "content": "$.contains(${1:container}, ${0:contents})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "contains"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.css('${2:attribute}', '${3:value}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "css"
        ],
        "opts": []
      },
      {
        "content": "$.cssHooks['${1:CSS prop}'] = {\n\tget: (elem, computed, extra) ->\n\t\t${2: // handle getting the CSS property}\n\tset: (elem, value) ->\n\t\t${0: // handle setting the CSS value}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "csshooks"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.css({${2:attribute1}: '${3:value1}', ${4:attribute2}: '${5:value2}'})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cssm"
        ],
        "opts": []
      },
      {
        "content": "$.Deferred()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "D"
        ],
        "opts": []
      },
      {
        "content": "${1:deferred}.always(${2:callbacks})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Dalways"
        ],
        "opts": []
      },
      {
        "content": "${1:deferred}.done(${2:callbacks})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Ddone"
        ],
        "opts": []
      },
      {
        "content": "${1:deferred}.fail(${2:callbacks})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Dfail"
        ],
        "opts": []
      },
      {
        "content": "${1:deferred}.isRejected()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Disrej"
        ],
        "opts": []
      },
      {
        "content": "${1:deferred}.isResolved()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Disres"
        ],
        "opts": []
      },
      {
        "content": "${1:deferred}.notify(${2:args})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Dnotify"
        ],
        "opts": []
      },
      {
        "content": "${1:deferred}.notifyWith(${2:this}, ${3:args})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Dnotifyw"
        ],
        "opts": []
      },
      {
        "content": "${1:deferred}.then(${2:doneFilter}, ${3:failFilter}, ${4:progressFilter})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Dpipe"
        ],
        "opts": []
      },
      {
        "content": "${1:deferred}.progress(${2:callbacks})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Dprog"
        ],
        "opts": []
      },
      {
        "content": "${1:deferred}.promise(${2:target})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Dprom"
        ],
        "opts": []
      },
      {
        "content": "${1:deferred}.reject(${2:args})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Drej"
        ],
        "opts": []
      },
      {
        "content": "${1:deferred}.rejectWith(${2:this}, ${3:args})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Drejw"
        ],
        "opts": []
      },
      {
        "content": "${1:deferred}.resolve(${2:args})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Dres"
        ],
        "opts": []
      },
      {
        "content": "${1:deferred}.resolveWith(${2:this}, ${3:args})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Dresw"
        ],
        "opts": []
      },
      {
        "content": "${1:deferred}.state()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Dstate"
        ],
        "opts": []
      },
      {
        "content": "${1:deferred}.then(${2:doneCallbacks}, ${3:failCallbacks}, ${4:progressCallbacks})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Dthen"
        ],
        "opts": []
      },
      {
        "content": "$.when(${1:deferreds})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Dwhen"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.data(${2:obj})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "data"
        ],
        "opts": []
      },
      {
        "content": "$.data('${1:selector expression}', '${2:key}'${3:, 'value'})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dataa"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.dblclick (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dblclick"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.delay('${2:slow/400/fast}'${3:, 'queue name'})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "delay"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.delegate '${2:selector expression}', '${3:event name}', (${4:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dele"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.dequeue(${2:'queue name'})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "deq"
        ],
        "opts": []
      },
      {
        "content": "$.dequeue('${1:selector expression}'${2:, 'queue name'})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "deqq"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.detach('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "detach"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.die(${2:event}, ${3:handler})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "die"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.each (index) ->\n\t${0:this.innerHTML = this + \" is the element, \" + index + \" is the position\"}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "each"
        ],
        "opts": []
      },
      {
        "content": "$('<${1}/>'${2:, {}})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "el"
        ],
        "opts": []
      },
      {
        "content": "$.trim('${1:string}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eltrim"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.empty()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "empty"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.end()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "end"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.eq(${2:element index})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eq"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.error (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "error"
        ],
        "opts": []
      },
      {
        "content": "{\n\t:f${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eventsmap"
        ],
        "opts": []
      },
      {
        "content": "$.extend(${1:true, }${2:target}, ${3:obj})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "extend"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.fadeIn('${2:slow/400/fast}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fadein"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.fadeIn 'slow/400/fast', ->\n\t${0:// callback}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fadeinc"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.fadeOut('${2:slow/400/fast}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fadeout"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.fadeOut 'slow/400/fast', ->\n\t${0:// callback}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fadeoutc"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.fadeTo('${2:slow/400/fast}', ${3:0.5})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fadeto"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.fadeTo 'slow/400/fast', ${2:0.5}, ->\n\t${0:// callback}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fadetoc"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.filter('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "filter"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.filter (${2:index}) ->\n\t${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "filtert"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.find('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "find"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.focus (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "focus"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.focusIn (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "focusin"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.focusOut (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "focusout"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.get(${2:element index})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "get"
        ],
        "opts": []
      },
      {
        "content": "$.getJSON '${1:mydomain.com/url}',\n\t${2:{ param1: value1 },}\n\t(data, textStatus, jqXHR) ->\n\t\t${0:// success callback}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "getjson"
        ],
        "opts": []
      },
      {
        "content": "$.getScript '${1:mydomain.com/url}', (script, textStatus, jqXHR) ->\n\t${0:// callback}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "getscript"
        ],
        "opts": []
      },
      {
        "content": "$.grep(${1:array}, (item, index) >\n\t${2}\n${0:, true})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "grep"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.hasClass('${2:className}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "hasc"
        ],
        "opts": []
      },
      {
        "content": "$.hasData('${0:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "hasd"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.height(${2:integer})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "height"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.hide('${2:slow/400/fast}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "hide"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.hide '${2:slow/400/fast}', ->\n\t${0:// callback}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "hidec"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.hover (${2:e}) ->\n\t${3:// event handler}\n, ($2) ->\n\t${4:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "hover"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.html('${2:Some text <b>and bold!</b>}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "html"
        ],
        "opts": []
      },
      {
        "content": "$.inArray(${1:value}, ${0:array})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "inarr"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.insertAfter('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "insa"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.insertBefore('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "insb"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.is('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "is"
        ],
        "opts": []
      },
      {
        "content": "$.isArray(${1:obj})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isarr"
        ],
        "opts": []
      },
      {
        "content": "$.isEmptyObject(${1:obj})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isempty"
        ],
        "opts": []
      },
      {
        "content": "$.isFunction(${1:obj})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isfunc"
        ],
        "opts": []
      },
      {
        "content": "$.isNumeric(${1:value})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isnum"
        ],
        "opts": []
      },
      {
        "content": "$.isPlainObject(${1:obj})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isobj"
        ],
        "opts": []
      },
      {
        "content": "$.isWindow(${1:obj})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "iswin"
        ],
        "opts": []
      },
      {
        "content": "$.isXMLDoc(${1:node})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isxml"
        ],
        "opts": []
      },
      {
        "content": "$('${1:selector}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jj"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.keydown (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "kdown"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.keypress (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "kpress"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.keyup (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "kup"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.last('${1:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "last"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.live '${2:events}', (${3:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "live"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.load (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "load"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.load('${2:mydomain.com/url}',\n\t${2:{ param1: value1 },}\n\t(responseText, textStatus, xhr) ->\n\t\t${0:// success callback}\n})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "loadf"
        ],
        "opts": []
      },
      {
        "content": "$.makeArray(${0:obj})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "makearray"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.map (${2:index}, ${3:element}) ->\n\t${0:// callback}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "map"
        ],
        "opts": []
      },
      {
        "content": "$.map ${1:arrayOrObject}, (${2:value}, ${3:indexOrKey}) ->\n\t${0:// callback}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mapp"
        ],
        "opts": []
      },
      {
        "content": "$.merge(${1:target}, ${0:original})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "merge"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.mousedown (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mdown"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.mouseenter (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "menter"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.mouseleave (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mleave"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.mousemove (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mmove"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.mouseout (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mout"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.mouseover (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mover"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.mouseup (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mup"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.next('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "next"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.nextAll('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nexta"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.nextUntil('${2:selector expression}'${3:, 'filter expression'})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nextu"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.not('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "not"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.off('${2:events}', '${3:selector expression}'${4:, handler})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "off"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.offset()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "offset"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.offsetParent()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "offsetp"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.on '${2:events}', '${3:selector expression}', (${4:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "on"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.one '${2:event name}', (${3:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "one"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.outerHeight()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "outerh"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.outerWidth()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "outerw"
        ],
        "opts": []
      },
      {
        "content": "$.param(${1:obj})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "param"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.parent('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "parent"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.parents('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "parents"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.parentsUntil('${2:selector expression}'${3:, 'filter expression'})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "parentsu"
        ],
        "opts": []
      },
      {
        "content": "$.parseJSON(${1:data})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "parsejson"
        ],
        "opts": []
      },
      {
        "content": "$.parseXML(${1:data})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "parsexml"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.position()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pos"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.prepend('${2:Some text <b>and bold!</b>}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prepend"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.prependTo('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prependto"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.prev('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prev"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.prevAll('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "preva"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.prevUntil('${2:selector expression}'${3:, 'filter expression'})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prevu"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.promise(${2:'fx'}, ${3:target})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "promise"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.prop('${2:property name}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prop"
        ],
        "opts": []
      },
      {
        "content": "$.proxy(${1:function}, ${2:this})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "proxy"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.pushStack(${2:elements})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pushstack"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.queue(${2:name}${3:, newQueue})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "queue"
        ],
        "opts": []
      },
      {
        "content": "$.queue(${1:element}${2:, name}${3:, newQueue})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "queuee"
        ],
        "opts": []
      },
      {
        "content": "$(() ->\n\t${0}\n)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ready"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.remove()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rem"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.removeAttr('${2:attribute name}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rema"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.removeClass('${2:class name}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "remc"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.removeData('${2:key name}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "remd"
        ],
        "opts": []
      },
      {
        "content": "$.removeData(${1:element}${2:, 'key name}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "remdd"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.removeProp('${2:property name}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "remp"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.replaceAll(${2:target})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "repa"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.replaceWith(${2:content})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "repw"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.reset (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "reset"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.resize (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "resize"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.scroll (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "scroll"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.scrollLeft(${2:value})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "scrolll"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.scrollTop(${2:value})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "scrollt"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.slideDown('${2:slow/400/fast}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sdown"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.slideDown('${2:slow/400/fast}', ->\n\t${0:// callback}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sdownc"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.select (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "select"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.serialize()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "serialize"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.serializeArray()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "serializea"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.show('${2:slow/400/fast}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "show"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.show '${2:slow/400/fast}', ->\n\t${0:// callback}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "showc"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.siblings('${2:selector expression}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sib"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.size()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "size"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.slice(${2:start}${3:, end})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "slice"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.slideToggle('${2:slow/400/fast}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "stoggle"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.stop('${2:queue}', ${3:false}, ${4:false})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "stop"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.submit (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "submit"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.slideUp('${2:slow/400/fast}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sup"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.slideUp '${2:slow/400/fast}', ->\n\t${0:// callback}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "supc"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.text(${2:'some text'})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "text"
        ],
        "opts": []
      },
      {
        "content": "$(this)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "this"
        ],
        "opts": []
      },
      {
        "content": "${0:obj}.toArray()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "toarr"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.toggle  (${2:e}) ->\n\t${3:// event handler}\n, ($2) ->\n\t${4:// event handler}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tog"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.toggleClass('${2:class name}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "togclass"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.toggle('${2:slow/400/fast}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "togsh"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.trigger('${2:event name}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "trig"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.triggerHandler('${2:event name}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "trigh"
        ],
        "opts": []
      },
      {
        "content": "$.trim(${1:str})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "$trim"
        ],
        "opts": []
      },
      {
        "content": "$.type(${1:obj})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "$type"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.unbind('${2:event name}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "unbind"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.undelegate(${2:selector expression}, ${3:event}, ${4:handler})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "undele"
        ],
        "opts": []
      },
      {
        "content": "$.unique(${1:array})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "uniq"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.unload (${2:e}) ->\n\t${0:// event handler}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "unload"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.unwrap()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "unwrap"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.val('${2:text}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "val"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.width(${2:integer})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "width"
        ],
        "opts": []
      },
      {
        "content": "${1:obj}.wrap('${2:&ltdiv class=\"extra-wrapper\"&gt&lt/div&gt}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wrap"
        ],
        "opts": []
      }
    ],
    "json": [
      {
        "content": "\"${1:key}\": \"${0:value}\",",
        "doc": null,
        "grammar": "snu",
        "label": "String",
        "matches": [
          "s"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "\"${1:key}\": ${0:value},",
        "doc": null,
        "grammar": "snu",
        "label": "Number",
        "matches": [
          "n"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "[\n\t${VISUAL}$0\n],",
        "doc": null,
        "grammar": "snu",
        "label": "Array",
        "matches": [
          "a"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "\"${1:key}\": [\n\t${VISUAL}$0\n],",
        "doc": null,
        "grammar": "snu",
        "label": "Named array",
        "matches": [
          "na"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "{\n\t${VISUAL}$0\n},",
        "doc": null,
        "grammar": "snu",
        "label": "Object",
        "matches": [
          "o"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "\"${1:key}\": {\n\t${VISUAL}$0\n},",
        "doc": null,
        "grammar": "snu",
        "label": "Named object",
        "matches": [
          "no"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "\"${0:key}\": null,",
        "doc": null,
        "grammar": "snu",
        "label": "Null",
        "matches": [
          "null"
        ],
        "opts": [
          "b"
        ]
      }
    ],
    "jsonc": [
      {
        "content": "{\n\t\"name\": \"Launch Angular\",\n\t\"type\": \"${1:chrome}\",\n\t\"request\": \"launch\",\n\t\"preLaunchTask\": \"${2:npm: start}\",\n\t\"url\": \"http://localhost:${3:4200}/\",\n\t\"webRoot\": \"${4:\\${workspaceFolder\\}}\"\n}",
        "doc": null,
        "grammar": "lsp",
        "label": "Create launch config for Chrome",
        "matches": [
          "a-launch-chrome"
        ],
        "opts": []
      },
      {
        "content": "{\n\t\"name\": \"Launch Angular\",\n\t\"type\": \"${1:edge}\",\n\t\"version\": \"${2:dev}\",\n\t\"request\": \"launch\",\n\t\"preLaunchTask\": \"${3:npm: start}\",\n\t\"url\": \"http://localhost:${4:4200}/\",\n\t\"webRoot\": \"${5:\\${workspaceFolder\\}}\"\n}",
        "doc": null,
        "grammar": "lsp",
        "label": "Create launch config for Edge",
        "matches": [
          "a-launch-edge"
        ],
        "opts": []
      },
      {
        "content": "{\n\t\"type\": \"npm\",\n\t\"script\": \"${1:start}\",\n\t\"isBackground\": true,\n\t\"presentation\": {\n\t\t\"focus\": true,\n\t\t\"panel\": \"dedicated\"\n\t},\n\t\"group\": {\n\t\t\"kind\": \"build\",\n\t\t\"isDefault\": true\n\t},\n\t\"problemMatcher\": {\n\t\t\"owner\": \"typescript\",\n\t\t\"source\": \"ts\",\n\t\t\"applyTo\": \"closedDocuments\",\n\t\t\"fileLocation\": [\"relative\", \"\\${cwd\\}\"],\n\t\t\"pattern\": \"\\$tsc\",\n\t\t\"background\": {\n\t\t\t\"activeOnStart\": true,\n\t\t\t\"beginsPattern\": {\n\t\t\t\t\"regexp\": \"(.*?)\"\n\t\t\t},\n\t\t\t\"endsPattern\": {\n\t\t\t\t\"regexp\": \"Compiled |Failed to compile.\"\n\t\t\t}\n\t\t}\n\t}\n}",
        "doc": null,
        "grammar": "lsp",
        "label": "Create task to start Angular",
        "matches": [
          "a-task-start"
        ],
        "opts": []
      }
    ],
    "jsp": [
      {
        "content": "<%@page contentType=\"text/html\" pageEncoding=\"UTF-8\"%>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@page"
        ],
        "opts": []
      },
      {
        "content": "<%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %>\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/functions\" prefix=\"fn\" %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jstl"
        ],
        "opts": []
      },
      {
        "content": "<%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jstl:c"
        ],
        "opts": []
      },
      {
        "content": "<%@ taglib uri=\"http://java.sun.com/jsp/jstl/functions\" prefix=\"fn\" %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jstl:fn"
        ],
        "opts": []
      },
      {
        "content": "${pageContext.request.contextPath}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cpath"
        ],
        "opts": []
      },
      {
        "content": "<c:out value=\"${1}\" default=\"${0}\" />",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cout"
        ],
        "opts": []
      },
      {
        "content": "<c:set var=\"${1}\" value=\"${0}\" />",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cset"
        ],
        "opts": []
      },
      {
        "content": "<c:remove var=\"${1}\" scope=\"${0:page}\" />",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cremove"
        ],
        "opts": []
      },
      {
        "content": "<c:catch var=\"${0}\" />",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ccatch"
        ],
        "opts": []
      },
      {
        "content": "<c:if test=\"${${1}}\">\n\t${0}\n</c:if>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cif"
        ],
        "opts": []
      },
      {
        "content": "<c:choose>\n\t${0}\n</c:choose>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cchoose"
        ],
        "opts": []
      },
      {
        "content": "<c:when test=\"${${1}}\">\n\t${0}\n</c:when>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cwhen"
        ],
        "opts": []
      },
      {
        "content": "<c:otherwise>\n\t${0}\n</c:otherwise>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cother"
        ],
        "opts": []
      },
      {
        "content": "<c:forEach items=\"${${1}}\" var=\"${2}\" varStatus=\"${3}\">\n\t${0:<c:out value=\"$2\" />}\n</c:forEach>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cfore"
        ],
        "opts": []
      },
      {
        "content": "<c:set var=\"${1}\">${2:item1,item2,item3}</c:set>\n<c:forTokens var=\"${3}\" items=\"${$1}\" delims=\"${4:,}\">\n\t${0:<c:out value=\"$3\" />}\n</c:forTokens>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cfort"
        ],
        "opts": []
      },
      {
        "content": "<c:param name=\"${1}\" value=\"${0}\" />",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cparam"
        ],
        "opts": []
      },
      {
        "content": "<c:param name=\"${1}\" value=\"${2}\" />\ncparam+${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cparam+"
        ],
        "opts": []
      },
      {
        "content": "<c:import url=\"${1}\" />",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cimport"
        ],
        "opts": []
      },
      {
        "content": "<c:import url=\"${1}\">\n\t<c:param name=\"${2}\" value=\"${3}\" />\n\tcparam+${0}\n</c:import>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cimport+"
        ],
        "opts": []
      },
      {
        "content": "<c:url value=\"${1}\" var=\"${2}\" />\n<a href=\"${$2}\">${0}</a>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "curl"
        ],
        "opts": []
      },
      {
        "content": "<c:url value=\"${1}\" var=\"${2}\">\n\t<c:param name=\"${4}\" value=\"${5}\" />\n\tcparam+${0}\n</c:url>\n<a href=\"${$2}\">${3}</a>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "curl+"
        ],
        "opts": []
      },
      {
        "content": "<c:redirect url=\"${0}\" />",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "credirect"
        ],
        "opts": []
      },
      {
        "content": "${fn:contains(${1:string}, ${0:substr})}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "contains"
        ],
        "opts": []
      },
      {
        "content": "${fn:containsIgnoreCase(${1:string}, ${0:substr})}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "contains:i"
        ],
        "opts": []
      },
      {
        "content": "${fn:endsWith(${1:string}, ${0:suffix})}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "endswith"
        ],
        "opts": []
      },
      {
        "content": "${fn:escapeXml(${0:string})}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "escape"
        ],
        "opts": []
      },
      {
        "content": "${fn:indexOf(${1:string}, ${0:substr})}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "indexof"
        ],
        "opts": []
      },
      {
        "content": "${fn:join(${1:collection}, ${0:delims})}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "join"
        ],
        "opts": []
      },
      {
        "content": "${fn:length(${0:collection_or_string})}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "length"
        ],
        "opts": []
      },
      {
        "content": "${fn:replace(${1:string}, ${2:substr}, ${0:replace})}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "replace"
        ],
        "opts": []
      },
      {
        "content": "${fn:split(${1:string}, ${0:delims})}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "split"
        ],
        "opts": []
      },
      {
        "content": "${fn:startsWith(${1:string}, ${0:prefix})}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "startswith"
        ],
        "opts": []
      },
      {
        "content": "${fn:substring(${1:string}, ${2:begin}, ${0:end})}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "substr"
        ],
        "opts": []
      },
      {
        "content": "${fn:substringAfter(${1:string}, ${0:substr})}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "substr:a"
        ],
        "opts": []
      },
      {
        "content": "${fn:substringBefore(${1:string}, ${0:substr})}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "substr:b"
        ],
        "opts": []
      },
      {
        "content": "${fn:toLowerCase(${0:string})}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lc"
        ],
        "opts": []
      },
      {
        "content": "${fn:toUpperCase(${0:string})}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "uc"
        ],
        "opts": []
      },
      {
        "content": "${fn:trim(${0:string})}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "trim"
        ],
        "opts": []
      }
    ],
    "julia": [
      {
        "content": "#!/usr/bin/env julia",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#!"
        ],
        "opts": []
      },
      {
        "content": "function ${1}(${2})\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fun function definition"
        ],
        "opts": []
      },
      {
        "content": "return(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ret return"
        ],
        "opts": []
      },
      {
        "content": "print(\"${1}\")\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pr print"
        ],
        "opts": []
      },
      {
        "content": "println(\"${1}\")\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prl print line"
        ],
        "opts": []
      },
      {
        "content": "using ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "use load a package"
        ],
        "opts": []
      },
      {
        "content": "include(\"${1}\")\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "incl include source code"
        ],
        "opts": []
      },
      {
        "content": "for ${1} in ${2}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forc for loop iterating over iterable container"
        ],
        "opts": []
      },
      {
        "content": "for ${1} = ${2}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for standard for loop"
        ],
        "opts": []
      },
      {
        "content": "for ${1} = ${2}, ${3} = ${4}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fornest nested for loop"
        ],
        "opts": []
      },
      {
        "content": "while ${1} ${2:<=} ${3}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh while loop"
        ],
        "opts": []
      },
      {
        "content": "if ${1}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if if statement"
        ],
        "opts": []
      },
      {
        "content": "else\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "el else part of statement"
        ],
        "opts": []
      },
      {
        "content": "else if ${1}\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eif else if part of if statement"
        ],
        "opts": []
      },
      {
        "content": "if ${1}\n\t${2}\nelse\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife full if-else statement"
        ],
        "opts": []
      },
      {
        "content": "${1} ? ${2} : ${3:nothing}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tern ternary operator"
        ],
        "opts": []
      },
      {
        "content": "try\n\t${1:${VISUAL}}\ncatch ${2}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "try try catch"
        ],
        "opts": []
      },
      {
        "content": "finally\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fin finally statement"
        ],
        "opts": []
      },
      {
        "content": "throw(${1})\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "thr throw"
        ],
        "opts": []
      },
      {
        "content": "@info \"${1}\" ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@i"
        ],
        "opts": []
      },
      {
        "content": "@warn \"${1}\" ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@w"
        ],
        "opts": []
      },
      {
        "content": "@error \"${1}\" ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@e"
        ],
        "opts": []
      },
      {
        "content": "@debug \"${1}\" ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@d"
        ],
        "opts": []
      },
      {
        "content": "@testset \"${1}\" begin\n\t${2}\n\t@test ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@t @testset with @test"
        ],
        "opts": []
      },
      {
        "content": "@testset \"${1}\" begin\n\t${2}\n\t@test_throws ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@tt @testset with @test_throws"
        ],
        "opts": []
      },
      {
        "content": "function ${1}(${2})\n    ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "function ... end",
        "matches": [
          "function"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "macro ${1}(${2})\n    ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "macro ... end",
        "matches": [
          "macro"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "struct ${1}\n    ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "struct ... end",
        "matches": [
          "struct"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "module ${1}\n${0}\nend#module",
        "doc": "",
        "grammar": "snu",
        "label": "module ... end",
        "matches": [
          "module"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "let ${1}\n    ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "let ... end",
        "matches": [
          "let"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "quote\n    ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "quote ... end",
        "matches": [
          "quote"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "begin\n    ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "begin ... end",
        "matches": [
          "begin"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "for ${1}\n    ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "for ... end",
        "matches": [
          "for"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "if ${1}\n    ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "if ... end",
        "matches": [
          "if"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "try\n    ${1}\n${2:catch}\n    ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "try ... end",
        "matches": [
          "try"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "while ${1:true}\n    ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "while ... end",
        "matches": [
          "while"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "#' @description\n#'\n#' ${1:function description}\n#'\n#' ${2:@param ${3:name}::${4:Type} ${5:Description}}\n#'\n#' ${6:@returns ${7:name}::${8:Type} ${9:Description}}\n#'\n#' @examples\n#'\n#' ${10: function call examples}",
        "doc": null,
        "grammar": "snu",
        "label": "function documentation",
        "matches": [
          "docf"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "#' @description\n#'\n#' ${1:type description}\n#'\n#' ${2:@field ${3:name}::${4:Type} ${5:Description}}\n#'\n#' @examples\n#'\n#' ${10: constructor examples}",
        "doc": null,
        "grammar": "snu",
        "label": "type definition",
        "matches": [
          "doct"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "#' @param ${1:name}::${2:Type} ${0:Description}",
        "doc": null,
        "grammar": "snu",
        "label": "function parameter documentation",
        "matches": [
          "par"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "#' @field ${1:name}::${2:Type} ${0:Description}",
        "doc": null,
        "grammar": "snu",
        "label": "type field documentation",
        "matches": [
          "fld"
        ],
        "opts": [
          "b"
        ]
      }
    ],
    "kotlin": [
      {
        "content": "fun ${1:name}(${2}): ${3:String} {\n\t${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fun"
        ],
        "opts": []
      },
      {
        "content": "private fun ${1:name}(${2}): ${3:String} {\n\t${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pfun"
        ],
        "opts": []
      },
      {
        "content": "return ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ret"
        ],
        "opts": []
      },
      {
        "content": "when (${1:${VISUAL}}) {\n\t${2} -> ${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whe"
        ],
        "opts": []
      },
      {
        "content": "class ${1} {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cla"
        ],
        "opts": []
      },
      {
        "content": "companion object {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cobj"
        ],
        "opts": []
      },
      {
        "content": "object ${1} {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "obj"
        ],
        "opts": []
      },
      {
        "content": "if (${1}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "if (${1}) {\n\t${2:${VISUAL}}\n} else {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife"
        ],
        "opts": []
      }
    ],
    "kp19pp": [
      {
        "content": "<token_desc> token{\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "token_desc"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "<left>{\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "left"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "<grammar> grammar{\n\tE<${1}>\n\t\t: [${2}] ${3}\n\t\t;\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "grammar"
        ],
        "opts": [
          "head"
        ]
      }
    ],
    "laravel": [
      {
        "content": "/*!\n* \\class       $1\n*\n* \\author      ${3:`!v g:snips_author`}\n* \\date        `!v strftime('%d-%m-%y')`\n*/\nclass ${1:`!v expand('%:t:r')`} extends ${2:BaseController} {\n\tfunction __construct() {\n\t}\n\tpublic function index() {\n\t}\n\tpublic function create() {\n\t}\n\tpublic function store() {\n\t}\n\tpublic function show($id) {\n\t}\n\tpublic function edit($id) {\n\t}\n\tpublic function update($id) {\n\t}\n\tpublic function destroy($id) {\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "l_rsc"
        ],
        "opts": []
      },
      {
        "content": "/*!\n* \\namespace   $1\n* \\class       $2\n*\n* \\author      ${3:`!v g:snips_author`}\n* \\date        `!v strftime('%d-%m-%y')`\n*/\nnamespace ${1:Services};\nuse Illuminate\\Support\\ServiceProvider;\nclass ${2:`!v expand('%:t:r')`} extends ServiceProvider {\n\tpublic function register() {\n\t\t$this->app->bind('${4}Service', function ($app) {\n\t\t\treturn new ${5}(\n\t\t\t\t$app->make('Repositories\\\\${6}Interface')\n\t\t\t);\n\t\t});\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "l_ssp"
        ],
        "opts": []
      },
      {
        "content": "/*!\n* \\namespace   $2\n* \\class       $3\n*\n* \\author      ${4:`!v g:snips_author`}\n* \\date        `!v strftime('%d-%m-%y')`\n*/\nnamespace ${2:Repositories\\\\${1:}};\nuse Entities\\\\$1;\nuse $2\\\\$1Repository;\nuse Illuminate\\Support\\ServiceProvider;\nclass ${3:`!v expand('%:t:r')`} extends ServiceProvider {\n\t/*!\n\t* \\var     defer\n\t* \\brief   Defer service\n\t*/\n\tprotected $defer = ${5:true};\n\tpublic function register() {\n\t\t\t$this->app->bind('$2\\\\$1Interface', function($app) {\n\t\t\t\t\treturn new $1Repository(new $1());\n\t\t\t});\n\t}\n\t/*!\n\t* \\brief   If $defer == true need this fn\n\t*/ \n\tpublic function provides() {\n\t\t\treturn ['$2\\\\$1Interface'];\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "l_rsp"
        ],
        "opts": []
      },
      {
        "content": "/*!\n* \\namespace   $1\n* \\class       $2\n*\n* \\author      ${3:`!v g:snips_author`}\n* \\date        `!v strftime('%d-%m-%y')`\n*/\nnamespace ${1:Entities};\nclass ${2:`!v expand('%:t:r')`} extends \\Eloquent {\n\tprotected $table   = '${4:`!p snip.rv = t[2].lower()`}';\n\tpublic $timestamps = ${5:false};\n\tprotected $hidden  = array(${6});\n\tprotected $guarded = array(${7:'id'});\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "l_md"
        ],
        "opts": []
      },
      {
        "content": "/*!\n* \\namespace   $1\n* \\class       $2\n* \\implements  $3\n*\n* \\author      ${4:`!v g:snips_author`}\n* \\date        `!v strftime('%d-%m-%y')`\n*/\nnamespace ${1:Repositories};\nuse Illuminate\\Database\\Eloquent\\Model;\nabstract class ${2:`!v expand('%:t:r')`} implements ${3:BaseRepositoryInterface} {\n\tprotected $model;\n\t/*!\n\t* \\fn      __construct\n\t*\n\t* \\brief   Take the model\n\t*/\n\tpublic function __construct(Model $model) {\n\t\t\t$this->model = $model;\n\t}\n\t/*!\n\t* \\fn      all\n\t*\n\t* \\return  Illuminate\\Database\\Eloquent\\Collection\n\t*/\n\tpublic function all($columns = array('*')) {\n\t\t\treturn $this->model->all()->toArray();\n\t}\n\t/*!\n\t* \\fn      create\n\t*\n\t* \\return  Illuminate\\Database\\Eloquent\\Model\n\t*/\n\tpublic function create(array $attributes) {\n\t\t\treturn $this->model->create($attributes);\n\t}\n\t/*!\n\t* \\fn      destroy\n\t*\n\t* \\return  int\n\t*/\n\tpublic function destroy($ids) {\n\t\t\treturn $this->model->destroy($ids);\n\t}\n\t/*!\n\t* \\fn      find\n\t*\n\t* \\return  mixed\n\t*/\n\tpublic function find($id, $columns = array('*')) {\n\t\treturn $this->model->find($id, $columns);\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "l_ar"
        ],
        "opts": []
      },
      {
        "content": "/*!\n* \\namespace   $1\n* \\class       $3\n* \\implements  $4\n*\n* \\author      ${5:`!v g:snips_author`}\n* \\date        `!v strftime('%d-%m-%y')`\n*/\nnamespace ${1:Repositories\\\\${2}};\nclass ${3:`!v expand('%:t:r')`} extends \\\\${6} implements ${4:$3RepositoryInterface} {\n\t${7}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "l_r"
        ],
        "opts": []
      },
      {
        "content": "/*!\n* \\namespace $1\n* \\class     $2\n*\n* \\author    ${6:`!v g:snips_author`}\n* \\date      `!v strftime('%d-%m-%y')`\n*/\nnamespace Services\\\\${1};\nuse ${3:Repositories\\\\${4:Interface}};\nclass ${2:`!v expand('%:t:r')`} {\n\tprotected $${5:repo};\n\t/*!\n\t* \\fn      __construct\n\t*/\n\tpublic function __construct($4 $repo) {\n\t\t$this->$5 = $repo;\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "l_s"
        ],
        "opts": []
      },
      {
        "content": "/*!\n* \\namespace   $1\n* \\class       $2\n*\n* \\author      ${5:`!v g:snips_author`}\n* \\date        `!v strftime('%d-%m-%y')`\n*/\nnamespace ${1:Services};\nuse \\Illuminate\\Support\\Facades\\Facade;\nclass ${2:`!v expand('%:t:r')`} extends Facade {\n\t/*!\n\t* \\fn          getFacadeAccessor\n\t*\n\t* \\return      string\n\t*/\n\tprotected static function getFacadeAccessor() { return '${4:${3}Service}'; }\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "l_f"
        ],
        "opts": []
      }
    ],
    "ledger": [
      {
        "content": "`strftime(\"%Y/%m/%d\")` ${1:transaction}\n    ${2:account}    ${3:value}\n    ${0:account}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ent"
        ],
        "opts": []
      },
      {
        "content": "${1:`!v strftime(\"%Y\")`}-${2:`!v strftime(\"%m\")`}-${3:`!v strftime(\"%d\")`} ${4:*} ${5:Payee}\n\t${6:Expenses}  \t\t\\$${7:0.00}\n\t${8:Assets:Checking}$0",
        "doc": null,
        "grammar": "snu",
        "label": "Transaction",
        "matches": [
          "t"
        ],
        "opts": [
          "b"
        ]
      }
    ],
    "lfe": [
      {
        "content": "(defmodule ${1:`vim_snippets#Filename()`}\n\t(export ${2:all}))\n$0",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defmo"
        ],
        "opts": []
      },
      {
        "content": "(defun $1 ($2)\n\t$0)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "def"
        ],
        "opts": []
      },
      {
        "content": "(defmodule ${1:`vim_snippets#Filename()`}\n\t(behaviour ltest-unit)\n\t(export all))\n(include-lib \"ltest/include/ltest-macros.lfe\")\n$0",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ltest"
        ],
        "opts": []
      },
      {
        "content": "(deftest $1\n\t$0)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "test"
        ],
        "opts": []
      }
    ],
    "lhaskell": [],
    "liquid": [
      {
        "content": "{% comment %}${1:#:comment}{% endcomment %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "comment"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "{% raw %}${1:#:TARGET}{% endraw %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "raw"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "{% if ${1:#:condition} %}\n  ${0:TARGET}\n{% endif %}",
        "doc": "",
        "grammar": "snu",
        "label": "if endif",
        "matches": [
          "if"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "{% elseif ${1:#:condition} %}\n  ${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "elseif"
        ],
        "opts": []
      },
      {
        "content": "{% if ${1:#:condition} %}\n  ${2:TARGET}\n{% else %}\n  ${3}\n{% endif %}",
        "doc": "",
        "grammar": "snu",
        "label": "if else endif",
        "matches": [
          "ifelse"
        ],
        "opts": []
      },
      {
        "content": "{% unless ${1:#:TARGET} %}\n  ${0:TARGET}\n{% endunless %}",
        "doc": "",
        "grammar": "snu",
        "label": "unless endunless",
        "matches": [
          "unless"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "{% case ${1:#:condition} %}\n{% when ${2:#:TARGET} %}\n  ${3}\n{% endcase%}",
        "doc": "",
        "grammar": "snu",
        "label": "case when endcase",
        "matches": [
          "case"
        ],
        "opts": []
      },
      {
        "content": "{% else %}\n  ${1:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "else"
        ],
        "opts": []
      },
      {
        "content": "{% when ${1:#:TARGET} %}\n  ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "when"
        ],
        "opts": []
      },
      {
        "content": "{% cycle ${1:#:TARGET} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cycle"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "{% for ${1:#:var} in ${2:#:list} %}\n  ${0:TARGET}\n{% endfor%}",
        "doc": "",
        "grammar": "snu",
        "label": "for in endfor",
        "matches": [
          "for"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "{% tablerow ${1:#:var} in ${2:#:list} %}\n  ${0:TARGET}\n{% endtablerow %}",
        "doc": "",
        "grammar": "snu",
        "label": "tablerow in endtablerow",
        "matches": [
          "tablerow"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "{% assign ${1:#:var} = ${2:#:value} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "assign"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "{% capture ${1:#:var} %}${2:#:TARGET}{% endcapture %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "capture"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "{% include ${1:#:TARGET} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "include"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "{{ ${1:#:TARGET} }}",
        "doc": "",
        "grammar": "snu",
        "label": "{{ }}",
        "matches": [
          "output",
          "{{"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "{{ ${1:#:TARGET} | ${2:#:filter} }}",
        "doc": "",
        "grammar": "snu",
        "label": "{{ | }}",
        "matches": [
          "filter",
          "{{"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "{% highlight ${1:#:TARGET} %}\n  ${2:code}\n{% endhighlight %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "highlight",
          "hl"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "{% highlight ${1:#:TARGET} linenos %}\n  ${2:code}\n{% endhighlight %}",
        "doc": "",
        "grammar": "snu",
        "label": "Line number",
        "matches": [
          "highlight_line",
          "hl_l"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "{% post_url ${1:#:TARGET} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "post_url"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "{% gist `getreg('+')=='' ? '<\\`0\\`>' : getreg('+')` %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gist"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "---\nlayout: ${1}\ntitle: ${2}\ncategory: ${3}\n---\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "layout title category",
        "matches": [
          "---",
          "front-matter"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "{% if ${1:condition} %}\n\t${0:${VISUAL}}\n{% endif %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "{% else %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "else"
        ],
        "opts": []
      },
      {
        "content": "{% elsif ${1:condition} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "elsif"
        ],
        "opts": []
      },
      {
        "content": "{% if ${1:condition} %}\n\t${2}\n{% else %}\n\t${0}\n{% endif %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifelse"
        ],
        "opts": []
      },
      {
        "content": "{% unless ${1:condition} %}\n\t${0:${VISUAL}}\n{% endunless %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "unless"
        ],
        "opts": []
      },
      {
        "content": "{% case ${1:variable} %}\n\t{% when ${2:condition} %}\n\t\t${3}\n\t{% else %}\n\t\t${0}\n{% endcase %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case"
        ],
        "opts": []
      },
      {
        "content": "{% when ${1:condition} %}\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "when"
        ],
        "opts": []
      },
      {
        "content": "{% cycle '${1:odd}', '${2:even}' %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cycle"
        ],
        "opts": []
      },
      {
        "content": "{% cycle '${1:group name}': '${2:odd}', '${3:even}' %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cyclegroup"
        ],
        "opts": []
      },
      {
        "content": "{% for ${1:item} in ${2:collection} %}\n\t${0}\n{% endfor %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "limit: ${1:5}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "limit"
        ],
        "opts": []
      },
      {
        "content": "offset: ${1:0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "offset"
        ],
        "opts": []
      },
      {
        "content": "reversed",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "reversed"
        ],
        "opts": []
      },
      {
        "content": "{% break %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "break"
        ],
        "opts": []
      },
      {
        "content": "{% continue %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "continue"
        ],
        "opts": []
      },
      {
        "content": "{% tablerow ${1:item} in ${2:collection} cols: ${3:2} %}\n\t${0}\n{% endtablerow %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tablerow"
        ],
        "opts": []
      },
      {
        "content": "{% assign ${1:variable} = ${0:value} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "assign"
        ],
        "opts": []
      },
      {
        "content": "{% increment ${0:variable} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "increment"
        ],
        "opts": []
      },
      {
        "content": "{% decrement ${0:variable} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "decrement"
        ],
        "opts": []
      },
      {
        "content": "{% capture ${1:variable} %}${0}{% endcapture %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "capture"
        ],
        "opts": []
      },
      {
        "content": "{% include '${0:snippet}' %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "include"
        ],
        "opts": []
      },
      {
        "content": "{% include '${1:snippet}', ${2:variable}: ${0:value} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "includewith"
        ],
        "opts": []
      },
      {
        "content": "{% render '${0:snippet}' %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "render"
        ],
        "opts": []
      },
      {
        "content": "{% render '${1:snippet}', ${2:variable}: ${0:value} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "renderwith"
        ],
        "opts": []
      },
      {
        "content": "{% section '${1:snippet}' %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "section"
        ],
        "opts": []
      },
      {
        "content": "{% raw %}${0}{% endraw %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "raw"
        ],
        "opts": []
      },
      {
        "content": "{% layout '${1:layout}' %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "layout"
        ],
        "opts": []
      },
      {
        "content": "{% layout none %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "layoutnone"
        ],
        "opts": []
      },
      {
        "content": "{% paginate ${1:collection.products} by ${2:12} %}\n\t{% for ${3:product} in $1 %}\n\t\t${0}\n\t{% endfor %}\n{% endpaginate %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "paginate"
        ],
        "opts": []
      },
      {
        "content": "{% schema %}\n\t{\n\t\t${0}\n\t}\n{% endschema %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "schema"
        ],
        "opts": []
      },
      {
        "content": "{% stylesheet %}\n\t${0}\n{% endstylesheet %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "stylesheet"
        ],
        "opts": []
      },
      {
        "content": "{% stylesheet '${1:scss}' %}\n\t${0}\n{% endstylesheet %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "stylesheet_scss"
        ],
        "opts": []
      },
      {
        "content": "{% javascript %}\n\t${0}\n{% endjavascript %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "javascript"
        ],
        "opts": []
      },
      {
        "content": "{%- comment -%}${0:${VISUAL}}{%- endcomment -%}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "comment-"
        ],
        "opts": []
      },
      {
        "content": "{%- if ${1:condition} -%}\n\t${0:${VISUAL}}\n{%- endif -%}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if-"
        ],
        "opts": []
      },
      {
        "content": "{%- else -%}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "else-"
        ],
        "opts": []
      },
      {
        "content": "{%- elsif ${1:condition} -%}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "elsif-"
        ],
        "opts": []
      },
      {
        "content": "{%- if ${1:condition} -%}\n\t${2}\n{%- else -%}\n\t${0}\n{%- endif -%}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifelse-"
        ],
        "opts": []
      },
      {
        "content": "{%- unless ${1:condition} -%}\n\t${0:${VISUAL}}\n{%- endunless -%}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "unless-"
        ],
        "opts": []
      },
      {
        "content": "{%- case ${1:variable} -%}\n\t{%- when ${2:condition} -%}\n\t\t${3}\n\t{%- else -%}\n\t\t${0}\n{%- endcase -%}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case-"
        ],
        "opts": []
      },
      {
        "content": "{%- when ${1:condition} -%}\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "when-"
        ],
        "opts": []
      },
      {
        "content": "{%- cycle '${1:odd}', '${2:even}' -%}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cycle-"
        ],
        "opts": []
      },
      {
        "content": "{%- cycle '${1:group name}': '${2:odd}', '${3:even}' -%}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cyclegroup-"
        ],
        "opts": []
      },
      {
        "content": "{%- for ${1:item} in ${2:collection} -%}\n\t${0}\n{%- endfor -%}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for-"
        ],
        "opts": []
      },
      {
        "content": "{%- continue -%}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "continue-"
        ],
        "opts": []
      },
      {
        "content": "{%- tablerow ${1:item} in ${2:collection} cols: ${3:2} -%}\n\t${0}\n{%- endtablerow -%}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tablerow-"
        ],
        "opts": []
      },
      {
        "content": "{%- assign ${1:variable} = ${0:value} -%}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "assign-"
        ],
        "opts": []
      },
      {
        "content": "{%- capture ${1:variable} -%}${0}{%- endcapture -%}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "capture-"
        ],
        "opts": []
      },
      {
        "content": "{%- include '${0:snippet}' -%}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "include-"
        ],
        "opts": []
      },
      {
        "content": "{%- include '${1:snippet}', ${2:variable}: ${0:value} -%}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "includewith-"
        ],
        "opts": []
      },
      {
        "content": "{%- render '${0:snippet}' -%}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "render-"
        ],
        "opts": []
      },
      {
        "content": "{%- render '${1:snippet}', ${2:variable}: ${0:value} -%}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "renderwith-"
        ],
        "opts": []
      },
      {
        "content": "{%- section '${1:snippet}' -%}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "section-"
        ],
        "opts": []
      },
      {
        "content": "{%- layout '${1:layout}' -%}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "layout-"
        ],
        "opts": []
      },
      {
        "content": "{%- layout none -%}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "layoutnone-"
        ],
        "opts": []
      },
      {
        "content": "{%- paginate ${1:collection.products} by ${2:12} -%}\n\t{%- for ${3:product} in $1 -%}\n\t\t${0}\n\t{%- endfor -%}\n{%- endpaginate -%}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "paginate-"
        ],
        "opts": []
      },
      {
        "content": "| join: '${1:, }'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "join"
        ],
        "opts": []
      },
      {
        "content": "| first",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "first"
        ],
        "opts": []
      },
      {
        "content": "| last",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "last"
        ],
        "opts": []
      },
      {
        "content": "| concat: ${1:array}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "concat"
        ],
        "opts": []
      },
      {
        "content": "| map: '${1:key}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "map"
        ],
        "opts": []
      },
      {
        "content": "| reverse",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "reverse"
        ],
        "opts": []
      },
      {
        "content": "| size",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "size"
        ],
        "opts": []
      },
      {
        "content": "| sort: '${1:key}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sort"
        ],
        "opts": []
      },
      {
        "content": "| uniq",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "uniq"
        ],
        "opts": []
      },
      {
        "content": "| img_tag",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "img_tag"
        ],
        "opts": []
      },
      {
        "content": "| img_tag: '${1:alt}', '${2:class}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "img_tag_param"
        ],
        "opts": []
      },
      {
        "content": "| script_tag",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "script_tag"
        ],
        "opts": []
      },
      {
        "content": "| stylesheet_tag",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "stylesheet_tag"
        ],
        "opts": []
      },
      {
        "content": "| abs",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "abs"
        ],
        "opts": []
      },
      {
        "content": "| ceil",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ceil"
        ],
        "opts": []
      },
      {
        "content": "| divided_by: ${1:2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "divided_by"
        ],
        "opts": []
      },
      {
        "content": "| floor",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "floor"
        ],
        "opts": []
      },
      {
        "content": "| minus: ${1:1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "minus"
        ],
        "opts": []
      },
      {
        "content": "| plus: ${1:1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "plus"
        ],
        "opts": []
      },
      {
        "content": "| round: ${1:0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "round"
        ],
        "opts": []
      },
      {
        "content": "| times: ${1:1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "times"
        ],
        "opts": []
      },
      {
        "content": "| modulo: ${1:2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "modulo"
        ],
        "opts": []
      },
      {
        "content": "| money",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "money"
        ],
        "opts": []
      },
      {
        "content": "| money_with_currency",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "money_with_currency"
        ],
        "opts": []
      },
      {
        "content": "| money_without_trailing_zeros",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "money_without_trailing_zeros"
        ],
        "opts": []
      },
      {
        "content": "| money_without_currency",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "money_without_currency"
        ],
        "opts": []
      },
      {
        "content": "| append: '${1:string}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "append"
        ],
        "opts": []
      },
      {
        "content": "| camelcase",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "camelcase"
        ],
        "opts": []
      },
      {
        "content": "| capitalize",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "capitalize"
        ],
        "opts": []
      },
      {
        "content": "| downcase",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "downcase"
        ],
        "opts": []
      },
      {
        "content": "| escape",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "escape"
        ],
        "opts": []
      },
      {
        "content": "| handleize",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "handleize"
        ],
        "opts": []
      },
      {
        "content": "| md5",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "md5"
        ],
        "opts": []
      },
      {
        "content": "| newline_to_br",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "newline_to_br"
        ],
        "opts": []
      },
      {
        "content": "| pluralize: '${1:item}', '${2:items}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pluralize"
        ],
        "opts": []
      },
      {
        "content": "| prepend: '${1:string}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prepend"
        ],
        "opts": []
      },
      {
        "content": "| remove: '${1:string}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "remove"
        ],
        "opts": []
      },
      {
        "content": "| remove_first: '${1:string}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "remove_first"
        ],
        "opts": []
      },
      {
        "content": "| replace: '${1:target}', '${2:replace}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "replace"
        ],
        "opts": []
      },
      {
        "content": "| replace_first: '${1:target}', '${2:replace}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "replace_first"
        ],
        "opts": []
      },
      {
        "content": "| slice: ${1:0}, ${2:5}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "slice"
        ],
        "opts": []
      },
      {
        "content": "| slice: ${1:at}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "slice_single"
        ],
        "opts": []
      },
      {
        "content": "| split: '${1:,}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "split"
        ],
        "opts": []
      },
      {
        "content": "| strip",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "strip"
        ],
        "opts": []
      },
      {
        "content": "| lstrip",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lstrip"
        ],
        "opts": []
      },
      {
        "content": "| rstrip",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rstrip"
        ],
        "opts": []
      },
      {
        "content": "| strip_html",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "strip_html"
        ],
        "opts": []
      },
      {
        "content": "| strip_newlines",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "strip_newlines"
        ],
        "opts": []
      },
      {
        "content": "| truncate: ${1:20}, '${2:...}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "truncate"
        ],
        "opts": []
      },
      {
        "content": "| truncatewords: ${1:5}, '${2:...}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "truncatewords"
        ],
        "opts": []
      },
      {
        "content": "| upcase",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "upcase"
        ],
        "opts": []
      },
      {
        "content": "| url_encode",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "url_encode"
        ],
        "opts": []
      },
      {
        "content": "| url_escape",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "url_escape"
        ],
        "opts": []
      },
      {
        "content": "| url_param_escape",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "url_param_escape"
        ],
        "opts": []
      },
      {
        "content": "| asset_url",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asset_url"
        ],
        "opts": []
      },
      {
        "content": "| asset_img_url: '${1:medium}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asset_img_url"
        ],
        "opts": []
      },
      {
        "content": "| img_url: '${1:medium}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "img_url"
        ],
        "opts": []
      },
      {
        "content": "{% schema %}\n\t{\n\t\t\"name\": \"${1}\",\n\t\t\"class\": \"${2}\",\n\t\t\"settings\": [\n\t\t\t${0}\n\t\t]\n\t}\n{% endschema %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "_schema"
        ],
        "opts": []
      },
      {
        "content": "\"blocks\": [\n\t{\n\t\t\"type\": \"${1}\",\n\t\t\"name\": \"${2}\",\n\t\t\"settings\": [\n\t\t\t${0}\n\t\t]\n\t}\n]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "_blocks"
        ],
        "opts": []
      },
      {
        "content": "{\n\t\"type\": \"text\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"default\": \"${3}\",\n\t\"info\": \"${4}\",\n\t\"placeholder\": \"${0}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "_text"
        ],
        "opts": []
      },
      {
        "content": "{\n\t\"type\": \"textarea\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"default\": \"${3}\",\n\t\"info\": \"${4}\",\n\t\"placeholder\": \"${0}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "_textarea"
        ],
        "opts": []
      },
      {
        "content": "{\n\t\"type\": \"image_picker\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${0}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "_image_picker"
        ],
        "opts": []
      },
      {
        "content": "{\n\t\"type\": \"radio\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"options\": [\n\t\t{ \"value\": \"${5}\", \"label\": \"${0}\" }\n\t],\n\t\"default\": \"${3}\",\n\t\"info\": \"${4}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "_radio"
        ],
        "opts": []
      },
      {
        "content": "{\n\t\"type\": \"select\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"options\": [\n\t\t{\n\t\t\t\"group\": \"${5}\",\n\t\t\t\"value\": \"${6}\",\n\t\t\t\"label\": \"${0}\"\n\t\t}\n\t],\n\t\"default\": \"${3}\",\n\t\"info\": \"${4}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "_select"
        ],
        "opts": []
      },
      {
        "content": "{\n\t\"type\": \"checkbox\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"default\": ${3:true},\n\t\"info\": \"${0}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "_checkbox"
        ],
        "opts": []
      },
      {
        "content": "{\n\t\"type\": \"range\",\n\t\"id\": \"${1}\",\n\t\"min\": ${2},\n\t\"max\": ${3},\n\t\"step\": ${4},\n\t\"unit\": \"${5}\",\n\t\"label\": \"${6}\",\n\t\"default\": ${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "_range"
        ],
        "opts": []
      },
      {
        "content": "{\n\t\"type\": \"color\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"default\": \"${3}\",\n\t\"info\": \"${0}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "_color"
        ],
        "opts": []
      },
      {
        "content": "{\n\t\"type\": \"font_picker\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"info\": \"${3}\",\n\t\"default\": \"${0:helvetica_n4}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "_font"
        ],
        "opts": []
      },
      {
        "content": "{\n\t\"type\": \"collection\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"info\": \"${0}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "_collection"
        ],
        "opts": []
      },
      {
        "content": "{\n\t\"type\": \"product\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"info\": \"${0}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "_product"
        ],
        "opts": []
      },
      {
        "content": "{\n\t\"type\": \"blog\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"info\": \"${0}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "_blog"
        ],
        "opts": []
      },
      {
        "content": "{\n\t\"type\": \"page\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"info\": \"${0}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "_page"
        ],
        "opts": []
      },
      {
        "content": "{\n\t\"type\": \"link_list\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"info\": \"${0}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "_link_list"
        ],
        "opts": []
      },
      {
        "content": "{\n\t\"type\": \"url\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"info\": \"${0}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "_url"
        ],
        "opts": []
      },
      {
        "content": "{\n\t\"type\": \"video_url\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"accept\": [\"youtube\", \"vimeo\"${0}],\n\t\"default\": \"${3}\",\n\t\"info\": \"${4}\",\n\t\"placeholder\": \"${5}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "_video"
        ],
        "opts": []
      },
      {
        "content": "{\n\t\"type\": \"richtext\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"default\": \"<p>${0}</p>\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "_richtext"
        ],
        "opts": []
      },
      {
        "content": "{\n\t\"type\": \"html\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"default\": \"<div>${0}</div>\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "_html"
        ],
        "opts": []
      },
      {
        "content": "{\n\t\"type\": \"article\",\n\t\"id\": \"${1}\",\n\t\"label\": \"${2}\",\n\t\"info\": \"${0}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "_article"
        ],
        "opts": []
      },
      {
        "content": "{\n\t\"type\": \"header\",\n\t\"content\": \"${1}\",\n\t\"info\": \"${0}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "_header"
        ],
        "opts": []
      },
      {
        "content": "{\n\t\"type\": \"paragraph\",\n\t\"content\": \"${0}\"\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "_paragraph"
        ],
        "opts": []
      }
    ],
    "lodash": [
      {
        "content": "_.runInContext(${context})",
        "doc": "_.mixin({ 'foo': _.constant('foo') });\n\nvar lodash = _.runInContext();\nlodash.mixin({ 'bar': lodash.constant('bar') });\n\n_.isFunction(_.foo);\n// => true\n_.isFunction(_.bar);\n// => false\n\nlodash.isFunction(lodash.foo);\n// => false\nlodash.isFunction(lodash.bar);\n// => true\n\n// Create a suped-up `defer` in Node.js.\nvar defer = _.runInContext({ 'setTimeout': setImmediate }).defer;\n\nCreate a new pristine `lodash` function using the `context` object.",
        "grammar": "lsp",
        "label": "lodash-runincontext",
        "matches": [
          "lodash runincontext"
        ],
        "opts": []
      },
      {
        "content": "_.chunk(${array}, ${size})",
        "doc": "_.chunk(['a', 'b', 'c', 'd'], 2);\n// => [['a', 'b'], ['c', 'd']]\n\n_.chunk(['a', 'b', 'c', 'd'], 3);\n// => [['a', 'b', 'c'], ['d']]\n\nCreates an array of elements split into groups the length of `size`.\nIf `array` can't be split evenly, the final chunk will be the remaining\nelements.",
        "grammar": "lsp",
        "label": "lodash-chunk",
        "matches": [
          "lodash chunk"
        ],
        "opts": []
      },
      {
        "content": "_.compact(${array})",
        "doc": "_.compact([0, 1, false, 2, '', 3]);\n// => [1, 2, 3]\n\nCreates an array with all falsey values removed. The values `false`, `null`,\n`0`, `\"\"`, `undefined`, and `NaN` are falsey.",
        "grammar": "lsp",
        "label": "lodash-compact",
        "matches": [
          "lodash compact"
        ],
        "opts": []
      },
      {
        "content": "_.concat(${array}, ${values})",
        "doc": "var array = [1];\nvar other = _.concat(array, 2, [3], [[4]]);\n\nconsole.log(other);\n// => [1, 2, 3, [4]]\n\nconsole.log(array);\n// => [1]\n\nCreates a new array concatenating `array` with any additional arrays\nand/or values.",
        "grammar": "lsp",
        "label": "lodash-concat",
        "matches": [
          "lodash concat"
        ],
        "opts": []
      },
      {
        "content": "_.difference(${array}, ${values})",
        "doc": "_.difference([2, 1], [2, 3]);\n// => [1]\n\nCreates an array of `array` values not included in the other given arrays\nusing [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\nfor equality comparisons. The order and references of result values are\ndetermined by the first array.\n\n**Note:** Unlike `_.pullAll`, this method returns a new array.",
        "grammar": "lsp",
        "label": "lodash-difference",
        "matches": [
          "lodash difference"
        ],
        "opts": []
      },
      {
        "content": "_.differenceBy(${array}, ${values}, ${iteratee})",
        "doc": "_.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n// => [1.2]\n\n// The `_.property` iteratee shorthand.\n_.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');\n// => [{ 'x': 2 }]\n\nThis method is like `_.difference` except that it accepts `iteratee` which\nis invoked for each element of `array` and `values` to generate the criterion\nby which they're compared. The order and references of result values are\ndetermined by the first array. The iteratee is invoked with one argument:\n(value).\n\n**Note:** Unlike `_.pullAllBy`, this method returns a new array.",
        "grammar": "lsp",
        "label": "lodash-differenceby",
        "matches": [
          "lodash differenceby"
        ],
        "opts": []
      },
      {
        "content": "_.differenceWith(${array}, ${values}, ${comparator})",
        "doc": "var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n\n_.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);\n// => [{ 'x': 2, 'y': 1 }]\n\nThis method is like `_.difference` except that it accepts `comparator`\nwhich is invoked to compare elements of `array` to `values`. The order and\nreferences of result values are determined by the first array. The comparator\nis invoked with two arguments: (arrVal, othVal).\n\n**Note:** Unlike `_.pullAllWith`, this method returns a new array.",
        "grammar": "lsp",
        "label": "lodash-differencewith",
        "matches": [
          "lodash differencewith"
        ],
        "opts": []
      },
      {
        "content": "_.drop(${array}, ${n})",
        "doc": "_.drop([1, 2, 3]);\n// => [2, 3]\n\n_.drop([1, 2, 3], 2);\n// => [3]\n\n_.drop([1, 2, 3], 5);\n// => []\n\n_.drop([1, 2, 3], 0);\n// => [1, 2, 3]\n\nCreates a slice of `array` with `n` elements dropped from the beginning.",
        "grammar": "lsp",
        "label": "lodash-drop",
        "matches": [
          "lodash drop"
        ],
        "opts": []
      },
      {
        "content": "_.dropRight(${array}, ${n})",
        "doc": "_.dropRight([1, 2, 3]);\n// => [1, 2]\n\n_.dropRight([1, 2, 3], 2);\n// => [1]\n\n_.dropRight([1, 2, 3], 5);\n// => []\n\n_.dropRight([1, 2, 3], 0);\n// => [1, 2, 3]\n\nCreates a slice of `array` with `n` elements dropped from the end.",
        "grammar": "lsp",
        "label": "lodash-dropright",
        "matches": [
          "lodash dropright"
        ],
        "opts": []
      },
      {
        "content": "_.dropRightWhile(${array}, ${predicate})",
        "doc": "var users = [\n  { 'user': 'barney',  'active': true },\n  { 'user': 'fred',    'active': false },\n  { 'user': 'pebbles', 'active': false }\n];\n\n_.dropRightWhile(users, function(o) { return !o.active; });\n// => objects for ['barney']\n\n// The `_.matches` iteratee shorthand.\n_.dropRightWhile(users, { 'user': 'pebbles', 'active': false });\n// => objects for ['barney', 'fred']\n\n// The `_.matchesProperty` iteratee shorthand.\n_.dropRightWhile(users, ['active', false]);\n// => objects for ['barney']\n\n// The `_.property` iteratee shorthand.\n_.dropRightWhile(users, 'active');\n// => objects for ['barney', 'fred', 'pebbles']\n\nCreates a slice of `array` excluding elements dropped from the end.\nElements are dropped until `predicate` returns falsey. The predicate is\ninvoked with three arguments: (value, index, array).",
        "grammar": "lsp",
        "label": "lodash-droprightwhile",
        "matches": [
          "lodash droprightwhile"
        ],
        "opts": []
      },
      {
        "content": "_.dropWhile(${array}, ${predicate})",
        "doc": "var users = [\n  { 'user': 'barney',  'active': false },\n  { 'user': 'fred',    'active': false },\n  { 'user': 'pebbles', 'active': true }\n];\n\n_.dropWhile(users, function(o) { return !o.active; });\n// => objects for ['pebbles']\n\n// The `_.matches` iteratee shorthand.\n_.dropWhile(users, { 'user': 'barney', 'active': false });\n// => objects for ['fred', 'pebbles']\n\n// The `_.matchesProperty` iteratee shorthand.\n_.dropWhile(users, ['active', false]);\n// => objects for ['pebbles']\n\n// The `_.property` iteratee shorthand.\n_.dropWhile(users, 'active');\n// => objects for ['barney', 'fred', 'pebbles']\n\nCreates a slice of `array` excluding elements dropped from the beginning.\nElements are dropped until `predicate` returns falsey. The predicate is\ninvoked with three arguments: (value, index, array).",
        "grammar": "lsp",
        "label": "lodash-dropwhile",
        "matches": [
          "lodash dropwhile"
        ],
        "opts": []
      },
      {
        "content": "_.fill(${array}, ${value}, ${start}, ${end})",
        "doc": "var array = [1, 2, 3];\n\n_.fill(array, 'a');\nconsole.log(array);\n// => ['a', 'a', 'a']\n\n_.fill(Array(3), 2);\n// => [2, 2, 2]\n\n_.fill([4, 6, 8, 10], '*', 1, 3);\n// => [4, '*', '*', 10]\n\nFills elements of `array` with `value` from `start` up to, but not\nincluding, `end`.\n\n**Note:** This method mutates `array`.",
        "grammar": "lsp",
        "label": "lodash-fill",
        "matches": [
          "lodash fill"
        ],
        "opts": []
      },
      {
        "content": "_.findIndex(${array}, ${predicate}, ${fromIndex})",
        "doc": "var users = [\n  { 'user': 'barney',  'active': false },\n  { 'user': 'fred',    'active': false },\n  { 'user': 'pebbles', 'active': true }\n];\n\n_.findIndex(users, function(o) { return o.user == 'barney'; });\n// => 0\n\n// The `_.matches` iteratee shorthand.\n_.findIndex(users, { 'user': 'fred', 'active': false });\n// => 1\n\n// The `_.matchesProperty` iteratee shorthand.\n_.findIndex(users, ['active', false]);\n// => 0\n\n// The `_.property` iteratee shorthand.\n_.findIndex(users, 'active');\n// => 2\n\nThis method is like `_.find` except that it returns the index of the first\nelement `predicate` returns truthy for instead of the element itself.",
        "grammar": "lsp",
        "label": "lodash-findindex",
        "matches": [
          "lodash findindex"
        ],
        "opts": []
      },
      {
        "content": "_.findLastIndex(${array}, ${predicate}, ${fromIndex})",
        "doc": "var users = [\n  { 'user': 'barney',  'active': true },\n  { 'user': 'fred',    'active': false },\n  { 'user': 'pebbles', 'active': false }\n];\n\n_.findLastIndex(users, function(o) { return o.user == 'pebbles'; });\n// => 2\n\n// The `_.matches` iteratee shorthand.\n_.findLastIndex(users, { 'user': 'barney', 'active': true });\n// => 0\n\n// The `_.matchesProperty` iteratee shorthand.\n_.findLastIndex(users, ['active', false]);\n// => 2\n\n// The `_.property` iteratee shorthand.\n_.findLastIndex(users, 'active');\n// => 0\n\nThis method is like `_.findIndex` except that it iterates over elements\nof `collection` from right to left.",
        "grammar": "lsp",
        "label": "lodash-findlastindex",
        "matches": [
          "lodash findlastindex"
        ],
        "opts": []
      },
      {
        "content": "_.flatten(${array})",
        "doc": "_.flatten([1, [2, [3, [4]], 5]]);\n// => [1, 2, [3, [4]], 5]\n\nFlattens `array` a single level deep.",
        "grammar": "lsp",
        "label": "lodash-flatten",
        "matches": [
          "lodash flatten"
        ],
        "opts": []
      },
      {
        "content": "_.flattenDeep(${array})",
        "doc": "_.flattenDeep([1, [2, [3, [4]], 5]]);\n// => [1, 2, 3, 4, 5]\n\nRecursively flattens `array`.",
        "grammar": "lsp",
        "label": "lodash-flattendeep",
        "matches": [
          "lodash flattendeep"
        ],
        "opts": []
      },
      {
        "content": "_.flattenDepth(${array}, ${depth})",
        "doc": "var array = [1, [2, [3, [4]], 5]];\n\n_.flattenDepth(array, 1);\n// => [1, 2, [3, [4]], 5]\n\n_.flattenDepth(array, 2);\n// => [1, 2, 3, [4], 5]\n\nRecursively flatten `array` up to `depth` times.",
        "grammar": "lsp",
        "label": "lodash-flattendepth",
        "matches": [
          "lodash flattendepth"
        ],
        "opts": []
      },
      {
        "content": "_.fromPairs(${pairs})",
        "doc": "_.fromPairs([['a', 1], ['b', 2]]);\n// => { 'a': 1, 'b': 2 }\n\nThe inverse of `_.toPairs`; this method returns an object composed\nfrom key-value `pairs`.",
        "grammar": "lsp",
        "label": "lodash-frompairs",
        "matches": [
          "lodash frompairs"
        ],
        "opts": []
      },
      {
        "content": "_.first(${array})",
        "doc": "_.head([1, 2, 3]);\n// => 1\n\n_.head([]);\n// => undefined\n\nGets the first element of `array`.",
        "grammar": "lsp",
        "label": "lodash-first",
        "matches": [
          "lodash first"
        ],
        "opts": []
      },
      {
        "content": "_.indexOf(${array}, ${value}, ${fromIndex})",
        "doc": "_.indexOf([1, 2, 1, 2], 2);\n// => 1\n\n// Search from the `fromIndex`.\n_.indexOf([1, 2, 1, 2], 2, 2);\n// => 3\n\nGets the index at which the first occurrence of `value` is found in `array`\nusing [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\nfor equality comparisons. If `fromIndex` is negative, it's used as the\noffset from the end of `array`.",
        "grammar": "lsp",
        "label": "lodash-indexof",
        "matches": [
          "lodash indexof"
        ],
        "opts": []
      },
      {
        "content": "_.initial(${array})",
        "doc": "_.initial([1, 2, 3]);\n// => [1, 2]\n\nGets all but the last element of `array`.",
        "grammar": "lsp",
        "label": "lodash-initial",
        "matches": [
          "lodash initial"
        ],
        "opts": []
      },
      {
        "content": "_.intersection(${arrays})",
        "doc": "_.intersection([2, 1], [2, 3]);\n// => [2]\n\nCreates an array of unique values that are included in all given arrays\nusing [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\nfor equality comparisons. The order and references of result values are\ndetermined by the first array.",
        "grammar": "lsp",
        "label": "lodash-intersection",
        "matches": [
          "lodash intersection"
        ],
        "opts": []
      },
      {
        "content": "_.intersectionBy(${arrays}, ${iteratee})",
        "doc": "_.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n// => [2.1]\n\n// The `_.property` iteratee shorthand.\n_.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n// => [{ 'x': 1 }]\n\nThis method is like `_.intersection` except that it accepts `iteratee`\nwhich is invoked for each element of each `arrays` to generate the criterion\nby which they're compared. The order and references of result values are\ndetermined by the first array. The iteratee is invoked with one argument:\n(value).",
        "grammar": "lsp",
        "label": "lodash-intersectionby",
        "matches": [
          "lodash intersectionby"
        ],
        "opts": []
      },
      {
        "content": "_.intersectionWith(${arrays}, ${comparator})",
        "doc": "var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\nvar others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n\n_.intersectionWith(objects, others, _.isEqual);\n// => [{ 'x': 1, 'y': 2 }]\n\nThis method is like `_.intersection` except that it accepts `comparator`\nwhich is invoked to compare elements of `arrays`. The order and references\nof result values are determined by the first array. The comparator is\ninvoked with two arguments: (arrVal, othVal).",
        "grammar": "lsp",
        "label": "lodash-intersectionwith",
        "matches": [
          "lodash intersectionwith"
        ],
        "opts": []
      },
      {
        "content": "_.join(${array}, ${separator})",
        "doc": "_.join(['a', 'b', 'c'], '~');\n// => 'a~b~c'\n\nConverts all elements in `array` into a string separated by `separator`.",
        "grammar": "lsp",
        "label": "lodash-join",
        "matches": [
          "lodash join"
        ],
        "opts": []
      },
      {
        "content": "_.last(${array})",
        "doc": "_.last([1, 2, 3]);\n// => 3\n\nGets the last element of `array`.",
        "grammar": "lsp",
        "label": "lodash-last",
        "matches": [
          "lodash last"
        ],
        "opts": []
      },
      {
        "content": "_.lastIndexOf(${array}, ${value}, ${fromIndex})",
        "doc": "_.lastIndexOf([1, 2, 1, 2], 2);\n// => 3\n\n// Search from the `fromIndex`.\n_.lastIndexOf([1, 2, 1, 2], 2, 2);\n// => 1\n\nThis method is like `_.indexOf` except that it iterates over elements of\n`array` from right to left.",
        "grammar": "lsp",
        "label": "lodash-lastindexof",
        "matches": [
          "lodash lastindexof"
        ],
        "opts": []
      },
      {
        "content": "_.nth(${array}, ${n})",
        "doc": "var array = ['a', 'b', 'c', 'd'];\n\n_.nth(array, 1);\n// => 'b'\n\n_.nth(array, -2);\n// => 'c';\n\nGets the element at index `n` of `array`. If `n` is negative, the nth\nelement from the end is returned.",
        "grammar": "lsp",
        "label": "lodash-nth",
        "matches": [
          "lodash nth"
        ],
        "opts": []
      },
      {
        "content": "_.pull(${array}, ${values})",
        "doc": "var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n\n_.pull(array, 'a', 'c');\nconsole.log(array);\n// => ['b', 'b']\n\nRemoves all given values from `array` using\n[`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\nfor equality comparisons.\n\n**Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`\nto remove elements from an array by predicate.",
        "grammar": "lsp",
        "label": "lodash-pull",
        "matches": [
          "lodash pull"
        ],
        "opts": []
      },
      {
        "content": "_.pullAll(${array}, ${values})",
        "doc": "var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n\n_.pullAll(array, ['a', 'c']);\nconsole.log(array);\n// => ['b', 'b']\n\nThis method is like `_.pull` except that it accepts an array of values to remove.\n\n**Note:** Unlike `_.difference`, this method mutates `array`.",
        "grammar": "lsp",
        "label": "lodash-pullall",
        "matches": [
          "lodash pullall"
        ],
        "opts": []
      },
      {
        "content": "_.pullAllBy(${array}, ${values}, ${iteratee})",
        "doc": "var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\n\n_.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');\nconsole.log(array);\n// => [{ 'x': 2 }]\n\nThis method is like `_.pullAll` except that it accepts `iteratee` which is\ninvoked for each element of `array` and `values` to generate the criterion\nby which they're compared. The iteratee is invoked with one argument: (value).\n\n**Note:** Unlike `_.differenceBy`, this method mutates `array`.",
        "grammar": "lsp",
        "label": "lodash-pullallby",
        "matches": [
          "lodash pullallby"
        ],
        "opts": []
      },
      {
        "content": "_.pullAllWith(${array}, ${values}, ${comparator})",
        "doc": "var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];\n\n_.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);\nconsole.log(array);\n// => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]\n\nThis method is like `_.pullAll` except that it accepts `comparator` which\nis invoked to compare elements of `array` to `values`. The comparator is\ninvoked with two arguments: (arrVal, othVal).\n\n**Note:** Unlike `_.differenceWith`, this method mutates `array`.",
        "grammar": "lsp",
        "label": "lodash-pullallwith",
        "matches": [
          "lodash pullallwith"
        ],
        "opts": []
      },
      {
        "content": "_.pullAt(${array}, ${indexes})",
        "doc": "var array = ['a', 'b', 'c', 'd'];\nvar pulled = _.pullAt(array, [1, 3]);\n\nconsole.log(array);\n// => ['a', 'c']\n\nconsole.log(pulled);\n// => ['b', 'd']\n\nRemoves elements from `array` corresponding to `indexes` and returns an\narray of removed elements.\n\n**Note:** Unlike `_.at`, this method mutates `array`.",
        "grammar": "lsp",
        "label": "lodash-pullat",
        "matches": [
          "lodash pullat"
        ],
        "opts": []
      },
      {
        "content": "_.remove(${array}, ${predicate})",
        "doc": "var array = [1, 2, 3, 4];\nvar evens = _.remove(array, function(n) {\n  return n % 2 == 0;\n});\n\nconsole.log(array);\n// => [1, 3]\n\nconsole.log(evens);\n// => [2, 4]\n\nRemoves all elements from `array` that `predicate` returns truthy for\nand returns an array of the removed elements. The predicate is invoked\nwith three arguments: (value, index, array).\n\n**Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`\nto pull elements from an array by value.",
        "grammar": "lsp",
        "label": "lodash-remove",
        "matches": [
          "lodash remove"
        ],
        "opts": []
      },
      {
        "content": "_.reverse()",
        "doc": "var array = [1, 2, 3];\n\n_(array).reverse().value()\n// => [3, 2, 1]\n\nconsole.log(array);\n// => [3, 2, 1]\n\nThis method is the wrapper version of `_.reverse`.\n\n**Note:** This method mutates the wrapped array.",
        "grammar": "lsp",
        "label": "lodash-reverse",
        "matches": [
          "lodash reverse"
        ],
        "opts": []
      },
      {
        "content": "_.slice(${array}, ${start}, ${end})",
        "doc": "undefined\n\nCreates a slice of `array` from `start` up to, but not including, `end`.\n\n**Note:** This method is used instead of\n[`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are\nreturned.",
        "grammar": "lsp",
        "label": "lodash-slice",
        "matches": [
          "lodash slice"
        ],
        "opts": []
      },
      {
        "content": "_.sortedIndex(${array}, ${value})",
        "doc": "_.sortedIndex([30, 50], 40);\n// => 1\n\nUses a binary search to determine the lowest index at which `value`\nshould be inserted into `array` in order to maintain its sort order.",
        "grammar": "lsp",
        "label": "lodash-sortedindex",
        "matches": [
          "lodash sortedindex"
        ],
        "opts": []
      },
      {
        "content": "_.sortedIndexBy(${array}, ${value}, ${iteratee})",
        "doc": "var objects = [{ 'x': 4 }, { 'x': 5 }];\n\n_.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n// => 0\n\n// The `_.property` iteratee shorthand.\n_.sortedIndexBy(objects, { 'x': 4 }, 'x');\n// => 0\n\nThis method is like `_.sortedIndex` except that it accepts `iteratee`\nwhich is invoked for `value` and each element of `array` to compute their\nsort ranking. The iteratee is invoked with one argument: (value).",
        "grammar": "lsp",
        "label": "lodash-sortedindexby",
        "matches": [
          "lodash sortedindexby"
        ],
        "opts": []
      },
      {
        "content": "_.sortedIndexOf(${array}, ${value})",
        "doc": "_.sortedIndexOf([4, 5, 5, 5, 6], 5);\n// => 1\n\nThis method is like `_.indexOf` except that it performs a binary\nsearch on a sorted `array`.",
        "grammar": "lsp",
        "label": "lodash-sortedindexof",
        "matches": [
          "lodash sortedindexof"
        ],
        "opts": []
      },
      {
        "content": "_.sortedLastIndex(${array}, ${value})",
        "doc": "_.sortedLastIndex([4, 5, 5, 5, 6], 5);\n// => 4\n\nThis method is like `_.sortedIndex` except that it returns the highest\nindex at which `value` should be inserted into `array` in order to\nmaintain its sort order.",
        "grammar": "lsp",
        "label": "lodash-sortedlastindex",
        "matches": [
          "lodash sortedlastindex"
        ],
        "opts": []
      },
      {
        "content": "_.sortedLastIndexBy(${array}, ${value}, ${iteratee})",
        "doc": "var objects = [{ 'x': 4 }, { 'x': 5 }];\n\n_.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n// => 1\n\n// The `_.property` iteratee shorthand.\n_.sortedLastIndexBy(objects, { 'x': 4 }, 'x');\n// => 1\n\nThis method is like `_.sortedLastIndex` except that it accepts `iteratee`\nwhich is invoked for `value` and each element of `array` to compute their\nsort ranking. The iteratee is invoked with one argument: (value).",
        "grammar": "lsp",
        "label": "lodash-sortedlastindexby",
        "matches": [
          "lodash sortedlastindexby"
        ],
        "opts": []
      },
      {
        "content": "_.sortedLastIndexOf(${array}, ${value})",
        "doc": "_.sortedLastIndexOf([4, 5, 5, 5, 6], 5);\n// => 3\n\nThis method is like `_.lastIndexOf` except that it performs a binary\nsearch on a sorted `array`.",
        "grammar": "lsp",
        "label": "lodash-sortedlastindexof",
        "matches": [
          "lodash sortedlastindexof"
        ],
        "opts": []
      },
      {
        "content": "_.sortedUniq(${array})",
        "doc": "_.sortedUniq([1, 1, 2]);\n// => [1, 2]\n\nThis method is like `_.uniq` except that it's designed and optimized\nfor sorted arrays.",
        "grammar": "lsp",
        "label": "lodash-sorteduniq",
        "matches": [
          "lodash sorteduniq"
        ],
        "opts": []
      },
      {
        "content": "_.sortedUniqBy(${array}, ${iteratee})",
        "doc": "_.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);\n// => [1.1, 2.3]\n\nThis method is like `_.uniqBy` except that it's designed and optimized\nfor sorted arrays.",
        "grammar": "lsp",
        "label": "lodash-sorteduniqby",
        "matches": [
          "lodash sorteduniqby"
        ],
        "opts": []
      },
      {
        "content": "_.tail(${array})",
        "doc": "_.tail([1, 2, 3]);\n// => [2, 3]\n\nGets all but the first element of `array`.",
        "grammar": "lsp",
        "label": "lodash-tail",
        "matches": [
          "lodash tail"
        ],
        "opts": []
      },
      {
        "content": "_.take(${array}, ${n})",
        "doc": "_.take([1, 2, 3]);\n// => [1]\n\n_.take([1, 2, 3], 2);\n// => [1, 2]\n\n_.take([1, 2, 3], 5);\n// => [1, 2, 3]\n\n_.take([1, 2, 3], 0);\n// => []\n\nCreates a slice of `array` with `n` elements taken from the beginning.",
        "grammar": "lsp",
        "label": "lodash-take",
        "matches": [
          "lodash take"
        ],
        "opts": []
      },
      {
        "content": "_.takeRight(${array}, ${n})",
        "doc": "_.takeRight([1, 2, 3]);\n// => [3]\n\n_.takeRight([1, 2, 3], 2);\n// => [2, 3]\n\n_.takeRight([1, 2, 3], 5);\n// => [1, 2, 3]\n\n_.takeRight([1, 2, 3], 0);\n// => []\n\nCreates a slice of `array` with `n` elements taken from the end.",
        "grammar": "lsp",
        "label": "lodash-takeright",
        "matches": [
          "lodash takeright"
        ],
        "opts": []
      },
      {
        "content": "_.takeRightWhile(${array}, ${predicate})",
        "doc": "var users = [\n  { 'user': 'barney',  'active': true },\n  { 'user': 'fred',    'active': false },\n  { 'user': 'pebbles', 'active': false }\n];\n\n_.takeRightWhile(users, function(o) { return !o.active; });\n// => objects for ['fred', 'pebbles']\n\n// The `_.matches` iteratee shorthand.\n_.takeRightWhile(users, { 'user': 'pebbles', 'active': false });\n// => objects for ['pebbles']\n\n// The `_.matchesProperty` iteratee shorthand.\n_.takeRightWhile(users, ['active', false]);\n// => objects for ['fred', 'pebbles']\n\n// The `_.property` iteratee shorthand.\n_.takeRightWhile(users, 'active');\n// => []\n\nCreates a slice of `array` with elements taken from the end. Elements are\ntaken until `predicate` returns falsey. The predicate is invoked with\nthree arguments: (value, index, array).",
        "grammar": "lsp",
        "label": "lodash-takerightwhile",
        "matches": [
          "lodash takerightwhile"
        ],
        "opts": []
      },
      {
        "content": "_.takeWhile(${array}, ${predicate})",
        "doc": "var users = [\n  { 'user': 'barney',  'active': false },\n  { 'user': 'fred',    'active': false },\n  { 'user': 'pebbles', 'active': true }\n];\n\n_.takeWhile(users, function(o) { return !o.active; });\n// => objects for ['barney', 'fred']\n\n// The `_.matches` iteratee shorthand.\n_.takeWhile(users, { 'user': 'barney', 'active': false });\n// => objects for ['barney']\n\n// The `_.matchesProperty` iteratee shorthand.\n_.takeWhile(users, ['active', false]);\n// => objects for ['barney', 'fred']\n\n// The `_.property` iteratee shorthand.\n_.takeWhile(users, 'active');\n// => []\n\nCreates a slice of `array` with elements taken from the beginning. Elements\nare taken until `predicate` returns falsey. The predicate is invoked with\nthree arguments: (value, index, array).",
        "grammar": "lsp",
        "label": "lodash-takewhile",
        "matches": [
          "lodash takewhile"
        ],
        "opts": []
      },
      {
        "content": "_.union(${arrays})",
        "doc": "_.union([2], [1, 2]);\n// => [2, 1]\n\nCreates an array of unique values, in order, from all given arrays using\n[`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\nfor equality comparisons.",
        "grammar": "lsp",
        "label": "lodash-union",
        "matches": [
          "lodash union"
        ],
        "opts": []
      },
      {
        "content": "_.unionBy(${arrays}, ${iteratee})",
        "doc": "_.unionBy([2.1], [1.2, 2.3], Math.floor);\n// => [2.1, 1.2]\n\n// The `_.property` iteratee shorthand.\n_.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n// => [{ 'x': 1 }, { 'x': 2 }]\n\nThis method is like `_.union` except that it accepts `iteratee` which is\ninvoked for each element of each `arrays` to generate the criterion by\nwhich uniqueness is computed. Result values are chosen from the first\narray in which the value occurs. The iteratee is invoked with one argument:\n(value).",
        "grammar": "lsp",
        "label": "lodash-unionby",
        "matches": [
          "lodash unionby"
        ],
        "opts": []
      },
      {
        "content": "_.unionWith(${arrays}, ${comparator})",
        "doc": "var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\nvar others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n\n_.unionWith(objects, others, _.isEqual);\n// => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n\nThis method is like `_.union` except that it accepts `comparator` which\nis invoked to compare elements of `arrays`. Result values are chosen from\nthe first array in which the value occurs. The comparator is invoked\nwith two arguments: (arrVal, othVal).",
        "grammar": "lsp",
        "label": "lodash-unionwith",
        "matches": [
          "lodash unionwith"
        ],
        "opts": []
      },
      {
        "content": "_.uniq(${array})",
        "doc": "_.uniq([2, 1, 2]);\n// => [2, 1]\n\nCreates a duplicate-free version of an array, using\n[`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\nfor equality comparisons, in which only the first occurrence of each element\nis kept. The order of result values is determined by the order they occur\nin the array.",
        "grammar": "lsp",
        "label": "lodash-uniq",
        "matches": [
          "lodash uniq"
        ],
        "opts": []
      },
      {
        "content": "_.uniqBy(${array}, ${iteratee})",
        "doc": "_.uniqBy([2.1, 1.2, 2.3], Math.floor);\n// => [2.1, 1.2]\n\n// The `_.property` iteratee shorthand.\n_.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n// => [{ 'x': 1 }, { 'x': 2 }]\n\nThis method is like `_.uniq` except that it accepts `iteratee` which is\ninvoked for each element in `array` to generate the criterion by which\nuniqueness is computed. The order of result values is determined by the\norder they occur in the array. The iteratee is invoked with one argument:\n(value).",
        "grammar": "lsp",
        "label": "lodash-uniqby",
        "matches": [
          "lodash uniqby"
        ],
        "opts": []
      },
      {
        "content": "_.uniqWith(${array}, ${comparator})",
        "doc": "var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];\n\n_.uniqWith(objects, _.isEqual);\n// => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]\n\nThis method is like `_.uniq` except that it accepts `comparator` which\nis invoked to compare elements of `array`. The order of result values is\ndetermined by the order they occur in the array.The comparator is invoked\nwith two arguments: (arrVal, othVal).",
        "grammar": "lsp",
        "label": "lodash-uniqwith",
        "matches": [
          "lodash uniqwith"
        ],
        "opts": []
      },
      {
        "content": "_.unzip(${array})",
        "doc": "var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);\n// => [['a', 1, true], ['b', 2, false]]\n\n_.unzip(zipped);\n// => [['a', 'b'], [1, 2], [true, false]]\n\nThis method is like `_.zip` except that it accepts an array of grouped\nelements and creates an array regrouping the elements to their pre-zip\nconfiguration.",
        "grammar": "lsp",
        "label": "lodash-unzip",
        "matches": [
          "lodash unzip"
        ],
        "opts": []
      },
      {
        "content": "_.unzipWith(${array}, ${iteratee})",
        "doc": "var zipped = _.zip([1, 2], [10, 20], [100, 200]);\n// => [[1, 10, 100], [2, 20, 200]]\n\n_.unzipWith(zipped, _.add);\n// => [3, 30, 300]\n\nThis method is like `_.unzip` except that it accepts `iteratee` to specify\nhow regrouped values should be combined. The iteratee is invoked with the\nelements of each group: (...group).",
        "grammar": "lsp",
        "label": "lodash-unzipwith",
        "matches": [
          "lodash unzipwith"
        ],
        "opts": []
      },
      {
        "content": "_.without(${array}, ${values})",
        "doc": "_.without([2, 1, 2, 3], 1, 2);\n// => [3]\n\nCreates an array excluding all given values using\n[`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\nfor equality comparisons.\n\n**Note:** Unlike `_.pull`, this method returns a new array.",
        "grammar": "lsp",
        "label": "lodash-without",
        "matches": [
          "lodash without"
        ],
        "opts": []
      },
      {
        "content": "_.xor(${arrays})",
        "doc": "_.xor([2, 1], [2, 3]);\n// => [1, 3]\n\nCreates an array of unique values that is the\n[symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\nof the given arrays. The order of result values is determined by the order\nthey occur in the arrays.",
        "grammar": "lsp",
        "label": "lodash-xor",
        "matches": [
          "lodash xor"
        ],
        "opts": []
      },
      {
        "content": "_.xorBy(${arrays}, ${iteratee})",
        "doc": "_.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n// => [1.2, 3.4]\n\n// The `_.property` iteratee shorthand.\n_.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n// => [{ 'x': 2 }]\n\nThis method is like `_.xor` except that it accepts `iteratee` which is\ninvoked for each element of each `arrays` to generate the criterion by\nwhich by which they're compared. The order of result values is determined\nby the order they occur in the arrays. The iteratee is invoked with one\nargument: (value).",
        "grammar": "lsp",
        "label": "lodash-xorby",
        "matches": [
          "lodash xorby"
        ],
        "opts": []
      },
      {
        "content": "_.xorWith(${arrays}, ${comparator})",
        "doc": "var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\nvar others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n\n_.xorWith(objects, others, _.isEqual);\n// => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n\nThis method is like `_.xor` except that it accepts `comparator` which is\ninvoked to compare elements of `arrays`. The order of result values is\ndetermined by the order they occur in the arrays. The comparator is invoked\nwith two arguments: (arrVal, othVal).",
        "grammar": "lsp",
        "label": "lodash-xorwith",
        "matches": [
          "lodash xorwith"
        ],
        "opts": []
      },
      {
        "content": "_.zip(${arrays})",
        "doc": "_.zip(['a', 'b'], [1, 2], [true, false]);\n// => [['a', 1, true], ['b', 2, false]]\n\nCreates an array of grouped elements, the first of which contains the\nfirst elements of the given arrays, the second of which contains the\nsecond elements of the given arrays, and so on.",
        "grammar": "lsp",
        "label": "lodash-zip",
        "matches": [
          "lodash zip"
        ],
        "opts": []
      },
      {
        "content": "_.zipObject(${props}, ${values})",
        "doc": "_.zipObject(['a', 'b'], [1, 2]);\n// => { 'a': 1, 'b': 2 }\n\nThis method is like `_.fromPairs` except that it accepts two arrays,\none of property identifiers and one of corresponding values.",
        "grammar": "lsp",
        "label": "lodash-zipobject",
        "matches": [
          "lodash zipobject"
        ],
        "opts": []
      },
      {
        "content": "_.zipObjectDeep(${props}, ${values})",
        "doc": "_.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);\n// => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }\n\nThis method is like `_.zipObject` except that it supports property paths.",
        "grammar": "lsp",
        "label": "lodash-zipobjectdeep",
        "matches": [
          "lodash zipobjectdeep"
        ],
        "opts": []
      },
      {
        "content": "_.zipWith(${arrays}, ${iteratee})",
        "doc": "_.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {\n  return a + b + c;\n});\n// => [1, 222]\n\nThis method is like `_.zip` except that it accepts `iteratee` to specify\nhow grouped values should be combined. The iteratee is invoked with the\nelements of each group: (...group).",
        "grammar": "lsp",
        "label": "lodash-zipwith",
        "matches": [
          "lodash zipwith"
        ],
        "opts": []
      },
      {
        "content": "_.chain()",
        "doc": "var users = [\n  { 'user': 'barney', 'age': 36 },\n  { 'user': 'fred',   'age': 40 }\n];\n\n// A sequence without explicit chaining.\n_(users).head();\n// => { 'user': 'barney', 'age': 36 }\n\n// A sequence with explicit chaining.\n_(users)\n  .chain()\n  .head()\n  .pick('user')\n  .value();\n// => { 'user': 'barney' }\n\nCreates a `lodash` wrapper instance with explicit method chain sequences enabled.",
        "grammar": "lsp",
        "label": "lodash-chain",
        "matches": [
          "lodash chain"
        ],
        "opts": []
      },
      {
        "content": "_.tap(${value}, ${interceptor})",
        "doc": "_([1, 2, 3])\n .tap(function(array) {\n   // Mutate input array.\n   array.pop();\n })\n .reverse()\n .value();\n// => [2, 1]\n\nThis method invokes `interceptor` and returns `value`. The interceptor\nis invoked with one argument; (value). The purpose of this method is to\n\"tap into\" a method chain sequence in order to modify intermediate results.",
        "grammar": "lsp",
        "label": "lodash-tap",
        "matches": [
          "lodash tap"
        ],
        "opts": []
      },
      {
        "content": "_.thru(${value}, ${interceptor})",
        "doc": "_('  abc  ')\n .chain()\n .trim()\n .thru(function(value) {\n   return [value];\n })\n .value();\n// => ['abc']\n\nThis method is like `_.tap` except that it returns the result of `interceptor`.\nThe purpose of this method is to \"pass thru\" values replacing intermediate\nresults in a method chain sequence.",
        "grammar": "lsp",
        "label": "lodash-thru",
        "matches": [
          "lodash thru"
        ],
        "opts": []
      },
      {
        "content": "_.at(${object}, ${paths})",
        "doc": "var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n\n_.at(object, ['a[0].b.c', 'a[1]']);\n// => [3, 4]\n\nCreates an array of values corresponding to `paths` of `object`.",
        "grammar": "lsp",
        "label": "lodash-at",
        "matches": [
          "lodash at"
        ],
        "opts": []
      },
      {
        "content": "_.commit()",
        "doc": "var array = [1, 2];\nvar wrapped = _(array).push(3);\n\nconsole.log(array);\n// => [1, 2]\n\nwrapped = wrapped.commit();\nconsole.log(array);\n// => [1, 2, 3]\n\nwrapped.last();\n// => 3\n\nconsole.log(array);\n// => [1, 2, 3]\n\nExecutes the chain sequence and returns the wrapped result.",
        "grammar": "lsp",
        "label": "lodash-commit",
        "matches": [
          "lodash commit"
        ],
        "opts": []
      },
      {
        "content": "_.next()",
        "doc": "var wrapped = _([1, 2]);\n\nwrapped.next();\n// => { 'done': false, 'value': 1 }\n\nwrapped.next();\n// => { 'done': false, 'value': 2 }\n\nwrapped.next();\n// => { 'done': true, 'value': undefined }\n\nGets the next value on a wrapped object following the\n[iterator protocol](https://mdn.io/iteration_protocols#iterator).",
        "grammar": "lsp",
        "label": "lodash-next",
        "matches": [
          "lodash next"
        ],
        "opts": []
      },
      {
        "content": "_.plant(${value})",
        "doc": "function square(n) {\n  return n * n;\n}\n\nvar wrapped = _([1, 2]).map(square);\nvar other = wrapped.plant([3, 4]);\n\nother.value();\n// => [9, 16]\n\nwrapped.value();\n// => [1, 4]\n\nCreates a clone of the chain sequence planting `value` as the wrapped value.",
        "grammar": "lsp",
        "label": "lodash-plant",
        "matches": [
          "lodash plant"
        ],
        "opts": []
      },
      {
        "content": "_.value()",
        "doc": "_([1, 2, 3]).value();\n// => [1, 2, 3]\n\nExecutes the chain sequence to resolve the unwrapped value.",
        "grammar": "lsp",
        "label": "lodash-value",
        "matches": [
          "lodash value"
        ],
        "opts": []
      },
      {
        "content": "_.countBy(${collection}, ${iteratee})",
        "doc": "_.countBy([6.1, 4.2, 6.3], Math.floor);\n// => { '4': 1, '6': 2 }\n\n// The `_.property` iteratee shorthand.\n_.countBy(['one', 'two', 'three'], 'length');\n// => { '3': 2, '5': 1 }\n\nCreates an object composed of keys generated from the results of running\neach element of `collection` thru `iteratee`. The corresponding value of\neach key is the number of times the key was returned by `iteratee`. The\niteratee is invoked with one argument: (value).",
        "grammar": "lsp",
        "label": "lodash-countby",
        "matches": [
          "lodash countby"
        ],
        "opts": []
      },
      {
        "content": "_.every(${collection}, ${predicate})",
        "doc": "_.every([true, 1, null, 'yes'], Boolean);\n// => false\n\nvar users = [\n  { 'user': 'barney', 'age': 36, 'active': false },\n  { 'user': 'fred',   'age': 40, 'active': false }\n];\n\n// The `_.matches` iteratee shorthand.\n_.every(users, { 'user': 'barney', 'active': false });\n// => false\n\n// The `_.matchesProperty` iteratee shorthand.\n_.every(users, ['active', false]);\n// => true\n\n// The `_.property` iteratee shorthand.\n_.every(users, 'active');\n// => false\n\nChecks if `predicate` returns truthy for **all** elements of `collection`.\nIteration is stopped once `predicate` returns falsey. The predicate is\ninvoked with three arguments: (value, index|key, collection).\n\n**Note:** This method returns `true` for\n[empty collections](https://en.wikipedia.org/wiki/Empty_set) because\n[everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\nelements of empty collections.",
        "grammar": "lsp",
        "label": "lodash-every",
        "matches": [
          "lodash every"
        ],
        "opts": []
      },
      {
        "content": "_.filter(${collection}, ${predicate})",
        "doc": "var users = [\n  { 'user': 'barney', 'age': 36, 'active': true },\n  { 'user': 'fred',   'age': 40, 'active': false }\n];\n\n_.filter(users, function(o) { return !o.active; });\n// => objects for ['fred']\n\n// The `_.matches` iteratee shorthand.\n_.filter(users, { 'age': 36, 'active': true });\n// => objects for ['barney']\n\n// The `_.matchesProperty` iteratee shorthand.\n_.filter(users, ['active', false]);\n// => objects for ['fred']\n\n// The `_.property` iteratee shorthand.\n_.filter(users, 'active');\n// => objects for ['barney']\n\nIterates over elements of `collection`, returning an array of all elements\n`predicate` returns truthy for. The predicate is invoked with three\narguments: (value, index|key, collection).\n\n**Note:** Unlike `_.remove`, this method returns a new array.",
        "grammar": "lsp",
        "label": "lodash-filter",
        "matches": [
          "lodash filter"
        ],
        "opts": []
      },
      {
        "content": "_.find(${collection}, ${predicate}, ${fromIndex})",
        "doc": "var users = [\n  { 'user': 'barney',  'age': 36, 'active': true },\n  { 'user': 'fred',    'age': 40, 'active': false },\n  { 'user': 'pebbles', 'age': 1,  'active': true }\n];\n\n_.find(users, function(o) { return o.age < 40; });\n// => object for 'barney'\n\n// The `_.matches` iteratee shorthand.\n_.find(users, { 'age': 1, 'active': true });\n// => object for 'pebbles'\n\n// The `_.matchesProperty` iteratee shorthand.\n_.find(users, ['active', false]);\n// => object for 'fred'\n\n// The `_.property` iteratee shorthand.\n_.find(users, 'active');\n// => object for 'barney'\n\nIterates over elements of `collection`, returning the first element\n`predicate` returns truthy for. The predicate is invoked with three\narguments: (value, index|key, collection).",
        "grammar": "lsp",
        "label": "lodash-find",
        "matches": [
          "lodash find"
        ],
        "opts": []
      },
      {
        "content": "_.findLast(${collection}, ${predicate}, ${fromIndex})",
        "doc": "_.findLast([1, 2, 3, 4], function(n) {\n  return n % 2 == 1;\n});\n// => 3\n\nThis method is like `_.find` except that it iterates over elements of\n`collection` from right to left.",
        "grammar": "lsp",
        "label": "lodash-findlast",
        "matches": [
          "lodash findlast"
        ],
        "opts": []
      },
      {
        "content": "_.flatMap(${collection}, ${iteratee})",
        "doc": "function duplicate(n) {\n  return [n, n];\n}\n\n_.flatMap([1, 2], duplicate);\n// => [1, 1, 2, 2]\n\nCreates a flattened array of values by running each element in `collection`\nthru `iteratee` and flattening the mapped results. The iteratee is invoked\nwith three arguments: (value, index|key, collection).",
        "grammar": "lsp",
        "label": "lodash-flatmap",
        "matches": [
          "lodash flatmap"
        ],
        "opts": []
      },
      {
        "content": "_.flatMapDeep(${collection}, ${iteratee})",
        "doc": "function duplicate(n) {\n  return [[[n, n]]];\n}\n\n_.flatMapDeep([1, 2], duplicate);\n// => [1, 1, 2, 2]\n\nThis method is like `_.flatMap` except that it recursively flattens the\nmapped results.",
        "grammar": "lsp",
        "label": "lodash-flatmapdeep",
        "matches": [
          "lodash flatmapdeep"
        ],
        "opts": []
      },
      {
        "content": "_.flatMapDepth(${collection}, ${iteratee}, ${depth})",
        "doc": "function duplicate(n) {\n  return [[[n, n]]];\n}\n\n_.flatMapDepth([1, 2], duplicate, 2);\n// => [[1, 1], [2, 2]]\n\nThis method is like `_.flatMap` except that it recursively flattens the\nmapped results up to `depth` times.",
        "grammar": "lsp",
        "label": "lodash-flatmapdepth",
        "matches": [
          "lodash flatmapdepth"
        ],
        "opts": []
      },
      {
        "content": "_.each(${collection}, ${iteratee})",
        "doc": "_.forEach([1, 2], function(value) {\n  console.log(value);\n});\n// => Logs `1` then `2`.\n\n_.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n  console.log(key);\n});\n// => Logs 'a' then 'b' (iteration order is not guaranteed).\n\nIterates over elements of `collection` and invokes `iteratee` for each element.\nThe iteratee is invoked with three arguments: (value, index|key, collection).\nIteratee functions may exit iteration early by explicitly returning `false`.\n\n**Note:** As with other \"Collections\" methods, objects with a \"length\"\nproperty are iterated like arrays. To avoid this behavior use `_.forIn`\nor `_.forOwn` for object iteration.",
        "grammar": "lsp",
        "label": "lodash-each",
        "matches": [
          "lodash each"
        ],
        "opts": []
      },
      {
        "content": "_.eachRight(${collection}, ${iteratee})",
        "doc": "_.forEachRight([1, 2], function(value) {\n  console.log(value);\n});\n// => Logs `2` then `1`.\n\nThis method is like `_.forEach` except that it iterates over elements of\n`collection` from right to left.",
        "grammar": "lsp",
        "label": "lodash-eachright",
        "matches": [
          "lodash eachright"
        ],
        "opts": []
      },
      {
        "content": "_.groupBy(${collection}, ${iteratee})",
        "doc": "_.groupBy([6.1, 4.2, 6.3], Math.floor);\n// => { '4': [4.2], '6': [6.1, 6.3] }\n\n// The `_.property` iteratee shorthand.\n_.groupBy(['one', 'two', 'three'], 'length');\n// => { '3': ['one', 'two'], '5': ['three'] }\n\nCreates an object composed of keys generated from the results of running\neach element of `collection` thru `iteratee`. The order of grouped values\nis determined by the order they occur in `collection`. The corresponding\nvalue of each key is an array of elements responsible for generating the\nkey. The iteratee is invoked with one argument: (value).",
        "grammar": "lsp",
        "label": "lodash-groupby",
        "matches": [
          "lodash groupby"
        ],
        "opts": []
      },
      {
        "content": "_.includes(${collection}, ${value}, ${fromIndex})",
        "doc": "_.includes([1, 2, 3], 1);\n// => true\n\n_.includes([1, 2, 3], 1, 2);\n// => false\n\n_.includes({ 'a': 1, 'b': 2 }, 1);\n// => true\n\n_.includes('abcd', 'bc');\n// => true\n\nChecks if `value` is in `collection`. If `collection` is a string, it's\nchecked for a substring of `value`, otherwise\n[`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\nis used for equality comparisons. If `fromIndex` is negative, it's used as\nthe offset from the end of `collection`.",
        "grammar": "lsp",
        "label": "lodash-includes",
        "matches": [
          "lodash includes"
        ],
        "opts": []
      },
      {
        "content": "_.invokeMap(${collection}, ${path}, ${args})",
        "doc": "_.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');\n// => [[1, 5, 7], [1, 2, 3]]\n\n_.invokeMap([123, 456], String.prototype.split, '');\n// => [['1', '2', '3'], ['4', '5', '6']]\n\nInvokes the method at `path` of each element in `collection`, returning\nan array of the results of each invoked method. Any additional arguments\nare provided to each invoked method. If `path` is a function, it's invoked\nfor, and `this` bound to, each element in `collection`.",
        "grammar": "lsp",
        "label": "lodash-invokemap",
        "matches": [
          "lodash invokemap"
        ],
        "opts": []
      },
      {
        "content": "_.keyBy(${collection}, ${iteratee})",
        "doc": "var array = [\n  { 'dir': 'left', 'code': 97 },\n  { 'dir': 'right', 'code': 100 }\n];\n\n_.keyBy(array, function(o) {\n  return String.fromCharCode(o.code);\n});\n// => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n\n_.keyBy(array, 'dir');\n// => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n\nCreates an object composed of keys generated from the results of running\neach element of `collection` thru `iteratee`. The corresponding value of\neach key is the last element responsible for generating the key. The\niteratee is invoked with one argument: (value).",
        "grammar": "lsp",
        "label": "lodash-keyby",
        "matches": [
          "lodash keyby"
        ],
        "opts": []
      },
      {
        "content": "_.map(${collection}, ${iteratee})",
        "doc": "function square(n) {\n  return n * n;\n}\n\n_.map([4, 8], square);\n// => [16, 64]\n\n_.map({ 'a': 4, 'b': 8 }, square);\n// => [16, 64] (iteration order is not guaranteed)\n\nvar users = [\n  { 'user': 'barney' },\n  { 'user': 'fred' }\n];\n\n// The `_.property` iteratee shorthand.\n_.map(users, 'user');\n// => ['barney', 'fred']\n\nCreates an array of values by running each element in `collection` thru\n`iteratee`. The iteratee is invoked with three arguments:\n(value, index|key, collection).\n\nMany lodash methods are guarded to work as iteratees for methods like\n`_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n\nThe guarded methods are:\n`ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n`fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n`sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n`template`, `trim`, `trimEnd`, `trimStart`, and `words`",
        "grammar": "lsp",
        "label": "lodash-map",
        "matches": [
          "lodash map"
        ],
        "opts": []
      },
      {
        "content": "_.orderBy(${collection}, ${iteratees}, ${orders})",
        "doc": "var users = [\n  { 'user': 'fred',   'age': 48 },\n  { 'user': 'barney', 'age': 34 },\n  { 'user': 'fred',   'age': 40 },\n  { 'user': 'barney', 'age': 36 }\n];\n\n// Sort by `user` in ascending order and by `age` in descending order.\n_.orderBy(users, ['user', 'age'], ['asc', 'desc']);\n// => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n\nThis method is like `_.sortBy` except that it allows specifying the sort\norders of the iteratees to sort by. If `orders` is unspecified, all values\nare sorted in ascending order. Otherwise, specify an order of \"desc\" for\ndescending or \"asc\" for ascending sort order of corresponding values.",
        "grammar": "lsp",
        "label": "lodash-orderby",
        "matches": [
          "lodash orderby"
        ],
        "opts": []
      },
      {
        "content": "_.partition(${collection}, ${predicate})",
        "doc": "var users = [\n  { 'user': 'barney',  'age': 36, 'active': false },\n  { 'user': 'fred',    'age': 40, 'active': true },\n  { 'user': 'pebbles', 'age': 1,  'active': false }\n];\n\n_.partition(users, function(o) { return o.active; });\n// => objects for [['fred'], ['barney', 'pebbles']]\n\n// The `_.matches` iteratee shorthand.\n_.partition(users, { 'age': 1, 'active': false });\n// => objects for [['pebbles'], ['barney', 'fred']]\n\n// The `_.matchesProperty` iteratee shorthand.\n_.partition(users, ['active', false]);\n// => objects for [['barney', 'pebbles'], ['fred']]\n\n// The `_.property` iteratee shorthand.\n_.partition(users, 'active');\n// => objects for [['fred'], ['barney', 'pebbles']]\n\nCreates an array of elements split into two groups, the first of which\ncontains elements `predicate` returns truthy for, the second of which\ncontains elements `predicate` returns falsey for. The predicate is\ninvoked with one argument: (value).",
        "grammar": "lsp",
        "label": "lodash-partition",
        "matches": [
          "lodash partition"
        ],
        "opts": []
      },
      {
        "content": "_.reduce(${collection}, ${iteratee}, ${accumulator})",
        "doc": "_.reduce([1, 2], function(sum, n) {\n  return sum + n;\n}, 0);\n// => 3\n\n_.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n  (result[value] || (result[value] = [])).push(key);\n  return result;\n}, {});\n// => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n\nReduces `collection` to a value which is the accumulated result of running\neach element in `collection` thru `iteratee`, where each successive\ninvocation is supplied the return value of the previous. If `accumulator`\nis not given, the first element of `collection` is used as the initial\nvalue. The iteratee is invoked with four arguments:\n(accumulator, value, index|key, collection).\n\nMany lodash methods are guarded to work as iteratees for methods like\n`_.reduce`, `_.reduceRight`, and `_.transform`.\n\nThe guarded methods are:\n`assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\nand `sortBy`",
        "grammar": "lsp",
        "label": "lodash-reduce",
        "matches": [
          "lodash reduce"
        ],
        "opts": []
      },
      {
        "content": "_.reduceRight(${collection}, ${iteratee}, ${accumulator})",
        "doc": "var array = [[0, 1], [2, 3], [4, 5]];\n\n_.reduceRight(array, function(flattened, other) {\n  return flattened.concat(other);\n}, []);\n// => [4, 5, 2, 3, 0, 1]\n\nThis method is like `_.reduce` except that it iterates over elements of\n`collection` from right to left.",
        "grammar": "lsp",
        "label": "lodash-reduceright",
        "matches": [
          "lodash reduceright"
        ],
        "opts": []
      },
      {
        "content": "_.reject(${collection}, ${predicate})",
        "doc": "var users = [\n  { 'user': 'barney', 'age': 36, 'active': false },\n  { 'user': 'fred',   'age': 40, 'active': true }\n];\n\n_.reject(users, function(o) { return !o.active; });\n// => objects for ['fred']\n\n// The `_.matches` iteratee shorthand.\n_.reject(users, { 'age': 40, 'active': true });\n// => objects for ['barney']\n\n// The `_.matchesProperty` iteratee shorthand.\n_.reject(users, ['active', false]);\n// => objects for ['fred']\n\n// The `_.property` iteratee shorthand.\n_.reject(users, 'active');\n// => objects for ['barney']\n\nThe opposite of `_.filter`; this method returns the elements of `collection`\nthat `predicate` does **not** return truthy for.",
        "grammar": "lsp",
        "label": "lodash-reject",
        "matches": [
          "lodash reject"
        ],
        "opts": []
      },
      {
        "content": "_.sample(${collection})",
        "doc": "_.sample([1, 2, 3, 4]);\n// => 2\n\nGets a random element from `collection`.",
        "grammar": "lsp",
        "label": "lodash-sample",
        "matches": [
          "lodash sample"
        ],
        "opts": []
      },
      {
        "content": "_.sampleSize(${collection}, ${n})",
        "doc": "_.sampleSize([1, 2, 3], 2);\n// => [3, 1]\n\n_.sampleSize([1, 2, 3], 4);\n// => [2, 3, 1]\n\nGets `n` random elements at unique keys from `collection` up to the\nsize of `collection`.",
        "grammar": "lsp",
        "label": "lodash-samplesize",
        "matches": [
          "lodash samplesize"
        ],
        "opts": []
      },
      {
        "content": "_.shuffle(${collection})",
        "doc": "_.shuffle([1, 2, 3, 4]);\n// => [4, 1, 3, 2]\n\nCreates an array of shuffled values, using a version of the\n[Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).",
        "grammar": "lsp",
        "label": "lodash-shuffle",
        "matches": [
          "lodash shuffle"
        ],
        "opts": []
      },
      {
        "content": "_.size(${collection})",
        "doc": "_.size([1, 2, 3]);\n// => 3\n\n_.size({ 'a': 1, 'b': 2 });\n// => 2\n\n_.size('pebbles');\n// => 7\n\nGets the size of `collection` by returning its length for array-like\nvalues or the number of own enumerable string keyed properties for objects.",
        "grammar": "lsp",
        "label": "lodash-size",
        "matches": [
          "lodash size"
        ],
        "opts": []
      },
      {
        "content": "_.some(${collection}, ${predicate})",
        "doc": "_.some([null, 0, 'yes', false], Boolean);\n// => true\n\nvar users = [\n  { 'user': 'barney', 'active': true },\n  { 'user': 'fred',   'active': false }\n];\n\n// The `_.matches` iteratee shorthand.\n_.some(users, { 'user': 'barney', 'active': false });\n// => false\n\n// The `_.matchesProperty` iteratee shorthand.\n_.some(users, ['active', false]);\n// => true\n\n// The `_.property` iteratee shorthand.\n_.some(users, 'active');\n// => true\n\nChecks if `predicate` returns truthy for **any** element of `collection`.\nIteration is stopped once `predicate` returns truthy. The predicate is\ninvoked with three arguments: (value, index|key, collection).",
        "grammar": "lsp",
        "label": "lodash-some",
        "matches": [
          "lodash some"
        ],
        "opts": []
      },
      {
        "content": "_.sortBy(${collection}, ${iteratees})",
        "doc": "var users = [\n  { 'user': 'fred',   'age': 48 },\n  { 'user': 'barney', 'age': 36 },\n  { 'user': 'fred',   'age': 40 },\n  { 'user': 'barney', 'age': 34 }\n];\n\n_.sortBy(users, [function(o) { return o.user; }]);\n// => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n\n_.sortBy(users, ['user', 'age']);\n// => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]\n\nCreates an array of elements, sorted in ascending order by the results of\nrunning each element in a collection thru each iteratee. This method\nperforms a stable sort, that is, it preserves the original sort order of\nequal elements. The iteratees are invoked with one argument: (value).",
        "grammar": "lsp",
        "label": "lodash-sortby",
        "matches": [
          "lodash sortby"
        ],
        "opts": []
      },
      {
        "content": "_.now()",
        "doc": "_.defer(function(stamp) {\n  console.log(_.now() - stamp);\n}, _.now());\n// => Logs the number of milliseconds it took for the deferred invocation.\n\nGets the timestamp of the number of milliseconds that have elapsed since\nthe Unix epoch (1 January 1970 00:00:00 UTC).",
        "grammar": "lsp",
        "label": "lodash-now",
        "matches": [
          "lodash now"
        ],
        "opts": []
      },
      {
        "content": "_.after(${n}, ${func})",
        "doc": "var saves = ['profile', 'settings'];\n\nvar done = _.after(saves.length, function() {\n  console.log('done saving!');\n});\n\n_.forEach(saves, function(type) {\n  asyncSave({ 'type': type, 'complete': done });\n});\n// => Logs 'done saving!' after the two async saves have completed.\n\nThe opposite of `_.before`; this method creates a function that invokes\n`func` once it's called `n` or more times.",
        "grammar": "lsp",
        "label": "lodash-after",
        "matches": [
          "lodash after"
        ],
        "opts": []
      },
      {
        "content": "_.ary(${func}, ${n})",
        "doc": "_.map(['6', '8', '10'], _.ary(parseInt, 1));\n// => [6, 8, 10]\n\nCreates a function that invokes `func`, with up to `n` arguments,\nignoring any additional arguments.",
        "grammar": "lsp",
        "label": "lodash-ary",
        "matches": [
          "lodash ary"
        ],
        "opts": []
      },
      {
        "content": "_.before(${n}, ${func})",
        "doc": "jQuery(element).on('click', _.before(5, addContactToList));\n// => Allows adding up to 4 contacts to the list.\n\nCreates a function that invokes `func`, with the `this` binding and arguments\nof the created function, while it's called less than `n` times. Subsequent\ncalls to the created function return the result of the last `func` invocation.",
        "grammar": "lsp",
        "label": "lodash-before",
        "matches": [
          "lodash before"
        ],
        "opts": []
      },
      {
        "content": "_.bind(${func}, ${thisArg}, ${partials})",
        "doc": "function greet(greeting, punctuation) {\n  return greeting + ' ' + this.user + punctuation;\n}\n\nvar object = { 'user': 'fred' };\n\nvar bound = _.bind(greet, object, 'hi');\nbound('!');\n// => 'hi fred!'\n\n// Bound with placeholders.\nvar bound = _.bind(greet, object, _, '!');\nbound('hi');\n// => 'hi fred!'\n\nCreates a function that invokes `func` with the `this` binding of `thisArg`\nand `partials` prepended to the arguments it receives.\n\nThe `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\nmay be used as a placeholder for partially applied arguments.\n\n**Note:** Unlike native `Function#bind`, this method doesn't set the \"length\"\nproperty of bound functions.",
        "grammar": "lsp",
        "label": "lodash-bind",
        "matches": [
          "lodash bind"
        ],
        "opts": []
      },
      {
        "content": "_.bindKey(${object}, ${key}, ${partials})",
        "doc": "var object = {\n  'user': 'fred',\n  'greet': function(greeting, punctuation) {\n    return greeting + ' ' + this.user + punctuation;\n  }\n};\n\nvar bound = _.bindKey(object, 'greet', 'hi');\nbound('!');\n// => 'hi fred!'\n\nobject.greet = function(greeting, punctuation) {\n  return greeting + 'ya ' + this.user + punctuation;\n};\n\nbound('!');\n// => 'hiya fred!'\n\n// Bound with placeholders.\nvar bound = _.bindKey(object, 'greet', _, '!');\nbound('hi');\n// => 'hiya fred!'\n\nCreates a function that invokes the method at `object[key]` with `partials`\nprepended to the arguments it receives.\n\nThis method differs from `_.bind` by allowing bound functions to reference\nmethods that may be redefined or don't yet exist. See\n[Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)\nfor more details.\n\nThe `_.bindKey.placeholder` value, which defaults to `_` in monolithic\nbuilds, may be used as a placeholder for partially applied arguments.",
        "grammar": "lsp",
        "label": "lodash-bindkey",
        "matches": [
          "lodash bindkey"
        ],
        "opts": []
      },
      {
        "content": "_.curry(${func}, ${arity})",
        "doc": "var abc = function(a, b, c) {\n  return [a, b, c];\n};\n\nvar curried = _.curry(abc);\n\ncurried(1)(2)(3);\n// => [1, 2, 3]\n\ncurried(1, 2)(3);\n// => [1, 2, 3]\n\ncurried(1, 2, 3);\n// => [1, 2, 3]\n\n// Curried with placeholders.\ncurried(1)(_, 3)(2);\n// => [1, 2, 3]\n\nCreates a function that accepts arguments of `func` and either invokes\n`func` returning its result, if at least `arity` number of arguments have\nbeen provided, or returns a function that accepts the remaining `func`\narguments, and so on. The arity of `func` may be specified if `func.length`\nis not sufficient.\n\nThe `_.curry.placeholder` value, which defaults to `_` in monolithic builds,\nmay be used as a placeholder for provided arguments.\n\n**Note:** This method doesn't set the \"length\" property of curried functions.",
        "grammar": "lsp",
        "label": "lodash-curry",
        "matches": [
          "lodash curry"
        ],
        "opts": []
      },
      {
        "content": "_.curryRight(${func}, ${arity})",
        "doc": "var abc = function(a, b, c) {\n  return [a, b, c];\n};\n\nvar curried = _.curryRight(abc);\n\ncurried(3)(2)(1);\n// => [1, 2, 3]\n\ncurried(2, 3)(1);\n// => [1, 2, 3]\n\ncurried(1, 2, 3);\n// => [1, 2, 3]\n\n// Curried with placeholders.\ncurried(3)(1, _)(2);\n// => [1, 2, 3]\n\nThis method is like `_.curry` except that arguments are applied to `func`\nin the manner of `_.partialRight` instead of `_.partial`.\n\nThe `_.curryRight.placeholder` value, which defaults to `_` in monolithic\nbuilds, may be used as a placeholder for provided arguments.\n\n**Note:** This method doesn't set the \"length\" property of curried functions.",
        "grammar": "lsp",
        "label": "lodash-curryright",
        "matches": [
          "lodash curryright"
        ],
        "opts": []
      },
      {
        "content": "_.debounce(${func}, ${wait}, ${options}, ${options.leading}, ${options.maxWait}, ${options.trailing})",
        "doc": "// Avoid costly calculations while the window size is in flux.\njQuery(window).on('resize', _.debounce(calculateLayout, 150));\n\n// Invoke `sendMail` when clicked, debouncing subsequent calls.\njQuery(element).on('click', _.debounce(sendMail, 300, {\n  'leading': true,\n  'trailing': false\n}));\n\n// Ensure `batchLog` is invoked once after 1 second of debounced calls.\nvar debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\nvar source = new EventSource('/stream');\njQuery(source).on('message', debounced);\n\n// Cancel the trailing debounced invocation.\njQuery(window).on('popstate', debounced.cancel);\n\nCreates a debounced function that delays invoking `func` until after `wait`\nmilliseconds have elapsed since the last time the debounced function was\ninvoked. The debounced function comes with a `cancel` method to cancel\ndelayed `func` invocations and a `flush` method to immediately invoke them.\nProvide `options` to indicate whether `func` should be invoked on the\nleading and/or trailing edge of the `wait` timeout. The `func` is invoked\nwith the last arguments provided to the debounced function. Subsequent\ncalls to the debounced function return the result of the last `func`\ninvocation.\n\n**Note:** If `leading` and `trailing` options are `true`, `func` is\ninvoked on the trailing edge of the timeout only if the debounced function\nis invoked more than once during the `wait` timeout.\n\nIf `wait` is `0` and `leading` is `false`, `func` invocation is deferred\nuntil to the next tick, similar to `setTimeout` with a timeout of `0`.\n\nSee [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\nfor details over the differences between `_.debounce` and `_.throttle`.",
        "grammar": "lsp",
        "label": "lodash-debounce",
        "matches": [
          "lodash debounce"
        ],
        "opts": []
      },
      {
        "content": "_.defer(${func}, ${args})",
        "doc": "_.defer(function(text) {\n  console.log(text);\n}, 'deferred');\n// => Logs 'deferred' after one millisecond.\n\nDefers invoking the `func` until the current call stack has cleared. Any\nadditional arguments are provided to `func` when it's invoked.",
        "grammar": "lsp",
        "label": "lodash-defer",
        "matches": [
          "lodash defer"
        ],
        "opts": []
      },
      {
        "content": "_.delay(${func}, ${wait}, ${args})",
        "doc": "_.delay(function(text) {\n  console.log(text);\n}, 1000, 'later');\n// => Logs 'later' after one second.\n\nInvokes `func` after `wait` milliseconds. Any additional arguments are\nprovided to `func` when it's invoked.",
        "grammar": "lsp",
        "label": "lodash-delay",
        "matches": [
          "lodash delay"
        ],
        "opts": []
      },
      {
        "content": "_.flip(${func})",
        "doc": "var flipped = _.flip(function() {\n  return _.toArray(arguments);\n});\n\nflipped('a', 'b', 'c', 'd');\n// => ['d', 'c', 'b', 'a']\n\nCreates a function that invokes `func` with arguments reversed.",
        "grammar": "lsp",
        "label": "lodash-flip",
        "matches": [
          "lodash flip"
        ],
        "opts": []
      },
      {
        "content": "_.memoize(${func}, ${resolver})",
        "doc": "var object = { 'a': 1, 'b': 2 };\nvar other = { 'c': 3, 'd': 4 };\n\nvar values = _.memoize(_.values);\nvalues(object);\n// => [1, 2]\n\nvalues(other);\n// => [3, 4]\n\nobject.a = 2;\nvalues(object);\n// => [1, 2]\n\n// Modify the result cache.\nvalues.cache.set(object, ['a', 'b']);\nvalues(object);\n// => ['a', 'b']\n\n// Replace `_.memoize.Cache`.\n_.memoize.Cache = WeakMap;\n\nCreates a function that memoizes the result of `func`. If `resolver` is\nprovided, it determines the cache key for storing the result based on the\narguments provided to the memoized function. By default, the first argument\nprovided to the memoized function is used as the map cache key. The `func`\nis invoked with the `this` binding of the memoized function.\n\n**Note:** The cache is exposed as the `cache` property on the memoized\nfunction. Its creation may be customized by replacing the `_.memoize.Cache`\nconstructor with one whose instances implement the\n[`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\nmethod interface of `clear`, `delete`, `get`, `has`, and `set`.",
        "grammar": "lsp",
        "label": "lodash-memoize",
        "matches": [
          "lodash memoize"
        ],
        "opts": []
      },
      {
        "content": "_.negate(${predicate})",
        "doc": "function isEven(n) {\n  return n % 2 == 0;\n}\n\n_.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n// => [1, 3, 5]\n\nCreates a function that negates the result of the predicate `func`. The\n`func` predicate is invoked with the `this` binding and arguments of the\ncreated function.",
        "grammar": "lsp",
        "label": "lodash-negate",
        "matches": [
          "lodash negate"
        ],
        "opts": []
      },
      {
        "content": "_.once(${func})",
        "doc": "var initialize = _.once(createApplication);\ninitialize();\ninitialize();\n// => `createApplication` is invoked once\n\nCreates a function that is restricted to invoking `func` once. Repeat calls\nto the function return the value of the first invocation. The `func` is\ninvoked with the `this` binding and arguments of the created function.",
        "grammar": "lsp",
        "label": "lodash-once",
        "matches": [
          "lodash once"
        ],
        "opts": []
      },
      {
        "content": "_.overArgs(${func}, ${transforms})",
        "doc": "function doubled(n) {\n  return n * 2;\n}\n\nfunction square(n) {\n  return n * n;\n}\n\nvar func = _.overArgs(function(x, y) {\n  return [x, y];\n}, [square, doubled]);\n\nfunc(9, 3);\n// => [81, 6]\n\nfunc(10, 5);\n// => [100, 10]\n\nCreates a function that invokes `func` with its arguments transformed.",
        "grammar": "lsp",
        "label": "lodash-overargs",
        "matches": [
          "lodash overargs"
        ],
        "opts": []
      },
      {
        "content": "_.partial(${func}, ${partials})",
        "doc": "function greet(greeting, name) {\n  return greeting + ' ' + name;\n}\n\nvar sayHelloTo = _.partial(greet, 'hello');\nsayHelloTo('fred');\n// => 'hello fred'\n\n// Partially applied with placeholders.\nvar greetFred = _.partial(greet, _, 'fred');\ngreetFred('hi');\n// => 'hi fred'\n\nCreates a function that invokes `func` with `partials` prepended to the\narguments it receives. This method is like `_.bind` except it does **not**\nalter the `this` binding.\n\nThe `_.partial.placeholder` value, which defaults to `_` in monolithic\nbuilds, may be used as a placeholder for partially applied arguments.\n\n**Note:** This method doesn't set the \"length\" property of partially\napplied functions.",
        "grammar": "lsp",
        "label": "lodash-partial",
        "matches": [
          "lodash partial"
        ],
        "opts": []
      },
      {
        "content": "_.partialRight(${func}, ${partials})",
        "doc": "function greet(greeting, name) {\n  return greeting + ' ' + name;\n}\n\nvar greetFred = _.partialRight(greet, 'fred');\ngreetFred('hi');\n// => 'hi fred'\n\n// Partially applied with placeholders.\nvar sayHelloTo = _.partialRight(greet, 'hello', _);\nsayHelloTo('fred');\n// => 'hello fred'\n\nThis method is like `_.partial` except that partially applied arguments\nare appended to the arguments it receives.\n\nThe `_.partialRight.placeholder` value, which defaults to `_` in monolithic\nbuilds, may be used as a placeholder for partially applied arguments.\n\n**Note:** This method doesn't set the \"length\" property of partially\napplied functions.",
        "grammar": "lsp",
        "label": "lodash-partialright",
        "matches": [
          "lodash partialright"
        ],
        "opts": []
      },
      {
        "content": "_.rearg(${func}, ${indexes})",
        "doc": "var rearged = _.rearg(function(a, b, c) {\n  return [a, b, c];\n}, [2, 0, 1]);\n\nrearged('b', 'c', 'a')\n// => ['a', 'b', 'c']\n\nCreates a function that invokes `func` with arguments arranged according\nto the specified `indexes` where the argument value at the first index is\nprovided as the first argument, the argument value at the second index is\nprovided as the second argument, and so on.",
        "grammar": "lsp",
        "label": "lodash-rearg",
        "matches": [
          "lodash rearg"
        ],
        "opts": []
      },
      {
        "content": "_.rest(${func}, ${start})",
        "doc": "var say = _.rest(function(what, names) {\n  return what + ' ' + _.initial(names).join(', ') +\n    (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n});\n\nsay('hello', 'fred', 'barney', 'pebbles');\n// => 'hello fred, barney, & pebbles'\n\nCreates a function that invokes `func` with the `this` binding of the\ncreated function and arguments from `start` and beyond provided as\nan array.\n\n**Note:** This method is based on the\n[rest parameter](https://mdn.io/rest_parameters).",
        "grammar": "lsp",
        "label": "lodash-rest",
        "matches": [
          "lodash rest"
        ],
        "opts": []
      },
      {
        "content": "_.spread(${func}, ${start})",
        "doc": "var say = _.spread(function(who, what) {\n  return who + ' says ' + what;\n});\n\nsay(['fred', 'hello']);\n// => 'fred says hello'\n\nvar numbers = Promise.all([\n  Promise.resolve(40),\n  Promise.resolve(36)\n]);\n\nnumbers.then(_.spread(function(x, y) {\n  return x + y;\n}));\n// => a Promise of 76\n\nCreates a function that invokes `func` with the `this` binding of the\ncreate function and an array of arguments much like\n[`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).\n\n**Note:** This method is based on the\n[spread operator](https://mdn.io/spread_operator).",
        "grammar": "lsp",
        "label": "lodash-spread",
        "matches": [
          "lodash spread"
        ],
        "opts": []
      },
      {
        "content": "_.throttle(${func}, ${wait}, ${options}, ${options.leading}, ${options.trailing})",
        "doc": "// Avoid excessively updating the position while scrolling.\njQuery(window).on('scroll', _.throttle(updatePosition, 100));\n\n// Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\nvar throttled = _.throttle(renewToken, 300000, { 'trailing': false });\njQuery(element).on('click', throttled);\n\n// Cancel the trailing throttled invocation.\njQuery(window).on('popstate', throttled.cancel);\n\nCreates a throttled function that only invokes `func` at most once per\nevery `wait` milliseconds. The throttled function comes with a `cancel`\nmethod to cancel delayed `func` invocations and a `flush` method to\nimmediately invoke them. Provide `options` to indicate whether `func`\nshould be invoked on the leading and/or trailing edge of the `wait`\ntimeout. The `func` is invoked with the last arguments provided to the\nthrottled function. Subsequent calls to the throttled function return the\nresult of the last `func` invocation.\n\n**Note:** If `leading` and `trailing` options are `true`, `func` is\ninvoked on the trailing edge of the timeout only if the throttled function\nis invoked more than once during the `wait` timeout.\n\nIf `wait` is `0` and `leading` is `false`, `func` invocation is deferred\nuntil to the next tick, similar to `setTimeout` with a timeout of `0`.\n\nSee [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\nfor details over the differences between `_.throttle` and `_.debounce`.",
        "grammar": "lsp",
        "label": "lodash-throttle",
        "matches": [
          "lodash throttle"
        ],
        "opts": []
      },
      {
        "content": "_.unary(${func})",
        "doc": "_.map(['6', '8', '10'], _.unary(parseInt));\n// => [6, 8, 10]\n\nCreates a function that accepts up to one argument, ignoring any\nadditional arguments.",
        "grammar": "lsp",
        "label": "lodash-unary",
        "matches": [
          "lodash unary"
        ],
        "opts": []
      },
      {
        "content": "_.wrap(${value}, ${wrapper})",
        "doc": "var p = _.wrap(_.escape, function(func, text) {\n  return '<p>' + func(text) + '</p>';\n});\n\np('fred, barney, & pebbles');\n// => '<p>fred, barney, &amp; pebbles</p>'\n\nCreates a function that provides `value` to `wrapper` as its first\nargument. Any additional arguments provided to the function are appended\nto those provided to the `wrapper`. The wrapper is invoked with the `this`\nbinding of the created function.",
        "grammar": "lsp",
        "label": "lodash-wrap",
        "matches": [
          "lodash wrap"
        ],
        "opts": []
      },
      {
        "content": "_.castArray(${value})",
        "doc": "_.castArray(1);\n// => [1]\n\n_.castArray({ 'a': 1 });\n// => [{ 'a': 1 }]\n\n_.castArray('abc');\n// => ['abc']\n\n_.castArray(null);\n// => [null]\n\n_.castArray(undefined);\n// => [undefined]\n\n_.castArray();\n// => []\n\nvar array = [1, 2, 3];\nconsole.log(_.castArray(array) === array);\n// => true\n\nCasts `value` as an array if it's not one.",
        "grammar": "lsp",
        "label": "lodash-castarray",
        "matches": [
          "lodash castarray"
        ],
        "opts": []
      },
      {
        "content": "_.clone(${value})",
        "doc": "var objects = [{ 'a': 1 }, { 'b': 2 }];\n\nvar shallow = _.clone(objects);\nconsole.log(shallow[0] === objects[0]);\n// => true\n\nCreates a shallow clone of `value`.\n\n**Note:** This method is loosely based on the\n[structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\nand supports cloning arrays, array buffers, booleans, date objects, maps,\nnumbers, `Object` objects, regexes, sets, strings, symbols, and typed\narrays. The own enumerable properties of `arguments` objects are cloned\nas plain objects. An empty object is returned for uncloneable values such\nas error objects, functions, DOM nodes, and WeakMaps.",
        "grammar": "lsp",
        "label": "lodash-clone",
        "matches": [
          "lodash clone"
        ],
        "opts": []
      },
      {
        "content": "_.cloneWith(${value}, ${customizer})",
        "doc": "function customizer(value) {\n  if (_.isElement(value)) {\n    return value.cloneNode(false);\n  }\n}\n\nvar el = _.cloneWith(document.body, customizer);\n\nconsole.log(el === document.body);\n// => false\nconsole.log(el.nodeName);\n// => 'BODY'\nconsole.log(el.childNodes.length);\n// => 0\n\nThis method is like `_.clone` except that it accepts `customizer` which\nis invoked to produce the cloned value. If `customizer` returns `undefined`,\ncloning is handled by the method instead. The `customizer` is invoked with\nup to four arguments; (value [, index|key, object, stack]).",
        "grammar": "lsp",
        "label": "lodash-clonewith",
        "matches": [
          "lodash clonewith"
        ],
        "opts": []
      },
      {
        "content": "_.cloneDeep(${value})",
        "doc": "var objects = [{ 'a': 1 }, { 'b': 2 }];\n\nvar deep = _.cloneDeep(objects);\nconsole.log(deep[0] === objects[0]);\n// => false\n\nThis method is like `_.clone` except that it recursively clones `value`.",
        "grammar": "lsp",
        "label": "lodash-clonedeep",
        "matches": [
          "lodash clonedeep"
        ],
        "opts": []
      },
      {
        "content": "_.cloneDeepWith(${value}, ${customizer})",
        "doc": "function customizer(value) {\n  if (_.isElement(value)) {\n    return value.cloneNode(true);\n  }\n}\n\nvar el = _.cloneDeepWith(document.body, customizer);\n\nconsole.log(el === document.body);\n// => false\nconsole.log(el.nodeName);\n// => 'BODY'\nconsole.log(el.childNodes.length);\n// => 20\n\nThis method is like `_.cloneWith` except that it recursively clones `value`.",
        "grammar": "lsp",
        "label": "lodash-clonedeepwith",
        "matches": [
          "lodash clonedeepwith"
        ],
        "opts": []
      },
      {
        "content": "_.conformsTo(${object}, ${source})",
        "doc": "var object = { 'a': 1, 'b': 2 };\n\n_.conformsTo(object, { 'b': function(n) { return n > 1; } });\n// => true\n\n_.conformsTo(object, { 'b': function(n) { return n > 2; } });\n// => false\n\nChecks if `object` conforms to `source` by invoking the predicate\nproperties of `source` with the corresponding property values of `object`.\n\n**Note:** This method is equivalent to `_.conforms` when `source` is\npartially applied.",
        "grammar": "lsp",
        "label": "lodash-conformsto",
        "matches": [
          "lodash conformsto"
        ],
        "opts": []
      },
      {
        "content": "_.eq(${value}, ${other})",
        "doc": "var object = { 'a': 1 };\nvar other = { 'a': 1 };\n\n_.eq(object, object);\n// => true\n\n_.eq(object, other);\n// => false\n\n_.eq('a', 'a');\n// => true\n\n_.eq('a', Object('a'));\n// => false\n\n_.eq(NaN, NaN);\n// => true\n\nPerforms a\n[`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\ncomparison between two values to determine if they are equivalent.",
        "grammar": "lsp",
        "label": "lodash-eq",
        "matches": [
          "lodash eq"
        ],
        "opts": []
      },
      {
        "content": "_.gt(${value}, ${other})",
        "doc": "_.gt(3, 1);\n// => true\n\n_.gt(3, 3);\n// => false\n\n_.gt(1, 3);\n// => false\n\nChecks if `value` is greater than `other`.",
        "grammar": "lsp",
        "label": "lodash-gt",
        "matches": [
          "lodash gt"
        ],
        "opts": []
      },
      {
        "content": "_.gte(${value}, ${other})",
        "doc": "_.gte(3, 1);\n// => true\n\n_.gte(3, 3);\n// => true\n\n_.gte(1, 3);\n// => false\n\nChecks if `value` is greater than or equal to `other`.",
        "grammar": "lsp",
        "label": "lodash-gte",
        "matches": [
          "lodash gte"
        ],
        "opts": []
      },
      {
        "content": "_.isArguments(${value})",
        "doc": "_.isArguments(function() { return arguments; }());\n// => true\n\n_.isArguments([1, 2, 3]);\n// => false\n\nChecks if `value` is likely an `arguments` object.",
        "grammar": "lsp",
        "label": "lodash-isarguments",
        "matches": [
          "lodash isarguments"
        ],
        "opts": []
      },
      {
        "content": "_.isArray(${value})",
        "doc": "_.isArray([1, 2, 3]);\n// => true\n\n_.isArray(document.body.children);\n// => false\n\n_.isArray('abc');\n// => false\n\n_.isArray(_.noop);\n// => false\n\nChecks if `value` is classified as an `Array` object.",
        "grammar": "lsp",
        "label": "lodash-isarray",
        "matches": [
          "lodash isarray"
        ],
        "opts": []
      },
      {
        "content": "_.isArrayBuffer(${value})",
        "doc": "_.isArrayBuffer(new ArrayBuffer(2));\n// => true\n\n_.isArrayBuffer(new Array(2));\n// => false\n\nChecks if `value` is classified as an `ArrayBuffer` object.",
        "grammar": "lsp",
        "label": "lodash-isarraybuffer",
        "matches": [
          "lodash isarraybuffer"
        ],
        "opts": []
      },
      {
        "content": "_.isArrayLike(${value})",
        "doc": "_.isArrayLike([1, 2, 3]);\n// => true\n\n_.isArrayLike(document.body.children);\n// => true\n\n_.isArrayLike('abc');\n// => true\n\n_.isArrayLike(_.noop);\n// => false\n\nChecks if `value` is array-like. A value is considered array-like if it's\nnot a function and has a `value.length` that's an integer greater than or\nequal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.",
        "grammar": "lsp",
        "label": "lodash-isarraylike",
        "matches": [
          "lodash isarraylike"
        ],
        "opts": []
      },
      {
        "content": "_.isArrayLikeObject(${value})",
        "doc": "_.isArrayLikeObject([1, 2, 3]);\n// => true\n\n_.isArrayLikeObject(document.body.children);\n// => true\n\n_.isArrayLikeObject('abc');\n// => false\n\n_.isArrayLikeObject(_.noop);\n// => false\n\nThis method is like `_.isArrayLike` except that it also checks if `value`\nis an object.",
        "grammar": "lsp",
        "label": "lodash-isarraylikeobject",
        "matches": [
          "lodash isarraylikeobject"
        ],
        "opts": []
      },
      {
        "content": "_.isBoolean(${value})",
        "doc": "_.isBoolean(false);\n// => true\n\n_.isBoolean(null);\n// => false\n\nChecks if `value` is classified as a boolean primitive or object.",
        "grammar": "lsp",
        "label": "lodash-isboolean",
        "matches": [
          "lodash isboolean"
        ],
        "opts": []
      },
      {
        "content": "_.isBuffer(${value})",
        "doc": "_.isBuffer(new Buffer(2));\n// => true\n\n_.isBuffer(new Uint8Array(2));\n// => false\n\nChecks if `value` is a buffer.",
        "grammar": "lsp",
        "label": "lodash-isbuffer",
        "matches": [
          "lodash isbuffer"
        ],
        "opts": []
      },
      {
        "content": "_.isDate(${value})",
        "doc": "_.isDate(new Date);\n// => true\n\n_.isDate('Mon April 23 2012');\n// => false\n\nChecks if `value` is classified as a `Date` object.",
        "grammar": "lsp",
        "label": "lodash-isdate",
        "matches": [
          "lodash isdate"
        ],
        "opts": []
      },
      {
        "content": "_.isElement(${value})",
        "doc": "_.isElement(document.body);\n// => true\n\n_.isElement('<body>');\n// => false\n\nChecks if `value` is likely a DOM element.",
        "grammar": "lsp",
        "label": "lodash-iselement",
        "matches": [
          "lodash iselement"
        ],
        "opts": []
      },
      {
        "content": "_.isEmpty(${value})",
        "doc": "_.isEmpty(null);\n// => true\n\n_.isEmpty(true);\n// => true\n\n_.isEmpty(1);\n// => true\n\n_.isEmpty([1, 2, 3]);\n// => false\n\n_.isEmpty({ 'a': 1 });\n// => false\n\nChecks if `value` is an empty object, collection, map, or set.\n\nObjects are considered empty if they have no own enumerable string keyed\nproperties.\n\nArray-like values such as `arguments` objects, arrays, buffers, strings, or\njQuery-like collections are considered empty if they have a `length` of `0`.\nSimilarly, maps and sets are considered empty if they have a `size` of `0`.",
        "grammar": "lsp",
        "label": "lodash-isempty",
        "matches": [
          "lodash isempty"
        ],
        "opts": []
      },
      {
        "content": "_.isEqual(${value}, ${other})",
        "doc": "var object = { 'a': 1 };\nvar other = { 'a': 1 };\n\n_.isEqual(object, other);\n// => true\n\nobject === other;\n// => false\n\nPerforms a deep comparison between two values to determine if they are\nequivalent.\n\n**Note:** This method supports comparing arrays, array buffers, booleans,\ndate objects, error objects, maps, numbers, `Object` objects, regexes,\nsets, strings, symbols, and typed arrays. `Object` objects are compared\nby their own, not inherited, enumerable properties. Functions and DOM\nnodes are compared by strict equality, i.e. `===`.",
        "grammar": "lsp",
        "label": "lodash-isequal",
        "matches": [
          "lodash isequal"
        ],
        "opts": []
      },
      {
        "content": "_.isEqualWith(${value}, ${other}, ${customizer})",
        "doc": "function isGreeting(value) {\n  return /^h(?:i|ello)$/.test(value);\n}\n\nfunction customizer(objValue, othValue) {\n  if (isGreeting(objValue) && isGreeting(othValue)) {\n    return true;\n  }\n}\n\nvar array = ['hello', 'goodbye'];\nvar other = ['hi', 'goodbye'];\n\n_.isEqualWith(array, other, customizer);\n// => true\n\nThis method is like `_.isEqual` except that it accepts `customizer` which\nis invoked to compare values. If `customizer` returns `undefined`, comparisons\nare handled by the method instead. The `customizer` is invoked with up to\nsix arguments: (objValue, othValue [, index|key, object, other, stack]).",
        "grammar": "lsp",
        "label": "lodash-isequalwith",
        "matches": [
          "lodash isequalwith"
        ],
        "opts": []
      },
      {
        "content": "_.isError(${value})",
        "doc": "_.isError(new Error);\n// => true\n\n_.isError(Error);\n// => false\n\nChecks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\n`SyntaxError`, `TypeError`, or `URIError` object.",
        "grammar": "lsp",
        "label": "lodash-iserror",
        "matches": [
          "lodash iserror"
        ],
        "opts": []
      },
      {
        "content": "_.isFinite(${value})",
        "doc": "_.isFinite(3);\n// => true\n\n_.isFinite(Number.MIN_VALUE);\n// => true\n\n_.isFinite(Infinity);\n// => false\n\n_.isFinite('3');\n// => false\n\nChecks if `value` is a finite primitive number.\n\n**Note:** This method is based on\n[`Number.isFinite`](https://mdn.io/Number/isFinite).",
        "grammar": "lsp",
        "label": "lodash-isfinite",
        "matches": [
          "lodash isfinite"
        ],
        "opts": []
      },
      {
        "content": "_.isFunction(${value})",
        "doc": "_.isFunction(_);\n// => true\n\n_.isFunction(/abc/);\n// => false\n\nChecks if `value` is classified as a `Function` object.",
        "grammar": "lsp",
        "label": "lodash-isfunction",
        "matches": [
          "lodash isfunction"
        ],
        "opts": []
      },
      {
        "content": "_.isInteger(${value})",
        "doc": "_.isInteger(3);\n// => true\n\n_.isInteger(Number.MIN_VALUE);\n// => false\n\n_.isInteger(Infinity);\n// => false\n\n_.isInteger('3');\n// => false\n\nChecks if `value` is an integer.\n\n**Note:** This method is based on\n[`Number.isInteger`](https://mdn.io/Number/isInteger).",
        "grammar": "lsp",
        "label": "lodash-isinteger",
        "matches": [
          "lodash isinteger"
        ],
        "opts": []
      },
      {
        "content": "_.isLength(${value})",
        "doc": "_.isLength(3);\n// => true\n\n_.isLength(Number.MIN_VALUE);\n// => false\n\n_.isLength(Infinity);\n// => false\n\n_.isLength('3');\n// => false\n\nChecks if `value` is a valid array-like length.\n\n**Note:** This method is loosely based on\n[`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).",
        "grammar": "lsp",
        "label": "lodash-islength",
        "matches": [
          "lodash islength"
        ],
        "opts": []
      },
      {
        "content": "_.isObject(${value})",
        "doc": "_.isObject({});\n// => true\n\n_.isObject([1, 2, 3]);\n// => true\n\n_.isObject(_.noop);\n// => true\n\n_.isObject(null);\n// => false\n\nChecks if `value` is the\n[language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\nof `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)",
        "grammar": "lsp",
        "label": "lodash-isobject",
        "matches": [
          "lodash isobject"
        ],
        "opts": []
      },
      {
        "content": "_.isObjectLike(${value})",
        "doc": "_.isObjectLike({});\n// => true\n\n_.isObjectLike([1, 2, 3]);\n// => true\n\n_.isObjectLike(_.noop);\n// => false\n\n_.isObjectLike(null);\n// => false\n\nChecks if `value` is object-like. A value is object-like if it's not `null`\nand has a `typeof` result of \"object\".",
        "grammar": "lsp",
        "label": "lodash-isobjectlike",
        "matches": [
          "lodash isobjectlike"
        ],
        "opts": []
      },
      {
        "content": "_.isMap(${value})",
        "doc": "_.isMap(new Map);\n// => true\n\n_.isMap(new WeakMap);\n// => false\n\nChecks if `value` is classified as a `Map` object.",
        "grammar": "lsp",
        "label": "lodash-ismap",
        "matches": [
          "lodash ismap"
        ],
        "opts": []
      },
      {
        "content": "_.isMatch(${object}, ${source})",
        "doc": "var object = { 'a': 1, 'b': 2 };\n\n_.isMatch(object, { 'b': 2 });\n// => true\n\n_.isMatch(object, { 'b': 1 });\n// => false\n\nPerforms a partial deep comparison between `object` and `source` to\ndetermine if `object` contains equivalent property values.\n\n**Note:** This method is equivalent to `_.matches` when `source` is\npartially applied.\n\nPartial comparisons will match empty array and empty object `source`\nvalues against any array or object value, respectively. See `_.isEqual`\nfor a list of supported value comparisons.",
        "grammar": "lsp",
        "label": "lodash-ismatch",
        "matches": [
          "lodash ismatch"
        ],
        "opts": []
      },
      {
        "content": "_.isMatchWith(${object}, ${source}, ${customizer})",
        "doc": "function isGreeting(value) {\n  return /^h(?:i|ello)$/.test(value);\n}\n\nfunction customizer(objValue, srcValue) {\n  if (isGreeting(objValue) && isGreeting(srcValue)) {\n    return true;\n  }\n}\n\nvar object = { 'greeting': 'hello' };\nvar source = { 'greeting': 'hi' };\n\n_.isMatchWith(object, source, customizer);\n// => true\n\nThis method is like `_.isMatch` except that it accepts `customizer` which\nis invoked to compare values. If `customizer` returns `undefined`, comparisons\nare handled by the method instead. The `customizer` is invoked with five\narguments: (objValue, srcValue, index|key, object, source).",
        "grammar": "lsp",
        "label": "lodash-ismatchwith",
        "matches": [
          "lodash ismatchwith"
        ],
        "opts": []
      },
      {
        "content": "_.isNaN(${value})",
        "doc": "_.isNaN(NaN);\n// => true\n\n_.isNaN(new Number(NaN));\n// => true\n\nisNaN(undefined);\n// => true\n\n_.isNaN(undefined);\n// => false\n\nChecks if `value` is `NaN`.\n\n**Note:** This method is based on\n[`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as\nglobal [`isNaN`](https://mdn.io/isNaN) which returns `true` for\n`undefined` and other non-number values.",
        "grammar": "lsp",
        "label": "lodash-isnan",
        "matches": [
          "lodash isnan"
        ],
        "opts": []
      },
      {
        "content": "_.isNative(${value})",
        "doc": "_.isNative(Array.prototype.push);\n// => true\n\n_.isNative(_);\n// => false\n\nChecks if `value` is a pristine native function.\n\n**Note:** This method can't reliably detect native functions in the presence\nof the core-js package because core-js circumvents this kind of detection.\nDespite multiple requests, the core-js maintainer has made it clear: any\nattempt to fix the detection will be obstructed. As a result, we're left\nwith little choice but to throw an error. Unfortunately, this also affects\npackages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),\nwhich rely on core-js.",
        "grammar": "lsp",
        "label": "lodash-isnative",
        "matches": [
          "lodash isnative"
        ],
        "opts": []
      },
      {
        "content": "_.isNull(${value})",
        "doc": "_.isNull(null);\n// => true\n\n_.isNull(void 0);\n// => false\n\nChecks if `value` is `null`.",
        "grammar": "lsp",
        "label": "lodash-isnull",
        "matches": [
          "lodash isnull"
        ],
        "opts": []
      },
      {
        "content": "_.isNil(${value})",
        "doc": "_.isNil(null);\n// => true\n\n_.isNil(void 0);\n// => true\n\n_.isNil(NaN);\n// => false\n\nChecks if `value` is `null` or `undefined`.",
        "grammar": "lsp",
        "label": "lodash-isnil",
        "matches": [
          "lodash isnil"
        ],
        "opts": []
      },
      {
        "content": "_.isNumber(${value})",
        "doc": "_.isNumber(3);\n// => true\n\n_.isNumber(Number.MIN_VALUE);\n// => true\n\n_.isNumber(Infinity);\n// => true\n\n_.isNumber('3');\n// => false\n\nChecks if `value` is classified as a `Number` primitive or object.\n\n**Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are\nclassified as numbers, use the `_.isFinite` method.",
        "grammar": "lsp",
        "label": "lodash-isnumber",
        "matches": [
          "lodash isnumber"
        ],
        "opts": []
      },
      {
        "content": "_.isPlainObject(${value})",
        "doc": "function Foo() {\n  this.a = 1;\n}\n\n_.isPlainObject(new Foo);\n// => false\n\n_.isPlainObject([1, 2, 3]);\n// => false\n\n_.isPlainObject({ 'x': 0, 'y': 0 });\n// => true\n\n_.isPlainObject(Object.create(null));\n// => true\n\nChecks if `value` is a plain object, that is, an object created by the\n`Object` constructor or one with a `[[Prototype]]` of `null`.",
        "grammar": "lsp",
        "label": "lodash-isplainobject",
        "matches": [
          "lodash isplainobject"
        ],
        "opts": []
      },
      {
        "content": "_.isRegExp(${value})",
        "doc": "_.isRegExp(/abc/);\n// => true\n\n_.isRegExp('/abc/');\n// => false\n\nChecks if `value` is classified as a `RegExp` object.",
        "grammar": "lsp",
        "label": "lodash-isregexp",
        "matches": [
          "lodash isregexp"
        ],
        "opts": []
      },
      {
        "content": "_.isSafeInteger(${value})",
        "doc": "_.isSafeInteger(3);\n// => true\n\n_.isSafeInteger(Number.MIN_VALUE);\n// => false\n\n_.isSafeInteger(Infinity);\n// => false\n\n_.isSafeInteger('3');\n// => false\n\nChecks if `value` is a safe integer. An integer is safe if it's an IEEE-754\ndouble precision number which isn't the result of a rounded unsafe integer.\n\n**Note:** This method is based on\n[`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).",
        "grammar": "lsp",
        "label": "lodash-issafeinteger",
        "matches": [
          "lodash issafeinteger"
        ],
        "opts": []
      },
      {
        "content": "_.isSet(${value})",
        "doc": "_.isSet(new Set);\n// => true\n\n_.isSet(new WeakSet);\n// => false\n\nChecks if `value` is classified as a `Set` object.",
        "grammar": "lsp",
        "label": "lodash-isset",
        "matches": [
          "lodash isset"
        ],
        "opts": []
      },
      {
        "content": "_.isString(${value})",
        "doc": "_.isString('abc');\n// => true\n\n_.isString(1);\n// => false\n\nChecks if `value` is classified as a `String` primitive or object.",
        "grammar": "lsp",
        "label": "lodash-isstring",
        "matches": [
          "lodash isstring"
        ],
        "opts": []
      },
      {
        "content": "_.isSymbol(${value})",
        "doc": "_.isSymbol(Symbol.iterator);\n// => true\n\n_.isSymbol('abc');\n// => false\n\nChecks if `value` is classified as a `Symbol` primitive or object.",
        "grammar": "lsp",
        "label": "lodash-issymbol",
        "matches": [
          "lodash issymbol"
        ],
        "opts": []
      },
      {
        "content": "_.isTypedArray(${value})",
        "doc": "_.isTypedArray(new Uint8Array);\n// => true\n\n_.isTypedArray([]);\n// => false\n\nChecks if `value` is classified as a typed array.",
        "grammar": "lsp",
        "label": "lodash-istypedarray",
        "matches": [
          "lodash istypedarray"
        ],
        "opts": []
      },
      {
        "content": "_.isUndefined(${value})",
        "doc": "_.isUndefined(void 0);\n// => true\n\n_.isUndefined(null);\n// => false\n\nChecks if `value` is `undefined`.",
        "grammar": "lsp",
        "label": "lodash-isundefined",
        "matches": [
          "lodash isundefined"
        ],
        "opts": []
      },
      {
        "content": "_.isWeakMap(${value})",
        "doc": "_.isWeakMap(new WeakMap);\n// => true\n\n_.isWeakMap(new Map);\n// => false\n\nChecks if `value` is classified as a `WeakMap` object.",
        "grammar": "lsp",
        "label": "lodash-isweakmap",
        "matches": [
          "lodash isweakmap"
        ],
        "opts": []
      },
      {
        "content": "_.isWeakSet(${value})",
        "doc": "_.isWeakSet(new WeakSet);\n// => true\n\n_.isWeakSet(new Set);\n// => false\n\nChecks if `value` is classified as a `WeakSet` object.",
        "grammar": "lsp",
        "label": "lodash-isweakset",
        "matches": [
          "lodash isweakset"
        ],
        "opts": []
      },
      {
        "content": "_.lt(${value}, ${other})",
        "doc": "_.lt(1, 3);\n// => true\n\n_.lt(3, 3);\n// => false\n\n_.lt(3, 1);\n// => false\n\nChecks if `value` is less than `other`.",
        "grammar": "lsp",
        "label": "lodash-lt",
        "matches": [
          "lodash lt"
        ],
        "opts": []
      },
      {
        "content": "_.lte(${value}, ${other})",
        "doc": "_.lte(1, 3);\n// => true\n\n_.lte(3, 3);\n// => true\n\n_.lte(3, 1);\n// => false\n\nChecks if `value` is less than or equal to `other`.",
        "grammar": "lsp",
        "label": "lodash-lte",
        "matches": [
          "lodash lte"
        ],
        "opts": []
      },
      {
        "content": "_.toArray(${value})",
        "doc": "_.toArray({ 'a': 1, 'b': 2 });\n// => [1, 2]\n\n_.toArray('abc');\n// => ['a', 'b', 'c']\n\n_.toArray(1);\n// => []\n\n_.toArray(null);\n// => []\n\nConverts `value` to an array.",
        "grammar": "lsp",
        "label": "lodash-toarray",
        "matches": [
          "lodash toarray"
        ],
        "opts": []
      },
      {
        "content": "_.toFinite(${value})",
        "doc": "_.toFinite(3.2);\n// => 3.2\n\n_.toFinite(Number.MIN_VALUE);\n// => 5e-324\n\n_.toFinite(Infinity);\n// => 1.7976931348623157e+308\n\n_.toFinite('3.2');\n// => 3.2\n\nConverts `value` to a finite number.",
        "grammar": "lsp",
        "label": "lodash-tofinite",
        "matches": [
          "lodash tofinite"
        ],
        "opts": []
      },
      {
        "content": "_.toInteger(${value})",
        "doc": "_.toInteger(3.2);\n// => 3\n\n_.toInteger(Number.MIN_VALUE);\n// => 0\n\n_.toInteger(Infinity);\n// => 1.7976931348623157e+308\n\n_.toInteger('3.2');\n// => 3\n\nConverts `value` to an integer.\n\n**Note:** This method is loosely based on\n[`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).",
        "grammar": "lsp",
        "label": "lodash-tointeger",
        "matches": [
          "lodash tointeger"
        ],
        "opts": []
      },
      {
        "content": "_.toLength(${value})",
        "doc": "_.toLength(3.2);\n// => 3\n\n_.toLength(Number.MIN_VALUE);\n// => 0\n\n_.toLength(Infinity);\n// => 4294967295\n\n_.toLength('3.2');\n// => 3\n\nConverts `value` to an integer suitable for use as the length of an\narray-like object.\n\n**Note:** This method is based on\n[`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).",
        "grammar": "lsp",
        "label": "lodash-tolength",
        "matches": [
          "lodash tolength"
        ],
        "opts": []
      },
      {
        "content": "_.toNumber(${value})",
        "doc": "_.toNumber(3.2);\n// => 3.2\n\n_.toNumber(Number.MIN_VALUE);\n// => 5e-324\n\n_.toNumber(Infinity);\n// => Infinity\n\n_.toNumber('3.2');\n// => 3.2\n\nConverts `value` to a number.",
        "grammar": "lsp",
        "label": "lodash-tonumber",
        "matches": [
          "lodash tonumber"
        ],
        "opts": []
      },
      {
        "content": "_.toPlainObject(${value})",
        "doc": "function Foo() {\n  this.b = 2;\n}\n\nFoo.prototype.c = 3;\n\n_.assign({ 'a': 1 }, new Foo);\n// => { 'a': 1, 'b': 2 }\n\n_.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n// => { 'a': 1, 'b': 2, 'c': 3 }\n\nConverts `value` to a plain object flattening inherited enumerable string\nkeyed properties of `value` to own properties of the plain object.",
        "grammar": "lsp",
        "label": "lodash-toplainobject",
        "matches": [
          "lodash toplainobject"
        ],
        "opts": []
      },
      {
        "content": "_.toSafeInteger(${value})",
        "doc": "_.toSafeInteger(3.2);\n// => 3\n\n_.toSafeInteger(Number.MIN_VALUE);\n// => 0\n\n_.toSafeInteger(Infinity);\n// => 9007199254740991\n\n_.toSafeInteger('3.2');\n// => 3\n\nConverts `value` to a safe integer. A safe integer can be compared and\nrepresented correctly.",
        "grammar": "lsp",
        "label": "lodash-tosafeinteger",
        "matches": [
          "lodash tosafeinteger"
        ],
        "opts": []
      },
      {
        "content": "_.toString(${value})",
        "doc": "_.toString(null);\n// => ''\n\n_.toString(-0);\n// => '-0'\n\n_.toString([1, 2, 3]);\n// => '1,2,3'\n\nConverts `value` to a string. An empty string is returned for `null`\nand `undefined` values. The sign of `-0` is preserved.",
        "grammar": "lsp",
        "label": "lodash-tostring",
        "matches": [
          "lodash tostring"
        ],
        "opts": []
      },
      {
        "content": "_.assign(${object}, ${sources})",
        "doc": "function Foo() {\n  this.a = 1;\n}\n\nfunction Bar() {\n  this.c = 3;\n}\n\nFoo.prototype.b = 2;\nBar.prototype.d = 4;\n\n_.assign({ 'a': 0 }, new Foo, new Bar);\n// => { 'a': 1, 'c': 3 }\n\nAssigns own enumerable string keyed properties of source objects to the\ndestination object. Source objects are applied from left to right.\nSubsequent sources overwrite property assignments of previous sources.\n\n**Note:** This method mutates `object` and is loosely based on\n[`Object.assign`](https://mdn.io/Object/assign).",
        "grammar": "lsp",
        "label": "lodash-assign",
        "matches": [
          "lodash assign"
        ],
        "opts": []
      },
      {
        "content": "_.extend(${object}, ${sources})",
        "doc": "function Foo() {\n  this.a = 1;\n}\n\nfunction Bar() {\n  this.c = 3;\n}\n\nFoo.prototype.b = 2;\nBar.prototype.d = 4;\n\n_.assignIn({ 'a': 0 }, new Foo, new Bar);\n// => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }\n\nThis method is like `_.assign` except that it iterates over own and\ninherited source properties.\n\n**Note:** This method mutates `object`.",
        "grammar": "lsp",
        "label": "lodash-extend",
        "matches": [
          "lodash extend"
        ],
        "opts": []
      },
      {
        "content": "_.extendWith(${object}, ${sources}, ${customizer})",
        "doc": "function customizer(objValue, srcValue) {\n  return _.isUndefined(objValue) ? srcValue : objValue;\n}\n\nvar defaults = _.partialRight(_.assignInWith, customizer);\n\ndefaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n// => { 'a': 1, 'b': 2 }\n\nThis method is like `_.assignIn` except that it accepts `customizer`\nwhich is invoked to produce the assigned values. If `customizer` returns\n`undefined`, assignment is handled by the method instead. The `customizer`\nis invoked with five arguments: (objValue, srcValue, key, object, source).\n\n**Note:** This method mutates `object`.",
        "grammar": "lsp",
        "label": "lodash-extendwith",
        "matches": [
          "lodash extendwith"
        ],
        "opts": []
      },
      {
        "content": "_.assignWith(${object}, ${sources}, ${customizer})",
        "doc": "function customizer(objValue, srcValue) {\n  return _.isUndefined(objValue) ? srcValue : objValue;\n}\n\nvar defaults = _.partialRight(_.assignWith, customizer);\n\ndefaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n// => { 'a': 1, 'b': 2 }\n\nThis method is like `_.assign` except that it accepts `customizer`\nwhich is invoked to produce the assigned values. If `customizer` returns\n`undefined`, assignment is handled by the method instead. The `customizer`\nis invoked with five arguments: (objValue, srcValue, key, object, source).\n\n**Note:** This method mutates `object`.",
        "grammar": "lsp",
        "label": "lodash-assignwith",
        "matches": [
          "lodash assignwith"
        ],
        "opts": []
      },
      {
        "content": "_.create(${prototype}, ${properties})",
        "doc": "function Shape() {\n  this.x = 0;\n  this.y = 0;\n}\n\nfunction Circle() {\n  Shape.call(this);\n}\n\nCircle.prototype = _.create(Shape.prototype, {\n  'constructor': Circle\n});\n\nvar circle = new Circle;\ncircle instanceof Circle;\n// => true\n\ncircle instanceof Shape;\n// => true\n\nCreates an object that inherits from the `prototype` object. If a\n`properties` object is given, its own enumerable string keyed properties\nare assigned to the created object.",
        "grammar": "lsp",
        "label": "lodash-create",
        "matches": [
          "lodash create"
        ],
        "opts": []
      },
      {
        "content": "_.defaults(${object}, ${sources})",
        "doc": "_.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n// => { 'a': 1, 'b': 2 }\n\nAssigns own and inherited enumerable string keyed properties of source\nobjects to the destination object for all destination properties that\nresolve to `undefined`. Source objects are applied from left to right.\nOnce a property is set, additional values of the same property are ignored.\n\n**Note:** This method mutates `object`.",
        "grammar": "lsp",
        "label": "lodash-defaults",
        "matches": [
          "lodash defaults"
        ],
        "opts": []
      },
      {
        "content": "_.defaultsDeep(${object}, ${sources})",
        "doc": "_.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });\n// => { 'a': { 'b': 2, 'c': 3 } }\n\nThis method is like `_.defaults` except that it recursively assigns\ndefault properties.\n\n**Note:** This method mutates `object`.",
        "grammar": "lsp",
        "label": "lodash-defaultsdeep",
        "matches": [
          "lodash defaultsdeep"
        ],
        "opts": []
      },
      {
        "content": "_.findKey(${object}, ${predicate})",
        "doc": "var users = {\n  'barney':  { 'age': 36, 'active': true },\n  'fred':    { 'age': 40, 'active': false },\n  'pebbles': { 'age': 1,  'active': true }\n};\n\n_.findKey(users, function(o) { return o.age < 40; });\n// => 'barney' (iteration order is not guaranteed)\n\n// The `_.matches` iteratee shorthand.\n_.findKey(users, { 'age': 1, 'active': true });\n// => 'pebbles'\n\n// The `_.matchesProperty` iteratee shorthand.\n_.findKey(users, ['active', false]);\n// => 'fred'\n\n// The `_.property` iteratee shorthand.\n_.findKey(users, 'active');\n// => 'barney'\n\nThis method is like `_.find` except that it returns the key of the first\nelement `predicate` returns truthy for instead of the element itself.",
        "grammar": "lsp",
        "label": "lodash-findkey",
        "matches": [
          "lodash findkey"
        ],
        "opts": []
      },
      {
        "content": "_.findLastKey(${object}, ${predicate})",
        "doc": "var users = {\n  'barney':  { 'age': 36, 'active': true },\n  'fred':    { 'age': 40, 'active': false },\n  'pebbles': { 'age': 1,  'active': true }\n};\n\n_.findLastKey(users, function(o) { return o.age < 40; });\n// => returns 'pebbles' assuming `_.findKey` returns 'barney'\n\n// The `_.matches` iteratee shorthand.\n_.findLastKey(users, { 'age': 36, 'active': true });\n// => 'barney'\n\n// The `_.matchesProperty` iteratee shorthand.\n_.findLastKey(users, ['active', false]);\n// => 'fred'\n\n// The `_.property` iteratee shorthand.\n_.findLastKey(users, 'active');\n// => 'pebbles'\n\nThis method is like `_.findKey` except that it iterates over elements of\na collection in the opposite order.",
        "grammar": "lsp",
        "label": "lodash-findlastkey",
        "matches": [
          "lodash findlastkey"
        ],
        "opts": []
      },
      {
        "content": "_.forIn(${object}, ${iteratee})",
        "doc": "function Foo() {\n  this.a = 1;\n  this.b = 2;\n}\n\nFoo.prototype.c = 3;\n\n_.forIn(new Foo, function(value, key) {\n  console.log(key);\n});\n// => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).\n\nIterates over own and inherited enumerable string keyed properties of an\nobject and invokes `iteratee` for each property. The iteratee is invoked\nwith three arguments: (value, key, object). Iteratee functions may exit\niteration early by explicitly returning `false`.",
        "grammar": "lsp",
        "label": "lodash-forin",
        "matches": [
          "lodash forin"
        ],
        "opts": []
      },
      {
        "content": "_.forInRight(${object}, ${iteratee})",
        "doc": "function Foo() {\n  this.a = 1;\n  this.b = 2;\n}\n\nFoo.prototype.c = 3;\n\n_.forInRight(new Foo, function(value, key) {\n  console.log(key);\n});\n// => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.\n\nThis method is like `_.forIn` except that it iterates over properties of\n`object` in the opposite order.",
        "grammar": "lsp",
        "label": "lodash-forinright",
        "matches": [
          "lodash forinright"
        ],
        "opts": []
      },
      {
        "content": "_.forOwn(${object}, ${iteratee})",
        "doc": "function Foo() {\n  this.a = 1;\n  this.b = 2;\n}\n\nFoo.prototype.c = 3;\n\n_.forOwn(new Foo, function(value, key) {\n  console.log(key);\n});\n// => Logs 'a' then 'b' (iteration order is not guaranteed).\n\nIterates over own enumerable string keyed properties of an object and\ninvokes `iteratee` for each property. The iteratee is invoked with three\narguments: (value, key, object). Iteratee functions may exit iteration\nearly by explicitly returning `false`.",
        "grammar": "lsp",
        "label": "lodash-forown",
        "matches": [
          "lodash forown"
        ],
        "opts": []
      },
      {
        "content": "_.forOwnRight(${object}, ${iteratee})",
        "doc": "function Foo() {\n  this.a = 1;\n  this.b = 2;\n}\n\nFoo.prototype.c = 3;\n\n_.forOwnRight(new Foo, function(value, key) {\n  console.log(key);\n});\n// => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.\n\nThis method is like `_.forOwn` except that it iterates over properties of\n`object` in the opposite order.",
        "grammar": "lsp",
        "label": "lodash-forownright",
        "matches": [
          "lodash forownright"
        ],
        "opts": []
      },
      {
        "content": "_.functions(${object})",
        "doc": "function Foo() {\n  this.a = _.constant('a');\n  this.b = _.constant('b');\n}\n\nFoo.prototype.c = _.constant('c');\n\n_.functions(new Foo);\n// => ['a', 'b']\n\nCreates an array of function property names from own enumerable properties\nof `object`.",
        "grammar": "lsp",
        "label": "lodash-functions",
        "matches": [
          "lodash functions"
        ],
        "opts": []
      },
      {
        "content": "_.functionsIn(${object})",
        "doc": "function Foo() {\n  this.a = _.constant('a');\n  this.b = _.constant('b');\n}\n\nFoo.prototype.c = _.constant('c');\n\n_.functionsIn(new Foo);\n// => ['a', 'b', 'c']\n\nCreates an array of function property names from own and inherited\nenumerable properties of `object`.",
        "grammar": "lsp",
        "label": "lodash-functionsin",
        "matches": [
          "lodash functionsin"
        ],
        "opts": []
      },
      {
        "content": "_.get(${object}, ${path}, ${defaultValue})",
        "doc": "var object = { 'a': [{ 'b': { 'c': 3 } }] };\n\n_.get(object, 'a[0].b.c');\n// => 3\n\n_.get(object, ['a', '0', 'b', 'c']);\n// => 3\n\n_.get(object, 'a.b.c', 'default');\n// => 'default'\n\nGets the value at `path` of `object`. If the resolved value is\n`undefined`, the `defaultValue` is returned in its place.",
        "grammar": "lsp",
        "label": "lodash-get",
        "matches": [
          "lodash get"
        ],
        "opts": []
      },
      {
        "content": "_.has(${object}, ${path})",
        "doc": "var object = { 'a': { 'b': 2 } };\nvar other = _.create({ 'a': _.create({ 'b': 2 }) });\n\n_.has(object, 'a');\n// => true\n\n_.has(object, 'a.b');\n// => true\n\n_.has(object, ['a', 'b']);\n// => true\n\n_.has(other, 'a');\n// => false\n\nChecks if `path` is a direct property of `object`.",
        "grammar": "lsp",
        "label": "lodash-has",
        "matches": [
          "lodash has"
        ],
        "opts": []
      },
      {
        "content": "_.hasIn(${object}, ${path})",
        "doc": "var object = _.create({ 'a': _.create({ 'b': 2 }) });\n\n_.hasIn(object, 'a');\n// => true\n\n_.hasIn(object, 'a.b');\n// => true\n\n_.hasIn(object, ['a', 'b']);\n// => true\n\n_.hasIn(object, 'b');\n// => false\n\nChecks if `path` is a direct or inherited property of `object`.",
        "grammar": "lsp",
        "label": "lodash-hasin",
        "matches": [
          "lodash hasin"
        ],
        "opts": []
      },
      {
        "content": "_.invert(${object})",
        "doc": "var object = { 'a': 1, 'b': 2, 'c': 1 };\n\n_.invert(object);\n// => { '1': 'c', '2': 'b' }\n\nCreates an object composed of the inverted keys and values of `object`.\nIf `object` contains duplicate values, subsequent values overwrite\nproperty assignments of previous values.",
        "grammar": "lsp",
        "label": "lodash-invert",
        "matches": [
          "lodash invert"
        ],
        "opts": []
      },
      {
        "content": "_.invertBy(${object}, ${iteratee})",
        "doc": "var object = { 'a': 1, 'b': 2, 'c': 1 };\n\n_.invertBy(object);\n// => { '1': ['a', 'c'], '2': ['b'] }\n\n_.invertBy(object, function(value) {\n  return 'group' + value;\n});\n// => { 'group1': ['a', 'c'], 'group2': ['b'] }\n\nThis method is like `_.invert` except that the inverted object is generated\nfrom the results of running each element of `object` thru `iteratee`. The\ncorresponding inverted value of each inverted key is an array of keys\nresponsible for generating the inverted value. The iteratee is invoked\nwith one argument: (value).",
        "grammar": "lsp",
        "label": "lodash-invertby",
        "matches": [
          "lodash invertby"
        ],
        "opts": []
      },
      {
        "content": "_.invoke(${object}, ${path}, ${args})",
        "doc": "var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };\n\n_.invoke(object, 'a[0].b.c.slice', 1, 3);\n// => [2, 3]\n\nInvokes the method at `path` of `object`.",
        "grammar": "lsp",
        "label": "lodash-invoke",
        "matches": [
          "lodash invoke"
        ],
        "opts": []
      },
      {
        "content": "_.keys(${object})",
        "doc": "function Foo() {\n  this.a = 1;\n  this.b = 2;\n}\n\nFoo.prototype.c = 3;\n\n_.keys(new Foo);\n// => ['a', 'b'] (iteration order is not guaranteed)\n\n_.keys('hi');\n// => ['0', '1']\n\nCreates an array of the own enumerable property names of `object`.\n\n**Note:** Non-object values are coerced to objects. See the\n[ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\nfor more details.",
        "grammar": "lsp",
        "label": "lodash-keys",
        "matches": [
          "lodash keys"
        ],
        "opts": []
      },
      {
        "content": "_.keysIn(${object})",
        "doc": "function Foo() {\n  this.a = 1;\n  this.b = 2;\n}\n\nFoo.prototype.c = 3;\n\n_.keysIn(new Foo);\n// => ['a', 'b', 'c'] (iteration order is not guaranteed)\n\nCreates an array of the own and inherited enumerable property names of `object`.\n\n**Note:** Non-object values are coerced to objects.",
        "grammar": "lsp",
        "label": "lodash-keysin",
        "matches": [
          "lodash keysin"
        ],
        "opts": []
      },
      {
        "content": "_.mapKeys(${object}, ${iteratee})",
        "doc": "_.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {\n  return key + value;\n});\n// => { 'a1': 1, 'b2': 2 }\n\nThe opposite of `_.mapValues`; this method creates an object with the\nsame values as `object` and keys generated by running each own enumerable\nstring keyed property of `object` thru `iteratee`. The iteratee is invoked\nwith three arguments: (value, key, object).",
        "grammar": "lsp",
        "label": "lodash-mapkeys",
        "matches": [
          "lodash mapkeys"
        ],
        "opts": []
      },
      {
        "content": "_.mapValues(${object}, ${iteratee})",
        "doc": "var users = {\n  'fred':    { 'user': 'fred',    'age': 40 },\n  'pebbles': { 'user': 'pebbles', 'age': 1 }\n};\n\n_.mapValues(users, function(o) { return o.age; });\n// => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n\n// The `_.property` iteratee shorthand.\n_.mapValues(users, 'age');\n// => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n\nCreates an object with the same keys as `object` and values generated\nby running each own enumerable string keyed property of `object` thru\n`iteratee`. The iteratee is invoked with three arguments:\n(value, key, object).",
        "grammar": "lsp",
        "label": "lodash-mapvalues",
        "matches": [
          "lodash mapvalues"
        ],
        "opts": []
      },
      {
        "content": "_.merge(${object}, ${sources})",
        "doc": "var object = {\n  'a': [{ 'b': 2 }, { 'd': 4 }]\n};\n\nvar other = {\n  'a': [{ 'c': 3 }, { 'e': 5 }]\n};\n\n_.merge(object, other);\n// => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n\nThis method is like `_.assign` except that it recursively merges own and\ninherited enumerable string keyed properties of source objects into the\ndestination object. Source properties that resolve to `undefined` are\nskipped if a destination value exists. Array and plain object properties\nare merged recursively. Other objects and value types are overridden by\nassignment. Source objects are applied from left to right. Subsequent\nsources overwrite property assignments of previous sources.\n\n**Note:** This method mutates `object`.",
        "grammar": "lsp",
        "label": "lodash-merge",
        "matches": [
          "lodash merge"
        ],
        "opts": []
      },
      {
        "content": "_.mergeWith(${object}, ${sources}, ${customizer})",
        "doc": "function customizer(objValue, srcValue) {\n  if (_.isArray(objValue)) {\n    return objValue.concat(srcValue);\n  }\n}\n\nvar object = { 'a': [1], 'b': [2] };\nvar other = { 'a': [3], 'b': [4] };\n\n_.mergeWith(object, other, customizer);\n// => { 'a': [1, 3], 'b': [2, 4] }\n\nThis method is like `_.merge` except that it accepts `customizer` which\nis invoked to produce the merged values of the destination and source\nproperties. If `customizer` returns `undefined`, merging is handled by the\nmethod instead. The `customizer` is invoked with six arguments:\n(objValue, srcValue, key, object, source, stack).\n\n**Note:** This method mutates `object`.",
        "grammar": "lsp",
        "label": "lodash-mergewith",
        "matches": [
          "lodash mergewith"
        ],
        "opts": []
      },
      {
        "content": "_.omit(${object}, ${paths})",
        "doc": "var object = { 'a': 1, 'b': '2', 'c': 3 };\n\n_.omit(object, ['a', 'c']);\n// => { 'b': '2' }\n\nThe opposite of `_.pick`; this method creates an object composed of the\nown and inherited enumerable property paths of `object` that are not omitted.\n\n**Note:** This method is considerably slower than `_.pick`.",
        "grammar": "lsp",
        "label": "lodash-omit",
        "matches": [
          "lodash omit"
        ],
        "opts": []
      },
      {
        "content": "_.omitBy(${object}, ${predicate})",
        "doc": "var object = { 'a': 1, 'b': '2', 'c': 3 };\n\n_.omitBy(object, _.isNumber);\n// => { 'b': '2' }\n\nThe opposite of `_.pickBy`; this method creates an object composed of\nthe own and inherited enumerable string keyed properties of `object` that\n`predicate` doesn't return truthy for. The predicate is invoked with two\narguments: (value, key).",
        "grammar": "lsp",
        "label": "lodash-omitby",
        "matches": [
          "lodash omitby"
        ],
        "opts": []
      },
      {
        "content": "_.pick(${object}, ${paths})",
        "doc": "var object = { 'a': 1, 'b': '2', 'c': 3 };\n\n_.pick(object, ['a', 'c']);\n// => { 'a': 1, 'c': 3 }\n\nCreates an object composed of the picked `object` properties.",
        "grammar": "lsp",
        "label": "lodash-pick",
        "matches": [
          "lodash pick"
        ],
        "opts": []
      },
      {
        "content": "_.pickBy(${object}, ${predicate})",
        "doc": "var object = { 'a': 1, 'b': '2', 'c': 3 };\n\n_.pickBy(object, _.isNumber);\n// => { 'a': 1, 'c': 3 }\n\nCreates an object composed of the `object` properties `predicate` returns\ntruthy for. The predicate is invoked with two arguments: (value, key).",
        "grammar": "lsp",
        "label": "lodash-pickby",
        "matches": [
          "lodash pickby"
        ],
        "opts": []
      },
      {
        "content": "_.result(${object}, ${path}, ${defaultValue})",
        "doc": "var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };\n\n_.result(object, 'a[0].b.c1');\n// => 3\n\n_.result(object, 'a[0].b.c2');\n// => 4\n\n_.result(object, 'a[0].b.c3', 'default');\n// => 'default'\n\n_.result(object, 'a[0].b.c3', _.constant('default'));\n// => 'default'\n\nThis method is like `_.get` except that if the resolved value is a\nfunction it's invoked with the `this` binding of its parent object and\nits result is returned.",
        "grammar": "lsp",
        "label": "lodash-result",
        "matches": [
          "lodash result"
        ],
        "opts": []
      },
      {
        "content": "_.set(${object}, ${path}, ${value})",
        "doc": "var object = { 'a': [{ 'b': { 'c': 3 } }] };\n\n_.set(object, 'a[0].b.c', 4);\nconsole.log(object.a[0].b.c);\n// => 4\n\n_.set(object, ['x', '0', 'y', 'z'], 5);\nconsole.log(object.x[0].y.z);\n// => 5\n\nSets the value at `path` of `object`. If a portion of `path` doesn't exist,\nit's created. Arrays are created for missing index properties while objects\nare created for all other missing properties. Use `_.setWith` to customize\n`path` creation.\n\n**Note:** This method mutates `object`.",
        "grammar": "lsp",
        "label": "lodash-set",
        "matches": [
          "lodash set"
        ],
        "opts": []
      },
      {
        "content": "_.setWith(${object}, ${path}, ${value}, ${customizer})",
        "doc": "var object = {};\n\n_.setWith(object, '[0][1]', 'a', Object);\n// => { '0': { '1': 'a' } }\n\nThis method is like `_.set` except that it accepts `customizer` which is\ninvoked to produce the objects of `path`.  If `customizer` returns `undefined`\npath creation is handled by the method instead. The `customizer` is invoked\nwith three arguments: (nsValue, key, nsObject).\n\n**Note:** This method mutates `object`.",
        "grammar": "lsp",
        "label": "lodash-setwith",
        "matches": [
          "lodash setwith"
        ],
        "opts": []
      },
      {
        "content": "_.entries(${object})",
        "doc": "function Foo() {\n  this.a = 1;\n  this.b = 2;\n}\n\nFoo.prototype.c = 3;\n\n_.toPairs(new Foo);\n// => [['a', 1], ['b', 2]] (iteration order is not guaranteed)\n\nCreates an array of own enumerable string keyed-value pairs for `object`\nwhich can be consumed by `_.fromPairs`. If `object` is a map or set, its\nentries are returned.",
        "grammar": "lsp",
        "label": "lodash-entries",
        "matches": [
          "lodash entries"
        ],
        "opts": []
      },
      {
        "content": "_.entriesIn(${object})",
        "doc": "function Foo() {\n  this.a = 1;\n  this.b = 2;\n}\n\nFoo.prototype.c = 3;\n\n_.toPairsIn(new Foo);\n// => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)\n\nCreates an array of own and inherited enumerable string keyed-value pairs\nfor `object` which can be consumed by `_.fromPairs`. If `object` is a map\nor set, its entries are returned.",
        "grammar": "lsp",
        "label": "lodash-entriesin",
        "matches": [
          "lodash entriesin"
        ],
        "opts": []
      },
      {
        "content": "_.transform(${object}, ${iteratee}, ${accumulator})",
        "doc": "_.transform([2, 3, 4], function(result, n) {\n  result.push(n *= n);\n  return n % 2 == 0;\n}, []);\n// => [4, 9]\n\n_.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n  (result[value] || (result[value] = [])).push(key);\n}, {});\n// => { '1': ['a', 'c'], '2': ['b'] }\n\nAn alternative to `_.reduce`; this method transforms `object` to a new\n`accumulator` object which is the result of running each of its own\nenumerable string keyed properties thru `iteratee`, with each invocation\npotentially mutating the `accumulator` object. If `accumulator` is not\nprovided, a new object with the same `[[Prototype]]` will be used. The\niteratee is invoked with four arguments: (accumulator, value, key, object).\nIteratee functions may exit iteration early by explicitly returning `false`.",
        "grammar": "lsp",
        "label": "lodash-transform",
        "matches": [
          "lodash transform"
        ],
        "opts": []
      },
      {
        "content": "_.unset(${object}, ${path})",
        "doc": "var object = { 'a': [{ 'b': { 'c': 7 } }] };\n_.unset(object, 'a[0].b.c');\n// => true\n\nconsole.log(object);\n// => { 'a': [{ 'b': {} }] };\n\n_.unset(object, ['a', '0', 'b', 'c']);\n// => true\n\nconsole.log(object);\n// => { 'a': [{ 'b': {} }] };\n\nRemoves the property at `path` of `object`.\n\n**Note:** This method mutates `object`.",
        "grammar": "lsp",
        "label": "lodash-unset",
        "matches": [
          "lodash unset"
        ],
        "opts": []
      },
      {
        "content": "_.update(${object}, ${path}, ${updater})",
        "doc": "var object = { 'a': [{ 'b': { 'c': 3 } }] };\n\n_.update(object, 'a[0].b.c', function(n) { return n * n; });\nconsole.log(object.a[0].b.c);\n// => 9\n\n_.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });\nconsole.log(object.x[0].y.z);\n// => 0\n\nThis method is like `_.set` except that accepts `updater` to produce the\nvalue to set. Use `_.updateWith` to customize `path` creation. The `updater`\nis invoked with one argument: (value).\n\n**Note:** This method mutates `object`.",
        "grammar": "lsp",
        "label": "lodash-update",
        "matches": [
          "lodash update"
        ],
        "opts": []
      },
      {
        "content": "_.updateWith(${object}, ${path}, ${updater}, ${customizer})",
        "doc": "var object = {};\n\n_.updateWith(object, '[0][1]', _.constant('a'), Object);\n// => { '0': { '1': 'a' } }\n\nThis method is like `_.update` except that it accepts `customizer` which is\ninvoked to produce the objects of `path`.  If `customizer` returns `undefined`\npath creation is handled by the method instead. The `customizer` is invoked\nwith three arguments: (nsValue, key, nsObject).\n\n**Note:** This method mutates `object`.",
        "grammar": "lsp",
        "label": "lodash-updatewith",
        "matches": [
          "lodash updatewith"
        ],
        "opts": []
      },
      {
        "content": "_.values(${object})",
        "doc": "function Foo() {\n  this.a = 1;\n  this.b = 2;\n}\n\nFoo.prototype.c = 3;\n\n_.values(new Foo);\n// => [1, 2] (iteration order is not guaranteed)\n\n_.values('hi');\n// => ['h', 'i']\n\nCreates an array of the own enumerable string keyed property values of `object`.\n\n**Note:** Non-object values are coerced to objects.",
        "grammar": "lsp",
        "label": "lodash-values",
        "matches": [
          "lodash values"
        ],
        "opts": []
      },
      {
        "content": "_.valuesIn(${object})",
        "doc": "function Foo() {\n  this.a = 1;\n  this.b = 2;\n}\n\nFoo.prototype.c = 3;\n\n_.valuesIn(new Foo);\n// => [1, 2, 3] (iteration order is not guaranteed)\n\nCreates an array of the own and inherited enumerable string keyed property\nvalues of `object`.\n\n**Note:** Non-object values are coerced to objects.",
        "grammar": "lsp",
        "label": "lodash-valuesin",
        "matches": [
          "lodash valuesin"
        ],
        "opts": []
      },
      {
        "content": "_.clamp(${number}, ${lower}, ${upper})",
        "doc": "_.clamp(-10, -5, 5);\n// => -5\n\n_.clamp(10, -5, 5);\n// => 5\n\nClamps `number` within the inclusive `lower` and `upper` bounds.",
        "grammar": "lsp",
        "label": "lodash-clamp",
        "matches": [
          "lodash clamp"
        ],
        "opts": []
      },
      {
        "content": "_.inRange(${number}, ${start}, ${end})",
        "doc": "_.inRange(3, 2, 4);\n// => true\n\n_.inRange(4, 8);\n// => true\n\n_.inRange(4, 2);\n// => false\n\n_.inRange(2, 2);\n// => false\n\n_.inRange(1.2, 2);\n// => true\n\n_.inRange(5.2, 4);\n// => false\n\n_.inRange(-3, -2, -6);\n// => true\n\nChecks if `n` is between `start` and up to, but not including, `end`. If\n`end` is not specified, it's set to `start` with `start` then set to `0`.\nIf `start` is greater than `end` the params are swapped to support\nnegative ranges.",
        "grammar": "lsp",
        "label": "lodash-inrange",
        "matches": [
          "lodash inrange"
        ],
        "opts": []
      },
      {
        "content": "_.random(${lower}, ${upper}, ${floating})",
        "doc": "_.random(0, 5);\n// => an integer between 0 and 5\n\n_.random(5);\n// => also an integer between 0 and 5\n\n_.random(5, true);\n// => a floating-point number between 0 and 5\n\n_.random(1.2, 5.2);\n// => a floating-point number between 1.2 and 5.2\n\nProduces a random number between the inclusive `lower` and `upper` bounds.\nIf only one argument is provided a number between `0` and the given number\nis returned. If `floating` is `true`, or either `lower` or `upper` are\nfloats, a floating-point number is returned instead of an integer.\n\n**Note:** JavaScript follows the IEEE-754 standard for resolving\nfloating-point values which can produce unexpected results.",
        "grammar": "lsp",
        "label": "lodash-random",
        "matches": [
          "lodash random"
        ],
        "opts": []
      },
      {
        "content": "_.camelCase(${string})",
        "doc": "_.camelCase('Foo Bar');\n// => 'fooBar'\n\n_.camelCase('--foo-bar--');\n// => 'fooBar'\n\n_.camelCase('__FOO_BAR__');\n// => 'fooBar'\n\nConverts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).",
        "grammar": "lsp",
        "label": "lodash-camelcase",
        "matches": [
          "lodash camelcase"
        ],
        "opts": []
      },
      {
        "content": "_.capitalize(${string})",
        "doc": "_.capitalize('FRED');\n// => 'Fred'\n\nConverts the first character of `string` to upper case and the remaining\nto lower case.",
        "grammar": "lsp",
        "label": "lodash-capitalize",
        "matches": [
          "lodash capitalize"
        ],
        "opts": []
      },
      {
        "content": "_.deburr(${string})",
        "doc": "_.deburr('déjà vu');\n// => 'deja vu'\n\nDeburrs `string` by converting\n[Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\nand [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)\nletters to basic Latin letters and removing\n[combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).",
        "grammar": "lsp",
        "label": "lodash-deburr",
        "matches": [
          "lodash deburr"
        ],
        "opts": []
      },
      {
        "content": "_.endsWith(${string}, ${target}, ${position})",
        "doc": "_.endsWith('abc', 'c');\n// => true\n\n_.endsWith('abc', 'b');\n// => false\n\n_.endsWith('abc', 'b', 2);\n// => true\n\nChecks if `string` ends with the given target string.",
        "grammar": "lsp",
        "label": "lodash-endswith",
        "matches": [
          "lodash endswith"
        ],
        "opts": []
      },
      {
        "content": "_.escape(${string})",
        "doc": "_.escape('fred, barney, & pebbles');\n// => 'fred, barney, &amp; pebbles'\n\nConverts the characters \"&\", \"<\", \">\", '\"', and \"'\" in `string` to their\ncorresponding HTML entities.\n\n**Note:** No other characters are escaped. To escape additional\ncharacters use a third-party library like [_he_](https://mths.be/he).\n\nThough the \">\" character is escaped for symmetry, characters like\n\">\" and \"/\" don't need escaping in HTML and have no special meaning\nunless they're part of a tag or unquoted attribute value. See\n[Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\n(under \"semi-related fun fact\") for more details.\n\nWhen working with HTML you should always\n[quote attribute values](http://wonko.com/post/html-escaping) to reduce\nXSS vectors.",
        "grammar": "lsp",
        "label": "lodash-escape",
        "matches": [
          "lodash escape"
        ],
        "opts": []
      },
      {
        "content": "_.escapeRegExp(${string})",
        "doc": "_.escapeRegExp('[lodash](https://lodash.com/)');\n// => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n\nEscapes the `RegExp` special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\",\n\"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `string`.",
        "grammar": "lsp",
        "label": "lodash-escaperegexp",
        "matches": [
          "lodash escaperegexp"
        ],
        "opts": []
      },
      {
        "content": "_.kebabCase(${string})",
        "doc": "_.kebabCase('Foo Bar');\n// => 'foo-bar'\n\n_.kebabCase('fooBar');\n// => 'foo-bar'\n\n_.kebabCase('__FOO_BAR__');\n// => 'foo-bar'\n\nConverts `string` to\n[kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).",
        "grammar": "lsp",
        "label": "lodash-kebabcase",
        "matches": [
          "lodash kebabcase"
        ],
        "opts": []
      },
      {
        "content": "_.lowerCase(${string})",
        "doc": "_.lowerCase('--Foo-Bar--');\n// => 'foo bar'\n\n_.lowerCase('fooBar');\n// => 'foo bar'\n\n_.lowerCase('__FOO_BAR__');\n// => 'foo bar'\n\nConverts `string`, as space separated words, to lower case.",
        "grammar": "lsp",
        "label": "lodash-lowercase",
        "matches": [
          "lodash lowercase"
        ],
        "opts": []
      },
      {
        "content": "_.lowerFirst(${string})",
        "doc": "_.lowerFirst('Fred');\n// => 'fred'\n\n_.lowerFirst('FRED');\n// => 'fRED'\n\nConverts the first character of `string` to lower case.",
        "grammar": "lsp",
        "label": "lodash-lowerfirst",
        "matches": [
          "lodash lowerfirst"
        ],
        "opts": []
      },
      {
        "content": "_.pad(${string}, ${length}, ${chars})",
        "doc": "_.pad('abc', 8);\n// => '  abc   '\n\n_.pad('abc', 8, '_-');\n// => '_-abc_-_'\n\n_.pad('abc', 3);\n// => 'abc'\n\nPads `string` on the left and right sides if it's shorter than `length`.\nPadding characters are truncated if they can't be evenly divided by `length`.",
        "grammar": "lsp",
        "label": "lodash-pad",
        "matches": [
          "lodash pad"
        ],
        "opts": []
      },
      {
        "content": "_.padEnd(${string}, ${length}, ${chars})",
        "doc": "_.padEnd('abc', 6);\n// => 'abc   '\n\n_.padEnd('abc', 6, '_-');\n// => 'abc_-_'\n\n_.padEnd('abc', 3);\n// => 'abc'\n\nPads `string` on the right side if it's shorter than `length`. Padding\ncharacters are truncated if they exceed `length`.",
        "grammar": "lsp",
        "label": "lodash-padend",
        "matches": [
          "lodash padend"
        ],
        "opts": []
      },
      {
        "content": "_.padStart(${string}, ${length}, ${chars})",
        "doc": "_.padStart('abc', 6);\n// => '   abc'\n\n_.padStart('abc', 6, '_-');\n// => '_-_abc'\n\n_.padStart('abc', 3);\n// => 'abc'\n\nPads `string` on the left side if it's shorter than `length`. Padding\ncharacters are truncated if they exceed `length`.",
        "grammar": "lsp",
        "label": "lodash-padstart",
        "matches": [
          "lodash padstart"
        ],
        "opts": []
      },
      {
        "content": "_.parseInt(${string}, ${radix})",
        "doc": "_.parseInt('08');\n// => 8\n\n_.map(['6', '08', '10'], _.parseInt);\n// => [6, 8, 10]\n\nConverts `string` to an integer of the specified radix. If `radix` is\n`undefined` or `0`, a `radix` of `10` is used unless `value` is a\nhexadecimal, in which case a `radix` of `16` is used.\n\n**Note:** This method aligns with the\n[ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.",
        "grammar": "lsp",
        "label": "lodash-parseint",
        "matches": [
          "lodash parseint"
        ],
        "opts": []
      },
      {
        "content": "_.repeat(${string}, ${n})",
        "doc": "_.repeat('*', 3);\n// => '***'\n\n_.repeat('abc', 2);\n// => 'abcabc'\n\n_.repeat('abc', 0);\n// => ''\n\nRepeats the given string `n` times.",
        "grammar": "lsp",
        "label": "lodash-repeat",
        "matches": [
          "lodash repeat"
        ],
        "opts": []
      },
      {
        "content": "_.replace(${string}, ${pattern}, ${replacement})",
        "doc": "_.replace('Hi Fred', 'Fred', 'Barney');\n// => 'Hi Barney'\n\nReplaces matches for `pattern` in `string` with `replacement`.\n\n**Note:** This method is based on\n[`String#replace`](https://mdn.io/String/replace).",
        "grammar": "lsp",
        "label": "lodash-replace",
        "matches": [
          "lodash replace"
        ],
        "opts": []
      },
      {
        "content": "_.snakeCase(${string})",
        "doc": "_.snakeCase('Foo Bar');\n// => 'foo_bar'\n\n_.snakeCase('fooBar');\n// => 'foo_bar'\n\n_.snakeCase('--FOO-BAR--');\n// => 'foo_bar'\n\nConverts `string` to\n[snake case](https://en.wikipedia.org/wiki/Snake_case).",
        "grammar": "lsp",
        "label": "lodash-snakecase",
        "matches": [
          "lodash snakecase"
        ],
        "opts": []
      },
      {
        "content": "_.split(${string}, ${separator}, ${limit})",
        "doc": "_.split('a-b-c', '-', 2);\n// => ['a', 'b']\n\nSplits `string` by `separator`.\n\n**Note:** This method is based on\n[`String#split`](https://mdn.io/String/split).",
        "grammar": "lsp",
        "label": "lodash-split",
        "matches": [
          "lodash split"
        ],
        "opts": []
      },
      {
        "content": "_.startCase(${string})",
        "doc": "_.startCase('--foo-bar--');\n// => 'Foo Bar'\n\n_.startCase('fooBar');\n// => 'Foo Bar'\n\n_.startCase('__FOO_BAR__');\n// => 'FOO BAR'\n\nConverts `string` to\n[start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).",
        "grammar": "lsp",
        "label": "lodash-startcase",
        "matches": [
          "lodash startcase"
        ],
        "opts": []
      },
      {
        "content": "_.startsWith(${string}, ${target}, ${position})",
        "doc": "_.startsWith('abc', 'a');\n// => true\n\n_.startsWith('abc', 'b');\n// => false\n\n_.startsWith('abc', 'b', 1);\n// => true\n\nChecks if `string` starts with the given target string.",
        "grammar": "lsp",
        "label": "lodash-startswith",
        "matches": [
          "lodash startswith"
        ],
        "opts": []
      },
      {
        "content": "_.template(${string}, ${options}, ${options.escape}, ${options.evaluate}, ${options.imports}, ${options.interpolate}, ${options.sourceURL}, ${options.variable})",
        "doc": "// Use the \"interpolate\" delimiter to create a compiled template.\nvar compiled = _.template('hello <%= user %>!');\ncompiled({ 'user': 'fred' });\n// => 'hello fred!'\n\n// Use the HTML \"escape\" delimiter to escape data property values.\nvar compiled = _.template('<b><%- value %></b>');\ncompiled({ 'value': '<script>' });\n// => '<b>&lt;script&gt;</b>'\n\n// Use the \"evaluate\" delimiter to execute JavaScript and generate HTML.\nvar compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');\ncompiled({ 'users': ['fred', 'barney'] });\n// => '<li>fred</li><li>barney</li>'\n\n// Use the internal `print` function in \"evaluate\" delimiters.\nvar compiled = _.template('<% print(\"hello \" + user); %>!');\ncompiled({ 'user': 'barney' });\n// => 'hello barney!'\n\n// Use the ES template literal delimiter as an \"interpolate\" delimiter.\n// Disable support by replacing the \"interpolate\" delimiter.\nvar compiled = _.template('hello ${ user }!');\ncompiled({ 'user': 'pebbles' });\n// => 'hello pebbles!'\n\n// Use backslashes to treat delimiters as plain text.\nvar compiled = _.template('<%= \"\\\\<%- value %\\\\>\" %>');\ncompiled({ 'value': 'ignored' });\n// => '<%- value %>'\n\n// Use the `imports` option to import `jQuery` as `jq`.\nvar text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';\nvar compiled = _.template(text, { 'imports': { 'jq': jQuery } });\ncompiled({ 'users': ['fred', 'barney'] });\n// => '<li>fred</li><li>barney</li>'\n\n// Use the `sourceURL` option to specify a custom sourceURL for the template.\nvar compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });\ncompiled(data);\n// => Find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector.\n\n// Use the `variable` option to ensure a with-statement isn't used in the compiled template.\nvar compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });\ncompiled.source;\n// => function(data) {\n//   var __t, __p = '';\n//   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';\n//   return __p;\n// }\n\n// Use custom template delimiters.\n_.templateSettings.interpolate = /{{([\\s\\S]+?)}}/g;\nvar compiled = _.template('hello {{ user }}!');\ncompiled({ 'user': 'mustache' });\n// => 'hello mustache!'\n\n// Use the `source` property to inline compiled templates for meaningful\n// line numbers in error messages and stack traces.\nfs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\\\n  var JST = {\\\n    \"main\": ' + _.template(mainText).source + '\\\n  };\\\n');\n\nCreates a compiled template function that can interpolate data properties\nin \"interpolate\" delimiters, HTML-escape interpolated data properties in\n\"escape\" delimiters, and execute JavaScript in \"evaluate\" delimiters. Data\nproperties may be accessed as free variables in the template. If a setting\nobject is given, it takes precedence over `_.templateSettings` values.\n\n**Note:** In the development build `_.template` utilizes\n[sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)\nfor easier debugging.\n\nFor more information on precompiling templates see\n[lodash's custom builds documentation](https://lodash.com/custom-builds).\n\nFor more information on Chrome extension sandboxes see\n[Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).",
        "grammar": "lsp",
        "label": "lodash-template",
        "matches": [
          "lodash template"
        ],
        "opts": []
      },
      {
        "content": "_.toLower(${string})",
        "doc": "_.toLower('--Foo-Bar--');\n// => '--foo-bar--'\n\n_.toLower('fooBar');\n// => 'foobar'\n\n_.toLower('__FOO_BAR__');\n// => '__foo_bar__'\n\nConverts `string`, as a whole, to lower case just like\n[String#toLowerCase](https://mdn.io/toLowerCase).",
        "grammar": "lsp",
        "label": "lodash-tolower",
        "matches": [
          "lodash tolower"
        ],
        "opts": []
      },
      {
        "content": "_.toUpper(${string})",
        "doc": "_.toUpper('--foo-bar--');\n// => '--FOO-BAR--'\n\n_.toUpper('fooBar');\n// => 'FOOBAR'\n\n_.toUpper('__foo_bar__');\n// => '__FOO_BAR__'\n\nConverts `string`, as a whole, to upper case just like\n[String#toUpperCase](https://mdn.io/toUpperCase).",
        "grammar": "lsp",
        "label": "lodash-toupper",
        "matches": [
          "lodash toupper"
        ],
        "opts": []
      },
      {
        "content": "_.trim(${string}, ${chars})",
        "doc": "_.trim('  abc  ');\n// => 'abc'\n\n_.trim('-_-abc-_-', '_-');\n// => 'abc'\n\n_.map(['  foo  ', '  bar  '], _.trim);\n// => ['foo', 'bar']\n\nRemoves leading and trailing whitespace or specified characters from `string`.",
        "grammar": "lsp",
        "label": "lodash-trim",
        "matches": [
          "lodash trim"
        ],
        "opts": []
      },
      {
        "content": "_.trimEnd(${string}, ${chars})",
        "doc": "_.trimEnd('  abc  ');\n// => '  abc'\n\n_.trimEnd('-_-abc-_-', '_-');\n// => '-_-abc'\n\nRemoves trailing whitespace or specified characters from `string`.",
        "grammar": "lsp",
        "label": "lodash-trimend",
        "matches": [
          "lodash trimend"
        ],
        "opts": []
      },
      {
        "content": "_.trimStart(${string}, ${chars})",
        "doc": "_.trimStart('  abc  ');\n// => 'abc  '\n\n_.trimStart('-_-abc-_-', '_-');\n// => 'abc-_-'\n\nRemoves leading whitespace or specified characters from `string`.",
        "grammar": "lsp",
        "label": "lodash-trimstart",
        "matches": [
          "lodash trimstart"
        ],
        "opts": []
      },
      {
        "content": "_.truncate(${string}, ${options}, ${options.length}, ${options.omission}, ${options.separator})",
        "doc": "_.truncate('hi-diddly-ho there, neighborino');\n// => 'hi-diddly-ho there, neighbo...'\n\n_.truncate('hi-diddly-ho there, neighborino', {\n  'length': 24,\n  'separator': ' '\n});\n// => 'hi-diddly-ho there,...'\n\n_.truncate('hi-diddly-ho there, neighborino', {\n  'length': 24,\n  'separator': /,? +/\n});\n// => 'hi-diddly-ho there...'\n\n_.truncate('hi-diddly-ho there, neighborino', {\n  'omission': ' [...]'\n});\n// => 'hi-diddly-ho there, neig [...]'\n\nTruncates `string` if it's longer than the given maximum string length.\nThe last characters of the truncated string are replaced with the omission\nstring which defaults to \"...\".",
        "grammar": "lsp",
        "label": "lodash-truncate",
        "matches": [
          "lodash truncate"
        ],
        "opts": []
      },
      {
        "content": "_.unescape(${string})",
        "doc": "_.unescape('fred, barney, &amp; pebbles');\n// => 'fred, barney, & pebbles'\n\nThe inverse of `_.escape`; this method converts the HTML entities\n`&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to\ntheir corresponding characters.\n\n**Note:** No other HTML entities are unescaped. To unescape additional\nHTML entities use a third-party library like [_he_](https://mths.be/he).",
        "grammar": "lsp",
        "label": "lodash-unescape",
        "matches": [
          "lodash unescape"
        ],
        "opts": []
      },
      {
        "content": "_.upperCase(${string})",
        "doc": "_.upperCase('--foo-bar');\n// => 'FOO BAR'\n\n_.upperCase('fooBar');\n// => 'FOO BAR'\n\n_.upperCase('__foo_bar__');\n// => 'FOO BAR'\n\nConverts `string`, as space separated words, to upper case.",
        "grammar": "lsp",
        "label": "lodash-uppercase",
        "matches": [
          "lodash uppercase"
        ],
        "opts": []
      },
      {
        "content": "_.upperFirst(${string})",
        "doc": "_.upperFirst('fred');\n// => 'Fred'\n\n_.upperFirst('FRED');\n// => 'FRED'\n\nConverts the first character of `string` to upper case.",
        "grammar": "lsp",
        "label": "lodash-upperfirst",
        "matches": [
          "lodash upperfirst"
        ],
        "opts": []
      },
      {
        "content": "_.words(${string}, ${pattern})",
        "doc": "_.words('fred, barney, & pebbles');\n// => ['fred', 'barney', 'pebbles']\n\n_.words('fred, barney, & pebbles', /[^, ]+/g);\n// => ['fred', 'barney', '&', 'pebbles']\n\nSplits `string` into an array of its words.",
        "grammar": "lsp",
        "label": "lodash-words",
        "matches": [
          "lodash words"
        ],
        "opts": []
      },
      {
        "content": "_.attempt(${func}, ${args})",
        "doc": "// Avoid throwing errors for invalid selectors.\nvar elements = _.attempt(function(selector) {\n  return document.querySelectorAll(selector);\n}, '>_>');\n\nif (_.isError(elements)) {\n  elements = [];\n}\n\nAttempts to invoke `func`, returning either the result or the caught error\nobject. Any additional arguments are provided to `func` when it's invoked.",
        "grammar": "lsp",
        "label": "lodash-attempt",
        "matches": [
          "lodash attempt"
        ],
        "opts": []
      },
      {
        "content": "_.bindAll(${object}, ${methodNames})",
        "doc": "var view = {\n  'label': 'docs',\n  'click': function() {\n    console.log('clicked ' + this.label);\n  }\n};\n\n_.bindAll(view, ['click']);\njQuery(element).on('click', view.click);\n// => Logs 'clicked docs' when clicked.\n\nBinds methods of an object to the object itself, overwriting the existing\nmethod.\n\n**Note:** This method doesn't set the \"length\" property of bound functions.",
        "grammar": "lsp",
        "label": "lodash-bindall",
        "matches": [
          "lodash bindall"
        ],
        "opts": []
      },
      {
        "content": "_.cond(${pairs})",
        "doc": "var func = _.cond([\n  [_.matches({ 'a': 1 }),           _.constant('matches A')],\n  [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],\n  [_.stubTrue,                      _.constant('no match')]\n]);\n\nfunc({ 'a': 1, 'b': 2 });\n// => 'matches A'\n\nfunc({ 'a': 0, 'b': 1 });\n// => 'matches B'\n\nfunc({ 'a': '1', 'b': '2' });\n// => 'no match'\n\nCreates a function that iterates over `pairs` and invokes the corresponding\nfunction of the first predicate to return truthy. The predicate-function\npairs are invoked with the `this` binding and arguments of the created\nfunction.",
        "grammar": "lsp",
        "label": "lodash-cond",
        "matches": [
          "lodash cond"
        ],
        "opts": []
      },
      {
        "content": "_.conforms(${source})",
        "doc": "var objects = [\n  { 'a': 2, 'b': 1 },\n  { 'a': 1, 'b': 2 }\n];\n\n_.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));\n// => [{ 'a': 1, 'b': 2 }]\n\nCreates a function that invokes the predicate properties of `source` with\nthe corresponding property values of a given object, returning `true` if\nall predicates return truthy, else `false`.\n\n**Note:** The created function is equivalent to `_.conformsTo` with\n`source` partially applied.",
        "grammar": "lsp",
        "label": "lodash-conforms",
        "matches": [
          "lodash conforms"
        ],
        "opts": []
      },
      {
        "content": "_.constant(${value})",
        "doc": "var objects = _.times(2, _.constant({ 'a': 1 }));\n\nconsole.log(objects);\n// => [{ 'a': 1 }, { 'a': 1 }]\n\nconsole.log(objects[0] === objects[1]);\n// => true\n\nCreates a function that returns `value`.",
        "grammar": "lsp",
        "label": "lodash-constant",
        "matches": [
          "lodash constant"
        ],
        "opts": []
      },
      {
        "content": "_.defaultTo(${value}, ${defaultValue})",
        "doc": "_.defaultTo(1, 10);\n// => 1\n\n_.defaultTo(undefined, 10);\n// => 10\n\nChecks `value` to determine whether a default value should be returned in\nits place. The `defaultValue` is returned if `value` is `NaN`, `null`,\nor `undefined`.",
        "grammar": "lsp",
        "label": "lodash-defaultto",
        "matches": [
          "lodash defaultto"
        ],
        "opts": []
      },
      {
        "content": "_.flow(${funcs})",
        "doc": "function square(n) {\n  return n * n;\n}\n\nvar addSquare = _.flow([_.add, square]);\naddSquare(1, 2);\n// => 9\n\nCreates a function that returns the result of invoking the given functions\nwith the `this` binding of the created function, where each successive\ninvocation is supplied the return value of the previous.",
        "grammar": "lsp",
        "label": "lodash-flow",
        "matches": [
          "lodash flow"
        ],
        "opts": []
      },
      {
        "content": "_.flowRight(${funcs})",
        "doc": "function square(n) {\n  return n * n;\n}\n\nvar addSquare = _.flowRight([square, _.add]);\naddSquare(1, 2);\n// => 9\n\nThis method is like `_.flow` except that it creates a function that\ninvokes the given functions from right to left.",
        "grammar": "lsp",
        "label": "lodash-flowright",
        "matches": [
          "lodash flowright"
        ],
        "opts": []
      },
      {
        "content": "_.identity(${value})",
        "doc": "var object = { 'a': 1 };\n\nconsole.log(_.identity(object) === object);\n// => true\n\nThis method returns the first argument it receives.",
        "grammar": "lsp",
        "label": "lodash-identity",
        "matches": [
          "lodash identity"
        ],
        "opts": []
      },
      {
        "content": "_.iteratee(${func})",
        "doc": "var users = [\n  { 'user': 'barney', 'age': 36, 'active': true },\n  { 'user': 'fred',   'age': 40, 'active': false }\n];\n\n// The `_.matches` iteratee shorthand.\n_.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));\n// => [{ 'user': 'barney', 'age': 36, 'active': true }]\n\n// The `_.matchesProperty` iteratee shorthand.\n_.filter(users, _.iteratee(['user', 'fred']));\n// => [{ 'user': 'fred', 'age': 40 }]\n\n// The `_.property` iteratee shorthand.\n_.map(users, _.iteratee('user'));\n// => ['barney', 'fred']\n\n// Create custom iteratee shorthands.\n_.iteratee = _.wrap(_.iteratee, function(iteratee, func) {\n  return !_.isRegExp(func) ? iteratee(func) : function(string) {\n    return func.test(string);\n  };\n});\n\n_.filter(['abc', 'def'], /ef/);\n// => ['def']\n\nCreates a function that invokes `func` with the arguments of the created\nfunction. If `func` is a property name, the created function returns the\nproperty value for a given element. If `func` is an array or object, the\ncreated function returns `true` for elements that contain the equivalent\nsource properties, otherwise it returns `false`.",
        "grammar": "lsp",
        "label": "lodash-iteratee",
        "matches": [
          "lodash iteratee"
        ],
        "opts": []
      },
      {
        "content": "_.matches(${source})",
        "doc": "var objects = [\n  { 'a': 1, 'b': 2, 'c': 3 },\n  { 'a': 4, 'b': 5, 'c': 6 }\n];\n\n_.filter(objects, _.matches({ 'a': 4, 'c': 6 }));\n// => [{ 'a': 4, 'b': 5, 'c': 6 }]\n\nCreates a function that performs a partial deep comparison between a given\nobject and `source`, returning `true` if the given object has equivalent\nproperty values, else `false`.\n\n**Note:** The created function is equivalent to `_.isMatch` with `source`\npartially applied.\n\nPartial comparisons will match empty array and empty object `source`\nvalues against any array or object value, respectively. See `_.isEqual`\nfor a list of supported value comparisons.",
        "grammar": "lsp",
        "label": "lodash-matches",
        "matches": [
          "lodash matches"
        ],
        "opts": []
      },
      {
        "content": "_.matchesProperty(${path}, ${srcValue})",
        "doc": "var objects = [\n  { 'a': 1, 'b': 2, 'c': 3 },\n  { 'a': 4, 'b': 5, 'c': 6 }\n];\n\n_.find(objects, _.matchesProperty('a', 4));\n// => { 'a': 4, 'b': 5, 'c': 6 }\n\nCreates a function that performs a partial deep comparison between the\nvalue at `path` of a given object to `srcValue`, returning `true` if the\nobject value is equivalent, else `false`.\n\n**Note:** Partial comparisons will match empty array and empty object\n`srcValue` values against any array or object value, respectively. See\n`_.isEqual` for a list of supported value comparisons.",
        "grammar": "lsp",
        "label": "lodash-matchesproperty",
        "matches": [
          "lodash matchesproperty"
        ],
        "opts": []
      },
      {
        "content": "_.method(${path}, ${args})",
        "doc": "var objects = [\n  { 'a': { 'b': _.constant(2) } },\n  { 'a': { 'b': _.constant(1) } }\n];\n\n_.map(objects, _.method('a.b'));\n// => [2, 1]\n\n_.map(objects, _.method(['a', 'b']));\n// => [2, 1]\n\nCreates a function that invokes the method at `path` of a given object.\nAny additional arguments are provided to the invoked method.",
        "grammar": "lsp",
        "label": "lodash-method",
        "matches": [
          "lodash method"
        ],
        "opts": []
      },
      {
        "content": "_.methodOf(${object}, ${args})",
        "doc": "var array = _.times(3, _.constant),\n    object = { 'a': array, 'b': array, 'c': array };\n\n_.map(['a[2]', 'c[0]'], _.methodOf(object));\n// => [2, 0]\n\n_.map([['a', '2'], ['c', '0']], _.methodOf(object));\n// => [2, 0]\n\nThe opposite of `_.method`; this method creates a function that invokes\nthe method at a given path of `object`. Any additional arguments are\nprovided to the invoked method.",
        "grammar": "lsp",
        "label": "lodash-methodof",
        "matches": [
          "lodash methodof"
        ],
        "opts": []
      },
      {
        "content": "_.mixin(${object}, ${source}, ${options}, ${options.chain})",
        "doc": "function vowels(string) {\n  return _.filter(string, function(v) {\n    return /[aeiou]/i.test(v);\n  });\n}\n\n_.mixin({ 'vowels': vowels });\n_.vowels('fred');\n// => ['e']\n\n_('fred').vowels().value();\n// => ['e']\n\n_.mixin({ 'vowels': vowels }, { 'chain': false });\n_('fred').vowels();\n// => ['e']\n\nAdds all own enumerable string keyed function properties of a source\nobject to the destination object. If `object` is a function, then methods\nare added to its prototype as well.\n\n**Note:** Use `_.runInContext` to create a pristine `lodash` function to\navoid conflicts caused by modifying the original.",
        "grammar": "lsp",
        "label": "lodash-mixin",
        "matches": [
          "lodash mixin"
        ],
        "opts": []
      },
      {
        "content": "_.noConflict()",
        "doc": "var lodash = _.noConflict();\n\nReverts the `_` variable to its previous value and returns a reference to\nthe `lodash` function.",
        "grammar": "lsp",
        "label": "lodash-noconflict",
        "matches": [
          "lodash noconflict"
        ],
        "opts": []
      },
      {
        "content": "_.noop()",
        "doc": "_.times(2, _.noop);\n// => [undefined, undefined]\n\nThis method returns `undefined`.",
        "grammar": "lsp",
        "label": "lodash-noop",
        "matches": [
          "lodash noop"
        ],
        "opts": []
      },
      {
        "content": "_.nthArg(${n})",
        "doc": "var func = _.nthArg(1);\nfunc('a', 'b', 'c', 'd');\n// => 'b'\n\nvar func = _.nthArg(-2);\nfunc('a', 'b', 'c', 'd');\n// => 'c'\n\nCreates a function that gets the argument at index `n`. If `n` is negative,\nthe nth argument from the end is returned.",
        "grammar": "lsp",
        "label": "lodash-ntharg",
        "matches": [
          "lodash ntharg"
        ],
        "opts": []
      },
      {
        "content": "_.over(${iteratees})",
        "doc": "var func = _.over([Math.max, Math.min]);\n\nfunc(1, 2, 3, 4);\n// => [4, 1]\n\nCreates a function that invokes `iteratees` with the arguments it receives\nand returns their results.",
        "grammar": "lsp",
        "label": "lodash-over",
        "matches": [
          "lodash over"
        ],
        "opts": []
      },
      {
        "content": "_.overEvery(${predicates})",
        "doc": "var func = _.overEvery([Boolean, isFinite]);\n\nfunc('1');\n// => true\n\nfunc(null);\n// => false\n\nfunc(NaN);\n// => false\n\nCreates a function that checks if **all** of the `predicates` return\ntruthy when invoked with the arguments it receives.",
        "grammar": "lsp",
        "label": "lodash-overevery",
        "matches": [
          "lodash overevery"
        ],
        "opts": []
      },
      {
        "content": "_.overSome(${predicates})",
        "doc": "var func = _.overSome([Boolean, isFinite]);\n\nfunc('1');\n// => true\n\nfunc(null);\n// => true\n\nfunc(NaN);\n// => false\n\nCreates a function that checks if **any** of the `predicates` return\ntruthy when invoked with the arguments it receives.",
        "grammar": "lsp",
        "label": "lodash-oversome",
        "matches": [
          "lodash oversome"
        ],
        "opts": []
      },
      {
        "content": "_.property(${path})",
        "doc": "var objects = [\n  { 'a': { 'b': 2 } },\n  { 'a': { 'b': 1 } }\n];\n\n_.map(objects, _.property('a.b'));\n// => [2, 1]\n\n_.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n// => [1, 2]\n\nCreates a function that returns the value at `path` of a given object.",
        "grammar": "lsp",
        "label": "lodash-property",
        "matches": [
          "lodash property"
        ],
        "opts": []
      },
      {
        "content": "_.propertyOf(${object})",
        "doc": "var array = [0, 1, 2],\n    object = { 'a': array, 'b': array, 'c': array };\n\n_.map(['a[2]', 'c[0]'], _.propertyOf(object));\n// => [2, 0]\n\n_.map([['a', '2'], ['c', '0']], _.propertyOf(object));\n// => [2, 0]\n\nThe opposite of `_.property`; this method creates a function that returns\nthe value at a given path of `object`.",
        "grammar": "lsp",
        "label": "lodash-propertyof",
        "matches": [
          "lodash propertyof"
        ],
        "opts": []
      },
      {
        "content": "_.range(${start}, ${end}, ${step})",
        "doc": "_.range(4);\n// => [0, 1, 2, 3]\n\n_.range(-4);\n// => [0, -1, -2, -3]\n\n_.range(1, 5);\n// => [1, 2, 3, 4]\n\n_.range(0, 20, 5);\n// => [0, 5, 10, 15]\n\n_.range(0, -4, -1);\n// => [0, -1, -2, -3]\n\n_.range(1, 4, 0);\n// => [1, 1, 1]\n\n_.range(0);\n// => []\n\nCreates an array of numbers (positive and/or negative) progressing from\n`start` up to, but not including, `end`. A step of `-1` is used if a negative\n`start` is specified without an `end` or `step`. If `end` is not specified,\nit's set to `start` with `start` then set to `0`.\n\n**Note:** JavaScript follows the IEEE-754 standard for resolving\nfloating-point values which can produce unexpected results.",
        "grammar": "lsp",
        "label": "lodash-range",
        "matches": [
          "lodash range"
        ],
        "opts": []
      },
      {
        "content": "_.rangeRight(${start}, ${end}, ${step})",
        "doc": "_.rangeRight(4);\n// => [3, 2, 1, 0]\n\n_.rangeRight(-4);\n// => [-3, -2, -1, 0]\n\n_.rangeRight(1, 5);\n// => [4, 3, 2, 1]\n\n_.rangeRight(0, 20, 5);\n// => [15, 10, 5, 0]\n\n_.rangeRight(0, -4, -1);\n// => [-3, -2, -1, 0]\n\n_.rangeRight(1, 4, 0);\n// => [1, 1, 1]\n\n_.rangeRight(0);\n// => []\n\nThis method is like `_.range` except that it populates values in\ndescending order.",
        "grammar": "lsp",
        "label": "lodash-rangeright",
        "matches": [
          "lodash rangeright"
        ],
        "opts": []
      },
      {
        "content": "_.stubArray()",
        "doc": "var arrays = _.times(2, _.stubArray);\n\nconsole.log(arrays);\n// => [[], []]\n\nconsole.log(arrays[0] === arrays[1]);\n// => false\n\nThis method returns a new empty array.",
        "grammar": "lsp",
        "label": "lodash-stubarray",
        "matches": [
          "lodash stubarray"
        ],
        "opts": []
      },
      {
        "content": "_.stubFalse()",
        "doc": "_.times(2, _.stubFalse);\n// => [false, false]\n\nThis method returns `false`.",
        "grammar": "lsp",
        "label": "lodash-stubfalse",
        "matches": [
          "lodash stubfalse"
        ],
        "opts": []
      },
      {
        "content": "_.stubObject()",
        "doc": "var objects = _.times(2, _.stubObject);\n\nconsole.log(objects);\n// => [{}, {}]\n\nconsole.log(objects[0] === objects[1]);\n// => false\n\nThis method returns a new empty object.",
        "grammar": "lsp",
        "label": "lodash-stubobject",
        "matches": [
          "lodash stubobject"
        ],
        "opts": []
      },
      {
        "content": "_.stubString()",
        "doc": "_.times(2, _.stubString);\n// => ['', '']\n\nThis method returns an empty string.",
        "grammar": "lsp",
        "label": "lodash-stubstring",
        "matches": [
          "lodash stubstring"
        ],
        "opts": []
      },
      {
        "content": "_.stubTrue()",
        "doc": "_.times(2, _.stubTrue);\n// => [true, true]\n\nThis method returns `true`.",
        "grammar": "lsp",
        "label": "lodash-stubtrue",
        "matches": [
          "lodash stubtrue"
        ],
        "opts": []
      },
      {
        "content": "_.times(${n}, ${iteratee})",
        "doc": "_.times(3, String);\n// => ['0', '1', '2']\n\n _.times(4, _.constant(0));\n// => [0, 0, 0, 0]\n\nInvokes the iteratee `n` times, returning an array of the results of\neach invocation. The iteratee is invoked with one argument; (index).",
        "grammar": "lsp",
        "label": "lodash-times",
        "matches": [
          "lodash times"
        ],
        "opts": []
      },
      {
        "content": "_.toPath(${value})",
        "doc": "_.toPath('a.b.c');\n// => ['a', 'b', 'c']\n\n_.toPath('a[0].b.c');\n// => ['a', '0', 'b', 'c']\n\nConverts `value` to a property path array.",
        "grammar": "lsp",
        "label": "lodash-topath",
        "matches": [
          "lodash topath"
        ],
        "opts": []
      },
      {
        "content": "_.uniqueId(${prefix})",
        "doc": "_.uniqueId('contact_');\n// => 'contact_104'\n\n_.uniqueId();\n// => '105'\n\nGenerates a unique ID. If `prefix` is given, the ID is appended to it.",
        "grammar": "lsp",
        "label": "lodash-uniqueid",
        "matches": [
          "lodash uniqueid"
        ],
        "opts": []
      },
      {
        "content": "_.add(${augend}, ${addend})",
        "doc": "_.add(6, 4);\n// => 10\n\nAdds two numbers.",
        "grammar": "lsp",
        "label": "lodash-add",
        "matches": [
          "lodash add"
        ],
        "opts": []
      },
      {
        "content": "_.ceil(${number}, ${precision})",
        "doc": "_.ceil(4.006);\n// => 5\n\n_.ceil(6.004, 2);\n// => 6.01\n\n_.ceil(6040, -2);\n// => 6100\n\nComputes `number` rounded up to `precision`.",
        "grammar": "lsp",
        "label": "lodash-ceil",
        "matches": [
          "lodash ceil"
        ],
        "opts": []
      },
      {
        "content": "_.divide(${dividend}, ${divisor})",
        "doc": "_.divide(6, 4);\n// => 1.5\n\nDivide two numbers.",
        "grammar": "lsp",
        "label": "lodash-divide",
        "matches": [
          "lodash divide"
        ],
        "opts": []
      },
      {
        "content": "_.floor(${number}, ${precision})",
        "doc": "_.floor(4.006);\n// => 4\n\n_.floor(0.046, 2);\n// => 0.04\n\n_.floor(4060, -2);\n// => 4000\n\nComputes `number` rounded down to `precision`.",
        "grammar": "lsp",
        "label": "lodash-floor",
        "matches": [
          "lodash floor"
        ],
        "opts": []
      },
      {
        "content": "_.max(${array})",
        "doc": "_.max([4, 2, 8, 6]);\n// => 8\n\n_.max([]);\n// => undefined\n\nComputes the maximum value of `array`. If `array` is empty or falsey,\n`undefined` is returned.",
        "grammar": "lsp",
        "label": "lodash-max",
        "matches": [
          "lodash max"
        ],
        "opts": []
      },
      {
        "content": "_.maxBy(${array}, ${iteratee})",
        "doc": "var objects = [{ 'n': 1 }, { 'n': 2 }];\n\n_.maxBy(objects, function(o) { return o.n; });\n// => { 'n': 2 }\n\n// The `_.property` iteratee shorthand.\n_.maxBy(objects, 'n');\n// => { 'n': 2 }\n\nThis method is like `_.max` except that it accepts `iteratee` which is\ninvoked for each element in `array` to generate the criterion by which\nthe value is ranked. The iteratee is invoked with one argument: (value).",
        "grammar": "lsp",
        "label": "lodash-maxby",
        "matches": [
          "lodash maxby"
        ],
        "opts": []
      },
      {
        "content": "_.mean(${array})",
        "doc": "_.mean([4, 2, 8, 6]);\n// => 5\n\nComputes the mean of the values in `array`.",
        "grammar": "lsp",
        "label": "lodash-mean",
        "matches": [
          "lodash mean"
        ],
        "opts": []
      },
      {
        "content": "_.meanBy(${array}, ${iteratee})",
        "doc": "var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n\n_.meanBy(objects, function(o) { return o.n; });\n// => 5\n\n// The `_.property` iteratee shorthand.\n_.meanBy(objects, 'n');\n// => 5\n\nThis method is like `_.mean` except that it accepts `iteratee` which is\ninvoked for each element in `array` to generate the value to be averaged.\nThe iteratee is invoked with one argument: (value).",
        "grammar": "lsp",
        "label": "lodash-meanby",
        "matches": [
          "lodash meanby"
        ],
        "opts": []
      },
      {
        "content": "_.min(${array})",
        "doc": "_.min([4, 2, 8, 6]);\n// => 2\n\n_.min([]);\n// => undefined\n\nComputes the minimum value of `array`. If `array` is empty or falsey,\n`undefined` is returned.",
        "grammar": "lsp",
        "label": "lodash-min",
        "matches": [
          "lodash min"
        ],
        "opts": []
      },
      {
        "content": "_.minBy(${array}, ${iteratee})",
        "doc": "var objects = [{ 'n': 1 }, { 'n': 2 }];\n\n_.minBy(objects, function(o) { return o.n; });\n// => { 'n': 1 }\n\n// The `_.property` iteratee shorthand.\n_.minBy(objects, 'n');\n// => { 'n': 1 }\n\nThis method is like `_.min` except that it accepts `iteratee` which is\ninvoked for each element in `array` to generate the criterion by which\nthe value is ranked. The iteratee is invoked with one argument: (value).",
        "grammar": "lsp",
        "label": "lodash-minby",
        "matches": [
          "lodash minby"
        ],
        "opts": []
      },
      {
        "content": "_.multiply(${multiplier}, ${multiplicand})",
        "doc": "_.multiply(6, 4);\n// => 24\n\nMultiply two numbers.",
        "grammar": "lsp",
        "label": "lodash-multiply",
        "matches": [
          "lodash multiply"
        ],
        "opts": []
      },
      {
        "content": "_.round(${number}, ${precision})",
        "doc": "_.round(4.006);\n// => 4\n\n_.round(4.006, 2);\n// => 4.01\n\n_.round(4060, -2);\n// => 4100\n\nComputes `number` rounded to `precision`.",
        "grammar": "lsp",
        "label": "lodash-round",
        "matches": [
          "lodash round"
        ],
        "opts": []
      },
      {
        "content": "_.subtract(${minuend}, ${subtrahend})",
        "doc": "_.subtract(6, 4);\n// => 2\n\nSubtract two numbers.",
        "grammar": "lsp",
        "label": "lodash-subtract",
        "matches": [
          "lodash subtract"
        ],
        "opts": []
      },
      {
        "content": "_.sum(${array})",
        "doc": "_.sum([4, 2, 8, 6]);\n// => 20\n\nComputes the sum of the values in `array`.",
        "grammar": "lsp",
        "label": "lodash-sum",
        "matches": [
          "lodash sum"
        ],
        "opts": []
      },
      {
        "content": "_.sumBy(${array}, ${iteratee})",
        "doc": "var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n\n_.sumBy(objects, function(o) { return o.n; });\n// => 20\n\n// The `_.property` iteratee shorthand.\n_.sumBy(objects, 'n');\n// => 20\n\nThis method is like `_.sum` except that it accepts `iteratee` which is\ninvoked for each element in `array` to generate the value to be summed.\nThe iteratee is invoked with one argument: (value).",
        "grammar": "lsp",
        "label": "lodash-sumby",
        "matches": [
          "lodash sumby"
        ],
        "opts": []
      }
    ],
    "lpc": [
      {
        "content": "#include <${1:stdio}.h>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "inc"
        ],
        "opts": []
      },
      {
        "content": "#include \"${1:`vim_snippets#Filename(\"$1.h\")`}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Inc"
        ],
        "opts": []
      },
      {
        "content": "#ifndef $1\n#define ${1:SYMBOL} ${2:value}\n#endif /* ifndef $1 */",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ndef"
        ],
        "opts": []
      },
      {
        "content": "#define",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "def"
        ],
        "opts": []
      },
      {
        "content": "#ifdef ${1:FOO}\n\t${2:#define }\n#endif",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifdef"
        ],
        "opts": []
      },
      {
        "content": "#if ${1:FOO}\n\t${0:${VISUAL}}\n#endif",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#if"
        ],
        "opts": []
      },
      {
        "content": "#ifndef ${1:`toupper(vim_snippets#Filename('$1_H', 'UNTITLED_H'))`}\n#define $1\n${0}\n#endif /* end of include guard: $1 */",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "once"
        ],
        "opts": []
      },
      {
        "content": "if(${1:true})\n{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "if(${1:true})\n{\n\t${2:${VISUAL}}\n}\nelse\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "else\n{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "el"
        ],
        "opts": []
      },
      {
        "content": "else if(${1:true})\n{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "elif"
        ],
        "opts": []
      },
      {
        "content": "if(${1:true}) ${0};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifi"
        ],
        "opts": []
      },
      {
        "content": "${1:/* condition */} ? ${2:a} : ${3:b}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "t"
        ],
        "opts": []
      },
      {
        "content": "switch(${1:/* variable */})\n{\n\tcase ${2:/* variable case */}:\n\t\t${3}\n\t\t${4:break;}${5}\n\tdefault:\n\t\t${6}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "switch"
        ],
        "opts": []
      },
      {
        "content": "switch(${1:/* variable */})\n{\n\tcase ${2:/* variable case */}:\n\t\t${3}\n\t\t${4:break;}${5}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "switchndef"
        ],
        "opts": []
      },
      {
        "content": "case ${1:/* variable case */}:\n\t${2}\n\t${3:break;}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case"
        ],
        "opts": []
      },
      {
        "content": "return ${0};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ret"
        ],
        "opts": []
      },
      {
        "content": "foreach(${1:mixed} ${2:ele} in ${3:arr})\n{\n\t${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fore"
        ],
        "opts": []
      },
      {
        "content": "for(int ${2:i} = 0; $2 < ${1:count}; $2${3:++})\n{\n\t${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "for(int ${1:i} = ${2:0}; ${3:$1 < 10}; $1${4:++})\n{\n\t${5}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forr"
        ],
        "opts": []
      },
      {
        "content": "while(${1:/* condition */})\n{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh"
        ],
        "opts": []
      },
      {
        "content": "do{\n\t${0:${VISUAL}}\n}while (${1:/* condition */});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "do"
        ],
        "opts": []
      },
      {
        "content": "${1:void} ${2:function_name}(${3})\n{\n\t${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fnc"
        ],
        "opts": []
      },
      {
        "content": "${1:void} ${2:function_name}()\n{\n\t${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defun0"
        ],
        "opts": []
      },
      {
        "content": "${1:void} ${2:function_name}(${3:Type} ${4:Parameter})\n{\n\t${5}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defun1"
        ],
        "opts": []
      },
      {
        "content": "${1:void} ${2:function_name}(${3:Type} ${4:Parameter}, ${5:Type} ${6:Parameter})\n{\n\t${7}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defun2"
        ],
        "opts": []
      },
      {
        "content": "${1:void} ${2:function_name}(${3:Type} ${4:Parameter}, ${5:Type} ${6:Parameter}, ${7:Type} ${8:Parameter})\n{\n\t${9}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defun3"
        ],
        "opts": []
      },
      {
        "content": "${1:void} ${2:function_name}(${3});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fund"
        ],
        "opts": []
      },
      {
        "content": "printf(\"${1:%s}\\n\"${2});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pr"
        ],
        "opts": []
      },
      {
        "content": "fprintf(${1:stderr}, \"${2:%s}\\n\"${3});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fpr"
        ],
        "opts": []
      },
      {
        "content": "printf(\"${1:} = %d\\n\", $1);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prd"
        ],
        "opts": []
      },
      {
        "content": "printf(\"${1:} = %f\\n\", $1);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prf"
        ],
        "opts": []
      },
      {
        "content": "printf(\"${1:} = %${2}\\n\", $1);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prx"
        ],
        "opts": []
      },
      {
        "content": "/*! TODO: ${1:Todo description here} */",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "todo"
        ],
        "opts": []
      },
      {
        "content": "[${1}]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "."
        ],
        "opts": []
      },
      {
        "content": "// code for ${1} by `$USER` create at `strftime(\"%Y-%m-%d %H:%M:%S\")`",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "head"
        ],
        "opts": []
      }
    ],
    "ls": [
      {
        "content": "for ${1:name} in ${2:array}\n\tlet $1\n\t\t${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forinlet"
        ],
        "opts": []
      },
      {
        "content": "for ${1:name} in ${2:array}\n\t${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fora"
        ],
        "opts": []
      },
      {
        "content": "for ${1:key}, ${2:value} of ${3:object}\n\t${4}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "foro"
        ],
        "opts": []
      },
      {
        "content": "for ${1:name} from ${2:start} to ${3:finish}\n\t${4}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forr"
        ],
        "opts": []
      },
      {
        "content": "for ${1:name} from ${2:start} to ${3:finish} by ${4:step}\n\t${5}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forrb"
        ],
        "opts": []
      },
      {
        "content": "for ${1:name} from ${2:start} til ${3:finish}\n\t${4}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forrex"
        ],
        "opts": []
      },
      {
        "content": "for ${1:name} from ${2:start} til ${3:finish} by ${4:step}\n\t${5}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forrexb"
        ],
        "opts": []
      },
      {
        "content": "(${1:args}) ->\n\t${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fun"
        ],
        "opts": []
      },
      {
        "content": "(${1:args}) ~>\n\t${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bfun"
        ],
        "opts": []
      },
      {
        "content": "class ${1:`substitute(Filename(), '\\(_\\|^\\)\\(.\\)', '\\u\\2', 'g')`}\n\t${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cla class .."
        ],
        "opts": []
      },
      {
        "content": "class ${1:`substitute(Filename(), '\\(_\\|^\\)\\(.\\)', '\\u\\2', 'g')`}\n\t(${2:args}) ->\n\t\t${3}\n\t${4}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cla class .. constructor: .."
        ],
        "opts": []
      },
      {
        "content": "class ${1:`substitute(Filename(), '\\(_\\|^\\)\\(.\\)', '\\u\\2', 'g')`} extends ${2:ParentClass}\n\t${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cla class .. extends .."
        ],
        "opts": []
      },
      {
        "content": "class ${1:`substitute(Filename(), '\\(_\\|^\\)\\(.\\)', '\\u\\2', 'g')`} extends ${2:ParentClass}\n\t(${3:args}) ->\n\t\t${4}\n\t${5}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cla class .. extends .. constructor: .."
        ],
        "opts": []
      },
      {
        "content": "if ${1:condition}\n\t${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "if ${1:condition}\n\t${2}\nelse\n\t${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "else if ${1:condition}\n\t${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "elif"
        ],
        "opts": []
      },
      {
        "content": "if ${1:condition} then ${2:value} else ${3:other}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifte"
        ],
        "opts": []
      },
      {
        "content": "${1:action} unless ${2:condition}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "unl"
        ],
        "opts": []
      },
      {
        "content": "switch ${1:object}\ncase ${2:value}\n\t${3}\ndefault void",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "swi"
        ],
        "opts": []
      },
      {
        "content": "match ${1:object}\n| ${2:value} => ${3}\n| otherwise => void",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mat"
        ],
        "opts": []
      },
      {
        "content": "console.log ${1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "log"
        ],
        "opts": []
      },
      {
        "content": "JSON.stringify ${1}, void, 2",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "str"
        ],
        "opts": []
      },
      {
        "content": "try\n\t${1:${VISUAL}}\ncatch ${2:error}\n\t${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "try"
        ],
        "opts": []
      },
      {
        "content": "${2:$1} = require '${1}'${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "req"
        ],
        "opts": []
      },
      {
        "content": "require! ${1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "req!"
        ],
        "opts": []
      },
      {
        "content": "${1:root} = exports ? this",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "exp"
        ],
        "opts": []
      }
    ],
    "lua": [
      {
        "content": "#!/usr/bin/env lua\n$1",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#!"
        ],
        "opts": []
      },
      {
        "content": "local ${1:x} = ${0:1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "local"
        ],
        "opts": []
      },
      {
        "content": "function ${1:fname}(${2:...})\n\t${0:-- body}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fun"
        ],
        "opts": []
      },
      {
        "content": "for ${1:i}=${2:1},${3:10} do\n\t${0:print(i)}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "for ${1:i},${2:v} in pairs(${3:table_name}) do\n\t${0:-- body}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forp"
        ],
        "opts": []
      },
      {
        "content": "for ${1:i},${2:v} in ipairs(${3:table_name}) do\n\t${0:-- body}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fori"
        ],
        "opts": []
      },
      {
        "content": "if ${1:condition} then\n\t${2:-- body}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "if ${1:condition} then\n\t${2:-- if condition}\nelse\n\t${0:-- else}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "elseif ${1:condition} then\n\t${0:--body}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "elif"
        ],
        "opts": []
      },
      {
        "content": "repeat\n\t${1:--body}\nuntil ${0:condition}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "repeat"
        ],
        "opts": []
      },
      {
        "content": "while ${1:condition} do\n\t${0:--body}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "while"
        ],
        "opts": []
      },
      {
        "content": "print(\"${1:string}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "print"
        ],
        "opts": []
      },
      {
        "content": "import \"${1:import file}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "im"
        ],
        "opts": []
      },
      {
        "content": "function ${1:#:function_name}(${2:#:argument})\n\t${0:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "function name(args)...end",
        "matches": [
          "func"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "if ${1:#:condition} then\n  ${0:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "for ${2:i} = 0, ${1:#:Things} do\n  ${0:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "for ${2:k}, ${3:v} in ${1:ipairs(xs)} do\n  ${0:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forin"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "for k, v in ipairs(${1:table}) do\n  print(k, v)\nend",
        "doc": "",
        "grammar": "snu",
        "label": "for k, v in ipairs(table) do",
        "matches": [
          "print_table"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "print(${0:TARGET})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "print",
          "p"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "[[${0:TARGET}]]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "comment"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "describe(${1:#:message}, function()\n  ${0:TARGET}\nend)",
        "doc": "",
        "grammar": "snu",
        "label": "describe(message, func)",
        "matches": [
          "describe"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "it(${1:#:message}, function()\n  ${0:TARGET}\nend)",
        "doc": "",
        "grammar": "snu",
        "label": "it(message, func)",
        "matches": [
          "it"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "before_each(function()\n  ${0:TARGET}\nend)",
        "doc": "",
        "grammar": "snu",
        "label": "before_each(func)",
        "matches": [
          "before_each"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "after_each(function()\n  ${0:TARGET}\nend)",
        "doc": "",
        "grammar": "snu",
        "label": "after_each(func)",
        "matches": [
          "after_each"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "setup(function()\n  ${0:TARGET}\nend)",
        "doc": "",
        "grammar": "snu",
        "label": "setup(func)",
        "matches": [
          "setup"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "tear_down(function()\n  ${0:TARGET}\nend)",
        "doc": "",
        "grammar": "snu",
        "label": "tear_down(func)",
        "matches": [
          "tear_down"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "finally(function()\n  ${0:TARGET}\nend)",
        "doc": "",
        "grammar": "snu",
        "label": "finally(func)",
        "matches": [
          "finally"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "#!/usr/bin/env lua\n$0",
        "doc": null,
        "grammar": "snu",
        "label": "#!/usr/bin/env lua",
        "matches": [
          "#!"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "assert(${1:condition}`!p\nif t[2]:\n\tsnip.rv = \", \"\nelse:\n\tsnip.rv = \"\"\n`${2:msg})",
        "doc": null,
        "grammar": "snu",
        "label": "Assertion",
        "matches": [
          "assert"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "function ${1:new_function}(${2:args})\n\t$0\nend",
        "doc": null,
        "grammar": "snu",
        "label": "New function",
        "matches": [
          "!fun(ction)?!"
        ],
        "opts": [
          "b",
          "r"
        ]
      },
      {
        "content": "for ${1:name},${2:val} in pairs(${3:table_name}) do\n\t$0\nend",
        "doc": null,
        "grammar": "snu",
        "label": "pair for loop",
        "matches": [
          "forp"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "for ${1:idx},${2:val} in ipairs(${3:table_name}) do\n\t$0\nend",
        "doc": null,
        "grammar": "snu",
        "label": "ipair for foop",
        "matches": [
          "fori"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "for ${1:i}=${2:first},${3:last}${4/^..*/(?0:,:)/}${4:step} do\n\t$0\nend",
        "doc": null,
        "grammar": "snu",
        "label": "numeric for loop",
        "matches": [
          "for"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "do\n\t$0\nend",
        "doc": null,
        "grammar": "snu",
        "label": "do block",
        "matches": [
          "do"
        ],
        "opts": []
      },
      {
        "content": "repeat\n\t$1\nuntil $0",
        "doc": null,
        "grammar": "snu",
        "label": "repeat loop",
        "matches": [
          "repeat"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "while $1 do\n\t$0\nend",
        "doc": null,
        "grammar": "snu",
        "label": "while loop",
        "matches": [
          "while"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "if $1 then\n\t$0\nend",
        "doc": null,
        "grammar": "snu",
        "label": "if statement",
        "matches": [
          "if"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "if $1 then\n\t$2\nelse\n\t$0\nend",
        "doc": null,
        "grammar": "snu",
        "label": "if/else statement",
        "matches": [
          "ife"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "if $1 then\n\t$2\nelseif $3 then\n\t$0\nend",
        "doc": null,
        "grammar": "snu",
        "label": "if/elseif statement",
        "matches": [
          "eif"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "if $1 then\n\t$2\nelseif $3 then\n\t$4\nelse\n\t$0\nend",
        "doc": null,
        "grammar": "snu",
        "label": "if/elseif/else statement",
        "matches": [
          "eife"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "local ok, err = pcall(${1:your_function})\nif not ok then\n\thandler(${2:ok, err})\n${3:else\n\tsuccess(${4:ok, err})\n}end",
        "doc": null,
        "grammar": "snu",
        "label": "pcall statement",
        "matches": [
          "pcall"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "local ${1:x} = ${0:1}",
        "doc": null,
        "grammar": "snu",
        "label": "local x = 1",
        "matches": [
          "local"
        ],
        "opts": []
      }
    ],
    "make": [
      {
        "content": "CFLAGS=-Wall -g ${0: -llua -lzeromq}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "CFLAGS"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "clean:\n  rm -f ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "clean:"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": ".PHONY: clean, mrproper\nCC = gcc\nCFLAGS = -g -Wall\nall: $1\n%.o: %.c\n\t$(CC) $(CFLAGS) -c -o $@ $<\n${1:out}: $1.o\n\t$(CC) $(CFLAGS) -o $@ $+\nclean:\n\trm -f *.o core.*\nmrproper: clean\n\trm -f $1",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "base"
        ],
        "opts": []
      },
      {
        "content": "${1:out}: $1.o\n\t$(CC) $(CFLAGS) -o $@ $+",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "add"
        ],
        "opts": []
      },
      {
        "content": "print-%: ; @echo $*=$($*)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "print"
        ],
        "opts": []
      },
      {
        "content": "ifeq (${1:cond0}, ${2:cond1})\n\t${0:${VISUAL}}\nendif",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "ifeq (${1:cond0}, ${2:cond1})\n\t${3:${VISUAL}}\nelse\n\t${0}\nendif",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "else\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "el"
        ],
        "opts": []
      },
      {
        "content": ".DEFAULT_GOAL := ${1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "default"
        ],
        "opts": []
      },
      {
        "content": "help: ## Prints help for targets with comments\n\t@cat $(MAKEFILE_LIST) | grep -E '^[a-zA-Z_-]+:.*?## .*$$' | awk 'BEGIN {FS = \":.*?## \"}; {printf \"\\033[36m%-30s\\033[0m %s\\n\", $\\$1, $\\$2}'\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "help"
        ],
        "opts": []
      }
    ],
    "mako": [
      {
        "content": "<%def name=\"${1:name}\">\n\t${0:}\n</%def>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "def"
        ],
        "opts": []
      },
      {
        "content": "<%call expr=\"${1:name}\">\n\t${0:}\n</%call>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "call"
        ],
        "opts": []
      },
      {
        "content": "<%doc>\n\t${0:}\n</%doc>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doc"
        ],
        "opts": []
      },
      {
        "content": "<%text>\n\t${0:}\n</%text>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "text"
        ],
        "opts": []
      },
      {
        "content": "% for ${1:i} in ${2:iter}:\n\t${0:}\n% endfor",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "% if ${1:condition}:\n\t${0:}\n% endif",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if if"
        ],
        "opts": []
      },
      {
        "content": "% if ${1:condition}:\n\t${2:}\n% else:\n\t${0:}\n% endif",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife if/else"
        ],
        "opts": []
      },
      {
        "content": "% try:\n\t${1:${VISUAL}}\n% except${2:}:\n\t${0:pass}\n% endtry",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "try"
        ],
        "opts": []
      },
      {
        "content": "% while ${1:}:\n\t${0:}\n% endwhile",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh"
        ],
        "opts": []
      },
      {
        "content": "${ ${0:} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "$"
        ],
        "opts": []
      },
      {
        "content": "<% ${0:} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "<%"
        ],
        "opts": []
      },
      {
        "content": "<!% ${0:} %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "<!%"
        ],
        "opts": []
      },
      {
        "content": "<%inherit file=\"${0:filename}\" />",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "inherit"
        ],
        "opts": []
      },
      {
        "content": "<%include file=\"${0:filename}\" />",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "include"
        ],
        "opts": []
      },
      {
        "content": "<%namespace file=\"${0:name}\" />",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "namespace"
        ],
        "opts": []
      },
      {
        "content": "<%page args=\"${0:}\" />",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "page"
        ],
        "opts": []
      },
      {
        "content": "<%def name=\"${1:name}\">\n\t${2:}\n</%def>",
        "doc": null,
        "grammar": "snu",
        "label": "definition",
        "matches": [
          "def"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "<%call expr=\"${1:name}\">\n\t${2:}\n</%call>",
        "doc": null,
        "grammar": "snu",
        "label": "call",
        "matches": [
          "call"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "<%doc>\n\t${1:}\n</%doc>",
        "doc": null,
        "grammar": "snu",
        "label": "doc",
        "matches": [
          "doc"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "<%text>\n\t${1:}\n</%text>",
        "doc": null,
        "grammar": "snu",
        "label": "text",
        "matches": [
          "text"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "% for ${1:i} in ${2:iter}:\n\t${3:}\n% endfor",
        "doc": null,
        "grammar": "snu",
        "label": "for",
        "matches": [
          "for"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "% if ${1:condition}:\n\t${2:}\n% endif",
        "doc": null,
        "grammar": "snu",
        "label": "if ",
        "matches": [
          "if"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "% if ${1:condition}:\n\t${2:}\n% else:\n\t${3:}\n% endif",
        "doc": null,
        "grammar": "snu",
        "label": "if/else",
        "matches": [
          "if"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "% try:\n\t${1:}\n% except${2:}:\n\t${3:pass}\n% endtry",
        "doc": null,
        "grammar": "snu",
        "label": "try",
        "matches": [
          "try"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "% while ${1:}:\n\t${2:}\n% endwhile",
        "doc": null,
        "grammar": "snu",
        "label": "wh",
        "matches": [
          "wh"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "${${1:}}",
        "doc": null,
        "grammar": "snu",
        "label": "$",
        "matches": [
          "$"
        ],
        "opts": [
          "i"
        ]
      },
      {
        "content": "<% ${1:} %>",
        "doc": null,
        "grammar": "snu",
        "label": "<%",
        "matches": [
          "<%"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "<!% ${1:} %>",
        "doc": null,
        "grammar": "snu",
        "label": "<!%",
        "matches": [
          "<!%"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "<%inherit file=\"${1:filename}\" />",
        "doc": null,
        "grammar": "snu",
        "label": "inherit",
        "matches": [
          "inherit"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "<%include file=\"${1:filename}\" />",
        "doc": null,
        "grammar": "snu",
        "label": "include",
        "matches": [
          "include"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "<%namespace file=\"${1:name}\" />",
        "doc": null,
        "grammar": "snu",
        "label": "namespace",
        "matches": [
          "namespace"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "<%page args=\"${1:}\" />",
        "doc": null,
        "grammar": "snu",
        "label": "page",
        "matches": [
          "page"
        ],
        "opts": [
          "b"
        ]
      }
    ],
    "markdown": [
      {
        "content": "[${1:text}](https://${2:address})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "["
        ],
        "opts": []
      },
      {
        "content": "[${1:link}](${2:`@*`})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "[*"
        ],
        "opts": []
      },
      {
        "content": "[${1:link}](${2:`@+`})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "[c"
        ],
        "opts": []
      },
      {
        "content": "[${1:text}](https://${2:address} \"${3:title}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "[\""
        ],
        "opts": []
      },
      {
        "content": "[${1:link}](${2:`@*`} \"${3:title}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "[\"*"
        ],
        "opts": []
      },
      {
        "content": "[${1:link}](${2:`@+`} \"${3:title}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "[\"c"
        ],
        "opts": []
      },
      {
        "content": "[${1:id}]: https://${2:url}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "[:"
        ],
        "opts": []
      },
      {
        "content": "[${1:id}]: ${2:`@*`}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "[:*"
        ],
        "opts": []
      },
      {
        "content": "[${1:id}]: ${2:`@+`}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "[:c"
        ],
        "opts": []
      },
      {
        "content": "[${1:id}]: https://${2:url} \"${3:title}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "[:\""
        ],
        "opts": []
      },
      {
        "content": "[${1:id}]: ${2:`@*`} \"${3:title}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "[:\"*"
        ],
        "opts": []
      },
      {
        "content": "[${1:id}]: ${2:`@+`} \"${3:title}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "[:\"c"
        ],
        "opts": []
      },
      {
        "content": "![${1:alttext}](${2:/images/image.jpg})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "!["
        ],
        "opts": []
      },
      {
        "content": "![${1:alt}](${2:`@*`})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "![*"
        ],
        "opts": []
      },
      {
        "content": "![${1:alt}](${2:`@+`})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "![c"
        ],
        "opts": []
      },
      {
        "content": "![${1:alttext}](${2:/images/image.jpg} \"${3:title}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "![\""
        ],
        "opts": []
      },
      {
        "content": "![${1:alt}](${2:`@*`} \"${3:title}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "![\"*"
        ],
        "opts": []
      },
      {
        "content": "![${1:alt}](${2:`@+`} \"${3:title}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "![\"c"
        ],
        "opts": []
      },
      {
        "content": "![${1:id}]: ${2:url}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "![:"
        ],
        "opts": []
      },
      {
        "content": "![${1:id}]: ${2:`@*`}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "![:*"
        ],
        "opts": []
      },
      {
        "content": "![${1:id}]: ${2:url} \"${3:title}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "![:\""
        ],
        "opts": []
      },
      {
        "content": "![${1:id}]: ${2:`@*`} \"${3:title}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "![:\"*"
        ],
        "opts": []
      },
      {
        "content": "![${1:id}]: ${2:`@+`} \"${3:title}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "![:\"c"
        ],
        "opts": []
      },
      {
        "content": "<http://${1:url}>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "<"
        ],
        "opts": []
      },
      {
        "content": "<`@*`>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "<*"
        ],
        "opts": []
      },
      {
        "content": "<`@+`>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "<c"
        ],
        "opts": []
      },
      {
        "content": "**${1:bold}**",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "**"
        ],
        "opts": []
      },
      {
        "content": "__${1:bold}__",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "__"
        ],
        "opts": []
      },
      {
        "content": "`repeat('=', strlen(getline(line('.') - 3)))`\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "==="
        ],
        "opts": []
      },
      {
        "content": "-   ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "-"
        ],
        "opts": []
      },
      {
        "content": "`repeat('-', strlen(getline(line('.') - 3)))`\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "---"
        ],
        "opts": []
      },
      {
        "content": "{% blockquote %}\n${0:quote}\n{% endblockquote %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "blockquote"
        ],
        "opts": []
      },
      {
        "content": "{% blockquote ${1:author}, ${2:title} %}\n${0:quote}\n{% endblockquote %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "blockquote-author"
        ],
        "opts": []
      },
      {
        "content": "{% blockquote ${1:author} ${2:URL} ${3:link_text} %}\n${0:quote}\n{% endblockquote %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "blockquote-link"
        ],
        "opts": []
      },
      {
        "content": "\\`\\`\\`${1}\n${0:${VISUAL}}\n\\`\\`\\`",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "```"
        ],
        "opts": []
      },
      {
        "content": "\\`\\`\\`${1:language}\n${2:code}\n\\`\\`\\`",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "```l"
        ],
        "opts": []
      },
      {
        "content": "{% codeblock %}\n${0:code_snippet}\n{% endcodeblock %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "codeblock-short"
        ],
        "opts": []
      },
      {
        "content": "{% codeblock ${1:title} lang:${2:language} ${3:URL} ${4:link_text} %}\n${0:code_snippet}\n{% endcodeblock %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "codeblock-full"
        ],
        "opts": []
      },
      {
        "content": "{% gist ${1:gist_id} ${0:filename} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gist-full"
        ],
        "opts": []
      },
      {
        "content": "{% gist ${0:gist_id} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gist-short"
        ],
        "opts": []
      },
      {
        "content": "{% img ${1:class} ${2:URL} ${3:width} ${4:height} ${5:title_text} ${0:alt_text} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "img"
        ],
        "opts": []
      },
      {
        "content": "{% youtube ${0:video_id} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "youtube"
        ],
        "opts": []
      },
      {
        "content": "|  ${0:factors}      |    ${1:a}       |  ${2:b}   \t|\n| ------------- |-------------  | ------- |\n|    ${3:f1}    |    Y          | N       |\n|    ${4:f2}    |    Y          | N       |",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tb"
        ],
        "opts": []
      },
      {
        "content": "{% pullquote %}\n${1:text} {\" ${2:quote} \"} ${0:text}\n{% endpullquote %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pullquote"
        ],
        "opts": []
      },
      {
        "content": "# ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "# section heading",
        "matches": [
          "section",
          "heading"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "[${1:#:link_id}][]${2}",
        "doc": "",
        "grammar": "snu",
        "label": "[link][]",
        "matches": [
          "link"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "[${1:#:link}][${2:id}]${3}",
        "doc": "",
        "grammar": "snu",
        "label": "[link][id]",
        "matches": [
          "linkid"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "[${1:#:link}](https://${2:#:url})${3}",
        "doc": "",
        "grammar": "snu",
        "label": "[link](url)",
        "matches": [
          "linkurl"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "[${1:#:link}](mailto:${2:#:email})${3}",
        "doc": "",
        "grammar": "snu",
        "label": "[link](email)",
        "matches": [
          "linkemail"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "[${1:#:link}](${2:#:url} \"${3:#:title}\")${4}",
        "doc": "",
        "grammar": "snu",
        "label": "[link](url \"title\")",
        "matches": [
          "linkurltitle"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "[${1:#:id}]: https://${2:#:url} \"${3:#:title}\"",
        "doc": "",
        "grammar": "snu",
        "label": "[id]: url \"title\"",
        "matches": [
          "idurl"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "[${1:#:id}]: mailto:${2:#:url} \"${3:#:title}\"",
        "doc": "",
        "grammar": "snu",
        "label": "[id]: email \"title\"",
        "matches": [
          "idemail"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "![${1:#:alt}][${2:#:id}]${3}",
        "doc": "",
        "grammar": "snu",
        "label": "![alt][id]",
        "matches": [
          "altid"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "![${1:#:alt}](${2:#:url})${3}",
        "doc": "",
        "grammar": "snu",
        "label": "![alt](url)",
        "matches": [
          "alturl"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "![${1:#:alt}](${2:#:url} \"${3:#:title}\")${4}",
        "doc": "",
        "grammar": "snu",
        "label": "![alt](url \"title\")",
        "matches": [
          "alturltitle"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "*${1}*${2}",
        "doc": "",
        "grammar": "snu",
        "label": "*emphasis*",
        "matches": [
          "emphasis1"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "_${1}_${2}",
        "doc": "",
        "grammar": "snu",
        "label": "_emphasis_",
        "matches": [
          "emphasis2"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "**${1}**${2}",
        "doc": "",
        "grammar": "snu",
        "label": "**strong**",
        "matches": [
          "strong1"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "__${1}__${2}",
        "doc": "",
        "grammar": "snu",
        "label": "__strong__",
        "matches": [
          "strong2"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "\\`${1}\\`${2}",
        "doc": "",
        "grammar": "snu",
        "label": "`code`",
        "matches": [
          "code"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "\\`\\`\\`${1:#:language}\n${2:#:code }\n\\`\\`\\`",
        "doc": "",
        "grammar": "snu",
        "label": "code block",
        "matches": [
          "codeblock"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "quote block",
        "matches": [
          "blockquote"
        ],
        "opts": [
          "head"
        ]
      }
    ],
    "matlab": [
      {
        "content": "if ${1}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if if"
        ],
        "opts": []
      },
      {
        "content": "if ${1}\n\t${2}\nelse\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife if ... else"
        ],
        "opts": []
      },
      {
        "content": "else\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "el else"
        ],
        "opts": []
      },
      {
        "content": "elseif ${1}\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eif elsif"
        ],
        "opts": []
      },
      {
        "content": "while ${1}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh while"
        ],
        "opts": []
      },
      {
        "content": "for ${1:i} = ${2:1:n}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for for"
        ],
        "opts": []
      },
      {
        "content": "parfor ${1:i} = ${2:1:n}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "parfor parfor"
        ],
        "opts": []
      },
      {
        "content": "function [${3:out}] = ${1:`vim_snippets#Filename(\"$1\", \"fun_name\")`}(${2}) \n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fun function"
        ],
        "opts": []
      },
      {
        "content": "try\n\t${1}\ncatch ${2:err}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "try try ... catch"
        ],
        "opts": []
      },
      {
        "content": "switch ${1:n}\n\tcase ${2:0}\n\t\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "switch switch"
        ],
        "opts": []
      },
      {
        "content": "@(${1:x}) ${0:x*x}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@ anonymous function"
        ],
        "opts": []
      },
      {
        "content": "classdef ${1:`vim_snippets#Filename(\"$1\", \"class_name\")`}\n   properties\n\t  ${2}\n   end\n   methods\n\t  ${0}\n   end\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cl class"
        ],
        "opts": []
      },
      {
        "content": "switch ${1:n}\n\tcase ${2:0}\n\t\t${3}${4:\n\totherwise\n\t\t${5}}\nend",
        "doc": null,
        "grammar": "snu",
        "label": "switch ... otherwise",
        "matches": [
          "switch"
        ],
        "opts": []
      },
      {
        "content": "classdef ${1:`!p\nsnip.rv = snip.basename or \"class_name\"`} \n\tproperties\n\t\t${2}\n\tend\n\tmethods\n\t\tfunction obj = $1(${3})\n\t\t\t${4}\n\t\tend${0}\n\tend\nend",
        "doc": null,
        "grammar": "snu",
        "label": "class with constructor",
        "matches": [
          "clc"
        ],
        "opts": [
          "b"
        ]
      }
    ],
    "mediawiki": [
      {
        "content": "== ${1} ==\n${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "=="
        ],
        "opts": []
      },
      {
        "content": "=== ${1} ===\n${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "==="
        ],
        "opts": []
      },
      {
        "content": "==== ${1} ====\n${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "===="
        ],
        "opts": []
      },
      {
        "content": "===== ${1} =====\n${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "====="
        ],
        "opts": []
      },
      {
        "content": "====== ${1} ======\n${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "======"
        ],
        "opts": []
      },
      {
        "content": "[[${1}]] ${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "[["
        ],
        "opts": []
      },
      {
        "content": "''${1}''",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "''"
        ],
        "opts": []
      },
      {
        "content": "'''${1}'''",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "'''"
        ],
        "opts": []
      },
      {
        "content": "'''''${1}'''''",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "'''''"
        ],
        "opts": []
      },
      {
        "content": "<syntaxhighlight lang=\"${1}\">\n${2}\n</syntaxhighlight>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sy"
        ],
        "opts": []
      },
      {
        "content": "<pre>\n${1}\n</pre>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pre"
        ],
        "opts": []
      },
      {
        "content": "<html>\n${1}\n</html>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "html"
        ],
        "opts": []
      },
      {
        "content": "<nowiki>${1}</nowiki>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nowiki"
        ],
        "opts": []
      },
      {
        "content": "<tt>${1}</tt>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tt"
        ],
        "opts": []
      },
      {
        "content": "<blockquote>${1}</blockquote>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "blockquote"
        ],
        "opts": []
      },
      {
        "content": "<!--\nvim: filetype=mediawiki\n-->",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ft"
        ],
        "opts": []
      },
      {
        "content": "{|class=\"wikitable\"\n|+ ${1}\n! ${2}\n! ${3}\n|-\n| ${4}\n| ${5}\n|-\n| ${6}\n| ${7}\n|-\n|\n|\n|}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "{|"
        ],
        "opts": []
      }
    ],
    "mkd": [],
    "moon": [
      {
        "content": "print 'Hello world!'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "helloworld"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "[${0:TARGET} for ${1:x} in ${2:xs}]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "map"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "moon.p ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "${1:f} = (${2:args}) ->\n  ${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defn"
        ],
        "opts": []
      },
      {
        "content": "${1:f}: (${2:args}) =>\n  ${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defm"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "${1:moon} = require '$1'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "require"
        ],
        "opts": [
          "head"
        ]
      }
    ],
    "mustache": [
      {
        "content": "{{#${1:value}}}\n${0:${VISUAL}}\n{{/$1}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if # {{#value}} ... {{/value}}"
        ],
        "opts": []
      },
      {
        "content": "{{^${1:value}}}\n${0:${VISUAL}}\n{{/$1}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifn # {{^value}} ... {{/value}}"
        ],
        "opts": []
      },
      {
        "content": "{{#${1:value}}}\n${2:${VISUAL}}\n{{/$1}}\n{{^$1}}\n${3}\n{{/$1}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife # {{#value}} ... {{/value}} {{^value}} ... {{/value}}"
        ],
        "opts": []
      }
    ],
    "neosnippet": [
      {
        "content": "snippet     ${1:#:trigger}\nabbr        ${2:#:abbr}\noptions     head\n    ${3:#:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "snippet abbr options <snippet code>",
        "matches": [
          "snippet",
          "snip"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "include ${0:filetype}.snip",
        "doc": "",
        "grammar": "snu",
        "label": "include *.snip",
        "matches": [
          "include",
          "inc"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "${${0:0}}",
        "doc": "",
        "grammar": "snu",
        "label": "${..}",
        "matches": [
          "$"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "\\${0}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "${0}",
        "matches": [
          "0"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "\\${1}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "${1}",
        "matches": [
          "1"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "\\${2}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "${2}",
        "matches": [
          "2"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "\\${3}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "${3}",
        "matches": [
          "3"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "\\${4}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "${4}",
        "matches": [
          "4"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "\\${5}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "${5}",
        "matches": [
          "5"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "${${1:0}:${0:default}}",
        "doc": "",
        "grammar": "snu",
        "label": "${X:default}",
        "matches": [
          "$:"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "\\${0:${0:default}}",
        "doc": "",
        "grammar": "snu",
        "label": "${0:default}",
        "matches": [
          "0:"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "\\${1:${0:default}}",
        "doc": "",
        "grammar": "snu",
        "label": "${1:default}",
        "matches": [
          "1:"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "\\${2:${0:default}}",
        "doc": "",
        "grammar": "snu",
        "label": "${2:default}",
        "matches": [
          "2:"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "\\${3:${0:default}}",
        "doc": "",
        "grammar": "snu",
        "label": "${3:default}",
        "matches": [
          "3:"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "\\${4:${0:default}}",
        "doc": "",
        "grammar": "snu",
        "label": "${4:default}",
        "matches": [
          "4:"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "\\${5:${0:default}}",
        "doc": "",
        "grammar": "snu",
        "label": "${5:default}",
        "matches": [
          "5:"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "${${1:0}#${0:optional}}",
        "doc": "",
        "grammar": "snu",
        "label": "${X#optional}",
        "matches": [
          "$#"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "\\${0:#${0:optional}}",
        "doc": "",
        "grammar": "snu",
        "label": "${0:#optional}",
        "matches": [
          "0#"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "\\${1:#${0:optional}}",
        "doc": "",
        "grammar": "snu",
        "label": "${1:#optional}",
        "matches": [
          "1#"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "\\${2:#${0:optional}}",
        "doc": "",
        "grammar": "snu",
        "label": "${2:#optional}",
        "matches": [
          "2#"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "\\${3:#${0:optional}}",
        "doc": "",
        "grammar": "snu",
        "label": "${3:#optional}",
        "matches": [
          "3#"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "\\${4:#${0:optional}}",
        "doc": "",
        "grammar": "snu",
        "label": "${4:#optional}",
        "matches": [
          "4#"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "\\${5:#${0:optional}}",
        "doc": "",
        "grammar": "snu",
        "label": "${5:#optional}",
        "matches": [
          "5#"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "${${0:0}:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "${*:TARGET}",
        "matches": [
          "TARGET",
          "T"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "\\${0:TARGET}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "${0:TARGET}",
        "matches": [
          "0t",
          "0T"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "\\${1:TARGET}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "${1:TARGET}",
        "matches": [
          "1t",
          "1T"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "\\${2:TARGET}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "${2:TARGET}",
        "matches": [
          "2t",
          "2T"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "\\${3:TARGET}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "${3:TARGET}",
        "matches": [
          "3t",
          "3T"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "\\${4:TARGET}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "${4:TARGET}",
        "matches": [
          "4t",
          "4T"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "\\${5:TARGET}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "${5:TARGET}",
        "matches": [
          "5T",
          "5t"
        ],
        "opts": [
          "word"
        ]
      }
    ],
    "next": [
      {
        "content": "export async function getServerSideProps(${1:context}) {\n  return {\n    props: {}, \n  }\n}",
        "doc": "If you export an async function called getServerSideProps from a page, Next.js will pre-render this page on each request using the data returned by getServerSideProps. The context parameter is an object containing the following keys: params, req, res, query, preview, previewData.",
        "grammar": "lsp",
        "label": "next-get-server-side-props",
        "matches": [
          "next getserversideprops"
        ],
        "opts": []
      },
      {
        "content": "export async function getStaticProps(${1:context}) {\n  return {\n    props: {}, \n  }\n}",
        "doc": "If you export an async function called getStaticProps from a page, Next.js will pre-render this page at build time using the props returned by getStaticProps. The context parameter is an object containing the following keys: params, preview, previewData.",
        "grammar": "lsp",
        "label": "next-get-static-props",
        "matches": [
          "next getstaticprops"
        ],
        "opts": []
      },
      {
        "content": "export async function getStaticPaths() {\n  return {\n    paths: [\n      { params: { ... } } \n    ],\n    fallback: ${1|true,false|}\n  };\n}",
        "doc": "If a page has dynamic routes (documentation) and uses getStaticProps it needs to define a list of paths that have to be rendered to HTML at build time. If you export an async function called getStaticPaths from a page that uses dynamic routes, Next.js will statically pre-render all the paths specified by getStaticPaths.",
        "grammar": "lsp",
        "label": "next-get-static-paths",
        "matches": [
          "next getstaticpaths"
        ],
        "opts": []
      },
      {
        "content": "import { useRouter } from 'next/router'",
        "doc": null,
        "grammar": "lsp",
        "label": "next-import-use-router",
        "matches": [
          "next import userouter"
        ],
        "opts": []
      },
      {
        "content": "import Link from 'next/link'",
        "doc": null,
        "grammar": "lsp",
        "label": "next-import-link",
        "matches": [
          "next import link"
        ],
        "opts": []
      },
      {
        "content": "<Link href=\"${1:#}\">\n  <a>${2:content}</a>\n</Link>",
        "doc": "Link accepts the following props: href, as, passHref, prefetch, replace, scroll, shallow",
        "grammar": "lsp",
        "label": "next-link",
        "matches": [
          "next link"
        ],
        "opts": []
      },
      {
        "content": "<Link href={{ pathname: '${1:/path}', query: { ${2:paramName}: '${3:paramValue}' } }}>\n  <a>${4:content}</a>\n</Link>",
        "doc": null,
        "grammar": "lsp",
        "label": "next-link-url-object",
        "matches": [
          "next link url object"
        ],
        "opts": []
      },
      {
        "content": "<Link href=\"${1:/path/[id]}\" as=\"${2:/path/${id}}\">\n  <a>${3:content}</a>\n</Link>",
        "doc": null,
        "grammar": "lsp",
        "label": "next-link-dynamic-route",
        "matches": [
          "next link dynamic route"
        ],
        "opts": []
      },
      {
        "content": "import Head from 'next/head'",
        "doc": null,
        "grammar": "lsp",
        "label": "next-import-head",
        "matches": [
          "next import head"
        ],
        "opts": []
      },
      {
        "content": "<Head>\n${1:content}\n</Head>",
        "doc": null,
        "grammar": "lsp",
        "label": "next-head",
        "matches": [
          "next head"
        ],
        "opts": []
      },
      {
        "content": "export default (req, res) => {\n  res.json(${1:object});\n};",
        "doc": "API routes provide built in middlewares which parse the incoming request. Those middlewares are: req.cookies, req.body, req.query.",
        "grammar": "lsp",
        "label": "next-api",
        "matches": [
          "next api"
        ],
        "opts": []
      },
      {
        "content": "export default (req, res) => {\n  if (req.method === 'POST') {\n    $1\n  } else {\n    $2\n  }\n};",
        "doc": null,
        "grammar": "lsp",
        "label": "next-api-method",
        "matches": [
          "next api method"
        ],
        "opts": []
      }
    ],
    "nim": [
      {
        "content": "proc ${1:#:name}(${2}) =\n  ${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "proc"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "proc ${1:#:name}(${2}):\ndiscard \"\"\"${3:#:function documentation}\"\"\"\n  ${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "procd"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "proc ${1:#:name}(${2}):${3:#:type} =\n  ${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "proct"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "proc ${1:#:name}(${2}) =\n  ${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "procg"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "proc ${1:#:name}(${2}):${3:#:type} =\n  ${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "procgt"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "template ${1:#:name}(${2}):${3:type} =\n  ${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "template"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "macro ${1:#:name}(${2}):${3:type} =\n  ${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "macro"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "elif ${1:#:condition}:\n  ${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "elif ...: ...",
        "matches": [
          "elif"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "else:\n  ${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "else: ...",
        "matches": [
          "else"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "for ${1:#:value} in ${2:#:list}:\n  ${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "for ... in ...: ...",
        "matches": [
          "for"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "if ${1:#:condition}:\n  ${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "if ...: ...",
        "matches": [
          "if"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "when ${1:#:condition}:\n  ${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "when ...: ...",
        "matches": [
          "when"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "if isMainModule:\n  ${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "if isMainModule: ...",
        "matches": [
          "ifmain",
          "main"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "try:\n  ${1:pass}\nexcept ${2:#:ExceptionClass}:\n  ${3:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "try: ... except ...: ...",
        "matches": [
          "tryexcept"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "try:\n  ${1:pass}\nfinally:\n  ${2:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "try: ... finally: ...",
        "matches": [
          "tryfinally"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "try: ${1:pass}\ndefer: ${2:pass}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "trydefer"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "while ${1:#:condition}:\n  ${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "while"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "echo(${0:#:TARGET})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "echo"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "fmt\"${0:#:TARGET}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fmt"
        ],
        "opts": [
          "word"
        ]
      }
    ],
    "nuxt": [
      {
        "content": "<nuxt-link to=\"$1\">$2</nuxt-link>$0",
        "doc": null,
        "grammar": "lsp",
        "label": "nuxt-linkto",
        "matches": [
          "nuxt linkto"
        ],
        "opts": []
      },
      {
        "content": "<nuxt-link :to=\"{\t${1|name,path|}: '${2:value}', ${3|params,query|}: {\t${4:key}: '${5:value}'\t}\t}\">$6</nuxt-link>$0",
        "doc": null,
        "grammar": "lsp",
        "label": "nuxt-namedlinkto",
        "matches": [
          "nuxt namedlinkto"
        ],
        "opts": []
      },
      {
        "content": "<nuxt>$1</nuxt>$0",
        "doc": null,
        "grammar": "lsp",
        "label": "nuxt-view",
        "matches": [
          "nuxt view"
        ],
        "opts": []
      },
      {
        "content": "<nuxt name=\"$1\">$2</nuxt>$0",
        "doc": null,
        "grammar": "lsp",
        "label": "nuxt-namedview",
        "matches": [
          "nuxt namedview"
        ],
        "opts": []
      },
      {
        "content": "<nuxt-child $1/>$0",
        "doc": null,
        "grammar": "lsp",
        "label": "nuxt-child",
        "matches": [
          "nuxt child"
        ],
        "opts": []
      },
      {
        "content": "asyncData ({isDev, route, store, env, params, query, req, res, redirect, error}) {\n\treturn { ${1:data} }\n\n},",
        "doc": "Fetch and pre-render data on the server without using a store. The result from asyncData will be merged with data",
        "grammar": "lsp",
        "label": "nuxt-async-data",
        "matches": [
          "nuxt asyncdata"
        ],
        "opts": []
      },
      {
        "content": "head () {\n\treturn {\n\t\ttitle: '${1:title}',\n\t\tmeta: [\n\t\t\t{ hid: '${2:description}', name: '${3:description}', content: '${4:custom description}' }\n\t\t]\n\t}\n},",
        "doc": "Use the head method to set the HTML Head tags for the current page",
        "grammar": "lsp",
        "label": "nuxt-head",
        "matches": [
          "nuxt head"
        ],
        "opts": []
      },
      {
        "content": "middleware ({ store, redirect }) {\n\t${1:data}\n},",
        "doc": "Set the middleware for a specific page of the application.",
        "grammar": "lsp",
        "label": "nuxt-middleware",
        "matches": [
          "nuxt middleware"
        ],
        "opts": []
      },
      {
        "content": "validate({ params, query, store }) {\n\t${1:data}\n},",
        "doc": "Validate is called every time before navigating to a new route.",
        "grammar": "lsp",
        "label": "nuxt-validate",
        "matches": [
          "nuxt validate"
        ],
        "opts": []
      },
      {
        "content": "watchQuery (newQuery, oldQuery) {\n\t${1:data}\n},",
        "doc": "Use the watchQuery key to set up a watcher for query strings.",
        "grammar": "lsp",
        "label": "nuxt-watch-query",
        "matches": [
          "nuxt watchquery"
        ],
        "opts": []
      },
      {
        "content": "nuxtServerInit ({ commit }, { req }) {\n\t${1:data}\n}",
        "doc": "In universal mode, useful to fetch data on the server and give directly to the client-side.",
        "grammar": "lsp",
        "label": "nuxt-serverinit",
        "matches": [
          "nuxt serverinit"
        ],
        "opts": []
      }
    ],
    "nuxt-config": [
      {
        "content": "{ rel: 'stylesheet', href: '${1:https://fonts.googleapis.com/css?family=Montserrat:600|Rufina:700}' }",
        "doc": "link to include fonts in a nuxt project, in nuxt-config",
        "grammar": "lsp",
        "label": "Nuxt Font",
        "matches": [
          "nfont"
        ],
        "opts": []
      },
      {
        "content": "css: ['assets/${1:normalize.css}'],",
        "doc": "link to css assets such as normalize",
        "grammar": "lsp",
        "label": "Nuxt Use CSS File",
        "matches": [
          "ncss"
        ],
        "opts": []
      }
    ],
    "nuxt-script": [
      {
        "content": "async asyncData ({ ${1:$axios}, { ${2:params} }) {\n\tconst data = await $axios.$get(`${3:endpoint/${params.slug}}`)\n\treturn { data }\n},",
        "doc": "Nuxt asyncData with Axios module",
        "grammar": "lsp",
        "label": "Nuxt Async",
        "matches": [
          "nasyncdataaxios"
        ],
        "opts": []
      },
      {
        "content": "async fetch ({ store, ${1:params} }) {\n\tlet { data } = await fetch('${2:endpoint}').then(res => res.json())\n\tstore.commit('${3:MUTATION_TYPE}', data)\n},",
        "doc": "Nuxt Fetch",
        "grammar": "lsp",
        "label": "Nuxt Fetch",
        "matches": [
          "nfetch"
        ],
        "opts": []
      },
      {
        "content": "async fetch () {\n\tlet this.data = await this.$axios.$get('${1:endpoint/${this.$route.params.slug}}')\n},",
        "doc": "Nuxt Fetch with Axios module",
        "grammar": "lsp",
        "label": "Nuxt Fetch with Axios",
        "matches": [
          "nfetchaxios"
        ],
        "opts": []
      },
      {
        "content": "this.$route.params.${1:id}",
        "doc": "Nuxt Route Params",
        "grammar": "lsp",
        "label": "Nuxt Route Params",
        "matches": [
          "nparam"
        ],
        "opts": []
      },
      {
        "content": "head () {\n\treturn {\n\t\ttitle: ${1:'Page Title'},\n\t\tmeta: [\n\t\t\t// hid is used as unique identifier. Do not use `vmid` for it as it will not work\n\t\t\t{ hid: 'description', name: 'description', content: ${2:'My custom description'} }\n\t\t]\n\t}\n},",
        "doc": "Nuxt Head",
        "grammar": "lsp",
        "label": "Nuxt Head",
        "matches": [
          "nhead"
        ],
        "opts": []
      }
    ],
    "objc": [
      {
        "content": "#import <${1:Cocoa/Cocoa.h}>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Imp"
        ],
        "opts": []
      },
      {
        "content": "#import \"${1:`vim_snippets#Filename()`.h}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "imp"
        ],
        "opts": []
      },
      {
        "content": "@selector(${1:method}:)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sel"
        ],
        "opts": []
      },
      {
        "content": "@\"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "s"
        ],
        "opts": []
      },
      {
        "content": "${1:NSObject} *${2:foo} = [${3:$1 alloc}]${4};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "o"
        ],
        "opts": []
      },
      {
        "content": "NSLog(@\"${1:%@}\"${2});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "log"
        ],
        "opts": []
      },
      {
        "content": "@interface ${1:`vim_snippets#Filename('', 'someClass')`} : ${2:NSObject}\n{\n}\n@end\n@implementation $1\n${0}\n@end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "objc"
        ],
        "opts": []
      },
      {
        "content": "@interface ${1:`vim_snippets#Filename('', 'someClass')`} : ${2:NSObject}\n{${3}\n}\n${0}\n@end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "int"
        ],
        "opts": []
      },
      {
        "content": "@interface ${1:`vim_snippets#Filename('', 'someClass')`} : ${2:NSObject}\n{${3}\n}\n${0}\n@end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@interface"
        ],
        "opts": []
      },
      {
        "content": "@implementation ${1:`vim_snippets#Filename('', 'someClass')`}\n${0}\n@end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "impl"
        ],
        "opts": []
      },
      {
        "content": "@implementation ${1:`vim_snippets#Filename('', 'someClass')`}\n${0}\n@end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@implementation"
        ],
        "opts": []
      },
      {
        "content": "@protocol ${1:`vim_snippets#Filename('$1Delegate', 'MyProtocol')`} ${2:<NSObject>}\n${0}\n@end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pro"
        ],
        "opts": []
      },
      {
        "content": "@protocol ${1:`vim_snippets#Filename('$1Delegate', 'MyProtocol')`} ${2:<NSObject>}\n${0}\n@end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@protocol"
        ],
        "opts": []
      },
      {
        "content": "- (id)init\n{\n\tif (self = [super init]) {\n\t\t${0}\n\t}\n\treturn self;\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "init"
        ],
        "opts": []
      },
      {
        "content": "- (void) dealloc\n{\n\t${0:deallocations}\n\t[super dealloc];\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dealloc"
        ],
        "opts": []
      },
      {
        "content": "[super ${1:init}]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "su"
        ],
        "opts": []
      },
      {
        "content": "IBOutlet ${1:NSSomeClass} *${2:$1};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ibo"
        ],
        "opts": []
      },
      {
        "content": "@interface ${1:NSObject} (${2:MyCategory})\n@end\n@implementation $1 ($2)\n${0}\n@end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cat"
        ],
        "opts": []
      },
      {
        "content": "@interface ${1:`vim_snippets#Filename('$1', 'NSObject')`} (${2:MyCategory})\n${0}\n@end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cath"
        ],
        "opts": []
      },
      {
        "content": "- (${1:id})${2:method}\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "m"
        ],
        "opts": []
      },
      {
        "content": "- (${1:id})${2:method};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "md"
        ],
        "opts": []
      },
      {
        "content": "- (IBAction)${1:method}:(${2:id})sender;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ibad"
        ],
        "opts": []
      },
      {
        "content": "- (IBAction)${1:method}:(${2:id})sender\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "iba"
        ],
        "opts": []
      },
      {
        "content": "- (void)awakeFromNib\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wake"
        ],
        "opts": []
      },
      {
        "content": "+ (${1:id})${2:method}\n{\n\t${0:return nil;}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "M"
        ],
        "opts": []
      },
      {
        "content": "- (${1:id})${2:method}\n{\n\t[super $2];${0}\n\treturn self;\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sm"
        ],
        "opts": []
      },
      {
        "content": "- (${1:id})${2:thing}\n{\n\treturn $2;\n}\n- (void)set$2:($1)${3:new$2}\n{\n\t[$3 retain];\n\t[$2 release];\n\t$2 = $3;\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "objacc"
        ],
        "opts": []
      },
      {
        "content": "for (${1:Class} *${2:some$1} in ${3:array}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forin"
        ],
        "opts": []
      },
      {
        "content": "for (${1:object} in ${2:array}) {\n\t${0:statements}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fore"
        ],
        "opts": []
      },
      {
        "content": "unsigned int ${1:object}Count = [${2:array} count];\nfor (unsigned int index = 0; index < $1Count; index++) {\n\t${3:id} $1 = [$2 $1AtIndex:index];\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forarray"
        ],
        "opts": []
      },
      {
        "content": "unsigned int ${1:object}Count = [${2:array} count];\nfor (unsigned int index = 0; index < $1Count; index++) {\n\t${3:id} $1 = [$2 $1AtIndex:index];\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fora"
        ],
        "opts": []
      },
      {
        "content": "@try {\n\t${1:statements}\n}\n@catch (NSException * e) {\n\t${2:handler}\n}\n@finally {\n\t${0:statements}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@try"
        ],
        "opts": []
      },
      {
        "content": "@catch (${1:exception}) {\n\t${0:handler}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@catch"
        ],
        "opts": []
      },
      {
        "content": "@finally {\n\t${0:statements}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@finally"
        ],
        "opts": []
      },
      {
        "content": "@property (${1:retain}) ${2:NSSomeClass} ${3:*$2};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prop"
        ],
        "opts": []
      },
      {
        "content": "@synthesize ${1:property};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "syn"
        ],
        "opts": []
      },
      {
        "content": "[[${1:foo} alloc] init${2}];",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "alloc"
        ],
        "opts": []
      },
      {
        "content": "[[${1:foo} alloc] init${2}];",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "a"
        ],
        "opts": []
      },
      {
        "content": "[${1:foo} retain];",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ret"
        ],
        "opts": []
      },
      {
        "content": "[${0:foo} release];",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rel"
        ],
        "opts": []
      },
      {
        "content": "[${0:foo} autorelease];",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "arel"
        ],
        "opts": []
      },
      {
        "content": "NSAutoreleasePool *${1:pool} = [[NSAutoreleasePool alloc] init];\n${0}\n[$1 drain];",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pool"
        ],
        "opts": []
      },
      {
        "content": "NSException *${1:badness};\n$1 = [NSException exceptionWithName:@\"${2:$1Name}\"\n                             reason:@\"${0}\"\n                           userInfo:nil];\n[$1 raise];",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "except"
        ],
        "opts": []
      },
      {
        "content": "#pragma mark ${0:-}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prag"
        ],
        "opts": []
      },
      {
        "content": "@class ${1:Foo};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cl"
        ],
        "opts": []
      },
      {
        "content": "[[NSColor ${0:blackColor}] set];",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "color"
        ],
        "opts": []
      },
      {
        "content": "NSMutableArray *${1:array} = [NSMutable array];",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "array"
        ],
        "opts": []
      },
      {
        "content": "NSArray ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nsa"
        ],
        "opts": []
      },
      {
        "content": "NSMutableArray ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nsma"
        ],
        "opts": []
      },
      {
        "content": "NSArray * array;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "aa"
        ],
        "opts": []
      },
      {
        "content": "NSMutableArray * array;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ma"
        ],
        "opts": []
      },
      {
        "content": "NSMutableDictionary *${1:dict} = [NSMutableDictionary dictionary];",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dict"
        ],
        "opts": []
      },
      {
        "content": "NSDictionary ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nsd"
        ],
        "opts": []
      },
      {
        "content": "NSMutableDictionary ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nsmd"
        ],
        "opts": []
      },
      {
        "content": "NSString ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nss"
        ],
        "opts": []
      },
      {
        "content": "NSMutableString ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nsms"
        ],
        "opts": []
      },
      {
        "content": "@selector(${1:#:method}:)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sel"
        ],
        "opts": []
      },
      {
        "content": "#import <${1:Cocoa/Cocoa.h}>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "imp"
        ],
        "opts": []
      },
      {
        "content": "#import \"${1}}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Imp"
        ],
        "opts": []
      },
      {
        "content": "NSLog(@\"${1}\")",
        "doc": "",
        "grammar": "snu",
        "label": "NSLog(...)",
        "matches": [
          "log"
        ],
        "opts": []
      },
      {
        "content": "@interface ${1} : ${2:NSObject}\n{\n}\n@end\n@implementation ${1}\n- (id)init\n{\n\tif((self = [super init]))\n\t{${0}\n\t}\n\treturn self;\n}\n@end",
        "doc": "",
        "grammar": "snu",
        "label": "Class",
        "matches": [
          "cl"
        ],
        "opts": []
      },
      {
        "content": "@interface ${1} : ${2:NSObject}\n{${3}\n}\n${0}\n@end",
        "doc": "",
        "grammar": "snu",
        "label": "ClassInterface",
        "matches": [
          "cli"
        ],
        "opts": []
      },
      {
        "content": "@implementation ${1:object}\n- (id)init\n{\n\tif((self = [super init]))\n\t{${0}\n\t}\n\treturn self;\n}\n@end",
        "doc": "",
        "grammar": "snu",
        "label": "ClassImplementation",
        "matches": [
          "clm"
        ],
        "opts": []
      },
      {
        "content": "@interface ${1:NSObject} (${2:Category})\n@end\n@implementation ${1} (${2})\n${0}\n@end",
        "doc": "",
        "grammar": "snu",
        "label": "Category",
        "matches": [
          "cat"
        ],
        "opts": []
      },
      {
        "content": "@interface ${1:NSObject)} (${2:Category)})\n${0}\n@end",
        "doc": "",
        "grammar": "snu",
        "label": "CategoryInterface",
        "matches": [
          "cati"
        ],
        "opts": []
      },
      {
        "content": "NSMutableArray *${1:#:array} = [NSMutableArray array];",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "array"
        ],
        "opts": []
      },
      {
        "content": "NSMutableDictionary *${1:#:dict} = [NSMutableDictionary dictionary];",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dict"
        ],
        "opts": []
      },
      {
        "content": "NSBezierPath *${1:#:path} = [NSBezierPath bezierPath];",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bez"
        ],
        "opts": []
      },
      {
        "content": "- (${1:#:id})${2:#:method}${3:(#:id)}${4:#:anArgument}\n{\n${0}\n\treturn nil;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "Method",
        "matches": [
          "m"
        ],
        "opts": []
      },
      {
        "content": "- (${1:#:id})${2:#:method}${3:(#:id)}${4:#:anArgument};",
        "doc": "",
        "grammar": "snu",
        "label": "Method",
        "matches": [
          "M"
        ],
        "opts": []
      },
      {
        "content": "+ (${1:#:id})${2:#:method}${3:(#:id)}${4:#:anArgument}\n{\n${0}\n\treturn nil;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "ClassMethod",
        "matches": [
          "cm"
        ],
        "opts": []
      },
      {
        "content": "+ (${1:#:id})${0:#:method};",
        "doc": "",
        "grammar": "snu",
        "label": "InterfaceClassMethod",
        "matches": [
          "icm"
        ],
        "opts": []
      },
      {
        "content": "- (${1:#:id})${2:#:method}${3:(#:id)}${4:#:anArgument}\n{\n\t${1} res = [super ${2:#:method}]\n\treturn res;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "SubMethod",
        "matches": [
          "sm"
        ],
        "opts": []
      },
      {
        "content": "+ (void)initialize\n{\n\t[[NSUserDefaults standardUserDefaults] registerDefaults:[NSDictionary dictionaryWithObjectsAndKeys:\n\t\t${0}@\"value\", @\"key\",\n\t\tnil]];\n}",
        "doc": "",
        "grammar": "snu",
        "label": "MethodInitialize",
        "matches": [
          "mi"
        ],
        "opts": []
      },
      {
        "content": "- (${1:#:id})${2:#:thing}\n{\n\treturn ${2};\n}\n- (void)set${2}:(${1})aValue\n{\n\t${0}${1}old${2} = ${2};\n\t${2} = [aValue retain];\n\t[old${2} release];\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "obj"
        ],
        "opts": []
      },
      {
        "content": "- (${1:#:id})${2:#:thing};\n- (void)set${2}:(${1})aValue;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "iobj"
        ],
        "opts": []
      },
      {
        "content": "- (NSString${$1: *)})${1:#:thing}\n{\n\treturn ${2};\n}\n- (void)set${1}:(NSString${2: *})${3}\n{\n\t${3} = [${3} copy];\n\t[${2} release];\n\t${2} = ${3};\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "str"
        ],
        "opts": []
      },
      {
        "content": "- (NSString${1: *)}${1:#:thing};\n- (void)set${1}:(NSString${2: *})${2};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "istr"
        ],
        "opts": []
      },
      {
        "content": "- (${1:#:id})${2:#:attribute}\n{\n\t[self willAccessValueForKey:@\"$2\"];\n\t$1 value = [self primitiveValueForKey:@\"$2\"];\n\t[self didAccessValueForKey:@\"$2\"];\n\treturn value;\n}\n- (void)set$2:($1)aValue\n{\n\t[self willChangeValueForKey:@\"$2\"];\n\t[self setPrimitiveValue:aValue forKey:@\"$2\"];\n\t[self didChangeValueForKey:@\"$2\"];\n}",
        "doc": "",
        "grammar": "snu",
        "label": "CoreData",
        "matches": [
          "cd"
        ],
        "opts": []
      },
      {
        "content": "- (void)addObjectTo${1:#:Things}:(${2:#:id})anObject\n{\n\t[${3}} addObject:anObject];\n}\n- (void)insertObject:($2)anObject in$1AtIndex:(unsigned int)i\n{\n\t[${3} insertObject:anObject atIndex:i];\n}\n- (${2})objectIn${1}AtIndex:(unsigned int)i\n{\n\treturn [${3} objectAtIndex:i];\n}\n- (unsigned int)indexOfObjectIn${1}:(${2})anObject\n{\n\treturn [${3} indexOfObject:anObject];\n}\n- (void)removeObjectFrom${1}AtIndex:(unsigned int)i\n{\n\t [${3} removeObjectAtIndex:i];\n}\n- (unsigned int)countOf${1}\n{\n\treturn [${3} count];\n}\n- (NSArray${4: *}${1}\n{\n\treturn ${3}\n}\n- (void)set${1}:(NSArray${4: *})new${1}\n{\n\t[${3} setArray:new${1}];\n}",
        "doc": "",
        "grammar": "snu",
        "label": "KVCArry",
        "matches": [
          "karray"
        ],
        "opts": []
      },
      {
        "content": "- (void)addObjectTo${1:#:Things}:(${2:#:id})anObject;\n- (void)insertObject:(${2})anObject in${1}AtIndex:(unsigned int)i;\n- (${2})objectIn${1}AtIndex:(unsigned int)i;\n- (unsigned int)indexOfObjectIn${1}:(${2})anObject;\n- (void)removeObjectFrom${1}AtIndex:(unsigned int)i;\n- (unsigned int)countOf${1};\n- (NSArray${3: *})${1};\n- (void)set${1}:(NSArray${3: *})new${1};",
        "doc": "",
        "grammar": "snu",
        "label": "InterfaceAccessorsForKVCArray",
        "matches": [
          "iarray"
        ],
        "opts": []
      },
      {
        "content": "- (${1:unsigned int})${2:#:thing}\n{\n\treturn ${3};\n}\n- (void)set${2}:(${1:unsigned int})new${2}\n{\n\t${3} = new${2};\n}",
        "doc": "",
        "grammar": "snu",
        "label": "PrimitiveType",
        "matches": [
          "acc"
        ],
        "opts": []
      },
      {
        "content": "- (${1:unsigned int})${2:thing};\n- (void)set${2}:($1)new${2};",
        "doc": "",
        "grammar": "snu",
        "label": "Interface:AccessorsForPrimitiveType",
        "matches": [
          "iacc"
        ],
        "opts": []
      },
      {
        "content": "[[NSUserDefaults standardUserDefaults] objectForKey:${1:key}];",
        "doc": "",
        "grammar": "snu",
        "label": "ReadDefaultsValue",
        "matches": [
          "rdef"
        ],
        "opts": []
      },
      {
        "content": "[[NSUserDefaults standardUserDefaults] setObject:${1:object} forKey:${2:key}];",
        "doc": "",
        "grammar": "snu",
        "label": "WriteDefaultsValue",
        "matches": [
          "wdef"
        ],
        "opts": []
      },
      {
        "content": "IBOutlet ${1}${2: *}${3};",
        "doc": "",
        "grammar": "snu",
        "label": "IBOutlet",
        "matches": [
          "ibo"
        ],
        "opts": []
      },
      {
        "content": "@synthesize ${1:#:property};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "syn"
        ],
        "opts": []
      },
      {
        "content": "bind:@\"${2:#:binding}\" toObject:${3:observableController} withKeyPath:@\"${4:keyPath}\" options:${5:nil}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bind"
        ],
        "opts": []
      },
      {
        "content": "[[NSNotificationCenter defaultCenter] addObserver:${1:self} selector:@selector(${3}) name:${2:NSWindowDidBecomeMainNotification} object:${4:nil}];",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "reg"
        ],
        "opts": []
      },
      {
        "content": "[self lockFocus];\n${0}\n[self unlockFocus];",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "focus"
        ],
        "opts": []
      },
      {
        "content": "unsigned int\t${1:object}Count = [${2:array} count];\nfor(unsigned int index = 0; index < ${1}Count; index += 1)\n{\n\t${3:id}\t${1} = [${2} objectAtIndex:index];\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forarray"
        ],
        "opts": []
      },
      {
        "content": "int choice = NSRunAlertPanel(@\"${1:Something important!}\", @\"${2:Something important just happend, and now I need to ask you, do you want to continue?}\", @\"${3:Continue}\", @\"${4:Cancel}\", nil);\nif(choice == NSAlertDefaultReturn) // \"${3:Continue}\"\n{\n\t${0};\n}\nelse if(choice == NSAlertAlternateReturn) // \"${4:Cancel}\"\n{\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "alert"
        ],
        "opts": []
      },
      {
        "content": "${1} Send ${2} to ${1}, if ${1} supports it}${3}\nif ([${1:self} respondsToSelector:@selector(${2:someSelector:})])\n{\n    [${1} ${3}];\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "res"
        ],
        "opts": []
      },
      {
        "content": "if([${1:[self delegate]} respondsToSelector:@selector(${2:selfDidSomething:})])\n\t[${1} ${3}];",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "del"
        ],
        "opts": []
      },
      {
        "content": "[NSString stringWithFormat:@\"${1}\", ${2}]${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "format"
        ],
        "opts": []
      },
      {
        "content": "[NSGraphicsContext saveGraphicsState];\n${0}\n[NSGraphicsContext restoreGraphicsState];",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "save"
        ],
        "opts": []
      },
      {
        "content": "[NSThread detachNewThreadSelector:@selector(${1:#:method}:) toTarget:${2:#:aTarget} withObject:${3:#:anArgument}]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "thread"
        ],
        "opts": []
      },
      {
        "content": "NSAutoreleasePool${TM_C_POINTER: *}pool = [NSAutoreleasePool new];\n${0}\n[pool drain];",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pool"
        ],
        "opts": []
      },
      {
        "content": "#import \"${1:`!p snip.rv = re.sub(r'\\..*$', '.h', fn)`}\"",
        "doc": null,
        "grammar": "snu",
        "label": "#import (imp)",
        "matches": [
          "imp"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "#import <${1:Cocoa/Cocoa.h}>",
        "doc": null,
        "grammar": "snu",
        "label": "#import <> (Imp)",
        "matches": [
          "Imp"
        ],
        "opts": []
      },
      {
        "content": "@interface ${1:`!p\nif len(fn):\n\t\tsnip.rv = re.sub(r'\\..*$', '', fn)\nelse:\n\t\tsnip.rv = \"object\"\n`} : ${2:NSObject}\n{\n}\n@end\n\n@implementation $1\n- (id)init\n{\n\tif((self = [super init]))\n\t{$0\n\t}\n\treturn self;\n}\n@end",
        "doc": null,
        "grammar": "snu",
        "label": "020 Class (objc)",
        "matches": [
          "cl"
        ],
        "opts": []
      },
      {
        "content": "NSMutableArray *${1:array} = [NSMutableArray array];",
        "doc": null,
        "grammar": "snu",
        "label": "NSArray (array)",
        "matches": [
          "array"
        ],
        "opts": []
      },
      {
        "content": "NSMutableDictionary *${1:dict} = [NSMutableDictionary dictionary];",
        "doc": null,
        "grammar": "snu",
        "label": "NSDictionary (dict)",
        "matches": [
          "dict"
        ],
        "opts": []
      },
      {
        "content": "unsigned int\t${1:object}Count = [${2:array} count];\n\nfor(unsigned int index = 0; index < $1Count; index += 1)\n{\n\t${3:id}\t$1 = [$2 objectAtIndex:index];\n\t$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "for NSArray loop (forarray)",
        "matches": [
          "forarray"
        ],
        "opts": []
      },
      {
        "content": "- (${1:id})${2:thing}\n{\n\treturn $2;\n}\n\n- (void)set${2/./\\u$0/}:($1)aValue\n{\n\t$0${1/( \\*)?$/(?1:$1: )/}old${2/./\\u$0/} = $2;\n\t$2 = [aValue retain];\n\t[old${2/./\\u$0/} release];\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Object Accessors (objacc)",
        "matches": [
          "objacc"
        ],
        "opts": []
      },
      {
        "content": "@selector(${1:method}:)",
        "doc": null,
        "grammar": "snu",
        "label": "@selector",
        "matches": [
          "sel"
        ],
        "opts": []
      },
      {
        "content": "- (${1:id})${2:attribute}\n{\n\t[self willAccessValueForKey:@\"$2\"];\n\t$1 value = [self primitiveValueForKey:@\"$2\"];\n\t[self didAccessValueForKey:@\"$2\"];\n\treturn value;\n}\n\n- (void)set${2/./\\u$0/}:($1)aValue\n{\n\t[self willChangeValueForKey:@\"$2\"];\n\t[self setPrimitiveValue:aValue forKey:@\"$2\"];\n\t[self didChangeValueForKey:@\"$2\"];\n}",
        "doc": null,
        "grammar": "snu",
        "label": "CoreData Accessors Implementation",
        "matches": [
          "cdacc"
        ],
        "opts": []
      },
      {
        "content": "if([${1:[self delegate]} respondsToSelector:@selector(${2:selfDidSomething:})])\n\t[$1 ${3:${2/((^\\s*([A-Za-z0-9_]*:)\\s*)|(:\\s*$)|(:\\s*))/(?2:$2self :\\:<>)(?4::)(?5: :)/g}}];\n",
        "doc": null,
        "grammar": "snu",
        "label": "Delegate Responds to Selector",
        "matches": [
          "delegate"
        ],
        "opts": []
      },
      {
        "content": "[NSThread detachNewThreadSelector:@selector(${1:method}:) toTarget:${2:aTarget} withObject:${3:anArgument}]",
        "doc": null,
        "grammar": "snu",
        "label": "Detach New NSThread",
        "matches": [
          "thread"
        ],
        "opts": []
      },
      {
        "content": "IBOutlet ${1:NSSomeClass} *${2:${1/^[A-Z](?:[A-Z]+|[a-z]+)([A-Z]\\w*)/\\l$1/}};",
        "doc": null,
        "grammar": "snu",
        "label": "IBOutlet (ibo)",
        "matches": [
          "ibo"
        ],
        "opts": []
      },
      {
        "content": "+ (void)initialize\n{\n\t[[NSUserDefaults standardUserDefaults] registerDefaults:[NSDictionary dictionaryWithObjectsAndKeys:\n\t\t$0@\"value\", @\"key\",\n\t\tnil]];\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Initialize Implementation (I)",
        "matches": [
          "I"
        ],
        "opts": []
      },
      {
        "content": "bind:@\"${1:binding}\" toObject:${2:observableController} withKeyPath:@\"${3:keyPath}\" options:${4:nil}",
        "doc": null,
        "grammar": "snu",
        "label": "Key:value binding (bind)",
        "matches": [
          "bind"
        ],
        "opts": []
      },
      {
        "content": "- (void)addObjectTo${1:Things}:(${2:id})anObject\n{\n\t[${3:${1/./\\l$0/}} addObject:anObject];\n}\n\n- (void)insertObject:($2)anObject in$1AtIndex:(unsigned int)i\n{\n\t[$3 insertObject:anObject atIndex:i];\n}\n\n- ($2)objectIn$1AtIndex:(unsigned int)i\n{\n\treturn [$3 objectAtIndex:i];\n}\n\n- (unsigned int)indexOfObjectIn$1:($2)anObject\n{\n\treturn [$3 indexOfObject:anObject];\n}\n\n- (void)removeObjectFrom$1AtIndex:(unsigned int)i\n{\n\t[$3 removeObjectAtIndex:i];\n}\n\n- (unsigned int)countOf$1\n{\n\treturn [$3 count];\n}\n\n- (NSArray *${1/./\\l$0/}\n{\n\treturn $3;\n}\n\n- (void)set$1:(NSArray *)new$1\n{\n\t[$3 setArray:new$1];\n}",
        "doc": null,
        "grammar": "snu",
        "label": "LoD array (arracc)",
        "matches": [
          "arracc"
        ],
        "opts": []
      },
      {
        "content": "- (void)addObjectTo${1:Things}:(${2:id})anObject;\n- (void)insertObject:($2)anObject in$1AtIndex:(unsigned int)i;\n- ($2)objectIn$1AtIndex:(unsigned int)i;\n- (unsigned int)indexOfObjectIn$1:($2)anObject;\n- (void)removeObjectFrom$1AtIndex:(unsigned int)i;\n- (unsigned int)countOf$1;\n- (NSArray *)${1/./\\l$0/};\n- (void)set$1:(NSArray *)new$1;",
        "doc": null,
        "grammar": "snu",
        "label": "LoD array interface (arracc)",
        "matches": [
          "arracc"
        ],
        "opts": []
      },
      {
        "content": "[self lockFocus];\n$0\n[self unlockFocus];",
        "doc": null,
        "grammar": "snu",
        "label": "Lock Focus",
        "matches": [
          "focus"
        ],
        "opts": []
      },
      {
        "content": "NSAutoreleasePool *pool = [NSAutoreleasePool new];\n$0\n[pool drain];",
        "doc": null,
        "grammar": "snu",
        "label": "NSAutoreleasePool (pool)",
        "matches": [
          "pool"
        ],
        "opts": []
      },
      {
        "content": "NSLog(@\"$1\"${1/[^%]*(%)?.*/(?1:, :\\);)/}$2${1/[^%]*(%)?.*/(?1:\\);)/}",
        "doc": null,
        "grammar": "snu",
        "label": "NSLog (log) 2",
        "matches": [
          "log"
        ],
        "opts": []
      },
      {
        "content": "int choice = NSRunAlertPanel(@\"${1:Something important!}\", @\"${2:Something important just happend, and now I need to ask you, do you want to continue?}\", @\"${3:Continue}\", @\"${4:Cancel}\", nil);\nif(choice == NSAlertDefaultReturn) // \"$3\"\n{\n\t$0;\n}\nelse if(choice == NSAlertAlternateReturn) // \"$4\"\n{\n\t\t$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "NSRunAlertPanel (alert)",
        "matches": [
          "alert"
        ],
        "opts": []
      },
      {
        "content": "[NSString stringWithFormat:@\"$1\", $2]$0",
        "doc": null,
        "grammar": "snu",
        "label": "NSString stringWithFormat (format)",
        "matches": [
          "format"
        ],
        "opts": []
      },
      {
        "content": "- (${1:id})${2:thing};\n- (void)set${2/./\\u$0/}:($1)aValue;",
        "doc": null,
        "grammar": "snu",
        "label": "Object Accessors Interface (objacc)",
        "matches": [
          "objacc"
        ],
        "opts": []
      },
      {
        "content": "@property (${1/^(e)$|.*/(?1:r)/}${1:r}${1/^(?:(r)|(e)|(c)|(a))$|.*/(?1:etain)(?2:adonly)(?3:opy)(?4:ssign)/}) ${2:NSSomeClass}$ *${3:${2/^[A-Z](?:[A-Z]+|[a-z]+)([A-Z]\\w*)/\\l$1/}};",
        "doc": null,
        "grammar": "snu",
        "label": "Property",
        "matches": [
          "prop"
        ],
        "opts": []
      },
      {
        "content": "[[NSUserDefaults standardUserDefaults] objectForKey:${1:key}];",
        "doc": null,
        "grammar": "snu",
        "label": "Read from defaults (getprefs)",
        "matches": [
          "getprefs"
        ],
        "opts": []
      },
      {
        "content": "[[NSNotificationCenter defaultCenter] addObserver:${1:self} selector:@selector(${3:${2/^([A-Z]{2})?(.+?)(Notification)?$/\\l$2/}}:) name:${2:NSWindowDidBecomeMainNotification} object:${4:nil}];",
        "doc": null,
        "grammar": "snu",
        "label": "Register for Notification",
        "matches": [
          "obs"
        ],
        "opts": []
      },
      {
        "content": "if ([${1:self} respondsToSelector:@selector(${2:someSelector:})])\n{\n\t\t[$1 ${3:${2/((:\\s*$)|(:\\s*))/:<>(?3: )/g}}];\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Responds to Selector",
        "matches": [
          "responds"
        ],
        "opts": []
      },
      {
        "content": "[NSGraphicsContext saveGraphicsState];\n$0\n[NSGraphicsContext restoreGraphicsState];\n",
        "doc": null,
        "grammar": "snu",
        "label": "Save and Restore Graphics Context (gsave)",
        "matches": [
          "gsave"
        ],
        "opts": []
      },
      {
        "content": "- (${1:unsigned int})${2:thing}\n{\n\treturn ${3:$2};\n}\n\n- (void)set${2/./\\u$0/}:(${1:unsigned int})new${2/./\\u$0/}\n{\n\t$3 = new${2/./\\u$0/};\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Scalar Accessors (acc)",
        "matches": [
          "acc"
        ],
        "opts": []
      },
      {
        "content": "- (${1:unsigned int})${2:thing};\n- (void)set${2/./\\u$0/}:($1)new${2/./\\u$0/};",
        "doc": null,
        "grammar": "snu",
        "label": "Scalar Accessors Interface (acc)",
        "matches": [
          "acc"
        ],
        "opts": []
      },
      {
        "content": "- (NSString *)${1:thing}\n{\n\treturn ${2:$1};\n}\n\n- (void)set${1/.*/\\u$0/}:(NSString *)/})${3:a${1/.*/\\u$0/}}\n{\n\t$3 = [$3 copy];\n\t[$2 release];\n\t$2 = $3;\n}",
        "doc": null,
        "grammar": "snu",
        "label": "String Accessors (stracc)",
        "matches": [
          "stracc"
        ],
        "opts": []
      },
      {
        "content": "@synthesize ${1:property};",
        "doc": null,
        "grammar": "snu",
        "label": "Synthesize",
        "matches": [
          "syn"
        ],
        "opts": []
      },
      {
        "content": "[[NSUserDefaults standardUserDefaults] setObject:${1:object} forKey:${2:key}];",
        "doc": null,
        "grammar": "snu",
        "label": "Write to defaults (setprefs)",
        "matches": [
          "setprefs"
        ],
        "opts": []
      }
    ],
    "ocaml": [
      {
        "content": "(** ${0} *)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doc"
        ],
        "opts": []
      },
      {
        "content": "(* ${0} *)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "comment"
        ],
        "opts": []
      },
      {
        "content": "let ${1} = ${2} in\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "let"
        ],
        "opts": []
      },
      {
        "content": "let ${1} =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fn"
        ],
        "opts": []
      },
      {
        "content": "type ${1} = ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fun"
        ],
        "opts": []
      },
      {
        "content": "module ${1} = struct\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mod"
        ],
        "opts": []
      },
      {
        "content": "module type ${1} = sig\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "modty"
        ],
        "opts": []
      },
      {
        "content": "match ${1} with\n| ${2} -> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sw"
        ],
        "opts": []
      },
      {
        "content": "| ${1} -> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "|"
        ],
        "opts": []
      },
      {
        "content": "|> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p"
        ],
        "opts": []
      },
      {
        "content": "if ${1} then\n\t${2}\nelse\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "let rec ${1} =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fnr"
        ],
        "opts": []
      },
      {
        "content": "try\n\t${1}\nwith ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "try"
        ],
        "opts": []
      },
      {
        "content": "module type ${1} = sig\n  ${2:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "module signature",
        "matches": [
          "mot"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "module ${1} = struct\n  ${2:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "module struct",
        "matches": [
          "mod"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "module ${1} : sig\n  ${2:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "module signature",
        "matches": [
          "mos"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "(* ${0:TARGET} *)",
        "doc": "",
        "grammar": "snu",
        "label": "comment",
        "matches": [
          "cc"
        ],
        "opts": []
      },
      {
        "content": "(*\n   ${0:TARGET}\n*)",
        "doc": "",
        "grammar": "snu",
        "label": "multi line comment",
        "matches": [
          "Cc"
        ],
        "opts": []
      },
      {
        "content": "(** ${0:TARGET} *)",
        "doc": "",
        "grammar": "snu",
        "label": "ocamldoc comment (** .. *)",
        "matches": [
          "oo"
        ],
        "opts": []
      },
      {
        "content": "if ${1:TARGET}\nthen ${2}\nelse ${3}",
        "doc": "",
        "grammar": "snu",
        "label": "if..then..else",
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "let ${1:TARGET} in ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "let..in",
        "matches": [
          "let"
        ],
        "opts": []
      },
      {
        "content": "let rec ${1:TARGET}\nin ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "let rec .. in",
        "matches": [
          "letr"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "match ${1:TARGET} with\n| ${2} -> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "match",
        "matches": [
          "match"
        ],
        "opts": []
      },
      {
        "content": "object\n  ${0:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "object",
        "matches": [
          "obj"
        ],
        "opts": []
      },
      {
        "content": "try ${1:TARGET}\nwith ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "try..with",
        "matches": [
          "try"
        ],
        "opts": []
      },
      {
        "content": "let open ${1} in\n${2:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "let open .. in",
        "matches": [
          "lopen"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "for ${1:i} = ${2:0} to ${3:10} do\n  ${0:TARGET}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": "for i=x..y do; ... done",
        "matches": [
          "for"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "while ${1:true} do\n  ${2:TARGET}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": "while ... do; ... done",
        "matches": [
          "while"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "(fun ${1:x} -> ${2:TARGET})",
        "doc": "",
        "grammar": "snu",
        "label": "(fun x -> ...)",
        "matches": [
          "fun"
        ],
        "opts": []
      },
      {
        "content": "[| ${0:TARGET} |]",
        "doc": "",
        "grammar": "snu",
        "label": "array literal [| |]",
        "matches": [
          "arl"
        ],
        "opts": []
      },
      {
        "content": "failwith \"${0:TARGET}\"",
        "doc": "",
        "grammar": "snu",
        "label": "failwith \"...\"",
        "matches": [
          "fail"
        ],
        "opts": []
      },
      {
        "content": "begin ${0:TARGET} end",
        "doc": "",
        "grammar": "snu",
        "label": "begin ... end",
        "matches": [
          "beg"
        ],
        "opts": []
      },
      {
        "content": "exception ${0:TARGET} of ${1:string}",
        "doc": "",
        "grammar": "snu",
        "label": "exception",
        "matches": [
          "exn"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "{${0:}|${1:TARGET}|$0}",
        "doc": "",
        "grammar": "snu",
        "label": "string literals {xxx| ... |xxx}",
        "matches": [
          "lit"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "[@@deriving ${0:TARGET}]",
        "doc": "",
        "grammar": "snu",
        "label": "[@@deriving ...]",
        "matches": [
          "@@"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "raise (${1:Not_found})",
        "doc": null,
        "grammar": "snu",
        "label": "raise",
        "matches": [
          "rs"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "let open ${1:module} in\n${2:e}",
        "doc": null,
        "grammar": "snu",
        "label": "open",
        "matches": [
          "open"
        ],
        "opts": []
      },
      {
        "content": "try ${1:e}\nwith ${2:Not_found} -> ${3:()}",
        "doc": null,
        "grammar": "snu",
        "label": "try",
        "matches": [
          "try"
        ],
        "opts": []
      },
      {
        "content": "let ${1:name} = ref ${2:val} in\n${3:e}",
        "doc": null,
        "grammar": "snu",
        "label": "ref",
        "matches": [
          "ref"
        ],
        "opts": []
      },
      {
        "content": "match ${1:list} with\n| [] -> ${2:()}\n| x::xs -> ${3:()}",
        "doc": null,
        "grammar": "snu",
        "label": "pattern match on a list",
        "matches": [
          "matchl"
        ],
        "opts": []
      },
      {
        "content": "match ${1:x} with\n| Some(${2:y}) -> ${3:()}\n| None -> ${4:()}",
        "doc": null,
        "grammar": "snu",
        "label": "pattern match on an option type",
        "matches": [
          "matcho"
        ],
        "opts": []
      },
      {
        "content": "(fun ${1:x} -> ${2:x})",
        "doc": null,
        "grammar": "snu",
        "label": "anonymous function",
        "matches": [
          "fun"
        ],
        "opts": []
      },
      {
        "content": "(* ${1:comment} *)",
        "doc": null,
        "grammar": "snu",
        "label": "commment",
        "matches": [
          "cc"
        ],
        "opts": []
      },
      {
        "content": "let ${1:x} = ${2:v} in\n${3:e}",
        "doc": null,
        "grammar": "snu",
        "label": "let .. in binding",
        "matches": [
          "let"
        ],
        "opts": []
      },
      {
        "content": "let rec ${1:f} =\n\t${2:expr}",
        "doc": null,
        "grammar": "snu",
        "label": "let rec",
        "matches": [
          "lr"
        ],
        "opts": []
      },
      {
        "content": "if ${1:(* condition *)} then\n\t${2:(* A *)}\nelse\n\t${3:(* B *)}",
        "doc": null,
        "grammar": "snu",
        "label": "if",
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "if ${1:(* condition *)} then\n\t${2:(* A *)}",
        "doc": null,
        "grammar": "snu",
        "label": "If",
        "matches": [
          "If"
        ],
        "opts": []
      },
      {
        "content": "while ${1:(* condition *)} do\n\t${2:(* A *)}\ndone",
        "doc": null,
        "grammar": "snu",
        "label": "while",
        "matches": [
          "while"
        ],
        "opts": []
      },
      {
        "content": "for ${1:i} = ${2:1} to ${3:10} do\n\t${4:(* BODY *)}\ndone",
        "doc": null,
        "grammar": "snu",
        "label": "for",
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "match ${1:(* e1 *)} with\n| ${2:p} -> ${3:e2}",
        "doc": null,
        "grammar": "snu",
        "label": "match",
        "matches": [
          "match"
        ],
        "opts": []
      },
      {
        "content": "match ${1:(* e1 *)} with\n| ${2:p} -> ${3:e2}",
        "doc": null,
        "grammar": "snu",
        "label": "match",
        "matches": [
          "Match"
        ],
        "opts": []
      },
      {
        "content": "class ${1:name} = object\n\t${2:methods}\nend",
        "doc": null,
        "grammar": "snu",
        "label": "class",
        "matches": [
          "class"
        ],
        "opts": []
      },
      {
        "content": "object\n\t${2:methods}\nend",
        "doc": null,
        "grammar": "snu",
        "label": "obj",
        "matches": [
          "obj"
        ],
        "opts": []
      },
      {
        "content": "object (self)\n\t${2:methods}\nend",
        "doc": null,
        "grammar": "snu",
        "label": "object",
        "matches": [
          "Obj"
        ],
        "opts": []
      },
      {
        "content": "{< ${1:x} = ${2:y} >}",
        "doc": null,
        "grammar": "snu",
        "label": "object functional update",
        "matches": [
          "{{"
        ],
        "opts": []
      },
      {
        "content": "begin\n\t${1:block}\nend",
        "doc": null,
        "grammar": "snu",
        "label": "beg",
        "matches": [
          "beg"
        ],
        "opts": []
      },
      {
        "content": "module ${1:Mod} = ${2:Functor}(${3:Arg})",
        "doc": null,
        "grammar": "snu",
        "label": "module instantiantion with functor",
        "matches": [
          "ml"
        ],
        "opts": []
      },
      {
        "content": "module ${1:(* Name *)} = struct\n\t${2:(* BODY *)}\nend",
        "doc": null,
        "grammar": "snu",
        "label": "module - no signature",
        "matches": [
          "mod"
        ],
        "opts": []
      },
      {
        "content": "module ${1:(* Name *)} : ${2:(* SIG *)} = struct\n\t${3:(* BODY *)}\nend",
        "doc": null,
        "grammar": "snu",
        "label": "module with signature",
        "matches": [
          "Mod"
        ],
        "opts": []
      },
      {
        "content": "sig\n\t${2:(* BODY *)}\nend",
        "doc": null,
        "grammar": "snu",
        "label": "anonymous signature",
        "matches": [
          "sig"
        ],
        "opts": []
      },
      {
        "content": "functor (${1:Arg} : ${2:ARG}) -> ${3:(* BODY *)}",
        "doc": null,
        "grammar": "snu",
        "label": "functor signature or anonymous functor",
        "matches": [
          "sigf"
        ],
        "opts": []
      },
      {
        "content": "module ${1:M} (${2:Arg} : ${3:ARG}) = struct\n\t${4:(* BODY *)}\nend",
        "doc": null,
        "grammar": "snu",
        "label": "define functor - no signature",
        "matches": [
          "func"
        ],
        "opts": []
      },
      {
        "content": "module ${1:M} (${2:Arg} : ${3:ARG}) : ${4:SIG} = struct\n\t${5:(* BODY *)}\nend",
        "doc": null,
        "grammar": "snu",
        "label": "define functor - with signature",
        "matches": [
          "Func"
        ],
        "opts": []
      },
      {
        "content": "module type ${1:(* Name *)} = sig\n\t${2:(* BODY *)}\nend",
        "doc": null,
        "grammar": "snu",
        "label": "Declare module signature",
        "matches": [
          "mot"
        ],
        "opts": []
      },
      {
        "content": "module ${1:(* Name *)} : sig\n\t${2:(* SIGNATURE *)}\nend = struct\n\t${3:(* BODY *)}\nend",
        "doc": null,
        "grammar": "snu",
        "label": "Module with anonymous signature",
        "matches": [
          "module"
        ],
        "opts": []
      },
      {
        "content": "(** ${1:odoc} *)",
        "doc": null,
        "grammar": "snu",
        "label": "odoc",
        "matches": [
          "oo"
        ],
        "opts": []
      },
      {
        "content": "(*$T ${1:name}\n\t${2:test}\n*)",
        "doc": null,
        "grammar": "snu",
        "label": "inline qtest",
        "matches": [
          "qt"
        ],
        "opts": []
      }
    ],
    "octave": [],
    "openfoam": [
      {
        "content": "type\t\tfixedValue;\nvalue\t\tuniform ${0};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fv"
        ],
        "opts": []
      },
      {
        "content": "type\t\tzeroGradient;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "zg"
        ],
        "opts": []
      },
      {
        "content": "type\t\tsymmetryPlane;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sym"
        ],
        "opts": []
      },
      {
        "content": "forces\n{\n\ttype\t\t\t\tforces;\n\tfunctionObjectLibs\t(\"libforces.so\");\n\tenabled\t\t\t\ttrue;\n\toutputControl\t\t${1:timeStep};\n\toutputInterval\t\t${2:1};\n\tpatches\t\t\t\t(${3});\n\tlog\t\t\t\t\t${4:true};\n\tCofR\t\t\t\t(${0:0 0 0});\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forces"
        ],
        "opts": []
      },
      {
        "content": "${1:p}\n{\n\tsolver          GAMG;\n\ttolerance       1e-${2:6};\n\trelTol          ${0:0.0};\n\tsmoother        GaussSeidel;\n\tcacheAgglomeration true;\n\tnCellsInCoarsestLevel 10;\n\tagglomerator    faceAreaPair;\n\tmergeLevels     1;\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gamg"
        ],
        "opts": []
      },
      {
        "content": "${1:U}\n{\n\tsolver          PBiCG;\n\tpreconditioner  DILU;\n\ttolerance       1e-${2:6};\n\trelTol          ${0:0.0};\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pbicg"
        ],
        "opts": []
      },
      {
        "content": "PIMPLE\n{\n\tnOuterCorrectors \t${1:outer};\n\tnCorrectors     \t${2:inner};\n\tnNonOrthogonalCorrectors ${3:nonOrtho};\n\tpRefCell        \t${4:cell};\n\tpRefValue       \t${0:value for $4};\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pimple"
        ],
        "opts": []
      }
    ],
    "pandoc": [
      {
        "content": "% ${1:`!v vim_snippets#Filename('$1', 'title')`}\n% ${2:`!v g:snips_author`}\n% ${3:`!v strftime(\"%d %B %Y\")`}\n\n$0",
        "doc": null,
        "grammar": "snu",
        "label": "Title Header",
        "matches": [
          "title"
        ],
        "opts": [
          "b"
        ]
      }
    ],
    "perl": [
      {
        "content": "#!/opt/local/bin/perl\nuse strict;\nuse warnings;\n${1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "perl"
        ],
        "opts": []
      },
      {
        "content": "sub ${1:#:function_name} {\n\t${2:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sub"
        ],
        "opts": []
      },
      {
        "content": "if (${1:#:condition}) {\n\t${2:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "if (${1:#:condition}) {\n\t${2:TARGET}\n} else {\n\t${3:#:else...}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "if (${1:#:condition}) {\n\t${2:TARGET}\n} elsif (${3}) {\n\t${4:#:elsif...}\n} else {\n\t${5:#:else...}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifee"
        ],
        "opts": []
      },
      {
        "content": "${1:#:expression} if ${2:#:condition};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "xif"
        ],
        "opts": []
      },
      {
        "content": "while (${1:#:condition}) {\n\t${2:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "wh",
        "matches": [
          "while"
        ],
        "opts": []
      },
      {
        "content": "${1:#:expression} while ${2:#:condition};",
        "doc": "",
        "grammar": "snu",
        "label": "xwh",
        "matches": [
          "xwhile"
        ],
        "opts": []
      },
      {
        "content": "for (my $${1:#:var} = 0; $$1 < ${2:#:expression}; $$1++) {\n\t${3:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "for ${1} (${2:#:expression}){\n\t${3:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fore"
        ],
        "opts": []
      },
      {
        "content": "${1:#:expression} for @${2:#:array};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "xfor"
        ],
        "opts": []
      },
      {
        "content": "unless (${1:condition}) {\n\t${2:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "un",
        "matches": [
          "unless"
        ],
        "opts": []
      },
      {
        "content": "${1:#:expression} unless ${2:#:condition};",
        "doc": "",
        "grammar": "snu",
        "label": "xun",
        "matches": [
          "xunless"
        ],
        "opts": []
      },
      {
        "content": "eval {\n\t${1:TARGET}\n};\nif ($@) {\n\t${2:#:handle failure...}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eval"
        ],
        "opts": []
      },
      {
        "content": "#!/usr/bin/env perl",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#!"
        ],
        "opts": []
      },
      {
        "content": "=>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "."
        ],
        "opts": []
      },
      {
        "content": "sub ${1:function_name} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sub"
        ],
        "opts": []
      },
      {
        "content": "if (${1}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "if (${1}) {\n\t${2}\n}\nelse {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "if (${1}) {\n\t${2}\n}\nelsif (${3}) {\n\t${4:# elsif...}\n}\nelse {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifee"
        ],
        "opts": []
      },
      {
        "content": "elsif (${1}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eif"
        ],
        "opts": []
      },
      {
        "content": "${1:expression} if ${2:condition};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "xif"
        ],
        "opts": []
      },
      {
        "content": "unless (${1}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "unless"
        ],
        "opts": []
      },
      {
        "content": "${1:expression} unless ${2:condition};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "xunless"
        ],
        "opts": []
      },
      {
        "content": "local $@;\neval {\n\t${1:# do something risky...}\n};\nif (my $e = $@) {\n\t${0:# handle failure...}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eval"
        ],
        "opts": []
      },
      {
        "content": "while (${1}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh"
        ],
        "opts": []
      },
      {
        "content": "${1:expression} while ${2:condition};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "xwh"
        ],
        "opts": []
      },
      {
        "content": "for (my $${2:var} = 0; $$2 < ${1:count}; $$2${3:++}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cfor"
        ],
        "opts": []
      },
      {
        "content": "${1:expression} for @${2:array};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "xfor"
        ],
        "opts": []
      },
      {
        "content": "foreach my $${1:x} (@${2:array}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "${1:expression} foreach @${2:array};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fore"
        ],
        "opts": []
      },
      {
        "content": "package ${1:`expand('%:p:s?.*lib/??:r:gs?/?::?')`};\nuse strict;\nuse warnings;\n${0}\n1;\n__END__",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "package"
        ],
        "opts": []
      },
      {
        "content": "package ${1:`expand('%:p:s?.*lib/??:r:gs?/?::?')`} ${2:0.99};\nuse v5.14;\nuse warnings;\n${0}\n1;\n__END__",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "packagev514"
        ],
        "opts": []
      },
      {
        "content": "use Moose;\nuse namespace::autoclean;\n${1:#}BEGIN {extends '${2:ParentClass}'};\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "moose"
        ],
        "opts": []
      },
      {
        "content": "use parent qw(${0:Parent Class});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "parent"
        ],
        "opts": []
      },
      {
        "content": "my $${1:var} = do { local $/; open my $file, '<', \"${2:file}\"; <$file> };\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "slurp"
        ],
        "opts": []
      },
      {
        "content": "use strict;\nuse warnings;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "strwar"
        ],
        "opts": []
      },
      {
        "content": "## no critic\nour $VERSION = '${0:version}';\neval $VERSION;\n## use critic",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vers"
        ],
        "opts": []
      },
      {
        "content": "use feature 'switch';",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "switch"
        ],
        "opts": []
      },
      {
        "content": "sub {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asub"
        ],
        "opts": []
      },
      {
        "content": "BEGIN {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "begin"
        ],
        "opts": []
      },
      {
        "content": "__PACKAGE__->${1:package_method}(${0:var})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pkgmv"
        ],
        "opts": []
      },
      {
        "content": "__PACKAGE__->${0:package_method}()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pkgm"
        ],
        "opts": []
      },
      {
        "content": "__PACKAGE__->get_${0:package_method}()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pkget"
        ],
        "opts": []
      },
      {
        "content": "__PACKAGE__->get_${1:package_method}(${0:var})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pkgetv"
        ],
        "opts": []
      },
      {
        "content": "qr/\n     ${0:regex}\n/xms",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "qrx"
        ],
        "opts": []
      },
      {
        "content": "qr/${0:regex}/x",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "qr/"
        ],
        "opts": []
      },
      {
        "content": "given ($${1:var}) {\n\t${2:# cases}\n\t${0:# default}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "given"
        ],
        "opts": []
      },
      {
        "content": "when (${1:case}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "when"
        ],
        "opts": []
      },
      {
        "content": "@{ ${1:hash}  }{ ${0:array} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "hslice"
        ],
        "opts": []
      },
      {
        "content": "map {  ${0: body }    }  ${1: @array } ;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "map"
        ],
        "opts": []
      },
      {
        "content": "=head1 NAME\n${1:ClassName} - ${2:ShortDesc}\n=head1 SYNOPSIS\n  use $1;\n  ${3:# synopsis...}\n=head1 DESCRIPTION\n${0:# longer description...}\n=head1 INTERFACE\n=head1 DEPENDENCIES\n=head1 SEE ALSO",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ppod"
        ],
        "opts": []
      },
      {
        "content": "=head2 ${1:MethodName}\n${0:Summary....}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "psub"
        ],
        "opts": []
      },
      {
        "content": "=head2 ${1:MethodName}\n${0:Summary...}\n=cut",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "psubi"
        ],
        "opts": []
      },
      {
        "content": "=head2 $1\nSummary of $1\n=cut\nsub ${1:subroutine_name} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "subpod"
        ],
        "opts": []
      },
      {
        "content": "=over 2\n=item\nArguments\n=over 3\n=item\nC<${1:DataStructure}>\n  ${2:Sample}\n=back\n=item\nReturn\n=over 3\n=item\nC<${0:...return data}>\n=back\n=back",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "parg"
        ],
        "opts": []
      },
      {
        "content": "has ${1:attribute} => (\n\tis\t    => '${2:ro|rw}',\n\tisa \t=> '${3:Str|Int|HashRef|ArrayRef|etc}',\n\tdefault => sub {\n\t\t${4:defaultvalue}\n\t},\n\t${0:# other attributes}\n);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "has"
        ],
        "opts": []
      },
      {
        "content": "override ${1:attribute} => sub {\n\t${2:# my $self = shift;};\n\t${0:# my ($self, $args) = @_;};\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "override"
        ],
        "opts": []
      },
      {
        "content": "use Test::More;\nuse Test::Deep; # (); # uncomment to stop prototype errors\nuse Test::Exception;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tuse"
        ],
        "opts": []
      },
      {
        "content": "use lib qw{ ./t/lib };",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tlib"
        ],
        "opts": []
      },
      {
        "content": "$ENV{TEST_METHOD} = '${0:regex}';",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tmeths"
        ],
        "opts": []
      },
      {
        "content": "use ${0:test_class};\n$1->runtests();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "trunner"
        ],
        "opts": []
      },
      {
        "content": "sub t${1:number}_${2:test_case} :Test(${3:num_of_tests}) {\n\tmy $self = shift;\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tsub"
        ],
        "opts": []
      },
      {
        "content": "test ${1:test_name} => { description => '${2:Description of test.}'} => sub {\n\tmy ($self) = @_;\n\t${0}\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "trsub"
        ],
        "opts": []
      },
      {
        "content": "sub prep${1:number}_${2:test_case} :Test(startup) {\n\tmy $self = shift;\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tprep"
        ],
        "opts": []
      },
      {
        "content": "use Carp; # 'verbose';\n# cloak \"die\"\n# warn \"warning\"\n$SIG{'__DIE__'} = sub {\n\trequire Carp; Carp::confess\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "debug_trace"
        ],
        "opts": []
      },
      {
        "content": "use Data::Dump qw(dump);\nwarn dump ${1:variable}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dump"
        ],
        "opts": []
      },
      {
        "content": "use DDP;\np ${1:variable}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ddp"
        ],
        "opts": []
      },
      {
        "content": "subtest '${1: test_name}' => sub {\n\t${2}\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "subtest"
        ],
        "opts": []
      },
      {
        "content": "if ($1) {\n\t${2:# body...}\n}\nelse {\n\t${3:# else...}\n}\n",
        "doc": null,
        "grammar": "snu",
        "label": "Conditional if..else (ife)",
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "if ($1) {\n\t${2:# body...}\n}\nelsif ($3) {\n\t${4:# elsif...}\n}\nelse {\n\t${5:# else...}\n}\n",
        "doc": null,
        "grammar": "snu",
        "label": "Conditional if..elsif..else (ifee)",
        "matches": [
          "ifee"
        ],
        "opts": []
      },
      {
        "content": "${1:expression} unless ${2:condition};\n",
        "doc": null,
        "grammar": "snu",
        "label": "Conditional one-line (unless)",
        "matches": [
          "xunless"
        ],
        "opts": []
      },
      {
        "content": "${1:expression} if ${2:condition};\n",
        "doc": null,
        "grammar": "snu",
        "label": "Conditional one-line (xif)",
        "matches": [
          "xif"
        ],
        "opts": []
      },
      {
        "content": "sub ${1:function_name} {\n\t${2:# body...}\n}\n",
        "doc": null,
        "grammar": "snu",
        "label": "Function (sub)",
        "matches": [
          "sub"
        ],
        "opts": []
      },
      {
        "content": "${1:expression} foreach @${2:array};\n",
        "doc": null,
        "grammar": "snu",
        "label": "Loop one-line (xforeach)",
        "matches": [
          "xfore"
        ],
        "opts": []
      },
      {
        "content": "${1:expression} while ${2:condition};\n",
        "doc": null,
        "grammar": "snu",
        "label": "Loop one-line (xwhile)",
        "matches": [
          "xwhile"
        ],
        "opts": []
      },
      {
        "content": "#!/usr/bin/env perl -w\n\nuse strict;\nuse Test::More tests => ${1:1};\nuse ${2:ModuleName};\n\nok(${3:assertion});\n",
        "doc": null,
        "grammar": "snu",
        "label": "Test",
        "matches": [
          "test"
        ],
        "opts": []
      },
      {
        "content": "package ${1:ClassName};\n\n${2:use parent qw(${3:ParentClass});}${2/.+/\\n\\n/}sub new {\n\tmy $class = shift;\n\t$class = ref $class if ref $class;\n\tmy $self = bless {}, $class;\n\t$self;\n}\n\n1;\n",
        "doc": null,
        "grammar": "snu",
        "label": "class",
        "matches": [
          "class"
        ],
        "opts": []
      },
      {
        "content": "local $@;\neval {\n\t${1:# do something risky...}\n};\nif (my $${2:exception} = $@) {\n\t${3:# handle failure...}\n}\n",
        "doc": null,
        "grammar": "snu",
        "label": "eval",
        "matches": [
          "eval"
        ],
        "opts": []
      },
      {
        "content": "for (my $${1:var} = 0; $$1 < ${2:expression}; $$1++) {\n\t${3:# body...}\n}\n",
        "doc": null,
        "grammar": "snu",
        "label": "for",
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "foreach ${1:my $${2:x}} (@${3:array}) {\n\t${4:# body...}\n}\n",
        "doc": null,
        "grammar": "snu",
        "label": "foreach",
        "matches": [
          "fore"
        ],
        "opts": []
      },
      {
        "content": "if ($1) {\n\t${2:# body...}\n}\n",
        "doc": null,
        "grammar": "snu",
        "label": "if",
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "my $${1:var} = do { local $/ = undef; open my $fh, '<', ${2:$file}; <$fh> };\n",
        "doc": null,
        "grammar": "snu",
        "label": "slurp",
        "matches": [
          "slurp"
        ],
        "opts": []
      },
      {
        "content": "unless ($1) {\n\t${2:# body...}\n}\n",
        "doc": null,
        "grammar": "snu",
        "label": "unless",
        "matches": [
          "unless"
        ],
        "opts": []
      },
      {
        "content": "while ($1) {\n\t${2:# body...}\n}\n",
        "doc": null,
        "grammar": "snu",
        "label": "while",
        "matches": [
          "while"
        ],
        "opts": []
      },
      {
        "content": "until ($1) {\n\t${2:# body...}\n}\n",
        "doc": null,
        "grammar": "snu",
        "label": "until",
        "matches": [
          "until"
        ],
        "opts": []
      }
    ],
    "perl6": [
      {
        "content": "#!/usr/bin/env perl6",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#!"
        ],
        "opts": []
      },
      {
        "content": "=>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "."
        ],
        "opts": []
      },
      {
        "content": "sub ${1:function_name}(${2:Str $var}) {\n\t${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sub"
        ],
        "opts": []
      },
      {
        "content": "multi ${1:function_name}(${2:Str $var}) {\n\t${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mul"
        ],
        "opts": []
      },
      {
        "content": "if ${1} {\n\t${2}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "if ${1} {\n\t${2}\n}\nelse {\n\t${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "elsif ${1) {\n\t${2}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eif"
        ],
        "opts": []
      },
      {
        "content": "${1:expression} if ${2:condition};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "xif"
        ],
        "opts": []
      },
      {
        "content": "unless ${1} {\n\t${2}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "unless"
        ],
        "opts": []
      },
      {
        "content": "${1:expression} unless ${2:condition};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "xunless"
        ],
        "opts": []
      },
      {
        "content": "${1:condition} ?? ${2:value-if-true} !! ${3:value-if-false};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tc"
        ],
        "opts": []
      },
      {
        "content": "given ${1:$var} {\n  when ${2:condition} {\n\t  ${3:# code block ...}\n  }\n  ${4}\n  default {\n\t  ${5}\n  }\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "switch"
        ],
        "opts": []
      },
      {
        "content": "loop (my ${1:$i} = 0; $$1 < ${2:count}; $$1++) {\n\t${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "loop"
        ],
        "opts": []
      },
      {
        "content": "for ${1:@array} -> ${2:$variable} {\n\t${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "while ${1} {\n\t${2}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh"
        ],
        "opts": []
      },
      {
        "content": "repeat {\n\t${1}\n} ${2:while|until} ${3};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rp"
        ],
        "opts": []
      },
      {
        "content": "${1:my} class ${2:ClassName} ${3:is|does Parent|Role}{\n\t${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cl"
        ],
        "opts": []
      },
      {
        "content": "has ${1:Type} ${2:$!identifier};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "has"
        ],
        "opts": []
      },
      {
        "content": "method ${1:method_name}(${2:$attr}) {\n\t${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mth"
        ],
        "opts": []
      },
      {
        "content": "method ${1:!}${2:method_name}(${3:$attr}) {\n\t${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pmth"
        ],
        "opts": []
      },
      {
        "content": "submethod ${1:submethod_name}(${2:$attr}) {\n\t${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "smth"
        ],
        "opts": []
      },
      {
        "content": "use v6;\nuse Test;\n${1:use lib 'lib';}\nplan ${2:$num-tests};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "test"
        ],
        "opts": []
      },
      {
        "content": "my ${1:$var} = \"${2:filename}\".IO.slurp;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "slurp"
        ],
        "opts": []
      },
      {
        "content": "for \"${1:filename}\".IO.lines -> $line {\n\t${2}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rfile"
        ],
        "opts": []
      },
      {
        "content": "my $fh = open \"${1:filename}\", ${2::r|:w|:a};\n${3:# actions};\n$fh.close;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "open"
        ],
        "opts": []
      }
    ],
    "phoenix": [
      {
        "content": "defmodule ${1:AppName}Web.${2:ControllerName}Controller do\n\tuse $1Web, :controller\n\t${3}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cont"
        ],
        "opts": []
      },
      {
        "content": "defmodule ${1:AppName}Web.${2:ViewName}View do\n\tuse $1Web, :view\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "view"
        ],
        "opts": []
      },
      {
        "content": "defmodule ${1:AppName}Web.${2:ChannelName}Channel do\n\tuse $1Web, :channel\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "chan"
        ],
        "opts": []
      }
    ],
    "php": [
      {
        "content": "<?php\n${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "<?"
        ],
        "opts": []
      },
      {
        "content": "declare(strict_types=${1:1});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dst \"declare(strict_types=1)\""
        ],
        "opts": []
      },
      {
        "content": "echo ${0};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ec"
        ],
        "opts": []
      },
      {
        "content": "<?php echo ${0} ?>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "<?e"
        ],
        "opts": []
      },
      {
        "content": "<?=${0}?>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "<?="
        ],
        "opts": []
      },
      {
        "content": "<?= ${0} ?>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "?="
        ],
        "opts": []
      },
      {
        "content": "<?php ${0} ?>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "?"
        ],
        "opts": []
      },
      {
        "content": "<?php foreach ($${1:vars} as $${2:$var}): ?>\n\t${0:${VISUAL}}\n<?php endforeach ?>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "?f"
        ],
        "opts": []
      },
      {
        "content": "<?php if ($${1:var}): ?>\n\t${0:${VISUAL}}\n<?php endif ?>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "?i"
        ],
        "opts": []
      },
      {
        "content": "namespace ${1:Foo\\Bar\\Baz};\n${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ns"
        ],
        "opts": []
      },
      {
        "content": "class ${1:`vim_snippets#Filename()`}\n{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "c"
        ],
        "opts": []
      },
      {
        "content": "interface ${1:`vim_snippets#Filename()`}\n{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "i"
        ],
        "opts": []
      },
      {
        "content": "$this->",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "t."
        ],
        "opts": []
      },
      {
        "content": "function ${1}(${3})\n{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "f"
        ],
        "opts": []
      },
      {
        "content": "${1:protected} function ${2:foo}()\n{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "m"
        ],
        "opts": []
      },
      {
        "content": "/**\n * Sets the value of ${1:foo}\n *\n * @param ${2:string} $$1 ${3:description}\n *\n * @return ${4:`vim_snippets#Filename()`}\n */\n${5:public} function set${6:$1}(${7:$2 }$$1)\n{\n\t$this->${8:$1} = $$1;\n\treturn $this;\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sm \"PHP Class Setter\""
        ],
        "opts": []
      },
      {
        "content": "/**\n * Gets the value of ${1:foo}\n *\n * @return ${2:string}\n */\n${3:public} function get${4:$1}()\n{\n\treturn $this->${5:$1};\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gm \"PHP Class Getter Setter\""
        ],
        "opts": []
      },
      {
        "content": "${1:$foo}->set${2:Bar}(${0});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "$s"
        ],
        "opts": []
      },
      {
        "content": "${1:$foo}->get${0:Bar}();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "$g"
        ],
        "opts": []
      },
      {
        "content": "$${1:foo} = ${2:true} ? ${3:a} : ${0};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "=?:"
        ],
        "opts": []
      },
      {
        "content": "${1:true} ? ${2:a} : ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "?:"
        ],
        "opts": []
      },
      {
        "content": "$${1:retVal} = (${2:condition}) ? ${3:a} : ${4:b};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "t \"$retVal = (condition) ? a : b\""
        ],
        "opts": []
      },
      {
        "content": "$_COOKIE['${1:variable}']",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "C"
        ],
        "opts": []
      },
      {
        "content": "$_ENV['${1:variable}']",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "E"
        ],
        "opts": []
      },
      {
        "content": "$_FILES['${1:variable}']",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "F"
        ],
        "opts": []
      },
      {
        "content": "$_GET['${1:variable}']",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "G \"_GET array\""
        ],
        "opts": []
      },
      {
        "content": "$_POST['${1:variable}']",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "P \"_POST array\""
        ],
        "opts": []
      },
      {
        "content": "$_REQUEST['${1:variable}']",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "R"
        ],
        "opts": []
      },
      {
        "content": "$_SERVER['${1:variable}']",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "S"
        ],
        "opts": []
      },
      {
        "content": "$_SESSION['${1:variable}']",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "SS"
        ],
        "opts": []
      },
      {
        "content": "$_GET['${1}']",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "get \"get\""
        ],
        "opts": []
      },
      {
        "content": "$_POST['${1}']",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "post \"post\""
        ],
        "opts": []
      },
      {
        "content": "$_SESSION['${1}']",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "session \"session\""
        ],
        "opts": []
      },
      {
        "content": "include '${1:file}';",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "inc"
        ],
        "opts": []
      },
      {
        "content": "include_once '${1:file}';",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "inc1"
        ],
        "opts": []
      },
      {
        "content": "require '${1:file}';",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "req"
        ],
        "opts": []
      },
      {
        "content": "require_once '${1:file}';",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "req1"
        ],
        "opts": []
      },
      {
        "content": "/**\n * ${0}\n */",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "/*"
        ],
        "opts": []
      },
      {
        "content": "/**\n * ${1:undocumented class}\n *\n * @package ${2:default}\n * @subpackage ${3:default}\n * @author ${4:`g:snips_author`}\n */",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doc_cp"
        ],
        "opts": []
      },
      {
        "content": "/**\n * ${1:undocumented class variable}\n *\n * @var ${2:string}\n */",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doc_vp"
        ],
        "opts": []
      },
      {
        "content": "/**\n * ${3:undocumented class variable}\n *\n * @var ${4:string}\n */\n${1:var} $${2};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doc_v"
        ],
        "opts": []
      },
      {
        "content": "/** @var ${3:string} */\n${1:public} $${2};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "att"
        ],
        "opts": []
      },
      {
        "content": "/**\n * ${3:undocumented class}\n *\n * @package ${4:default}\n * @subpackage ${5:default}\n * @author ${6:`g:snips_author`}\n */\n${1:}class ${2:}\n{\n\t${0:${VISUAL}}\n} // END $1class $2",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doc_c"
        ],
        "opts": []
      },
      {
        "content": "/**\n * ${1:undocumented constant}\n */",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doc_dp"
        ],
        "opts": []
      },
      {
        "content": "/**\n * ${3:undocumented constant}\n */\ndefine(${1}, ${2});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doc_d"
        ],
        "opts": []
      },
      {
        "content": "/**\n * ${1:undocumented function}\n *\n * @return ${2:void}\n * @author ${3:`g:snips_author`}\n */",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doc_fp"
        ],
        "opts": []
      },
      {
        "content": "/**\n * ${4:undocumented function}\n *\n * @return ${5:void}\n * @author ${6:`g:snips_author`}\n */\n${1}function ${2}(${3});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doc_s"
        ],
        "opts": []
      },
      {
        "content": "/**\n * ${4:undocumented function}\n *\n * @return ${5:void}\n * @author ${6:`g:snips_author`}\n */\n${1}function ${2}(${3})\n{${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doc_f"
        ],
        "opts": []
      },
      {
        "content": "/**\n * ${1}\n *\n * @author ${2:`g:snips_author`}\n * @version ${3:$Id$}\n * @copyright ${4:$2}, `strftime('%d %B, %Y')`\n * @package ${0:default}\n */",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doc_h"
        ],
        "opts": []
      },
      {
        "content": "/**\n * $1\n * @package ${2:default}\n * @author ${3:`!v g:snips_author`}\n **/\ninterface ${1:someClass}\n{${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doc_i \"interface someClass {}\""
        ],
        "opts": []
      },
      {
        "content": "/**\n * {@inheritdoc}\n */",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "inheritdoc \"@inheritdoc docblock\""
        ],
        "opts": []
      },
      {
        "content": "/**\n * ${2:undocumented class}\n *\n * @package ${3:default}\n * @author ${4:`g:snips_author`}\n */\ninterface ${1:`vim_snippets#Filename()`}\n{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "interface"
        ],
        "opts": []
      },
      {
        "content": "/**\n * ${2:undocumented class}\n *\n * @package ${3:default}\n * @author ${4:`g:snips_author`}\n */\ntrait ${1:`vim_snippets#Filename()`}\n{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "trait"
        ],
        "opts": []
      },
      {
        "content": "/**\n * ${1}\n */\nclass ${2:`vim_snippets#Filename()`}\n{\n\t${3}\n\t/**\n\t * ${4}\n\t */\n\t${5:public} function ${6:__construct}(${7:argument})\n\t{\n\t\t${0}\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "class"
        ],
        "opts": []
      },
      {
        "content": "namespace ${1:`substitute(substitute(expand(\"%:h\"), '\\v^\\w+\\/(\\u)', '\\1', ''), '\\/', '\\\\\\', 'g')`};\n${2:abstract }class ${3:`vim_snippets#Filename()`}\n{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nc"
        ],
        "opts": []
      },
      {
        "content": "define('${1:VARIABLE_NAME}', ${2:'definition'});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "def \"define('VARIABLE_NAME', 'definition')\""
        ],
        "opts": []
      },
      {
        "content": "${1}defined('${2}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "def?"
        ],
        "opts": []
      },
      {
        "content": "while (${1:/* condition */}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh \"while (condition) { ... }\""
        ],
        "opts": []
      },
      {
        "content": "do {\n\t${0:${VISUAL}}\n} while (${1});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "do \"do { ... } while (condition)\""
        ],
        "opts": []
      },
      {
        "content": "if (${1}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if \"if (condition) { ... }\""
        ],
        "opts": []
      },
      {
        "content": "if (!${1}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifn \"if (!condition) { ... }\""
        ],
        "opts": []
      },
      {
        "content": "<?php if (${1}): ?>\n\t${0:${VISUAL}}\n<?php endif; ?>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifil \"<?php if (condition): ?> ... <?php endif; ?>\""
        ],
        "opts": []
      },
      {
        "content": "if (${1}) {\n\t${0:${VISUAL}}\n} else {\n\t${2}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife \"if (cond) { ... } else { ... }\""
        ],
        "opts": []
      },
      {
        "content": "<?php if (${1}): ?>\n\t${0:${VISUAL}}\n<?php else: ?>\n\t${2}\n<?php endif; ?>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifeil \"<?php if (condition): ?> ... <?php else: ?> ... <?php endif; ?>\""
        ],
        "opts": []
      },
      {
        "content": "else {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "el \"else { ... }\""
        ],
        "opts": []
      },
      {
        "content": "elseif (${1}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eif \"elseif(condition) { ... }\""
        ],
        "opts": []
      },
      {
        "content": "switch ($${1:variable}) {\n\tcase '${2:value}':\n\t\t${3}\n\t\tbreak;\n\t${0}\n\tdefault:\n\t\t${4}\n\t\tbreak;\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "switch \"switch($var) { case 'xyz': ... default: .... }\""
        ],
        "opts": []
      },
      {
        "content": "case '${1:value}':\n\t${0:${VISUAL}}\n\tbreak;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case \"case 'value': ... break\""
        ],
        "opts": []
      },
      {
        "content": "for ($${2:i} = 0; $$2 < ${1:count}; $$2${3:++}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for \"for ($i = 0; $i < $count; $i++) { ... }\""
        ],
        "opts": []
      },
      {
        "content": "foreach ($${1:variable} as $${2:value}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "foreach \"foreach ($var as $value) { .. }\""
        ],
        "opts": []
      },
      {
        "content": "<?php foreach ($${1:variable} as $${2:value}): ?>\n\t${0:${VISUAL}}\n<?php endforeach; ?>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "foreachil \"<?php foreach ($var as $value): ?>  ... <?php endforeach; ?>\""
        ],
        "opts": []
      },
      {
        "content": "foreach ($${1:variable} as $${2:key} => $${3:value}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "foreachk \"foreach ($var as $key => $value) { .. }\""
        ],
        "opts": []
      },
      {
        "content": "<?php foreach ($${1:variable} as $${2:key} => $${3:value}): ?>\n\t${0:<!-- html... -->}\n<?php endforeach; ?>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "foreachkil \"<?php foreach ($var as $key => $value): ?>  ... <?php endforeach; ?>\""
        ],
        "opts": []
      },
      {
        "content": "$${1:arrayName} = ['${2}' => ${3}];",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "array \"$... = ['' => ]\""
        ],
        "opts": []
      },
      {
        "content": "try {\n\t${0:${VISUAL}}\n} catch (${1:Exception} $e) {\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "try \"try { ... } catch (Exception $e) { ... }\""
        ],
        "opts": []
      },
      {
        "content": "${1:static }function (${2:args}) use (${3:&$x, $y /*put vars in scope (closure) */}) {\n\t${0}\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lambda"
        ],
        "opts": []
      },
      {
        "content": "echo '<pre>'; var_dump(${0}); echo '</pre>';",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pd"
        ],
        "opts": []
      },
      {
        "content": "echo '<pre>'; var_dump(${1}); echo '</pre>'; die(${0:});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pdd"
        ],
        "opts": []
      },
      {
        "content": "var_dump(${0});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vd"
        ],
        "opts": []
      },
      {
        "content": "var_dump(${1}); die(${0:});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vdd"
        ],
        "opts": []
      },
      {
        "content": "print_r(${0});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pr"
        ],
        "opts": []
      },
      {
        "content": "print_r(${0}, 1);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prs"
        ],
        "opts": []
      },
      {
        "content": "error_log(print_r($${1:foo}, true), 3, '${2:/tmp/debug.log}');",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vdf"
        ],
        "opts": []
      },
      {
        "content": "header (\"HTTP/1.1 301 Moved Permanently\");\nheader (\"Location: \".URL);\nexit();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "http_redirect"
        ],
        "opts": []
      },
      {
        "content": "error_log(var_export(${1}, true));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "log \"error_log(var_export($var, true));\""
        ],
        "opts": []
      },
      {
        "content": "var_export(${1});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "var \"var_export($var)\""
        ],
        "opts": []
      },
      {
        "content": "echo '<pre>' . var_export(${1}, 1) . '</pre>';",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ve \"Dumb debug helper in HTML\""
        ],
        "opts": []
      },
      {
        "content": "var_export($1);$0",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc \"Dumb debug helper in cli\""
        ],
        "opts": []
      },
      {
        "content": "/**\n * Gets the value of ${1:foo}\n *\n * @return ${2:string}\n */\npublic function get${3:$1}()\n{\n\treturn $this->${4:$1};\n}\n/**\n * Sets the value of $1\n *\n * @param $2 $$1 ${5:description}\n *\n * @return ${6:`vim_snippets#Filename()`}\n */\npublic function set$3(${7:$2 }$$1)\n{\n\t$this->$4 = $$1;\n\treturn $this;\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gs \"PHP Class Getter Setter\""
        ],
        "opts": []
      },
      {
        "content": "/**\n * ${1:description}\n *\n * @${0}\n */\n${2:protected} $${3:foo};\npublic function get${4:$3}()\n{\n\treturn $this->$3;\n}\npublic function set$4(${5:$4 }$${6:$3})\n{\n\t$this->$3 = $$6;\n\treturn $this;\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ags"
        ],
        "opts": []
      },
      {
        "content": "return true;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rett"
        ],
        "opts": []
      },
      {
        "content": "return false;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "retf"
        ],
        "opts": []
      },
      {
        "content": "$${1:foo} = array_map(function($${2:v}) {\n\t${0}\n\treturn $$2;\n}, $$1);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "am"
        ],
        "opts": []
      },
      {
        "content": "array_walk($${1:foo}, function(&$${2:v}, $${3:k}) {\n\t$$2 = ${0};\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "aw"
        ],
        "opts": []
      },
      {
        "content": "static $${1} = null;\nif (is_null($$1)){\n\t$$1 = ${2};\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "static_var"
        ],
        "opts": []
      },
      {
        "content": "<?php\nclass CSVWriter {\n\tpublic function __construct($file_or_handle, $sep = \"\\t\", $quot = '\"'){\n\t\t$args = func_get_args();\n\t\t$mode = isset($opts['mode']) ? $opts['mode'] : 'w';\n\t\t$this->f =\n\t\t\tis_string($file_or_handle)\n\t\t\t? fopen($file_or_handle, $mode)\n\t\t\t: $file_or_handle;\n\t\t$this->fputcsv_args = [$this->f, null, $sep, $quot];\n\t\tif (!$this->f) throw new Exception('bad file descriptor');\n\t}\n\tpublic function write($row){\n\t\t$this->fputcsv_args[1] =& $row;\n\t\tcall_user_func_array('fputcsv', $this->fputcsv_args);\n\t}\n\tpublic function close(){\n\t\tif (!is_null($this->f))\n\t\t\tfclose($this->f);\n\t\t$this->f = null;\n\t}\n\tpublic function __destruct(){\n\t\t$this->close();\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "CSVWriter"
        ],
        "opts": []
      },
      {
        "content": "// http://snipplr.com/view.php?codeview&id=1986 // modified\nclass CSVIterator implements Iterator\n{\t\n\tprivate $f;\n\tprivate $curr;\n\tprivate $rowCounter;\n\t /* opts keys:\n\t\t* row_size\n\t\t* escape\n\t\t* enclosure\n\t\t* delimiter\n\t\t*/\n\tpublic function __construct( $file_or_handle, $opts = [4096, ','] )\n\t{\n\t\t$d = function($n) use(&$opts){ return isset($opts[$n]) ? $opts[$n] : false; };\n\t\t$this->combine = $d('combine');\n\t\t$this->headers = $d('headers');\n\t\t$this->headerCheckFunction = $d('header_check_function');\n\t\t$this->f =\n\t\t\tis_string($file_or_handle)\n\t\t\t? fopen( $file_or_handle, 'r' )\n\t\t\t: $file_or_handle;\n\t\tif (!$this->f) throw new Exception('bad file descriptor');\n\t\t$this->fgetcsv_args = [\n\t\t\t\t$this->f,\n\t\t\t\tisset($opts['row_size']) ? $opts['row_size'] : 4096,\n\t\t\t\tisset($opts['delimiter']) ? $opts['delimiter'] : ',',\n\t\t\t\tisset($opts['enclosure']) ? $opts['enclosure'] : '\"',\n\t\t\t\tisset($opts['escape']) ? $opts['escape'] : '\\\\',\n\t\t];\n\t\t$this->start();\n\t}\n\tprotected function readRow(){\n\t\t$this->curr = call_user_func_array('fgetcsv', $this->fgetcsv_args );\n\t\t$this->rowCounter++;\n\t\tif ($this->rowCounter == 1){\n\t\t\t$this->processHeader();\n\t\t} elseif ($this->curr) {\n\t\t\t$this->processRow();\n\t\t}\n\t}\n\tpublic function processHeader(){\n\t\tif ($this->headers || $this->combine){\n\t\t\t$this->header = $this->curr;\n\t\t\tif ($this->headerCheckFunction){\n\t\t\t\t$f = $this->headerCheckFunction;\n\t\t\t\t$f($this->header);\n\t\t\t}\n\t\t\t$this->readRow();\n\t\t}\n\t}\n\tpublic function processRow(){\n\t\tif ($this->combine)\n\t\t\t$this->curr = array_combine($this->header, $this->curr);\n\t}\n\tpublic function start(){\n\t\t$this->rowCounter = 0;\n\t\trewind( $this->f );\n\t\t$this->readRow();\n\t}\n\tpublic function rewind()\n\t{\n\t\t$this->start();\n\t}\n\tpublic function current()\n\t{\n\t\t$curr = $this->curr;\n\t\t$this->readRow();\n\t\treturn $curr;\n\t}\n\tpublic function key()\n\t{\n\t\treturn $this->rowCounter;\n\t}\n\tpublic function next()\n\t{\n\t\treturn $this->curr;\n\t}\n\tpublic function valid(){\n\t\tif( !$this->next() )\n\t\t{\n\t\t\tfclose( $this->f );\n\t\t\treturn FALSE;\n\t\t}\n\t\treturn TRUE;\n\t}\n} // end class",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "CSVIterator"
        ],
        "opts": []
      },
      {
        "content": "$this->assertEquals(${1:$expected}, ${2:$actual});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ase \"$this->assertEquals($a, $b)\""
        ],
        "opts": []
      },
      {
        "content": "$this->assertNotEquals(${1:$expected}, ${2:$actual});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asne \"$this->assertNotEquals($a, $b)\""
        ],
        "opts": []
      },
      {
        "content": "$this->assertFalse(${1});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asf \"$this->assertFalse($a)\""
        ],
        "opts": []
      },
      {
        "content": "$this->assertTrue(${1});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ast \"$this->assertTrue($a)\""
        ],
        "opts": []
      },
      {
        "content": "$this->assertFileExists(${1:'path/to/file'});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asfex \"$this->assertFileExists('path/to/file')\""
        ],
        "opts": []
      },
      {
        "content": "$this->assertFileNotExists(${1:'path/to/file'});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asfnex \"$this->assertFileNotExists('path/to/file')\""
        ],
        "opts": []
      },
      {
        "content": "$this->assertContains(${1:$needle}, ${2:$haystack});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ascon \"$this->assertContains($needle, $haystack)\""
        ],
        "opts": []
      },
      {
        "content": "$this->assertNotContains(${1:$needle}, ${2:$haystack});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asncon \"$this->assertNotContains($needle, $haystack)\""
        ],
        "opts": []
      },
      {
        "content": "$this->assertContainsOnly(${1:$needle}, ${2:$haystack});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ascono \"$this->assertContainsOnly($needle, $haystack)\""
        ],
        "opts": []
      },
      {
        "content": "$this->assertContainsOnlyInstancesOf(${1:Example}::class, ${2:$haystack});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asconoi \"$this->assertContainsOnlyInstancesOf(Example::class, $haystack)\""
        ],
        "opts": []
      },
      {
        "content": "$this->assertArrayHasKey(${1:$key}, ${2:$array});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ashk \"$this->assertArrayHasKey($key, $array)\""
        ],
        "opts": []
      },
      {
        "content": "this->assertArrayNotHasKey(${1:$key}, ${2:$array});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asnhk \"$this->assertArrayNotHasKey($key, $array)\""
        ],
        "opts": []
      },
      {
        "content": "$this->assertClassHasAttribute(${1:$attributeName}, ${2:Example}::class);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ascha \"$this->assertClassHasAttribute($name, Example::class)\""
        ],
        "opts": []
      },
      {
        "content": "$this->assertInstanceOf(${1:Example}::class, ${2:$actual});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asi \"$this->assertInstanceOf(Example::class, $actual)\""
        ],
        "opts": []
      },
      {
        "content": "$this->assertInternalType(${1:'string'}, ${2:actual});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asit \"$this->assertInternalType('string', $actual)\""
        ],
        "opts": []
      },
      {
        "content": "$this->assertCount(${1:$expectedCount}, ${2:$haystack});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asco \"$this->assertCount($count, $haystack)\""
        ],
        "opts": []
      },
      {
        "content": "$this->assertNotCount(${1:$count}, ${2:$haystack});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asnco \"$this->assertNotCount($count, $haystack)\""
        ],
        "opts": []
      },
      {
        "content": "$this->assertArraySubset(${1:$subset}, ${2:$array});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "assub \"$this->assertArraySubset($subset, $array)\""
        ],
        "opts": []
      },
      {
        "content": "$this->assertNull(${1});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asnu \"$this->assertNull($a)\""
        ],
        "opts": []
      },
      {
        "content": "$this->assertNotNull(${1});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asnnu \"$this->assertNotNull($a)\""
        ],
        "opts": []
      },
      {
        "content": "public function test${1}()\n{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "test \"public function testXYZ() { ... }\""
        ],
        "opts": []
      },
      {
        "content": "protected function setUp()\n{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "setup \"protected function setUp() { ... }\""
        ],
        "opts": []
      },
      {
        "content": "protected function tearDown()\n{\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "teardown \"protected function tearDown() { ... }\""
        ],
        "opts": []
      },
      {
        "content": "$${1:observer} = $this->prophesize(${2:SomeClass}::class);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "proph \"$observer = $this->prophesize(SomeClass::class);\""
        ],
        "opts": []
      },
      {
        "content": "$${1:mock} = $this->createMock(${2:SomeClass}::class);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mock \"$mock = $this->createMock(SomeClass::class);\""
        ],
        "opts": []
      },
      {
        "content": "expects($this->${1:once}())\n\t->method('${2}')\n\t->with(${3})\n\t->willReturn(${4});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "exp \"phpunit expects\""
        ],
        "opts": []
      },
      {
        "content": "/**\n* @group ${1}\n*/",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "testcmt \"phpunit comment with group\""
        ],
        "opts": []
      },
      {
        "content": "$this->fail(${1});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fail \"$this->fail()\""
        ],
        "opts": []
      },
      {
        "content": "$this->markTestIncomplete(${1});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "marki \"$this->markTestIncomplete()\""
        ],
        "opts": []
      },
      {
        "content": "$this->markTestSkipped(${1});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "marks \"$this->markTestSkipped()\""
        ],
        "opts": []
      },
      {
        "content": "throw new ${1:Exception}(\"${2:Error Processing Request}\");",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "te \"throw new Exception()\""
        ],
        "opts": []
      },
      {
        "content": "file_put_contents(${1:file}, ${2:content}${3:, FILE_APPEND});$0",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fpc \"file_put_contents\" b"
        ],
        "opts": []
      },
      {
        "content": "str_replace(${1:search}, ${2:replace}, ${3:subject})$0",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sr \"str_replace\""
        ],
        "opts": []
      },
      {
        "content": "in_array(${1:needle}, ${2:haystack})$0",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ia \"in_array\""
        ],
        "opts": []
      },
      {
        "content": "isset(${1:var})$0",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "is \"isset\""
        ],
        "opts": []
      },
      {
        "content": "isset($${1:array}[${2:key}])$0",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isa \"isset array\""
        ],
        "opts": []
      },
      {
        "content": "is_null($${1:var})$0",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "in \"is_null\""
        ],
        "opts": []
      },
      {
        "content": "file_exists(${1:file})$0",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fe \"file_exists\""
        ],
        "opts": []
      },
      {
        "content": "is_dir(${1:path})$0",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "id \"is_dir\""
        ],
        "opts": []
      },
      {
        "content": "${1:public }function ${2:#:FunctionName}(${3})\n{\n\t${4:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "public function () {}",
        "matches": [
          "function"
        ],
        "opts": []
      },
      {
        "content": "function (${1})${2: use } {\n\t${3:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "function () {}",
        "matches": [
          "function_literal"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "<?php\n${1:TARGET}\n/* End of file ${2:filename}.php */",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "php"
        ],
        "opts": []
      },
      {
        "content": "<?php echo ${1} ?>${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pecho"
        ],
        "opts": []
      },
      {
        "content": "<?php echo htmlentities(${1}, ENT_QUOTES, 'utf-8') ?>${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "echoh"
        ],
        "opts": []
      },
      {
        "content": "<?$php foreach ($${1:#:variable} as $${2:#:key}${3: =>}): ?>\n${0:TARGET}\n<?php endforeach; ?>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pforeach"
        ],
        "opts": []
      },
      {
        "content": "<?php if (${1:#:condition}): ?>\n${2:TARGET}\n<?php else: ?>\n${0}\n<?php endif; ?>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pifelse"
        ],
        "opts": []
      },
      {
        "content": "<?php if (${1:#:condition}): ?>\n${0:TARGET}\n<?php endif; ?>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pif"
        ],
        "opts": []
      },
      {
        "content": "<?php else: ?>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pelse"
        ],
        "opts": []
      },
      {
        "content": "<?php $this->${0} ?>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pthis"
        ],
        "opts": []
      },
      {
        "content": "<?php echo $this->${0} ?>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pethis"
        ],
        "opts": []
      },
      {
        "content": "/**\n * ${3:#:undocumented class variable}\n *\n * @var ${4:#:string}\n **/\n${1:#:var} $${2};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doc_class_var"
        ],
        "opts": []
      },
      {
        "content": "/**\n * ${3:#:undocumented constant}\n **/\ndefine(${1} ${2});${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doc_constant"
        ],
        "opts": []
      },
      {
        "content": "/**\n * ${4:#:undocumented function}\n *\n * @return ${5:void}\n * @author ${6}\n **/\n${1}function ${2}(${3});${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doc_interface_function"
        ],
        "opts": []
      },
      {
        "content": "/**\n * ${4:#:undocumented function}\n *\n * @return ${5:void}\n * @author ${6}\n **/\n${1}function ${2}(${3})\n{\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doc_function"
        ],
        "opts": []
      },
      {
        "content": "/**\n * ${1}\n *\n * @author ${2}\n * @version ${3}\n * @copyright ${4}\n * @package ${5:default}\n **/\n/**\n * Define DocBlock\n **/",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doch"
        ],
        "opts": []
      },
      {
        "content": "/**\n * ${2:#:undocumented class}\n *\n * @package ${3:default}\n * @author ${4}\n **/\ninterface ${1}\n{\n\t${0:TARGET}\n} // END interface $1",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doci"
        ],
        "opts": []
      },
      {
        "content": "/**\n * ${0}\n */",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doc"
        ],
        "opts": []
      },
      {
        "content": "/**\n * ${1}\n */\nclass ${2:#:ClassName}${3:#:extends}\n{\n\t$5\n\tfunction ${4:__construct}(${5:#:argument})\n\t{\n\t\t${0:# code...}\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "class_with_constructor"
        ],
        "opts": []
      },
      {
        "content": "class ${2:#:ClassName} {\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "class"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "${1}defined('${2}')${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "def"
        ],
        "opts": []
      },
      {
        "content": "do {\n\t${0:TARGET}\n} while (${1:#:condition});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dowhile"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "$${1:#:retVal} = (${2:#:condition}) ? ${3:#:a} : ${4:#:b};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if?"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "if (${1:#:condition}) {\n\t${2:TARGET}\n} else {\n\t${3:#:code...}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifelse"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "if (${1:#:condition}) {\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "var_dump(${0:TARGET});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "var_dump"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "print_r(${1});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "echo \"${1:#:string}\";",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "echo"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "printf(\"${1:#:string}\\n\"${2:, });",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "println"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "else {\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "else"
        ],
        "opts": []
      },
      {
        "content": "elseif (${1:#:condition}) {\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "elseif"
        ],
        "opts": []
      },
      {
        "content": "for ($${1:i}=${2:0}; $$1 < ${3}; $$1++) {\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "foreach ($${1:#:variable} as $${2:#:key}${3: =>} $${4:#:value}) {\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "foreach-hashmap"
        ],
        "opts": []
      },
      {
        "content": "foreach ($${1:#:variable} as $${2:#:x}) {\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "foreach-list",
          "foreach"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "function __construct(${1})\n{\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "construct"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "<<<${1:HTML}\n${2:TARGET:#:content here}\n$1;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "here"
        ],
        "opts": []
      },
      {
        "content": "include '${1:#:file}';${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "inc"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "include_once '${1:#:file}';${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "inco"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "$${1:#:arrayName} = array('${2}' => ${3} ${0});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "array"
        ],
        "opts": []
      },
      {
        "content": "require '${1:#:file}';${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "req"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "require_once '${1:#:file}';${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "reqo"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "return${1};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ret"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "return false;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "retf"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "return true;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rett"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "case '${1:#:variable}':\n\t${0:#:code...}\n\tbreak;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "switch (${1:#:variable}) {\ncase '${2:#:value}':\n\t${3:#:code...}\n\tbreak;\n${0}\ndefault:\n\t${4:#:code...}\n\tbreak;\n}",
        "doc": "",
        "grammar": "snu",
        "label": "sw",
        "matches": [
          "switch"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "try {\n\t${1:TARGET}\n} catch (${2:#:Exception} $e) {\n\t${3:#:code}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "try"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "try {\n\t${1:TARGET}\n} catch (${2:#:Exception} $e) {\n\t${3:#:code}\n} finally {\n\t${4:#:code}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tryf"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "throw new ${1}Exception(${2:\"${3:#:Error Processing Request}\"}${4:});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "throw"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "while (${1}) {\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "wh",
        "matches": [
          "while"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "\\$GLOBALS['${1:#:variable}']${2: = }${3:#:something}${4:;}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gloabals"
        ],
        "opts": []
      },
      {
        "content": "\\$_COOKIE['${1:#:variable}']",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cookie"
        ],
        "opts": []
      },
      {
        "content": "\\$_ENV['${1:#:variable}']",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "env"
        ],
        "opts": []
      },
      {
        "content": "\\$_FILES['${1:#:variable}']",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "files"
        ],
        "opts": []
      },
      {
        "content": "\\$_GET['${1:#:variable}']",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "get"
        ],
        "opts": []
      },
      {
        "content": "\\$_POST['${1:#:variable}']",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "post"
        ],
        "opts": []
      },
      {
        "content": "\\$_REQUEST['${1:#:variable}']",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "request"
        ],
        "opts": []
      },
      {
        "content": "\\$_SERVER['${1:#:variable}']",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "server"
        ],
        "opts": []
      },
      {
        "content": "\\$_SESSION['${1:#:variable}']",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "session"
        ],
        "opts": []
      },
      {
        "content": "var_export(${1}, true)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "var_export",
          "inspect"
        ],
        "opts": []
      }
    ],
    "php-laravel": [
      {
        "content": "/*!\n * \\class       $1\n *\n * \\author      ${3:`!v g:snips_author`}\n * \\date        `!v strftime('%d-%m-%y')`\n */\n\nclass ${1:`!v expand('%:t:r')`} extends ${2:BaseController} {\n    function __construct() {\n    }\n    \n    public function index() {\n    }\n    \n    public function create() {\n    }\n    \n    public function store() {\n    }\n    \n    public function show($id) {\n    }\n    \n    public function edit($id) {\n    }\n    \n    public function update($id) {\n    }\n    \n    public function destroy($id) {\n    }\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Laravel resource controller",
        "matches": [
          "l_rsc"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "<?php\n\n/*!\n * \\namespace   $1\n * \\class       $2\n *\n * \\author      ${3:`!v g:snips_author`}\n * \\date        `!v strftime('%d-%m-%y')`\n */\n\nnamespace ${1:Services};\n\nuse Illuminate\\Support\\ServiceProvider;\n\nclass ${2:`!v expand('%:t:r')`} extends ServiceProvider {\n    \n    public function register() {\n        $this->app->bind('$4Service', function ($app) {\n            return new $5(\n                $app->make('Repositories\\\\$6Interface')\n            );\n        });\n    }\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Laravel service provider for service",
        "matches": [
          "l_ssp"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "<?php\n\n/*!\n * \\namespace   $2\n * \\class       $3\n *\n * \\author      ${4:`!v g:snips_author`}\n * \\date        `!v strftime('%d-%m-%y')`\n */\n\nnamespace ${2:Repositories\\\\${1:}};\n\nuse Entities\\\\$1;\nuse $2\\\\$1Repository;\nuse Illuminate\\Support\\ServiceProvider;\n\nclass ${3:`!v expand('%:t:r')`} extends ServiceProvider {\n    /*!\n     * \\var     defer\n     * \\brief   Defer service\n     */\n    protected $defer = ${5:true};\n\n    public function register() {\n        $this->app->bind('$2\\\\$1Interface', function($app) {\n            return new $1Repository(new $1());\n        });\n    }\n\n    /*!\n     * \\brief   If $defer == true need this fn\n     */ \n    public function provides() {\n        return ['$2\\\\$1Interface'];\n    }\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Laravel service provider for repository",
        "matches": [
          "l_rsp"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "<?php\n\n/*!\n * \\namespace   $1\n * \\class       $2\n *\n * \\author      ${3:`!v g:snips_author`}\n * \\date        `!v strftime('%d-%m-%y')`\n */\n\nnamespace ${1:Entities};\n\nclass ${2:`!v expand('%:t:r')`} extends \\Eloquent {\n    protected $table   = '${4:`!p snip.rv = t[2].lower()`}';\n\n    public $timestamps = ${5:false};\n\n    protected $hidden  = [$6];\n\n    protected $guarded = [${7:'id'}];\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Laravel simple model",
        "matches": [
          "l_md"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "<?php\n\n/*!\n * \\namespace   $1\n * \\class       $2\n * \\implements  $3\n *\n * \\author      ${4:`!v g:snips_author`}\n * \\date        `!v strftime('%d-%m-%y')`\n */\n\nnamespace ${1:Repositories};\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nabstract class ${2:`!v expand('%:t:r')`} implements ${3:BaseRepositoryInterface} {\n    protected $model;\n\n    /*!\n     * \\fn      __construct\n     *\n     * \\brief   Take the model\n     */\n\n    public function __construct(Model $model) {\n        $this->model = $model;\n    }\n\n    /*!\n     * \\fn      all\n     *\n     * \\return  Illuminate\\Database\\Eloquent\\Collection\n     */\n    public function all($columns = ['*']) {\n        return $this->model->all()->toArray();\n    }\n\n    /*!\n     * \\fn      create\n     *\n     * \\return  Illuminate\\Database\\Eloquent\\Model\n     */\n    public function create(array $attributes) {\n        return $this->model->create($attributes);\n    }\n\n    /*!\n     * \\fn      destroy\n     *\n     * \\return  int\n     */\n    public function destroy($ids) {\n        return $this->model->destroy($ids);\n    }\n\n    /*!\n     * \\fn      find\n     *\n     * \\return  mixed\n     */\n    public function find($id, $columns = ['*']) {\n        return $this->model->find($id, $columns);\n    }\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Laravel abstract Repository",
        "matches": [
          "l_ar"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "<?php\n\n/*!\n * \\namespace   $1\n * \\class       $3\n * \\implements  $4\n *\n * \\author      ${5:`!v g:snips_author`}\n * \\date        `!v strftime('%d-%m-%y')`\n */\n\nnamespace ${1:Repositories\\\\$2};\n\nclass ${3:`!v expand('%:t:r')`} extends \\\\$6 implements ${4:$3RepositoryInterface} {\n    $7\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Laravel Repository",
        "matches": [
          "l_r"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "<?php\n\n/*!\n * \\namespace   $1\n * \\class       $2\n *\n * \\author      ${6:`!v g:snips_author`}\n * \\date        `!v strftime('%d-%m-%y')`\n */\n\nnamespace Services\\\\$1;\n\nuse ${3:Repositories\\\\${4:Interface}};\n\nclass ${2:`!v expand('%:t:r')`} {\n    protected $${5:repo};\n    \n    /*!\n     * \\fn      __construct\n     */\n    public function __construct($4 $repo) {\n        $this->$5 = $repo;\n    }\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Laravel Service",
        "matches": [
          "l_s"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "<?php\n\n/*!\n * \\namespace   $1\n * \\class       $2\n *\n * \\author      ${5:`!v g:snips_author`}\n * \\date        `!v strftime('%d-%m-%y')`\n */\n\nnamespace ${1:Services};\n\nuse \\Illuminate\\Support\\Facades\\Facade;\n\nclass ${2:`!v expand('%:t:r')`} extends Facade {\n    /*!\n     * \\fn          getFacadeAccessor\n     *\n     * \\return      string\n     */\n    protected static function getFacadeAccessor() { return '${4:$3Service}'; }\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Laravel Facade",
        "matches": [
          "l_f"
        ],
        "opts": [
          "b"
        ]
      }
    ],
    "php-phpspec": [
      {
        "content": "<?php\n\nnamespace `!p\nrelpath = os.path.relpath(path)\nm = re.search(r'[A-Z].+(?=/)', relpath)\nif m:\n\tsnip.rv = m.group().replace('/', '\\\\')\n`;\n\nuse PhpSpec\\ObjectBehavior;\nuse Prophecy\\Argument;\n\n/**\n * @author `!v g:snips_author`\n */\nclass `!p\nsnip.rv = re.match(r'.*(?=\\.)', fn).group()\n` extends ObjectBehavior\n{\n\tfunction it_$1()\n\t{\n\t\t${0:${VISUAL}}\n\t}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "class XYZSpec extends ObjectBehaviour",
        "matches": [
          "spec"
        ],
        "opts": []
      },
      {
        "content": "function it_$1()\n{\n\t${0:${VISUAL}}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "function it_does_something() { ... }",
        "matches": [
          "it"
        ],
        "opts": []
      },
      {
        "content": "function let()\n{\n\t${0:${VISUAL}}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "function let() { ... }",
        "matches": [
          "let"
        ],
        "opts": []
      },
      {
        "content": "function letgo()\n{\n\t${0:${VISUAL}}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "function letgo() { ... }",
        "matches": [
          "letgo"
        ],
        "opts": []
      },
      {
        "content": "$this->beConstructedWith($1);",
        "doc": null,
        "grammar": "snu",
        "label": "$this->beConstructedWith($arg)",
        "matches": [
          "cw"
        ],
        "opts": []
      },
      {
        "content": "$this->beConstructedThrough(${1:'methodName'}, [${2:'$arg'}]);",
        "doc": null,
        "grammar": "snu",
        "label": "$this->beConstructedThrough($methodName, [$arg])",
        "matches": [
          "ct"
        ],
        "opts": []
      },
      {
        "content": "$this->${1:method}()->shouldReturn(${2:'value'});",
        "doc": null,
        "grammar": "snu",
        "label": "$this->XYZ()->shouldReturn('value')",
        "matches": [
          "sreturn"
        ],
        "opts": []
      },
      {
        "content": "$this->${1:method}()->shouldNotReturn(${2:'value'});",
        "doc": null,
        "grammar": "snu",
        "label": "$this->XYZ()->shouldNotReturn('value')",
        "matches": [
          "snreturn"
        ],
        "opts": []
      },
      {
        "content": "$this->${1:method}()->shouldBe(${2:'value'});",
        "doc": null,
        "grammar": "snu",
        "label": "$this->XYZ()->shouldBe('value')",
        "matches": [
          "sbe"
        ],
        "opts": []
      },
      {
        "content": "$this->${1:method}()->shouldNotBe(${2:'value'});",
        "doc": null,
        "grammar": "snu",
        "label": "$this->XYZ()->shouldNotBe('value')",
        "matches": [
          "snbe"
        ],
        "opts": []
      },
      {
        "content": "$this->${1:method}()->shouldEqual(${2:'value'});",
        "doc": null,
        "grammar": "snu",
        "label": "$this->XYZ()->shouldEqual('value')",
        "matches": [
          "sequal"
        ],
        "opts": []
      },
      {
        "content": "$this->${1:method}()->shouldNotEqual(${2:'value'});",
        "doc": null,
        "grammar": "snu",
        "label": "$this->XYZ()->shouldNotEqual('value')",
        "matches": [
          "snequal"
        ],
        "opts": []
      },
      {
        "content": "$this->${1:method}()->shouldBeEqualTo(${2:'value'});",
        "doc": null,
        "grammar": "snu",
        "label": "$this->XYZ()->shouldBeEqualTo('value')",
        "matches": [
          "sbequalto"
        ],
        "opts": []
      },
      {
        "content": "$this->${1:method}()->shouldNotBeEqualTo(${2:'value'});",
        "doc": null,
        "grammar": "snu",
        "label": "$this->XYZ()->shouldNotBeEqualTo('value')",
        "matches": [
          "snbequalto"
        ],
        "opts": []
      },
      {
        "content": "$this->${1:method}()->shouldBeLike(${2:'value'});",
        "doc": null,
        "grammar": "snu",
        "label": "$this->XYZ()->shouldBeLike('value')",
        "matches": [
          "sblike"
        ],
        "opts": []
      },
      {
        "content": "$this->${1:method}()->shouldNotBeLike(${2:'value'});",
        "doc": null,
        "grammar": "snu",
        "label": "$this->XYZ()->shouldNotBeLike('value')",
        "matches": [
          "snblike"
        ],
        "opts": []
      },
      {
        "content": "$this->shouldThrow(${1:'\\Exception'})->during${2:Method}(${3:'$arg'});",
        "doc": null,
        "grammar": "snu",
        "label": "$this->shouldThrow('\\Exception')->duringXYZ($arg)",
        "matches": [
          "sthrowm"
        ],
        "opts": []
      },
      {
        "content": "$this->shouldThrow(${1:'\\Exception'})->duringInstantiation();",
        "doc": null,
        "grammar": "snu",
        "label": "$this->shouldThrow('\\Exception')->duringInstantiation()",
        "matches": [
          "sthrowi"
        ],
        "opts": []
      },
      {
        "content": "$this->shouldHaveType($1);",
        "doc": null,
        "grammar": "snu",
        "label": "$this->shouldHaveType('Type')",
        "matches": [
          "stype"
        ],
        "opts": []
      },
      {
        "content": "$this->shouldNotHaveType($1);",
        "doc": null,
        "grammar": "snu",
        "label": "$this->shouldNotHaveType('Type')",
        "matches": [
          "sntype"
        ],
        "opts": []
      },
      {
        "content": "$this->shouldReturnAnInstanceOf($1);",
        "doc": null,
        "grammar": "snu",
        "label": "$this->shouldReturnAnInstanceOf('Type')",
        "matches": [
          "srinstance"
        ],
        "opts": []
      },
      {
        "content": "$this->shouldNotReturnAnInstanceOf($1);",
        "doc": null,
        "grammar": "snu",
        "label": "$this->shouldNotReturnAnInstanceOf('Type')",
        "matches": [
          "snrinstance"
        ],
        "opts": []
      },
      {
        "content": "$this->shouldBeAnInstanceOf($1);",
        "doc": null,
        "grammar": "snu",
        "label": "$this->shouldBeAnInstanceOf('Type')",
        "matches": [
          "sbinstance"
        ],
        "opts": []
      },
      {
        "content": "$this->shouldNotBeAnInstanceOf($1);",
        "doc": null,
        "grammar": "snu",
        "label": "$this->shouldNotBeAnInstanceOf('Type')",
        "matches": [
          "snbinstance"
        ],
        "opts": []
      },
      {
        "content": "$this->shouldImplement($1);",
        "doc": null,
        "grammar": "snu",
        "label": "$this->shouldImplement('Type')",
        "matches": [
          "simplement"
        ],
        "opts": []
      },
      {
        "content": "$this->shouldNotImplement($1);",
        "doc": null,
        "grammar": "snu",
        "label": "$this->shouldNotImplement('Type')",
        "matches": [
          "snimplement"
        ],
        "opts": []
      },
      {
        "content": "$this->shouldBe$1();",
        "doc": null,
        "grammar": "snu",
        "label": "$this->shouldBeXYZ()",
        "matches": [
          "sbstate"
        ],
        "opts": []
      },
      {
        "content": "$this->shouldNotBe$1();",
        "doc": null,
        "grammar": "snu",
        "label": "$this->shouldNotBeXYZ()",
        "matches": [
          "snbstate"
        ],
        "opts": []
      },
      {
        "content": "$this->${1:method}()->shouldHaveCount(${2:7});",
        "doc": null,
        "grammar": "snu",
        "label": "$this->XYZ()->shouldHaveCount(7)",
        "matches": [
          "scount"
        ],
        "opts": []
      },
      {
        "content": "$this->${1:method}()->shouldNotHaveCount(${2:7});",
        "doc": null,
        "grammar": "snu",
        "label": "$this->XYZ()->shouldNotHaveCount(7)",
        "matches": [
          "sncount"
        ],
        "opts": []
      },
      {
        "content": "$this->${1:method}()->shouldBe${2:String|Array|Bool}();",
        "doc": null,
        "grammar": "snu",
        "label": "$this->XYZ()->shouldBeString|Array|Bool()",
        "matches": [
          "sbscalar"
        ],
        "opts": []
      },
      {
        "content": "$this->${1:method}()->shouldNotBe${2:String|Array|Bool}();",
        "doc": null,
        "grammar": "snu",
        "label": "$this->XYZ()->shouldNotBeString|Array|Bool()",
        "matches": [
          "snbscalar"
        ],
        "opts": []
      },
      {
        "content": "$this->${1:method}()->shouldContain(${2:'value'});",
        "doc": null,
        "grammar": "snu",
        "label": "$this->XYZ()->shouldContain('value')",
        "matches": [
          "scontain"
        ],
        "opts": []
      },
      {
        "content": "$this->${1:method}()->shouldNotContain(${2:'value'});",
        "doc": null,
        "grammar": "snu",
        "label": "$this->XYZ()->shouldNotContain('value')",
        "matches": [
          "sncontain"
        ],
        "opts": []
      },
      {
        "content": "$this->${1:method}()->shouldHaveKey(${2:'key'});",
        "doc": null,
        "grammar": "snu",
        "label": "$this->XYZ()->shouldHaveKey('key')",
        "matches": [
          "skey"
        ],
        "opts": []
      },
      {
        "content": "$this->${1:method}()->shouldNotHaveKey(${2:'key'});",
        "doc": null,
        "grammar": "snu",
        "label": "$this->XYZ()->shouldNotHaveKey('key')",
        "matches": [
          "snkey"
        ],
        "opts": []
      },
      {
        "content": "$this->${1:method}()->shouldHaveKeyWithValue(${2:'key'}, ${3:'value'});",
        "doc": null,
        "grammar": "snu",
        "label": "$this->XYZ()->shouldHaveKeyWithValue('key', 'value')",
        "matches": [
          "skeyvalue"
        ],
        "opts": []
      },
      {
        "content": "$this->${1:method}()->shouldNotHaveKeyWithValue(${2:'key'}, ${3:'value'});",
        "doc": null,
        "grammar": "snu",
        "label": "$this->XYZ()->shouldNotHaveKeyWithValue('key', 'value')",
        "matches": [
          "snkeyvalue"
        ],
        "opts": []
      },
      {
        "content": "$this->${1:method}()->shouldStartWith(${2:'string'});",
        "doc": null,
        "grammar": "snu",
        "label": "$this->XYZ()->shouldStartWith('string')",
        "matches": [
          "sstart"
        ],
        "opts": []
      },
      {
        "content": "$this->${1:method}()->shouldNotStartWith(${2:'string'});",
        "doc": null,
        "grammar": "snu",
        "label": "$this->XYZ()->shouldNotStartWith('string')",
        "matches": [
          "snstart"
        ],
        "opts": []
      },
      {
        "content": "$this->${1:method}()->shouldEndWith(${2:'string'});",
        "doc": null,
        "grammar": "snu",
        "label": "$this->XYZ()->shouldEndWith('string')",
        "matches": [
          "send"
        ],
        "opts": []
      },
      {
        "content": "$this->${1:method}()->shouldNotEndWith(${2:'string'});",
        "doc": null,
        "grammar": "snu",
        "label": "$this->XYZ()->shouldNotEndWith('string')",
        "matches": [
          "snend"
        ],
        "opts": []
      },
      {
        "content": "$this->${1:method}()->shouldMatch(${2:'/wizard/i'});",
        "doc": null,
        "grammar": "snu",
        "label": "$this->XYZ()->shouldMatch('/wizard/i')",
        "matches": [
          "smatch"
        ],
        "opts": []
      },
      {
        "content": "$this->${1:method}()->shouldNotMatch(${2:'/wizard/i'});",
        "doc": null,
        "grammar": "snu",
        "label": "$this->XYZ()->shouldNotMatch('/wizard/i')",
        "matches": [
          "snmatch"
        ],
        "opts": []
      }
    ],
    "php-symfony2": [
      {
        "content": "<?php\n\nnamespace `!p\nrelpath = os.path.relpath(path)\nm = re.search(r'[A-Z].+(?=/)', relpath)\nif m:\n\tsnip.rv = m.group().replace('/', '\\\\')\n`;\n\n/**\n * ${1:@author `!v g:snips_author`}\n */\nclass `!p\nsnip.rv = re.match(r'.*(?=\\.)', fn).group()\n`$2\n{\n    public function __construct(${3:$options})\n    {\n        ${4:// code}\n    }$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Basic class with namespace snippet",
        "matches": [
          "classn"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "<?php\n\nnamespace `!p\nrelpath = os.path.relpath(path)\nm = re.search(r'[A-Z].+(?=/)', relpath)\nif m:\n\tsnip.rv = m.group().replace('/', '\\\\')\n`;\n\nuse Sensio\\Bundle\\FrameworkExtraBundle\\Configuration\\Method;\nuse Sensio\\Bundle\\FrameworkExtraBundle\\Configuration\\Route;\nuse Sensio\\Bundle\\FrameworkExtraBundle\\Configuration\\Template;\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller;\nuse Symfony\\Component\\HttpFoundation\\Request;\n\n/**\n * ${1:@author `!v g:snips_author`}\n */\nclass `!p\nsnip.rv = re.match(r'.*(?=\\.)', fn).group()\n` extends Controller\n{\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Symfony2 controller",
        "matches": [
          "contr"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "/**\n* @Route(\"/${1:route_name}\", name=\"$1\")\n* @Template()\n*/\npublic function $1Action($2)\n{\n\t$3\n\treturn ${4:[];}$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Symfony 2 Controller action",
        "matches": [
          "sfa"
        ],
        "opts": []
      },
      {
        "content": "/**\n * @Route(\"$3\", name=\"$4\")\n * @Method({${5:\"POST\"}})\n * @Template()\n */\npublic function $1Action($2)\n{\n\t$6\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Symfony2 action",
        "matches": [
          "act"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "/**\n * @Route(\"$3\", name=\"$4\")\n * @Method({${5:\"GET\"}})\n * @Template()\n */\npublic function $1Action($2)\n{\n\t$6\n\treturn [];\n}`!p\nrelpath = os.path.relpath(path)`",
        "doc": null,
        "grammar": "snu",
        "label": "Symfony2 action and template",
        "matches": [
          "actt"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "<?php\n\nnamespace `!p\nrelpath = os.path.relpath(path)\nm = re.search(r'[A-Z].+(?=/)', relpath)\nif m:\n\tsnip.rv = m.group().replace('/', '\\\\')\n`;\n\nuse Symfony\\Bundle\\FrameworkBundle\\Command\\ContainerAwareCommand;\nuse Symfony\\Component\\Console\\Input\\InputArgument;\nuse Symfony\\Component\\Console\\Input\\InputOption;\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\n\n/**\n * ${3:@author `!v g:snips_author`}\n */\nclass `!p\nsnip.rv = re.match(r'.*(?=\\.)', fn).group()\n` extends ContainerAwareCommand\n{\n\tprotected function configure()\n\t{\n\t\t$this->setName('$1')\n\t\t\t->setDescription('$2')\n\t\t\t->setDefinition([\n\t\t\t\tnew InputArgument('', InputArgument::REQUIRED, ''),\n\t\t\t\tnew InputOption('', null, InputOption::VALUE_NONE, ''),\n\t\t\t]);\n\t}\n\n\tprotected function execute(InputInterface $input, OutputInterface $output)\n\t{\n\t}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Symfony2 command",
        "matches": [
          "comm"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "<?php\n\nnamespace `!p\nrelpath = os.path.relpath(path)\nm = re.search(r'[A-Z].+(?=/)', relpath)\nif m:\n\tsnip.rv = m.group().replace('/', '\\\\')\n`;\n\nuse Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\n\n/**\n * ${1:@author `!v g:snips_author`}\n */\nclass `!p\nsnip.rv = re.match(r'.*(?=\\.)', fn).group()\n` implements EventSubscriberInterface\n{\n\tpublic function __construct()\n\t{\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tpublic static function getSubscribedEvents()\n\t{\n\t\treturn [];\n\t}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Symfony2 subscriber",
        "matches": [
          "subs"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "<?php\n\nnamespace `!p\nrelpath = os.path.relpath(path)\nm = re.search(r'[A-Z].+(?=/)', relpath)\nif m:\n\tsnip.rv = m.group().replace('/', '\\\\')\n`;\n\nuse Symfony\\Component\\Form\\DataTransformerInterface;\nuse Symfony\\Component\\Form\\Exception\\TransformationFailedException;\n\n/**\n * ${3:@author `!v g:snips_author`}\n */\nclass `!p\nsnip.rv = re.match(r'.*(?=\\.)', fn).group()\n` implements DataTransformerInterface\n{\n\t/**\n\t * {@inheritDoc}\n\t */\n\tpublic function transform($1)\n\t{\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tpublic function reverseTransform($2)\n\t{\n\t}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Symfony2 form data transformer",
        "matches": [
          "transf"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "<?php\n\nnamespace `!p\nrelpath = os.path.relpath(path)\nm = re.search(r'[A-Z].+(?=/)', relpath)\nif m:\n\tsnip.rv = m.group().replace('/', '\\\\')\n`;\n\nuse Doctrine\\ORM\\Mapping as ORM;\n\n/**\n * ${3:@author `!v g:snips_author`}\n *\n * @ORM\\Entity()\n * @ORM\\Table(name=\"`!p\ntmp = re.match(r'.*(?=\\.)', fn).group()\ntmp = re.sub(r'\\B([A-Z])', r'_\\1', tmp)\nsnip.rv = tmp.lower()\n`\")\n */\n`!p\nm = re.search(r'Abstract', path)\nif m:\n\tsnip.rv = 'abstract '\n`class `!p\nsnip.rv = re.match(r'.*(?=\\.)', fn).group()\n`\n{\n\t/**\n\t * @ORM\\Column(type=\"integer\")\n\t * @ORM\\GeneratedValue\n\t * @ORM\\Id\n\t */\n\tprivate $id;\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Symfony2 doctrine entity",
        "matches": [
          "ent"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "<?php\n\nnamespace `!p\nrelpath = os.path.relpath(path)\nm = re.search(r'[A-Z].+(?=/)', relpath)\nif m:\n\tsnip.rv = m.group().replace('/', '\\\\')\n`;\n\nuse Symfony\\Component\\Form\\AbstractType;\nuse Symfony\\Component\\Form\\FormBuilderInterface;\nuse Symfony\\Component\\OptionsResolver\\OptionsResolverInterface;\n\n/**\n * ${2:@author `!v g:snips_author`}\n */\nclass `!p\nsnip.rv = re.match(r'.*(?=\\.)', fn).group()\n` extends AbstractType\n{\n\t/**\n\t * {@inheritDoc}\n\t */\n\tpublic function buildForm(FormBuilderInterface $builder, array $options)\n\t{\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tpublic function setDefaultOptions(OptionsResolverInterface $resolver)\n\t{\n\t\t$resolver->setDefaults();\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tpublic function getName()\n\t{\n\t\treturn '$1';\n\t}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Symfony2 form type",
        "matches": [
          "form"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "<?php\n\nnamespace `!p\nrelpath = os.path.relpath(path)\nm = re.search(r'[A-Z].+(?=/)', relpath)\nif m:\n\tsnip.rv = m.group().replace('/', '\\\\')\n`;\n\nuse Symfony\\Component\\EventDispatcher\\Event;\n\n/**\n * ${2:@author `!v g:snips_author`}\n */\nclass `!p\nsnip.rv = re.match(r'.*(?=\\.)', fn).group()\n` extends Event\n{\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Symfony2 event",
        "matches": [
          "ev"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "$this->redirect($this->generateUrl('$1', $2));",
        "doc": null,
        "grammar": "snu",
        "label": "Symfony2 redirect",
        "matches": [
          "redir"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "use Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller;$1",
        "doc": null,
        "grammar": "snu",
        "label": "Symfony2 use Symfony\\..\\Controller",
        "matches": [
          "usecontroller"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "use Symfony\\Component\\HttpFoundation\\Request;$1",
        "doc": null,
        "grammar": "snu",
        "label": "Symfony2 use Symfony\\..\\Request",
        "matches": [
          "usereauest"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "use Sensio\\Bundle\\FrameworkExtraBundle\\Configuration\\Route;$1",
        "doc": null,
        "grammar": "snu",
        "label": "Symfony2 use Sensio\\..\\Route",
        "matches": [
          "useroute"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "use Symfony\\Component\\HttpFoundation\\Response;$1",
        "doc": null,
        "grammar": "snu",
        "label": "Symfony2 use Symfony\\..\\Response",
        "matches": [
          "useresponse"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "use Symfony\\Component\\HttpFoundation\\File\\UploadedFile;$1",
        "doc": null,
        "grammar": "snu",
        "label": "Symfony2 use Symfony\\..\\File",
        "matches": [
          "usefile"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "use Symfony\\Component\\Validator\\Constraints as Assert;$1",
        "doc": null,
        "grammar": "snu",
        "label": "Symfony2 use Symfony\\..\\Constraints as Assert",
        "matches": [
          "useassert"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "use Sensio\\Bundle\\FrameworkExtraBundle\\Configuration\\Template;$1",
        "doc": null,
        "grammar": "snu",
        "label": "Symfony2 use Sensio\\..\\Template",
        "matches": [
          "usetemplate"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "use Sensio\\Bundle\\FrameworkExtraBundle\\Configuration\\Cache;$1",
        "doc": null,
        "grammar": "snu",
        "label": "Symfony2 use Sensio\\..\\Cache",
        "matches": [
          "usecache"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "use Sensio\\Bundle\\FrameworkExtraBundle\\Configuration\\Method;$1",
        "doc": null,
        "grammar": "snu",
        "label": "Symfony2 use Sensio\\..\\Method",
        "matches": [
          "usemethod"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "use Doctrine\\Common\\Collections\\ArrayCollection;$1",
        "doc": null,
        "grammar": "snu",
        "label": "Symfony2 use Doctrine\\..\\ArrayCollection",
        "matches": [
          "usearray"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "use Doctrine\\ORM\\Mapping as ORM;$1",
        "doc": null,
        "grammar": "snu",
        "label": "Symfony2 use Doctrine\\..\\Mapping as ORM",
        "matches": [
          "useorm"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "use JMS\\SecurityExtraBundle\\Annotation\\Secure;$1",
        "doc": null,
        "grammar": "snu",
        "label": "Symfony2 use JMS\\..\\Secure",
        "matches": [
          "usesecure"
        ],
        "opts": [
          "b"
        ]
      }
    ],
    "plsql": [
      {
        "content": "create or replace package ${1:name}\nas\n\t${0:-- spec}\nend; -- end of package spec $1",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ps"
        ],
        "opts": []
      },
      {
        "content": "create or replace package body ${1:name}\nas\n\t${0:-- body}\nend; -- end of package body $1;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pb"
        ],
        "opts": []
      },
      {
        "content": "procedure ${1:name}(${0:args});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pps"
        ],
        "opts": []
      },
      {
        "content": "procedure ${1:name}(${2:args})\nas\nbegin\n\t${0:-- body}\nend $2;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ppb"
        ],
        "opts": []
      },
      {
        "content": "function ${1:name}(${2:args})\n  return ${0:type};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pfs"
        ],
        "opts": []
      },
      {
        "content": "function ${1:name}(${2:args})\n  return ${3:type}\nas\n\tl_res\t$3;\nbegin\n\t${0:-- body};\n\treturn l_res;\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pfb"
        ],
        "opts": []
      },
      {
        "content": "show errors;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "err"
        ],
        "opts": []
      },
      {
        "content": "${1:name} ${2:in} ${3:type} ${0: := null}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p"
        ],
        "opts": []
      },
      {
        "content": "type tr_${1:name} is record (${0:/* columns */});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tr"
        ],
        "opts": []
      },
      {
        "content": "type tt_${1:name} is table of tr_${0:name};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tt"
        ],
        "opts": []
      },
      {
        "content": "type tt_${1:name} is table of tr_${0:name} index by binary_integer;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tti"
        ],
        "opts": []
      },
      {
        "content": "/*\n *\t${0: comment ...}\n */",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doc"
        ],
        "opts": []
      },
      {
        "content": "begin\n\t${0}\nend;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "beg"
        ],
        "opts": []
      },
      {
        "content": "declare\n\t${1}\nbegin\n\t${0}\nend;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dec"
        ],
        "opts": []
      },
      {
        "content": "for ${1:i} in 1 .. ${0:l_res}.count loop\n\tpipe row( $2($1) );\nend loop;\nreturn;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rpipe"
        ],
        "opts": []
      },
      {
        "content": "bulk collect into ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bc"
        ],
        "opts": []
      },
      {
        "content": "l_${1}\t\t${0:number};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "l"
        ],
        "opts": []
      },
      {
        "content": "dbms_output.put_line('${0}');",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "log"
        ],
        "opts": []
      },
      {
        "content": "for ${1:i} in ${2:1}..${3:42} loop\n\t${0}\nend loop;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "for ${1:rec} in (${2: select}) loop\n\t${0}\nend loop;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fors"
        ],
        "opts": []
      },
      {
        "content": "for ${1:i} in ${2:l_var}.first .. $2.last loop\n\t${0: -- dbms_output.put_line($2($1)); }\nend loop;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forc"
        ],
        "opts": []
      },
      {
        "content": "if ${1} then\n\t${0}\nend if;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "if ${1} then\n\t${2}\nelse\n\t${0}\nend if;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife"
        ],
        "opts": []
      }
    ],
    "po": [
      {
        "content": "msgid \"${1}\"\nmsgstr \"${2}\"\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "msg"
        ],
        "opts": []
      }
    ],
    "processing": [
      {
        "content": "/**\n *  ${1:Description}\n *\n *\t@author ${2:name}\n *\t@since  ${3:`strftime(\"%d/%m/%y %H:%M:%S\")`}\n */\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doc"
        ],
        "opts": []
      },
      {
        "content": "/**\n *\t${1:@private}$0\n */\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "docc"
        ],
        "opts": []
      },
      {
        "content": "${1:public }class ${2:`fnamemodify(bufname(\"%\"),\":t:r\")`} ${3:extends}\n{\n\t//--------------------------------------\n\t//  CONSTRUCTOR\n\t//--------------------------------------\n\tpublic $2 (${4:arguments}) {\n\t\t${0:// expression}\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "class"
        ],
        "opts": []
      },
      {
        "content": "/**\n *  ${1:Description}\n *\n *\t@author ${2:$TM_FULLNAME}\n *\t@since  ${3:`strftime(\"%d/%m/%y %H:%M:%S\")`}\n */\npackage ${0:package};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "package"
        ],
        "opts": []
      },
      {
        "content": "${1:void/private/protected/public}${2: static} ${3:name}(${4}) {\n\t${5://if not void return null;}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fun"
        ],
        "opts": []
      },
      {
        "content": "${1:void }${2:name}(${3}) {\n\t${4://if not void return null;}\n}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fn"
        ],
        "opts": []
      },
      {
        "content": "static final ${1:Object} ${2:VAR_NAM} = ${0};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "const"
        ],
        "opts": []
      },
      {
        "content": "${1:private/public }${2:static }${3:String} ${4:str}${5: =}${0:value};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "var"
        ],
        "opts": []
      },
      {
        "content": "${1:private/public }${2:Object} ${3:o}${4: = new }$2(${0});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "obj"
        ],
        "opts": []
      },
      {
        "content": "for (int ${2:i} = 0; $2 < ${1:Things}.length; $2${3:++}) {\n\t${0:$1[$2]}\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "while (${1:/* condition */}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh"
        ],
        "opts": []
      },
      {
        "content": "break ${1:label};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "break"
        ],
        "opts": []
      },
      {
        "content": "case ${1:expression} :\n\t${0}\nbreak;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case"
        ],
        "opts": []
      },
      {
        "content": "default :\n\t${1}\nbreak;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "default"
        ],
        "opts": []
      },
      {
        "content": "switch(${1:expression}) {\n\tcase '${3:case}':\n\t\t${4}\n\t\tbreak;\n\t${0}\n\tdefault:\n\t\t${2}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "switch"
        ],
        "opts": []
      },
      {
        "content": "try {\n\t${0:${VISUAL}}\n} catch(${1:Exception} ${2:e}) {\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "try"
        ],
        "opts": []
      },
      {
        "content": "try {\n\t${0:${VISUAL}}\n} catch(${1:Exception} ${2:e}) {\n} finally {\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tryf"
        ],
        "opts": []
      },
      {
        "content": "throw new (\"${1:Exception()}\");",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "throw"
        ],
        "opts": []
      },
      {
        "content": "? ${1:trueExpression} : ${2:falseExpression}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "?"
        ],
        "opts": []
      },
      {
        "content": "if (${1:true}) {${0}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "if (${1:true}) {${2}}\nelse{${0}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "public ${1:String} get${2}() {\n\treturn ${0:fieldName};\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "get"
        ],
        "opts": []
      },
      {
        "content": "public void set${1}(${0:String} new${1}) {\n\t${1:fieldName} = new${1};\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "set"
        ],
        "opts": []
      },
      {
        "content": "println(\"${1:`fnamemodify(bufname(\"%\"),\":t:r\")`}::${2:method}() \"${3: +} ${0});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "println"
        ],
        "opts": []
      },
      {
        "content": "println(\"${0}\");",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pr"
        ],
        "opts": []
      },
      {
        "content": "void setup(){\n\t${1}\n}\nvoid draw(){\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "setup"
        ],
        "opts": []
      },
      {
        "content": "import processing.opengl.*;\nimport javax.media.opengl.*;\nPGraphicsOpenGL pgl;\nGL gl;\nvoid setup(){\n\tsize( ${1:300}, ${2:300}, OPENGL );\n\tcolorMode( RGB, 1.0 );\n\thint( ENABLE_OPENGL_4X_SMOOTH );\n\tpgl = (PGraphicsOpenGL) g;\n\tgl = pgl.gl;\n\tgl.setSwapInterval(1);\n\tinitGL();\n\t${3}\n}\nvoid draw(){\n\tpgl.beginGL();\n\t\t${4}\n\tpgl.endGL();\n\tgetOpenGLErrors();\n}\nvoid initGL(){\n\t${0}\n}\nvoid getOpenGLErrors(){\n\tint error = gl.glGetError();\n\tswitch (error){\n\t\tcase 1280 :\n\t\t\tprintln(\"GL_INVALID_ENUM - An invalid enumerant was passed to an OpenGL command.\");\n\t\tbreak;\n\t\tcase 1282 :\n\t\t\tprintln(\"GL_INVALID_OPERATION - An OpenGL command was issued that was invalid or inappropriate for the current state.\");\n\t\tbreak;\n\t\tcase 1281 :\n\t\t\tprintln(\"GL_INVALID_VALUE - A value was passed to OpenGL that was outside the allowed range.\");\n\t\tbreak;\n\t\tcase 1285 :\n\t\t\tprintln(\"GL_OUT_OF_MEMORY - OpenGL was unable to allocate enough memory to process a command.\");\n\t\tbreak;\n\t\tcase 1283 :\n\t\t\tprintln(\"GL_STACK_OVERFLOW - A command caused an OpenGL stack to overflow.\");\n\t\tbreak;\n\t\tcase 1284 :\n\t\t\tprintln(\"GL_STACK_UNDERFLOW - A command caused an OpenGL stack to underflow.\");\n\t\tbreak;\n\t\tcase 32817 :\n\t\t\tprintln(\"GL_TABLE_TOO_LARGE\");\n\t\tbreak;\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "opengl"
        ],
        "opts": []
      },
      {
        "content": "pgl.beginGL();\n\t${0}\npgl.endGL();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gl begin gl"
        ],
        "opts": []
      },
      {
        "content": "// specify the minimum swap interval for buffer swaps.\ngl.setSwapInterval(${0:interval});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gl gl swap interval"
        ],
        "opts": []
      },
      {
        "content": "// execute a display list\ngl.glCallList(${0:list});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gl gl call list"
        ],
        "opts": []
      },
      {
        "content": "// import java.nio.IntBuffer;\n// import java.nio.FloatBuffer;\n// import com.sun.opengl.util.BufferUtil;\n// You might need to create four buffers to store vertext data, normal data, texture coordinate data, and indices in vertex arrays\nIntBuffer bufferObjects = IntBuffer.allocate(${1:4});\ngl.glGenBuffers($1, bufferObjects);\nint vertexCount = ${2:3};\nint numCoordinates = ${0:3};\n// vertexCount * numCoordinates\nFloatBuffer vertices = BufferUtil.newFloatBuffer(vertexCount * numCoordinates);\nfloat[] v = {0.0f, 0.0f, 0.0f,\n\t\t\t\t\t\t 1.0f, 0.0f, 0.0f,\n\t\t\t\t\t\t 0.0f, 1.0f, 1.0f};\nvertices.put(v);\n// Bind the first buffer object ID for use with vertext array data\ngl.glBindBuffer(GL.GL_ARRAY_BUFFER, bufferObjects.get(0));\ngl.glBufferData(GL.GL_ARRAY_BUFFER, vertexCount * numCoordinates * BufferUtil.SIZEOF_FLOAT, vertices, GL.GL_STATIC_DRAW);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gl gl gen buffers"
        ],
        "opts": []
      },
      {
        "content": "${0:// A buffer ID of zero unbinds a buffer object}\ngl.glBindBuffer(GL.GL_ARRAY_BUFFER, ${1:0});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gl gl bind buffer"
        ],
        "opts": []
      },
      {
        "content": "${0:// Parameters are the same for glGenBuffers}\ngl.glDeleteBuffers(${1:4}, ${2:bufferObjects});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gl gl delete buffers"
        ],
        "opts": []
      },
      {
        "content": "// enable or disable writing into the depth buffer\ngl.glDepthMask(${0:flag});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gl gl depth mask"
        ],
        "opts": []
      },
      {
        "content": "// replaces the top of the active matrix stack with the identity matrix\ngl.glLoadIdentity();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gl gl load identity"
        ],
        "opts": []
      },
      {
        "content": "// set the current texture coordinates - 2 floats\ngl.glTexCoord2f(${1:0.0f}, ${0:0.0f});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gl gl tex coord 2f"
        ],
        "opts": []
      },
      {
        "content": "gl.glVertex2f(${1:0.0f}, ${0:0.0f});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gl gl vertex 2f"
        ],
        "opts": []
      },
      {
        "content": "gl.glVertex3f(${1:0.0f}, ${2:0.0f}, ${0:0.0f});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gl gl vertex 3f"
        ],
        "opts": []
      },
      {
        "content": "// multiply the current matrix by a translation matrix\ngl.glTranslatef(${1:x}, ${2:y}, ${0:z});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gl gl translate f"
        ],
        "opts": []
      },
      {
        "content": "// rotate, x-axis, y-axis, z-axiz\ngl.glRotatef(${1:angle}, ${2:x}, ${3:y}, ${0:z});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gl gl rotate f"
        ],
        "opts": []
      },
      {
        "content": "// multiply the current matrix by a general scaling matrix\ngl.glScalef(${1:x}, ${2:y}, ${0:z});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gl gl scale f"
        ],
        "opts": []
      },
      {
        "content": "gl.glColor4f(${1:red}, ${2:green}, ${3:blue}, ${0:alpha});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gl gl color 4f"
        ],
        "opts": []
      },
      {
        "content": "gl.glClearColor(${1:red}, ${2:green}, ${3:blue}, ${0:alpha});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gl gl clear color"
        ],
        "opts": []
      },
      {
        "content": "gl.glColor3f(${1:red}, ${2:green}, ${0:blue});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gl gl color 3f"
        ],
        "opts": []
      },
      {
        "content": "// spush and pop the current matrix stack\ngl.glPushMatrix();\n${0}\ngl.glPopMatrix();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gl gl push matrix"
        ],
        "opts": []
      },
      {
        "content": "gl.glGenLists(${0:1})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gl gl gen lists"
        ],
        "opts": []
      },
      {
        "content": "// Empties buffers. Call this when all previous issues commands completed\ngl.glFlush();\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gl gl flush"
        ],
        "opts": []
      },
      {
        "content": "println(gl.glGetError());",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gl gl get error"
        ],
        "opts": []
      },
      {
        "content": "gl.glClear(${1:GL.GL_COLOR_BUFFER_BIT}${2: | }${0:GL.GL_DEPTH_BUFFER_BIT});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gl gl clear"
        ],
        "opts": []
      },
      {
        "content": "frameRate(${1:30});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "frameRate"
        ],
        "opts": []
      },
      {
        "content": "saveFrame(\"${1:filename-####}${0:.ext}\");",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "saveFrame"
        ],
        "opts": []
      },
      {
        "content": "size(${1:200}, ${2:200}${0:, P3D});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "size normal"
        ],
        "opts": []
      },
      {
        "content": "size(${1:200}, ${2:200}${0:, OPENGL});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "size opengl"
        ],
        "opts": []
      },
      {
        "content": "color ${1:c}${2: = color(}${3:value1, }${4:value2, }${0:value3)};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "color"
        ],
        "opts": []
      },
      {
        "content": "char ${1:m}${2: = \"}${0:char\"};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "char"
        ],
        "opts": []
      },
      {
        "content": "float ${1:f}${2: = }${0:0.0f};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "float"
        ],
        "opts": []
      },
      {
        "content": "int ${1:f}${2: = }${0:0};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "int"
        ],
        "opts": []
      },
      {
        "content": "boolean ${1:b}${2: = }${0:true};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "boolean"
        ],
        "opts": []
      },
      {
        "content": "byte ${1:b}${2: = }${0:127};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "byte"
        ],
        "opts": []
      },
      {
        "content": "String ${1:str}${2: = \"}${0:CCCP\"};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "string"
        ],
        "opts": []
      },
      {
        "content": "${1:int}[] ${2:numbers}${3: = new $1}[${0:length}];",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "array"
        ],
        "opts": []
      },
      {
        "content": "${1:Object} ${2:o}${3: = new $1}(${0});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "object"
        ],
        "opts": []
      },
      {
        "content": "curve(${1:x1}, ${2:y1}, ${3:x2}, ${4:y2}, ${5:x3}, ${6:y3}, ${7:x4}, ${0:y4});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "curve"
        ],
        "opts": []
      },
      {
        "content": "curve(${1:x1}, ${2:y1}, ${3:z1}, ${4:x2}, ${5:y2}, ${6:z2}, ${7:x3}, ${8:y3}, ${9:z3}, ${10:x4}, ${11:y4}, ${0:z4});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "curve 3D"
        ],
        "opts": []
      },
      {
        "content": "curveDetail(${0:detail});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "curveDetail"
        ],
        "opts": []
      },
      {
        "content": "curvePoint(${1:a}, ${2:b}, ${3:c}, ${4:d}, ${0:t});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "curvePoint"
        ],
        "opts": []
      },
      {
        "content": "curveTightness(${0:squishy});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "curveTightness"
        ],
        "opts": []
      },
      {
        "content": "bezier(${1:x1}, ${2:y1}, ${3:cx1}, ${4:cy1}, ${5:cx2}, ${6:cy2}, ${7:x2}, ${0:y2});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bezier"
        ],
        "opts": []
      },
      {
        "content": "bezier(${1:x1}, ${2:y1}, ${3:z1}, ${4:cx1}, ${5:cy1}, ${6:cz1}, ${7:cx2}, ${8:cy2}, ${9:cz2}, ${10:x2}, ${11:y2}, ${0:z2});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bezier 3D"
        ],
        "opts": []
      },
      {
        "content": "bezierDetail(${0:detail});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bezierDetail"
        ],
        "opts": []
      },
      {
        "content": "bezierTangent(${1:a}, ${2:b}, ${3:c}, ${4:d}, ${0:t});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bezierTangent"
        ],
        "opts": []
      },
      {
        "content": "bezierPoint(${1:a}, ${2:b}, ${3:c}, ${4:d}, ${0:t});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bezierPoint"
        ],
        "opts": []
      },
      {
        "content": "vertex(${1:x}, ${2:y}${3:, }${4:u}${5:, }${0:v});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vertex"
        ],
        "opts": []
      },
      {
        "content": "vertex(${1:x}, ${2:y}, ${3:z}${4:, }${5:u}${6:, }${0:v});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vertex 3D"
        ],
        "opts": []
      },
      {
        "content": "bezierVertex(${1:cx1}, ${2:cy1}, ${3:cx2}, ${4:cy2}, ${5:x}, ${0:y});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bezierVertex"
        ],
        "opts": []
      },
      {
        "content": "bezierVertex(${1:cx1}, ${2:cy1}, ${3:cz1}, ${4:cx2}, ${5:cy2}, ${6:cz2}, ${7:x}, ${8:y}, ${0:z});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bezierVertex 3D"
        ],
        "opts": []
      },
      {
        "content": "curveVertex(${1:x}, ${0:y});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "curveVertex"
        ],
        "opts": []
      },
      {
        "content": "curveVertex(${1:x}, ${2:y}, ${0:z});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "curveVertex 3D"
        ],
        "opts": []
      },
      {
        "content": "stroke(${1:value1}, ${2:value2}, ${3:value3}${4:, }${0:alpha});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "stroke"
        ],
        "opts": []
      },
      {
        "content": "strokeWeight(${0:1});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "strokeWeight"
        ],
        "opts": []
      },
      {
        "content": "void mouseDragged(){\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mouseDragged"
        ],
        "opts": []
      },
      {
        "content": "void mouseMoved(){\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mouseMoved"
        ],
        "opts": []
      },
      {
        "content": "void mouseReleased(){\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mouseReleased"
        ],
        "opts": []
      },
      {
        "content": "void mousePressed(){\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mousePressed"
        ],
        "opts": []
      },
      {
        "content": "void keyReleased(){\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "keyReleased"
        ],
        "opts": []
      },
      {
        "content": "void keyTyped(){\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "keyTyped"
        ],
        "opts": []
      },
      {
        "content": "void keyPressed(){\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "keyPressed"
        ],
        "opts": []
      },
      {
        "content": "loadStrings(\"${0:filename}\");",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "loadStrings"
        ],
        "opts": []
      },
      {
        "content": "saveStrings(${1:filename}, ${0:strings});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "saveStrings"
        ],
        "opts": []
      },
      {
        "content": "loadBytes(\"${0:filename}\");",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "loadBytes"
        ],
        "opts": []
      },
      {
        "content": "beginRecord(${1:renderer}, ${0:filename});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "beginRecord"
        ],
        "opts": []
      },
      {
        "content": "saveBytes(${1:filename}, ${0:bytes});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "saveBytes"
        ],
        "opts": []
      },
      {
        "content": "createWriter(${0:filename});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "createWriter"
        ],
        "opts": []
      },
      {
        "content": "createReader(${0:filename});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "createReader"
        ],
        "opts": []
      },
      {
        "content": "pushMatrix();\n${0:};\npopMatrix();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pushMatrix"
        ],
        "opts": []
      },
      {
        "content": "text(${1:data}, ${2:x}, ${3:y}${4:, }${0:z});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "text data"
        ],
        "opts": []
      },
      {
        "content": "text(${1:stringdata}, ${2:x}, ${3:y}, ${4:width}, ${5:height}${6:, }${0:z});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "text stringdata"
        ],
        "opts": []
      },
      {
        "content": "textSize(${0:size});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "textSize"
        ],
        "opts": []
      },
      {
        "content": "textLeading(${0:size});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "textLeading"
        ],
        "opts": []
      },
      {
        "content": "textWidth(${0:data});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "textWidth"
        ],
        "opts": []
      },
      {
        "content": "PFont ${1:font};\n$1 = loadFont(\"${0:FFScala-32.vlw}\");",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "font"
        ],
        "opts": []
      },
      {
        "content": "${1:font} = loadFont(\"${0:FFScala-32.vlw}\");",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "loadFont"
        ],
        "opts": []
      },
      {
        "content": "textFont(${1:font}${2:, }${0:size});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "textFont"
        ],
        "opts": []
      },
      {
        "content": "tan(${0:rad});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tan"
        ],
        "opts": []
      },
      {
        "content": "atan(${0:rad});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "atan"
        ],
        "opts": []
      },
      {
        "content": "atan2(${0:rad});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "atan2"
        ],
        "opts": []
      },
      {
        "content": "sin(${0:rad});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sin"
        ],
        "opts": []
      },
      {
        "content": "asin(${0:rad});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asin"
        ],
        "opts": []
      },
      {
        "content": "cos(${0:rad});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cos"
        ],
        "opts": []
      },
      {
        "content": "acos(${0:rad});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "acos"
        ],
        "opts": []
      },
      {
        "content": "degrees(${0:rad});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "degrees"
        ],
        "opts": []
      },
      {
        "content": "radians(${0:deg});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "radians"
        ],
        "opts": []
      },
      {
        "content": "randomSeed(${0:value});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "randomSseed"
        ],
        "opts": []
      },
      {
        "content": "random(${1:value1}${2:, }${0:value2});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "random"
        ],
        "opts": []
      },
      {
        "content": "pow(${1:num}, ${0:exponent});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pow"
        ],
        "opts": []
      },
      {
        "content": "floor(${0:value});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "floor"
        ],
        "opts": []
      },
      {
        "content": "sqrt(${0:value});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sqrt"
        ],
        "opts": []
      },
      {
        "content": "abs(${0:value});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "abs"
        ],
        "opts": []
      },
      {
        "content": "sq(${0:value});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sq"
        ],
        "opts": []
      },
      {
        "content": "ceil(${0:value});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ceil"
        ],
        "opts": []
      },
      {
        "content": "exp(${0:value});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "exp"
        ],
        "opts": []
      },
      {
        "content": "round(${0:value}};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "round"
        ],
        "opts": []
      },
      {
        "content": "min(${1:value1}, ${2:value2}${3:, }${0:value3});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "min"
        ],
        "opts": []
      },
      {
        "content": "max(${1:value1}, ${2:value2}${3:, }${0:value3});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "max"
        ],
        "opts": []
      },
      {
        "content": "max(${0:array});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "max array"
        ],
        "opts": []
      },
      {
        "content": "min(${0:array});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "min array"
        ],
        "opts": []
      },
      {
        "content": "log(${0:value});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "log"
        ],
        "opts": []
      },
      {
        "content": "map(${1:value}, ${2:low1}, ${4:high1}, ${5:low2}, ${0:high2});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "map"
        ],
        "opts": []
      },
      {
        "content": "norm(${1:value}, ${2:low}, ${0:high});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "norm"
        ],
        "opts": []
      },
      {
        "content": "constrain(${1:value}, ${2:min}, ${0:max});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "constrain"
        ],
        "opts": []
      },
      {
        "content": "mag(${1:a}, ${2:b}${3:, }${0:c});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mag"
        ],
        "opts": []
      },
      {
        "content": "dist(${1:x1}, ${2:y1}, ${4:x2}, ${0:y2});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dist"
        ],
        "opts": []
      },
      {
        "content": "dist(${1:x1}, ${2:y1}, ${3:z1}, ${4:x2}, ${5:y2}, ${0:z2});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dist 3D"
        ],
        "opts": []
      },
      {
        "content": "noise(${1:x}${2:, }${3:y}${4:, }${0:z});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "noise"
        ],
        "opts": []
      },
      {
        "content": "noiseDetail(${1:octaves}${2:, }${0:falloff});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "noiseDetail"
        ],
        "opts": []
      },
      {
        "content": "noiseSeed(${0:x});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "noiseSeed"
        ],
        "opts": []
      },
      {
        "content": "shininess(${0:shine});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "shininess"
        ],
        "opts": []
      },
      {
        "content": "specular(${1:value1}, ${2:value2}, ${3:value3}${4:, }${0:alpha});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "specular"
        ],
        "opts": []
      },
      {
        "content": "ambient(${1:value1}, ${2:value2}, ${0:value3});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ambient"
        ],
        "opts": []
      },
      {
        "content": "emissive(${1:value1}, ${2:value2}, ${0:value3});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "emissive"
        ],
        "opts": []
      },
      {
        "content": "directionalLight(${1:v1}, ${2:v2}, ${3:v3}, ${4:nx}, ${5:ny}, ${0:nz});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "diretionalLight"
        ],
        "opts": []
      },
      {
        "content": "pointLight(${1:v1}, ${2:v2}, ${3:v3}, ${4:nx}, ${5:ny}, ${0:nz});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pointLight"
        ],
        "opts": []
      },
      {
        "content": "lightFalloff(${1:constant}, ${2:linear}, ${0:quadratic});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lightFalloff"
        ],
        "opts": []
      },
      {
        "content": "normal(${1:nx}, ${2:ny}, ${0:nz});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "normal"
        ],
        "opts": []
      },
      {
        "content": "lightSpecular(${1:v1}, ${2:v2}, ${0:v3});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lightSpecular"
        ],
        "opts": []
      },
      {
        "content": "ambientLight(${1:v1}, ${2:v2}, ${3:v3}${7:, ${4:x}, ${5:y}, ${0:z}});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ambientLight"
        ],
        "opts": []
      },
      {
        "content": "spotLight(${1:v1}, ${2:v2}, ${3:v3}, ${4:x}, ${5:y}, ${6:z}, ${7:nx}, ${8:ny}, ${9:nz}, ${10:angle}, ${0:concentration});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "spotLight"
        ],
        "opts": []
      },
      {
        "content": "camera(${1:eyeX}, ${2:eyeY}, ${3:eyeZ}, ${4:centerX}, ${5:centerY}, ${6:centerZ}, ${7:upX}, ${8:upY}, ${0:upZ});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "camera"
        ],
        "opts": []
      },
      {
        "content": "ortho(${1:left}, ${2:right}, ${3:bottom}, ${4:top}, ${5:near}, ${0:far});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ortho"
        ],
        "opts": []
      },
      {
        "content": "perspective(${1:fov}, ${2:aspect}, ${3:zNear}, ${0:zFar});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "perspective"
        ],
        "opts": []
      },
      {
        "content": "frustrum(${1:left}, ${2:right}, ${3:bottom}, ${4:top}, ${5:near}, ${0:far});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "frustrum"
        ],
        "opts": []
      },
      {
        "content": "rotate${1:X}(${0:angle});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rotate"
        ],
        "opts": []
      },
      {
        "content": "translate(${1:x}, ${2:y}${3:, }${0:z});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "translate"
        ],
        "opts": []
      },
      {
        "content": "scale(${0:size});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "scale size"
        ],
        "opts": []
      },
      {
        "content": "scale(${1:x}, ${2:y}${3:, }${0:z});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "scale"
        ],
        "opts": []
      },
      {
        "content": "${1:model/screen}${2:X}(${3:x}, ${4:y}, ${0:z});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "coord"
        ],
        "opts": []
      },
      {
        "content": "brightness(${0:color});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "brightness"
        ],
        "opts": []
      },
      {
        "content": "lerpColor(${1:c1}, ${2:c2}, ${0:amt});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lerpColor"
        ],
        "opts": []
      },
      {
        "content": "saturation(${0:color});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "saturation"
        ],
        "opts": []
      },
      {
        "content": "hue(${0:color});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "hue"
        ],
        "opts": []
      },
      {
        "content": "alpha(${0:color});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "alpha"
        ],
        "opts": []
      },
      {
        "content": "tint(${1:value1}, ${2:value2}, ${3:value3}${4:, }${0:alpha});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tint"
        ],
        "opts": []
      },
      {
        "content": "set(${1:x}, ${2:y}, ${0:color/image});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "set pixel"
        ],
        "opts": []
      },
      {
        "content": "pixels[${0:index}]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pixels"
        ],
        "opts": []
      },
      {
        "content": "get(${1:x}, ${2:y}${3:, }${4:width}${5:, }${0:height});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "get pixel"
        ],
        "opts": []
      },
      {
        "content": "triangle(${1:x1}, ${2:y1}, ${3:x2}, ${4:y2}, ${5:x3}, ${0:y3});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "triangle"
        ],
        "opts": []
      },
      {
        "content": "line(${1:x1}, ${2:y1}, ${3:x2}, ${0:y2});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "line"
        ],
        "opts": []
      },
      {
        "content": "line(${1:x1}, ${2:y1}, ${3:z1}, ${4:x2}, ${5:y2}, ${0:z2});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "line 3D"
        ],
        "opts": []
      },
      {
        "content": "arc(${1:x}, ${2:y}, ${3:width}, ${4:height}, ${5:start}, ${0:stop});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "arc"
        ],
        "opts": []
      },
      {
        "content": "point(${1:x}, ${2:y}${3:, }${0:z});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "point"
        ],
        "opts": []
      },
      {
        "content": "quad(${1:x1}, ${2:y1}, ${3:x2}, ${4:y2}, ${5:x3}, ${6:y3}, ${7:x4}, ${0:y4});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "quad"
        ],
        "opts": []
      },
      {
        "content": "ellipse(${1:x}, ${2:y}, ${3:width}, ${0:height});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ellipse"
        ],
        "opts": []
      },
      {
        "content": "rect(${1:x}, ${2:y}, ${3:width}, ${0:height});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rect"
        ],
        "opts": []
      },
      {
        "content": "box(${1:width}, ${2:height}, ${0:depth});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "box"
        ],
        "opts": []
      },
      {
        "content": "sphere(${0:radius});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sphere"
        ],
        "opts": []
      },
      {
        "content": "sphereDetail(${0:n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sphereDetails"
        ],
        "opts": []
      },
      {
        "content": "split(\"${1:str}\"${2: , }${0:delimiter});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "split"
        ],
        "opts": []
      },
      {
        "content": "splitTokens(${1:str}${2:, }${0:tokens});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "splitTokens"
        ],
        "opts": []
      },
      {
        "content": "join(${1:strgArray}${2: , }${0:seperator});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "join"
        ],
        "opts": []
      },
      {
        "content": "shorten(${0:array});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "shorten"
        ],
        "opts": []
      },
      {
        "content": "concat(${1:array1}, ${0:array2});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "concat"
        ],
        "opts": []
      },
      {
        "content": "subset(${1:array}, ${0:offset});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "subset"
        ],
        "opts": []
      },
      {
        "content": "append(${1:array}, ${0:element});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "append"
        ],
        "opts": []
      },
      {
        "content": "reverse(${0:array});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "reverse"
        ],
        "opts": []
      },
      {
        "content": "splice(${1:array}, ${2:value/array2}, ${0:index});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "splice"
        ],
        "opts": []
      },
      {
        "content": "sort(${1:dataArray}${2:, }${0:count});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sort"
        ],
        "opts": []
      },
      {
        "content": "expand(${1:array}${2:, }${0:newSize});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "expand"
        ],
        "opts": []
      },
      {
        "content": "arrayCopy(${1:src}, ${2:dest}, ${3:, }${0:length});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "arrayCopy"
        ],
        "opts": []
      },
      {
        "content": "str(\"${0:str}\");",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "str"
        ],
        "opts": []
      },
      {
        "content": "match(${1:str}, ${0:regexp});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "match"
        ],
        "opts": []
      },
      {
        "content": "trim(${0:str});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "trim"
        ],
        "opts": []
      },
      {
        "content": "nf(${2:value}, ${3:left}${4:, }${0:right});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nf"
        ],
        "opts": []
      },
      {
        "content": "nfs(${2:value}, ${3:left}${4:, }${0:right});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nfs"
        ],
        "opts": []
      },
      {
        "content": "nfp(${2:value}, ${3:left}${4:, }${0:right});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nfp"
        ],
        "opts": []
      },
      {
        "content": "nfc(${1:value}${2:, }${0:right});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nfc"
        ],
        "opts": []
      },
      {
        "content": "unbinary(\"${0:str}\"});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "unbinary"
        ],
        "opts": []
      },
      {
        "content": "hex(${0:c});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "hexadecimal"
        ],
        "opts": []
      },
      {
        "content": "unhex(${0:c});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "unhex"
        ],
        "opts": []
      },
      {
        "content": "binary(${1:value}${2:, }${0:digits});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "binary"
        ],
        "opts": []
      },
      {
        "content": "loadImage(${0:filename});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "loadImage"
        ],
        "opts": []
      },
      {
        "content": "image(${1:img}, ${2:x}, ${3:y}${4:, }${5:width}${6:, }${0:height});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "image"
        ],
        "opts": []
      },
      {
        "content": "copy(${1:srcImg}${2:, }${3:x}, ${4:y}, ${5:width}, ${6:height}, ${7:dx}, ${8:dy}, ${9:dwidth}, ${0:dheight});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "copy"
        ],
        "opts": []
      },
      {
        "content": "background(${1:value1}, ${2:value2}, ${3:value3}${4:, }${0:alpha});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bg"
        ],
        "opts": []
      },
      {
        "content": "PGraphics pg;\npg = createGraphics(${1:width}, ${2:height}${3:, }${0:applet});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pg"
        ],
        "opts": []
      },
      {
        "content": "PImage(${1:width}, ${0:height});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pimage"
        ],
        "opts": []
      },
      {
        "content": "fill(${1:value1}, ${2:value2}, ${3:value3}${4:, }${0:alpha});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fill"
        ],
        "opts": []
      },
      {
        "content": "red(${0:color});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "red"
        ],
        "opts": []
      },
      {
        "content": "green(${0:color});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "green"
        ],
        "opts": []
      },
      {
        "content": "blue(${0:color});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "blue"
        ],
        "opts": []
      },
      {
        "content": "status(${0:text});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "status"
        ],
        "opts": []
      },
      {
        "content": "param(${0:s});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "param"
        ],
        "opts": []
      },
      {
        "content": "link(${1:url}${2:, }${0:target});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "link"
        ],
        "opts": []
      },
      {
        "content": "@${1:param/return/private/public}  ${1:parameter}  ${0:description}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@"
        ],
        "opts": []
      }
    ],
    "progress": [
      {
        "content": "DEFINE BUFFER b_${1:TableName} FOR $1 ${0}.",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defbuf"
        ],
        "opts": []
      },
      {
        "content": "DEFINE VARIABLE ${1:VariableName} AS ${0}.",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defvar"
        ],
        "opts": []
      },
      {
        "content": "NO-LOCK",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nl"
        ],
        "opts": []
      },
      {
        "content": "NO-ERROR",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ne"
        ],
        "opts": []
      },
      {
        "content": "NO-LOCK NO-ERROR",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nle"
        ],
        "opts": []
      },
      {
        "content": "INITIAL ${0:?}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ini"
        ],
        "opts": []
      },
      {
        "content": "NO-UNDO",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nu"
        ],
        "opts": []
      },
      {
        "content": "ERROR",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "err"
        ],
        "opts": []
      },
      {
        "content": "FIND FIRST ${1:BufferName}\n${2:WHERE $1.${3}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ff"
        ],
        "opts": []
      },
      {
        "content": "DEFINE INPUT PARAMETER ${1:ParamName} AS ${0}.",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "input"
        ],
        "opts": []
      },
      {
        "content": "DEFINE OUTPUT PARAMETER ${1:ParamName} AS ${0:ParamType}.",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "output"
        ],
        "opts": []
      },
      {
        "content": "/******************************************************************************/\nPROCEDURE ${1:ProcName}:\n\t${0}\nEND PROCEDURE. /* $1 */\n/******************************************************************************/",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "proc"
        ],
        "opts": []
      },
      {
        "content": "MESSAGE \"${1:MessageContent}\" ${2:Data} VIEW-AS ALERT-BOX.",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "alert"
        ],
        "opts": []
      },
      {
        "content": "IF ${1:Condition}\nTHEN ${2:Action}\n${3:ELSE ${4:OtherWise}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "DO${1: Clauses}:\n\t${0}\nEND.",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "do"
        ],
        "opts": []
      },
      {
        "content": "INTEGER",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "int"
        ],
        "opts": []
      },
      {
        "content": "CHARACTER",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "char"
        ],
        "opts": []
      },
      {
        "content": "LOGICAL",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "log"
        ],
        "opts": []
      },
      {
        "content": "DECIMAL",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dec"
        ],
        "opts": []
      },
      {
        "content": "/* ------------------------------------------------------------------------- */",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sep"
        ],
        "opts": []
      }
    ],
    "prolog": [
      {
        "content": ":- initialization main.\nmain :-\n  current_prolog_flag(argv, Args),\n  writeln(Args),\n  halt.",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "main"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": ":- module(${1:name}, [${0:export}]).",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "module"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": ":- begin_tests(${1:name}).\n  ${0}\n:- end_tests($1).",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "begintest"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": ":- run_tests.\n:- halt.",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "runtest"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "test(${1:case}, [true(${2:var} = ${3:value})]) :-\n  ${0:goal}.",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "test"
        ],
        "opts": [
          "head"
        ]
      }
    ],
    "prop-types": [
      {
        "content": "import PropTypes from 'prop-types'\n",
        "doc": null,
        "grammar": "lsp",
        "label": "prop-types-import",
        "matches": [
          "impt",
          "prop-types import"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.array,",
        "doc": "Array prop type",
        "grammar": "lsp",
        "label": "prop-type-array",
        "matches": [
          "prop-types array",
          "pta"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.array.isRequired,",
        "doc": "Array prop type required",
        "grammar": "lsp",
        "label": "prop-type-array-required",
        "matches": [
          "prop-types array required",
          "ptar"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.bool,",
        "doc": "Bool prop type",
        "grammar": "lsp",
        "label": "prop-type-bool",
        "matches": [
          "prop-types bool",
          "ptb"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.bool.isRequired,",
        "doc": "Bool prop type required",
        "grammar": "lsp",
        "label": "prop-type-bool-required",
        "matches": [
          "ptbr",
          "prop-types bool required"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.func,",
        "doc": "Func prop type",
        "grammar": "lsp",
        "label": "prop-type-func",
        "matches": [
          "prop-types func",
          "ptf"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.func.isRequired,",
        "doc": "Func prop type required",
        "grammar": "lsp",
        "label": "prop-type-func-required",
        "matches": [
          "ptfr",
          "prop-types func required"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.number,",
        "doc": "Number prop type",
        "grammar": "lsp",
        "label": "prop-type-number",
        "matches": [
          "prop-types number",
          "ptn"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.number.isRequired,",
        "doc": "Number prop type required",
        "grammar": "lsp",
        "label": "prop-type-number-required",
        "matches": [
          "prop-types number required",
          "ptnr"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.object,",
        "doc": "Object prop type",
        "grammar": "lsp",
        "label": "prop-type-object",
        "matches": [
          "prop-types object",
          "pto"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.object.isRequired,",
        "doc": "Object prop type required",
        "grammar": "lsp",
        "label": "prop-type-object-required",
        "matches": [
          "ptor",
          "prop-types object required"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.string,",
        "doc": "String prop type",
        "grammar": "lsp",
        "label": "prop-type-string",
        "matches": [
          "pts",
          "prop-types string"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.string.isRequired,",
        "doc": "String prop type required",
        "grammar": "lsp",
        "label": "prop-type-string-required",
        "matches": [
          "prop-types string required",
          "ptsr"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.node,",
        "doc": "Anything that can be rendered: numbers, strings, elements or an array",
        "grammar": "lsp",
        "label": "prop-type-node",
        "matches": [
          "prop-types node",
          "ptnd"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.node.isRequired,",
        "doc": "Anything that can be rendered: numbers, strings, elements or an array required",
        "grammar": "lsp",
        "label": "prop-type-node-required",
        "matches": [
          "ptndr",
          "prop-types node required"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.element,",
        "doc": "React element prop type",
        "grammar": "lsp",
        "label": "prop-type-element",
        "matches": [
          "prop-types element",
          "ptel"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.element.isRequired,",
        "doc": "React element prop type required",
        "grammar": "lsp",
        "label": "prop-type-element-required",
        "matches": [
          "ptelr",
          "prop-types element required"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.instanceOf($0),",
        "doc": "Is an instance of a class prop type",
        "grammar": "lsp",
        "label": "prop-type-instance-of",
        "matches": [
          "pti",
          "prop-types instanceof"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.instanceOf($0).isRequired,",
        "doc": "Is an instance of a class prop type required",
        "grammar": "lsp",
        "label": "prop-type-instance-of-required",
        "matches": [
          "prop-types instanceof required",
          "ptir"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.oneOf(['$0']),",
        "doc": "Prop type limited to specific values by treating it as an enum",
        "grammar": "lsp",
        "label": "prop-type-enum",
        "matches": [
          "pte",
          "prop-types enum"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.oneOf(['$0']).isRequired,",
        "doc": "Prop type limited to specific values by treating it as an enum required",
        "grammar": "lsp",
        "label": "prop-type-enum-required",
        "matches": [
          "prop-types enum required",
          "pter"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.oneOfType([\n\t$0\n]),",
        "doc": "An object that could be one of many types",
        "grammar": "lsp",
        "label": "prop-type-one-of-type",
        "matches": [
          "prop-types oneoftype",
          "ptet"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.oneOfType([\n\t$0\n]).isRequired,",
        "doc": "An object that could be one of many types required",
        "grammar": "lsp",
        "label": "prop-type-one-of-type-required",
        "matches": [
          "ptetr",
          "prop-types oneoftype required"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.arrayOf($0),",
        "doc": "An array of a certain type",
        "grammar": "lsp",
        "label": "prop-type-array-of",
        "matches": [
          "ptao",
          "prop-types arrayof"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.arrayOf($0).isRequired,",
        "doc": "An array of a certain type required",
        "grammar": "lsp",
        "label": "prop-type-array-of-required",
        "matches": [
          "prop-types arrayof required",
          "ptaor"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.objectOf($0),",
        "doc": "An object with property values of a certain type",
        "grammar": "lsp",
        "label": "prop-type-object-of",
        "matches": [
          "ptoo",
          "prop-types objectof"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.objectOf($0).isRequired,",
        "doc": "An object with property values of a certain type required",
        "grammar": "lsp",
        "label": "prop-type-object-of-required",
        "matches": [
          "ptoor",
          "prop-types objectof required"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.shape({\n\t$0\n}),",
        "doc": "An object taking on a particular shape",
        "grammar": "lsp",
        "label": "prop-type-shape",
        "matches": [
          "ptsh",
          "prop-types shape"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.shape({\n\t$0\n}).isRequired,",
        "doc": "An object taking on a particular shape required",
        "grammar": "lsp",
        "label": "prop-type-shape-required",
        "matches": [
          "prop-types shape required",
          "ptshr"
        ],
        "opts": []
      },
      {
        "content": "static propTypes = {\n$0\n}\n",
        "doc": null,
        "grammar": "lsp",
        "label": "prop-type-static",
        "matches": [
          "ptypes",
          "prop-types static"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.any,",
        "doc": "Any prop type",
        "grammar": "lsp",
        "label": "prop-type-any",
        "matches": [
          "prop-types any",
          "ptany"
        ],
        "opts": []
      },
      {
        "content": "${1:${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/g}}.propTypes = {\n ${2:property}: ${3:PropTypes.node.isRequired},\n}",
        "doc": null,
        "grammar": "lsp",
        "label": "prop-type-init",
        "matches": [
          "prop-types init"
        ],
        "opts": []
      }
    ],
    "proto": [],
    "ps1": [
      {
        "content": "class {\n\t[string] ${1:FirstName}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "class"
        ],
        "opts": []
      },
      {
        "content": "function ${1:name} {\n\t[CmdletBinding()]\n\tparam (\n\t\t[Parameter(Mandatory = $true)]\n\t\t[string] ${2:Param}\n\t)\n\tbegin {\n\t}\n\tprocess {\n\t}\n\tend {\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "function"
        ],
        "opts": []
      },
      {
        "content": "$Params = @{\n\t${1:Param1} = '${2:Value1}'\n\t${3:Param2} = '${4:Value2}'\n}\n${5:CommandName} @Params",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "splatting"
        ],
        "opts": []
      },
      {
        "content": "enum ${1:name} {\n\t${2:item1}\n\t${3:item2}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "enum"
        ],
        "opts": []
      },
      {
        "content": "if (${1:condition}) {\n\t${2:statement}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "if ( ${1:condition} ) {\n\t${2}\n}\nelse {\n\t${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "while (${1:condition}) {\n\t${2:statement}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "while"
        ],
        "opts": []
      },
      {
        "content": "${1:command} | Where-Object -FilterScript { $PSItem.${2:property} -${3:operator} '${4:expression}' } | Sort-Object -Property ${5:sortproperty}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "filtersort"
        ],
        "opts": []
      },
      {
        "content": "foreach ( $${1:iterator} in $${2:collection} ) {\n\t${3:statement}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "foreach"
        ],
        "opts": []
      },
      {
        "content": "Export-CSV -NoTypeInformation -Path ${1:path}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "epcsv"
        ],
        "opts": []
      },
      {
        "content": "<#\n.SYNOPSIS\n\t${1:Short Description}\n.DESCRIPTION\n\t${2:Full Description}\n.PARAMETER ${3:Param1}\n\t${4: $3 usage}\n.EXAMPLE\n\t${5:Example}\n.NOTES\n\t${6:notes}\n.LINK\n\t${7:online help}\n#>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "help"
        ],
        "opts": []
      },
      {
        "content": "switch ( ${1:test} ){\n\t${2:condition1} { ${3:action} }\n\t${4:condition2} { ${5:action} }\n\tdefault { ${6:action} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "switch"
        ],
        "opts": []
      }
    ],
    "puppet": [
      {
        "content": "# ${1:`vim_snippets#Filename(substitute(expand('%:p:s?\\v.{-}/(\\w+)/manifests/(.+)\\.pp?\\1/\\2?'), '/', '::', 'g'), 'class-name')`}\n# ${2:A description of what this class does}\n#\n# @summary ${3:A short summary of the purpose of this class}\n#\n# @param ${4:parameter1}\n#   ${6:Explanation of what this parameter affects.}\n#\n# @example Simple use\n#   include $1\n#\n# @example Use with params\n#   class { '$1':\n#     $$4 => '${7:undef}',\n#   }\n#\n# @author ${8:`g:snips_author`} <${9:`g:snips_email`}>\n#\n# @note Copyright `strftime(\"%Y\")` $8\n#\nclass $1(\n\t${5:String} $$4 = undef,\n) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "classheader"
        ],
        "opts": []
      },
      {
        "content": "# ${1:`vim_snippets#Filename(expand('%:p:s?.*modules/??:h:h'), 'define-name')`}\n# ${2:A description of what this define does}\n#\n# @summary ${3:A short summary of the purpose of this define}\n#\n# @param ${4:parameter1} [${5:String}]\n#   ${6:Explanation of what this parameter affects.}\n#\n# @example Simple use\n#   $1 { 'namevar':\n#     $$4 => '${7:undef}',\n#   }\n#\n# @author ${8:`g:snips_author`} <${9:`g:snips_email`}>\n#\n# @note Copyright `strftime(\"%Y\")` $8\n#\ndefine $1(\n\t$$4 = undef,\n) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defheader"
        ],
        "opts": []
      },
      {
        "content": "class ${1:`vim_snippets#Filename('', 'name')`} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "class"
        ],
        "opts": []
      },
      {
        "content": "node \"${1:`vim_snippets#Filename('', 'fqdn')`}\" {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "node"
        ],
        "opts": []
      },
      {
        "content": "case $${1:variable} {\n\tdefault: { ${0} }\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case"
        ],
        "opts": []
      },
      {
        "content": "if $${1:variable} {\n\t${2}\n} else {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "if $${1:variable} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "if defined(${1:Resource}[\"${2:name}\"]) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifd"
        ],
        "opts": []
      },
      {
        "content": "if !defined(${1:Resource}[\"${2:name}\"]) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifnd"
        ],
        "opts": []
      },
      {
        "content": "else {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "el"
        ],
        "opts": []
      },
      {
        "content": "? {\n\t\"${1}\"\t=> ${0}\n  }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "?"
        ],
        "opts": []
      },
      {
        "content": "[ ${1} ]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "["
        ],
        "opts": []
      },
      {
        "content": "${1}\t=> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ">"
        ],
        "opts": []
      },
      {
        "content": "\"puppet://puppet/${1:module name}/${0:file name}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p:"
        ],
        "opts": []
      },
      {
        "content": "alert(\"${1:message}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "alert"
        ],
        "opts": []
      },
      {
        "content": "crit(\"${1:message}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "crit"
        ],
        "opts": []
      },
      {
        "content": "debug(\"${1:message}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "debug"
        ],
        "opts": []
      },
      {
        "content": "defined(${1:Resource}[\"${2:name}\"])",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defined"
        ],
        "opts": []
      },
      {
        "content": "emerg(\"${1:message}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "emerg"
        ],
        "opts": []
      },
      {
        "content": "extlookup(\"${1:variable}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "extlookup Simple extlookup"
        ],
        "opts": []
      },
      {
        "content": "extlookup(\"${1:variable}\", \"${2:default}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "extlookup Extlookup with defaults"
        ],
        "opts": []
      },
      {
        "content": "extlookup(\"${1:variable}\", \"${2:default}\", \"${3:data source}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "extlookup Extlookup with defaults and custom data file"
        ],
        "opts": []
      },
      {
        "content": "fail(\"${1:message}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fail"
        ],
        "opts": []
      },
      {
        "content": "info(\"${1:message}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "info"
        ],
        "opts": []
      },
      {
        "content": "inline_template(\"<%= ${1} %>\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "inline_template"
        ],
        "opts": []
      },
      {
        "content": "notice(\"${1:message}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "notice"
        ],
        "opts": []
      },
      {
        "content": "realize(${1:Resource}[${2:name}])",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "realize"
        ],
        "opts": []
      },
      {
        "content": "regsubst(${1:hay stack}, ${2:needle}, \"${3:replacement}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "regsubst"
        ],
        "opts": []
      },
      {
        "content": "include ${1:classname}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "inc"
        ],
        "opts": []
      },
      {
        "content": "split(${1:hay stack}, \"${2:patten}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "split"
        ],
        "opts": []
      },
      {
        "content": "versioncmp(\"${1:version}\", \"${2:version}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "versioncmp"
        ],
        "opts": []
      },
      {
        "content": "warning(\"${1:message}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "warning"
        ],
        "opts": []
      },
      {
        "content": "cron { \"${1:name}\":\n\tcommand => \"${2}\",\n\tuser    => \"${3:root}\",\n\t${4}    => ${0},\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cron"
        ],
        "opts": []
      },
      {
        "content": "exec { \"${1:name}\":\n\tcommand => \"${2:$1}\",\n\tuser    => \"${3:root}\",\n\t${4}    => ${0},\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "exec"
        ],
        "opts": []
      },
      {
        "content": "user { \"${1:user}\":\n\tensure      => present,\n\tcomment     => \"${2:$1}\",\n\tmanagehome  => true,\n\thome        => \"${0:/home/$1}\",\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "user"
        ],
        "opts": []
      },
      {
        "content": "group { \"${1:group}\":\n\tensure => ${0:present},\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "group"
        ],
        "opts": []
      },
      {
        "content": "host { \"${1:hostname}\":\n\tip => ${0:127.0.0.1},\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "host"
        ],
        "opts": []
      },
      {
        "content": "mailalias { \"${1:localpart}\":\n\trecipient => \"${0:recipient}\",\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mailalias"
        ],
        "opts": []
      },
      {
        "content": "mount { \"${1:destination path}\":\n\tensure\t=> ${2:mounted},\n\tdevice\t=> \"${0:device name or path}\",\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mount"
        ],
        "opts": []
      },
      {
        "content": "notify { \"${1:message}\": }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "notify"
        ],
        "opts": []
      },
      {
        "content": "package { \"${1:package name}\":\n\tensure\t=> ${0:present},\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "package"
        ],
        "opts": []
      },
      {
        "content": "yumrepo { \"${1:repo name}\":\n\tdescr   => \"${2:$1}\",\n\tenabled => ${0:1},\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yumrepo"
        ],
        "opts": []
      },
      {
        "content": "define ${1} (${2}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "define"
        ],
        "opts": []
      },
      {
        "content": "service { \"${1:service}\":\n\tensure    => running,\n\tenable    => true,\n\trequire   => [ Package[\"${2:package}\"], File[\"${3:file}\"], ],\n\tsubscribe => [ File[\"${4:configfile1}\"], File[\"${5:configfile2}\"], Package[\"${6:package}\"], ],\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "service"
        ],
        "opts": []
      },
      {
        "content": "file { \"${1:filename}\":\n\tensure  => ${2:present},\n\towner   => \"${3:root}\",\n\tgroup   => \"${4:root}\",\n\tmode    => \"${5:0644}\",\n\tsource  => \"puppet:///modules/${6:module}/${7:source}\",\n\tcontent => template(\"${8:module}/${9:template}\"),\n\talias   => \"${10:alias}\",\n\trequire => [ Package[\"${11:package}\"], File[\"${12:file}\"], ],\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "file"
        ],
        "opts": []
      },
      {
        "content": "archive { \"${1:filename}\":\n\tensure     => ${2:present},\n\turl        => \"http://${3:url}\",\n\textension  => \"${4:tgz}\",\n\ttarget     => \"${5:target}\",\n\tchecksum   => ${6:false},\n\tsrc_target => \"${7:/tmp}\",\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "archive"
        ],
        "opts": []
      },
      {
        "content": "firewall { \"${1:comment}\":\n\tproto\t=> ${2:tcp},\n\taction\t=> ${3:accept},\n\tport\t=> ${4},\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "firewall"
        ],
        "opts": []
      }
    ],
    "purescript": [
      {
        "content": "module `substitute(substitute(expand('%:r'), '[/\\\\]','.','g'),'^\\%(\\l*\\.\\)\\?','','')`\n\t(\n\t) where\nimport Prelude\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mod"
        ],
        "opts": []
      },
      {
        "content": "import ${0:Data.List}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "imp"
        ],
        "opts": []
      },
      {
        "content": "import ${1:Data.List} as ${0:List}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "impq"
        ],
        "opts": []
      },
      {
        "content": "${1:name} :: ${2:a}\n$1 = ${0:undefined}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fn0"
        ],
        "opts": []
      },
      {
        "content": "${1:fn} :: ${2:a} -> ${3:a}\n$1 ${4}= ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fn"
        ],
        "opts": []
      },
      {
        "content": "${1:fn} :: ${2:a} -> ${3:a}\n$1 ${4}= ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fn1"
        ],
        "opts": []
      },
      {
        "content": "${1:fn} :: ${2:a} -> ${3:a} -> ${4:a}\n$1 ${5}= ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fn2"
        ],
        "opts": []
      },
      {
        "content": "${1:fn} :: ${2:a} -> ${3:a} -> ${4:a} -> ${5:a}\n$1 ${6}= ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fn3"
        ],
        "opts": []
      },
      {
        "content": "case ${1} of\n\t${2} -> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case"
        ],
        "opts": []
      },
      {
        "content": "let\n\t${1} = ${2}\nin\n\t${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "let"
        ],
        "opts": []
      },
      {
        "content": "where\n\t${1} = ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "where"
        ],
        "opts": []
      },
      {
        "content": "module Test.Main where\nimport Prelude\nimport Test.Unit (suite, test)\nimport Test.Unit.Main (runTest)\nimport Test.Unit.Assert as Assert\nmain = runTest do\n\tsuite \"${1}\" do\n\t\ttest \"${2:the tests run}\" do\n\t\t\tAssert.equal\n\t\t\t\t\"Hello, world!\"\n\t\t\t\t\"Hello, sailor!\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "testunit"
        ],
        "opts": []
      },
      {
        "content": "if ${1} then\n\t${2:${VISUAL}}\nelse\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "{-| ${0}\n-}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doc"
        ],
        "opts": []
      },
      {
        "content": "type ${1:Type} =\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ty"
        ],
        "opts": []
      },
      {
        "content": "data ${1:Type} =\n\t${0:$1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "da"
        ],
        "opts": []
      },
      {
        "content": "newtype ${1:Type} =\n\t${2:$1} ${0:Int}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nty"
        ],
        "opts": []
      },
      {
        "content": "foreign import ${1} :: ${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fi"
        ],
        "opts": []
      }
    ],
    "python": [
      {
        "content": "#!/usr/bin/env python3\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "#!/usr/bin/env python3",
        "matches": [
          "#!",
          "shebang"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "class ${1:#:name}(${2:object}):\n\tdef __init__(self, ${3}):\n\t\t${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "class Class(...): ...",
        "matches": [
          "class"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "class ${1:#:name}(${2:object}):\n\t\"\"\"${3:#:class documentation}\"\"\"\n\tdef __init__(self, ${4}):\n\t\t\"\"\"${5:#:__init__ documentation}\"\"\"\n\t\t${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "class Class(...): \"...\"",
        "matches": [
          "classd"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "def ${1:#:name}(${2}):\n\t${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "def function(...): ...",
        "matches": [
          "def"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "def ${1:#:name}(${2}):\n\t\"\"\"${3:#:function documentation}\"\"\"\n\t${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "def function(...): \"\"\"...\"\"\"",
        "matches": [
          "defd"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "def ${1:#:name}(self, ${2}):\n\t${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "def method(self, ...): ...",
        "matches": [
          "defm"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "def ${1:#:name}(self, ${2}):\n\t\"\"\"${3:#:method documentation}\"\"\"\n\t${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "def method(self, ...): \"...\"",
        "matches": [
          "defmd"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "elif ${1:#:condition}:\n\t${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "elif ...: ...",
        "matches": [
          "elif"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "else:\n\t${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "else: ...",
        "matches": [
          "else"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "with open(${1:#:file}, '${2:r}') as ${3:f}:\n\t${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "with_open",
          "fileidiom"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "for ${1:#:value} in ${2:#:list}:\n\t${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "for ... in ...: ...",
        "matches": [
          "for"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "if ${1:#:condition}:\n\t${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "if ...: ...",
        "matches": [
          "if"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "if __name__ == '__main__':\n\t${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "if __name__ == '__main__': ...",
        "matches": [
          "ifmain",
          "main"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "try:\n\t${1:pass}\nexcept ${2:#:ExceptionClass}:\n\t${3:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "try: ... except ...: ...",
        "matches": [
          "tryexcept"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "try:\n\t${1:pass}\nfinally:\n\t${2:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "try: ... finally: ...",
        "matches": [
          "tryfinally"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "while ${1:#:condition}:\n\t${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "while ...: ...",
        "matches": [
          "while"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "with ${1:open}(${2:#:filename, mode}) as ${3:f}:\n\t${0:pass}",
        "doc": "",
        "grammar": "snu",
        "label": "with {func}({file}) as :",
        "matches": [
          "with"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "[$1 for ${1:x} in ${2:#:list} if ${3:#:condition}]",
        "doc": "",
        "grammar": "snu",
        "label": "[x for x in {list} if {condition}]",
        "matches": [
          "filter"
        ],
        "opts": []
      },
      {
        "content": "print(${0:#:TARGET})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "print"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "# -*- coding: utf-8 -*-",
        "doc": "",
        "grammar": "snu",
        "label": "# -*- coding ...",
        "matches": [
          "coding"
        ],
        "opts": []
      },
      {
        "content": "getattr(${1:#:obj}, ${2:#:attr})",
        "doc": "",
        "grammar": "snu",
        "label": "getattr(..., ...)",
        "matches": [
          "getattr"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "setattr(${1:#:obj}, ${2:#:attr}, ${3:#:value})",
        "doc": "",
        "grammar": "snu",
        "label": "setattr(..., ...)",
        "matches": [
          "setattr"
        ],
        "opts": []
      },
      {
        "content": "hasattr(${1:#:obj}, ${2:#:attr})",
        "doc": "",
        "grammar": "snu",
        "label": "hasattr(..., ...)",
        "matches": [
          "hasattr"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "import pdb; pdb.set_trace()",
        "doc": "",
        "grammar": "snu",
        "label": "import pdb..",
        "matches": [
          "pdb"
        ],
        "opts": []
      },
      {
        "content": "import ipdb; ipdb.set_trace()",
        "doc": "",
        "grammar": "snu",
        "label": "import ipdb..",
        "matches": [
          "ipdb"
        ],
        "opts": []
      },
      {
        "content": "import pudb; pudb.set_trace()",
        "doc": "",
        "grammar": "snu",
        "label": "import pudb..",
        "matches": [
          "pudb"
        ],
        "opts": []
      },
      {
        "content": "from PyQt5.QtCore import pyqtRemoveInputHook\npyqtRemoveInputHook()\nimport pdb; pdb.set_trace()",
        "doc": "",
        "grammar": "snu",
        "label": "removeInputHook...pdb",
        "matches": [
          "qtpdb"
        ],
        "opts": []
      },
      {
        "content": "from IPython import embed; embed()",
        "doc": "",
        "grammar": "snu",
        "label": "import ipython..",
        "matches": [
          "ipy"
        ],
        "opts": []
      },
      {
        "content": "#!/usr/bin/env python3",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#!"
        ],
        "opts": []
      },
      {
        "content": "#!/usr/bin/env python2\n# -*- coding: utf-8 -*-",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#!2"
        ],
        "opts": []
      },
      {
        "content": "#!/usr/bin/env python3",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#!3"
        ],
        "opts": []
      },
      {
        "content": "import ${0:module}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "imp"
        ],
        "opts": []
      },
      {
        "content": "def __unicode__(self):\n\t${0:representation}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "uni"
        ],
        "opts": []
      },
      {
        "content": "from ${1:package} import ${0:module}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "from"
        ],
        "opts": []
      },
      {
        "content": "\"\"\"\nFile: ${1:`vim_snippets#Filename('$1.py', 'foo.py')`}\nAuthor: `g:snips_author`\nEmail: `g:snips_email`\nGithub: `g:snips_github`\nDescription: ${0}\n\"\"\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "docs"
        ],
        "opts": []
      },
      {
        "content": "@unittest.skip(${1:skip_reason})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sk \"skip unittests\" b"
        ],
        "opts": []
      },
      {
        "content": "while ${1:condition}:\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh"
        ],
        "opts": []
      },
      {
        "content": "while True:\n\t${1}\n\tif ${0:condition}:\n\t\tbreak",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dowh"
        ],
        "opts": []
      },
      {
        "content": "with ${1:expr} as ${2:var}:\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "with"
        ],
        "opts": []
      },
      {
        "content": "async with ${1:expr} as ${2:var}:\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "awith"
        ],
        "opts": []
      },
      {
        "content": "class ${1:ClassName}(${2:object}):\n\t\"\"\"${3:docstring for $1}\"\"\"\n\tdef __init__(self, ${4:arg}):\n\t\t${5:super($1, self).__init__()}\n\t\tself.$4 = $4\n\t\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cl"
        ],
        "opts": []
      },
      {
        "content": "class ${1:class_name}:\n\t\"\"\"${0:description}\"\"\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cla"
        ],
        "opts": []
      },
      {
        "content": "class ${1:class_name}:\n\t\"\"\"${2:description}\"\"\"\n\tdef __init__(self, ${3:args}):\n\t\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "clai"
        ],
        "opts": []
      },
      {
        "content": "def ${1:fname}(${2:`indent('.') ? 'self' : ''`}):\n\t\"\"\"${3:docstring for $1}\"\"\"\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "def"
        ],
        "opts": []
      },
      {
        "content": "def ${1:fname}(${2:`indent('.') ? 'self' : ''`}):\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "deff"
        ],
        "opts": []
      },
      {
        "content": "async def ${1:fname}(${2:`indent('.') ? 'self' : ''`}):\n\t\"\"\"${3:docstring for $1}\"\"\"\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "adef"
        ],
        "opts": []
      },
      {
        "content": "async def ${1:fname}(${2:`indent('.') ? 'self' : ''`}):\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "adeff"
        ],
        "opts": []
      },
      {
        "content": "def __init__(self, ${1:args}):\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defi"
        ],
        "opts": []
      },
      {
        "content": "def ${1:mname}(self, ${2:arg}):\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defm"
        ],
        "opts": []
      },
      {
        "content": "async def ${1:mname}(self, ${2:arg}):\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "adefm"
        ],
        "opts": []
      },
      {
        "content": "def ${1:foo}():\n\tdoc = \"${2:The $1 property.}\"\n\tdef fget(self):\n\t\t${3:return self._$1}\n\tdef fset(self, value):\n\t\t${4:self._$1 = value}\n\tdef fdel(self):\n\t\t${0:del self._$1}\n\treturn locals()\n$1 = property(**$1())",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "property"
        ],
        "opts": []
      },
      {
        "content": "if ${1:condition}:\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "else:\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "el"
        ],
        "opts": []
      },
      {
        "content": "elif ${1:condition}:\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ei"
        ],
        "opts": []
      },
      {
        "content": "for ${1:item} in ${2:items}:\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "# -*- coding: utf-8 -*-",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cutf8"
        ],
        "opts": []
      },
      {
        "content": "# -*- coding: latin-1 -*-",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "clatin1"
        ],
        "opts": []
      },
      {
        "content": "# -*- coding: ascii -*-",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cascii"
        ],
        "opts": []
      },
      {
        "content": "${1:var} = lambda ${2:vars} : ${0:action}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ld"
        ],
        "opts": []
      },
      {
        "content": "return ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ret"
        ],
        "opts": []
      },
      {
        "content": "self.",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "."
        ],
        "opts": []
      },
      {
        "content": "self.${1:attribute} = $1",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sa self.attribute = attribute"
        ],
        "opts": []
      },
      {
        "content": "try:\n\t${1:${VISUAL}}\nexcept ${2:Exception} as ${3:e}:\n\t${0:raise $3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "try Try/Except"
        ],
        "opts": []
      },
      {
        "content": "try:\n\t${1:${VISUAL}}\nexcept ${2:Exception} as ${3:e}:\n\t${4:raise $3}\nelse:\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "trye Try/Except/Else"
        ],
        "opts": []
      },
      {
        "content": "try:\n\t${1:${VISUAL}}\nexcept ${2:Exception} as ${3:e}:\n\t${4:raise $3}\nfinally:\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tryf Try/Except/Finally"
        ],
        "opts": []
      },
      {
        "content": "try:\n\t${1:${VISUAL}}\nexcept ${2:Exception} as ${3:e}:\n\t${4:raise $3}\nelse:\n\t${5}\nfinally:\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tryef Try/Except/Else/Finally"
        ],
        "opts": []
      },
      {
        "content": "if __name__ == '__main__':\n\t${0:main()}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifmain"
        ],
        "opts": []
      },
      {
        "content": "__${1:init}__",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "_"
        ],
        "opts": []
      },
      {
        "content": "__import__('pdb').set_trace()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pdb"
        ],
        "opts": []
      },
      {
        "content": "__import__('bpdb').set_trace()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bpdb"
        ],
        "opts": []
      },
      {
        "content": "__import__('ipdb').set_trace()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ipdb"
        ],
        "opts": []
      },
      {
        "content": "__import__('IPython').embed()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "iem"
        ],
        "opts": []
      },
      {
        "content": "__import__('rpdb').set_trace()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rpdb"
        ],
        "opts": []
      },
      {
        "content": "__import__('wdb').set_trace()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wdb"
        ],
        "opts": []
      },
      {
        "content": "__import__('ptpython.repl', fromlist=('repl')).embed(globals(), locals(), vi_mode=${1:False}, history_filename=${2:None})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ptpython"
        ],
        "opts": []
      },
      {
        "content": "__import__('pudb').set_trace()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pudb"
        ],
        "opts": []
      },
      {
        "content": "from pudb.remote import set_trace\nset_trace()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pudbr"
        ],
        "opts": []
      },
      {
        "content": "__import__('nose').tools.set_trace()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nosetrace"
        ],
        "opts": []
      },
      {
        "content": "__import__('pprint').pprint(${1})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pprint"
        ],
        "opts": []
      },
      {
        "content": "\"\"\"${0:doc}\n\"\"\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\""
        ],
        "opts": []
      },
      {
        "content": "self.assertEqual(${0}, ${1})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "a="
        ],
        "opts": []
      },
      {
        "content": "def test_${1:description}(${2:`indent('.') ? 'self' : ''`}):\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "test"
        ],
        "opts": []
      },
      {
        "content": "class ${1:ExampleCase}(unittest.TestCase):\n\tdef test_${2:description}(self):\n\t\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "testcase"
        ],
        "opts": []
      },
      {
        "content": "# given: ${1}\n# when: ${2}\n# then: ${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tgwt"
        ],
        "opts": []
      },
      {
        "content": "from __future__ import ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fut"
        ],
        "opts": []
      },
      {
        "content": "try:\n\t# Short option syntax: \"hv:\"\n\t# Long option syntax: \"help\" or \"verbose=\"\n\topts, args = getopt.getopt(sys.argv[1:], \"${1:short_options}\", [${2:long_options}])\nexcept getopt.GetoptError, err:\n\t# Print debug info\n\tprint str(err)\n\t${3:error_action}\nfor option, argument in opts:\n\tif option in (\"-h\", \"--help\"):\n\t\t${0}\n\telif option in (\"-v\", \"--verbose\"):\n\t\tverbose = argument",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "getopt"
        ],
        "opts": []
      },
      {
        "content": "parser = ${VISUAL:argparse.}ArgumentParser()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "addp"
        ],
        "opts": []
      },
      {
        "content": "${0:sub_parser} = parser.add_subparsers().add_parser(\"${1:name}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "addsp"
        ],
        "opts": []
      },
      {
        "content": "parser.add_argument(\"${0:short_arg}\", \"${1:long_arg}\", default=${2:None}, help=\"${3:Help text}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "addarg"
        ],
        "opts": []
      },
      {
        "content": "parser.add_argument(\"${0:arg}\", nargs=\"${1:*}\", default=${2:None}, help=\"${3:Help text}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "addnarg"
        ],
        "opts": []
      },
      {
        "content": "parser.add_argument(\"${0:arg}\", \"${1:long_arg}\", action=\"${2:store_true}\", default=${3:False}, help=\"${4:Help text}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "addaarg"
        ],
        "opts": []
      },
      {
        "content": "\"${VISUAL:return }\"parser.parse_args()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pargs"
        ],
        "opts": []
      },
      {
        "content": "import logging\nLOGGER = logging.getLogger(${0:__name__})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "glog"
        ],
        "opts": []
      },
      {
        "content": "LOGGER.error(${0:msg})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "le"
        ],
        "opts": []
      },
      {
        "content": "LOGGER.debug(${0:msg})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lg"
        ],
        "opts": []
      },
      {
        "content": "LOGGER.warning(${0:msg})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lw"
        ],
        "opts": []
      },
      {
        "content": "LOGGER.critical(${0:msg})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lc"
        ],
        "opts": []
      },
      {
        "content": "LOGGER.info(${0:msg})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "li"
        ],
        "opts": []
      },
      {
        "content": "\"\"\"${1:Description}\n@param ${2:param}: ${3: Description}\n@type  $2: ${4: Type}\n@return: ${5: Description}\n@rtype : ${6: Type}\n@raise e: ${0: Description}\n\"\"\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "epydoc"
        ],
        "opts": []
      },
      {
        "content": "def ${1:__init__}(self, *args, **kwargs):\n    super(${0:ClassName}, self).$1(*args, **kwargs)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dol"
        ],
        "opts": []
      },
      {
        "content": "self.${1:var_name} = kwargs.get('$1', ${2:None})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "kwg"
        ],
        "opts": []
      },
      {
        "content": "${1:var_name} = kwargs.get('$1', ${2:None})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lkwg"
        ],
        "opts": []
      },
      {
        "content": "*args${1:,}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "args"
        ],
        "opts": []
      },
      {
        "content": "**kwargs${1:,}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "kwargs"
        ],
        "opts": []
      },
      {
        "content": "*args, **kwargs${1:,}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "akw"
        ],
        "opts": []
      },
      {
        "content": "[${1} for ${2} in ${3:${VISUAL}}]${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lcp list comprehension"
        ],
        "opts": []
      },
      {
        "content": "{${1}: ${2} for ${3} in ${4:${VISUAL}}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dcp dict comprehension"
        ],
        "opts": []
      },
      {
        "content": "{${1} for ${2} in ${3:${VISUAL}}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "scp set comprehension"
        ],
        "opts": []
      },
      {
        "content": "def __len__(self):\n\t${1:pass}\ndef __getitem__(self, key):\n\t${2:pass}\ndef __setitem__(self, key, value):\n\t${3:pass}\ndef __delitem__(self, key):\n\t${4:pass}\ndef __iter__(self):\n\t${5:pass}\ndef __reversed__(self):\n\t${6:pass}\ndef __contains__(self, item):\n\t${7:pass}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "contain \"methods for emulating a container type\" b"
        ],
        "opts": []
      },
      {
        "content": "def __enter__(self):\n\t${1:pass}\ndef __exit__(self, exc_type, exc_value, traceback):\n\t${2:pass}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "context \"context manager methods\" b"
        ],
        "opts": []
      },
      {
        "content": "def __getattr__(self, name):\n\t${1:pass}\ndef __setattr__(self, name, value):\n\t${2:pass}\ndef __delattr__(self, name):\n\t${3:pass}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "attr \"methods for customizing attribute access\" b"
        ],
        "opts": []
      },
      {
        "content": "def __get__(self, instance, owner):\n\t${1:pass}\ndef __set__(self, instance, value):\n\t${2:pass}\ndef __delete__(self, instance):\n\t${3:pass}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "desc \"methods implementing descriptors\" b"
        ],
        "opts": []
      },
      {
        "content": "def __eq__(self, other):\n\t${1:pass}\ndef __ne__(self, other):\n\t${2:pass}\ndef __lt__(self, other):\n\t${3:pass}\ndef __le__(self, other):\n\t${4:pass}\ndef __gt__(self, other):\n\t${5:pass}\ndef __ge__(self, other):\n\t${6:pass}\ndef __cmp__(self, other):\n\t${7:pass}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cmp \"methods implementing rich comparison\""
        ],
        "opts": []
      },
      {
        "content": "def __repr__(self):\n\t${1:pass}\ndef __str__(self):\n\t${2:pass}\ndef __unicode__(self):\n\t${3:pass}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "repr \"methods implementing string representation\""
        ],
        "opts": []
      },
      {
        "content": "def __add__(self, other):\n\t${1:pass}\ndef __sub__(self, other):\n\t${2:pass}\ndef __mul__(self, other):\n\t${3:pass}\ndef __div__(self, other):\n\t${4:pass}\ndef __truediv__(self, other):\n\t${5:pass}\ndef __floordiv__(self, other):\n\t${6:pass}\ndef __mod__(self, other):\n\t${7:pass}\ndef __divmod__(self, other):\n\t${8:pass}\ndef __pow__(self, other):\n\t${9:pass}\ndef __lshift__(self, other):\n\t${10:pass}\ndef __rshift__(self, other):\n\t${11:pass}\ndef __and__(self, other):\n\t${12:pass}\ndef __xor__(self, other):\n\t${13:pass}\ndef __or__(self, other):\n\t${14:pass}\ndef __neg__(self):\n\t${15:pass}\ndef __pos__(self):\n\t${16:pass}\ndef __abs__(self):\n\t${17:pass}\ndef __invert__(self):\n\t${18:pass}\ndef __complex__(self):\n\t${19:pass}\ndef __int__(self):\n\t${20:pass}\ndef __long__(self):\n\t${21:pass}\ndef __float__(self):\n\t${22:pass}\ndef __oct__(self):\n\t${22:pass}\ndef __hex__(self):\n\t${23:pass}\ndef __index__(self):\n\t${24:pass}\ndef __coerce__(self, other):\n\t${25:pass}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "numeric \"methods for emulating a numeric type\" b"
        ],
        "opts": []
      },
      {
        "content": "#!/usr/bin/env python\n$0",
        "doc": null,
        "grammar": "snu",
        "label": "#!/usr/bin/env python",
        "matches": [
          "#!"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "# -*- coding: utf-8 -*-\n$0",
        "doc": null,
        "grammar": "snu",
        "label": "# encoding: UTF-8",
        "matches": [
          "\"^# ?[uU][tT][fF]-?8"
        ],
        "opts": [
          "r"
        ]
      },
      {
        "content": "if __name__ == `!p snip.rv = get_quoting_style(snip)`__main__`!p snip.rv = get_quoting_style(snip)`:\n\t${1:${VISUAL:main()}}",
        "doc": null,
        "grammar": "snu",
        "label": "ifmain",
        "matches": [
          "ifmain"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "with ${1:expr}`!p snip.rv = \" as \" if t[2] else \"\"`${2:var}:\n\t${3:${VISUAL:pass}}\n$0",
        "doc": null,
        "grammar": "snu",
        "label": "with",
        "matches": [
          "with"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "for ${1:item} in ${2:iterable}:\n\t${3:${VISUAL:pass}}",
        "doc": null,
        "grammar": "snu",
        "label": "for loop",
        "matches": [
          "for"
        ],
        "opts": [
          "b"
        ]
      }
    ],
    "r": [
      {
        "content": "#!/usr/bin/env Rscript",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#!"
        ],
        "opts": []
      },
      {
        "content": "library(${0:package})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lib"
        ],
        "opts": []
      },
      {
        "content": "require(${0:package})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "req"
        ],
        "opts": []
      },
      {
        "content": "source('${0:file}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "source"
        ],
        "opts": []
      },
      {
        "content": "if (${1:condition}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "else {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "el"
        ],
        "opts": []
      },
      {
        "content": "else if (${1:condition}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ei"
        ],
        "opts": []
      },
      {
        "content": "while(${1}) {\n\t${2}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh"
        ],
        "opts": []
      },
      {
        "content": "for (${1:item} in ${2:list}) {\n\t${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "foreach (${1:item} = ${2:list}) {\n\t${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "foreach"
        ],
        "opts": []
      },
      {
        "content": "${1:name} <- function (${2:variables}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fun"
        ],
        "opts": []
      },
      {
        "content": "return(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ret"
        ],
        "opts": []
      },
      {
        "content": "${1:name}[${2:rows}, ${0:cols}]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "df"
        ],
        "opts": []
      },
      {
        "content": "c(${0:items})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "c"
        ],
        "opts": []
      },
      {
        "content": "list(${0:items})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "li"
        ],
        "opts": []
      },
      {
        "content": "matrix(${1:data}, nrow = ${2:rows}, ncol = ${0:cols})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mat"
        ],
        "opts": []
      },
      {
        "content": "apply(${1:array}, ${2:margin}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "apply"
        ],
        "opts": []
      },
      {
        "content": "lapply(${1:list}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lapply"
        ],
        "opts": []
      },
      {
        "content": "lapply(${1:list}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sapply"
        ],
        "opts": []
      },
      {
        "content": "vapply(${1:list}, ${2:function}, ${0:type})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vapply"
        ],
        "opts": []
      },
      {
        "content": "mapply(${1:function}, ${0:...})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mapply"
        ],
        "opts": []
      },
      {
        "content": "tapply(${1:vector}, ${2:index}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tapply"
        ],
        "opts": []
      },
      {
        "content": "rapply(${1:list}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rapply"
        ],
        "opts": []
      },
      {
        "content": "ddply(${1:frame}, ${2:variables}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dd"
        ],
        "opts": []
      },
      {
        "content": "dlply(${1:frame}, ${2:variables}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dl"
        ],
        "opts": []
      },
      {
        "content": "daply(${1:frame}, ${2:variables}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "da"
        ],
        "opts": []
      },
      {
        "content": "d_ply(${1:frame}, ${2:variables}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d_"
        ],
        "opts": []
      },
      {
        "content": "adply(${1:array}, ${2:margin}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ad"
        ],
        "opts": []
      },
      {
        "content": "alply(${1:array}, ${2:margin}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "al"
        ],
        "opts": []
      },
      {
        "content": "aaply(${1:array}, ${2:margin}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "aa"
        ],
        "opts": []
      },
      {
        "content": "a_ply(${1:array}, ${2:margin}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "a_"
        ],
        "opts": []
      },
      {
        "content": "ldply(${1:list}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ld"
        ],
        "opts": []
      },
      {
        "content": "llply(${1:list}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ll"
        ],
        "opts": []
      },
      {
        "content": "laply(${1:list}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "la"
        ],
        "opts": []
      },
      {
        "content": "l_ply(${1:list}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "l_"
        ],
        "opts": []
      },
      {
        "content": "mdply(${1:matrix}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "md"
        ],
        "opts": []
      },
      {
        "content": "mlply(${1:matrix}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ml"
        ],
        "opts": []
      },
      {
        "content": "maply(${1:matrix}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ma"
        ],
        "opts": []
      },
      {
        "content": "m_ply(${1:matrix}, ${0:function})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "m_"
        ],
        "opts": []
      },
      {
        "content": "plot(${1:x}, ${0:y})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pl"
        ],
        "opts": []
      },
      {
        "content": "ggplot(${1:data}, aes(${0:aesthetics}))",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ggp"
        ],
        "opts": []
      },
      {
        "content": "${1:(jpeg,bmp,png,tiff)}(filename = '${2:filename}', width = ${3}, height = ${4}, unit = '${5}')\n${0:plot}\ndev.off()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "img"
        ],
        "opts": []
      },
      {
        "content": "fisher.test(${1:x}, ${0:y})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fis"
        ],
        "opts": []
      },
      {
        "content": "chisq.test(${1:x}, ${0:y})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "chi"
        ],
        "opts": []
      },
      {
        "content": "t.test(${1:x}, ${0:y})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tt"
        ],
        "opts": []
      },
      {
        "content": "wilcox.test(${1:x}, ${0:y})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wil"
        ],
        "opts": []
      },
      {
        "content": "cor.test(${1:x}, ${0:y})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cor"
        ],
        "opts": []
      },
      {
        "content": "var.test(${1:x}, ${0:y})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fte"
        ],
        "opts": []
      },
      {
        "content": "kv.test(${1:x}, ${0:y})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "kvt"
        ],
        "opts": []
      }
    ],
    "r-snippets": [
      {
        "content": "rug(${1:jitter(${2:x})})",
        "doc": null,
        "grammar": "lsp",
        "label": "rug",
        "matches": [
          "rug"
        ],
        "opts": []
      },
      {
        "content": "apply(${1:X}, ${2:MARGIN}, ${3:FUN}, ${4:...})",
        "doc": "Apply",
        "grammar": "lsp",
        "label": "app",
        "matches": [
          "apply"
        ],
        "opts": []
      },
      {
        "content": "attach(${1:frame})",
        "doc": "Attach",
        "grammar": "lsp",
        "label": "att",
        "matches": [
          "attach"
        ],
        "opts": []
      },
      {
        "content": "cat(${1:file}, ${2:sep = ${3:\"\"}}, ${4:fill = ${5:FALSE}}, ${6:labels = ${7:NULL}}, ${8:append = ${9:FALSE}})",
        "doc": "Cat",
        "grammar": "lsp",
        "label": "cat",
        "matches": [
          "cat"
        ],
        "opts": []
      },
      {
        "content": "cum${1:max}(${2:x})",
        "doc": "Cummulative",
        "grammar": "lsp",
        "label": "cum",
        "matches": [
          "cum"
        ],
        "opts": []
      },
      {
        "content": "cummax(${1:x}",
        "doc": "Cummulative max",
        "grammar": "lsp",
        "label": "cuma",
        "matches": [
          "cumaax"
        ],
        "opts": []
      },
      {
        "content": "cummin(${1:x}",
        "doc": "Cummulative min",
        "grammar": "lsp",
        "label": "cumi",
        "matches": [
          "cumin"
        ],
        "opts": []
      },
      {
        "content": "data.frame(${1:...}, ${2:row.names = ${3:NULL}}, ${4:check.rows = ${5:FALSE}}, ${6:check.names = ${7:TRUE}}, ${8:stringsAsFactors = ${9:default.stringsAsFactors()}})",
        "doc": "Data Frame",
        "grammar": "lsp",
        "label": "daf",
        "matches": [
          "data.frame"
        ],
        "opts": []
      },
      {
        "content": "density(${1:x}${2:, bw = ${3:bandwidth}})",
        "doc": "Density",
        "grammar": "lsp",
        "label": "den",
        "matches": [
          "density"
        ],
        "opts": []
      },
      {
        "content": "detach(${0:})",
        "doc": "Detach",
        "grammar": "lsp",
        "label": "det",
        "matches": [
          "detach"
        ],
        "opts": []
      },
      {
        "content": "cut(${1:x}, breaks = c(${2:${3:}, ${4:max(${1:x})}}))",
        "doc": "Divide Into Intervals",
        "grammar": "lsp",
        "label": "cut",
        "matches": [
          "cut"
        ],
        "opts": []
      },
      {
        "content": "expand.grid(${1:...}, ${2:KEEP.OUT.ATTRS = ${3:TRUE}}, ${4:stringsAsFactors = ${5:TRUE}})",
        "doc": "Expand grid",
        "grammar": "lsp",
        "label": "exp",
        "matches": [
          "exppand"
        ],
        "opts": []
      },
      {
        "content": "factor(${1:x})",
        "doc": "Factor",
        "grammar": "lsp",
        "label": "fac",
        "matches": [
          "factor"
        ],
        "opts": []
      },
      {
        "content": "function(${1:x}) ${3:{$0\\}}",
        "doc": "Function",
        "grammar": "lsp",
        "label": "fun",
        "matches": [
          "function"
        ],
        "opts": []
      },
      {
        "content": "glm(${1:formula}, ${2:family = {3:gaussian}}, ${4:data})",
        "doc": "Generalized Linear Models",
        "grammar": "lsp",
        "label": "glm",
        "matches": [
          "glm"
        ],
        "opts": []
      },
      {
        "content": "grep(${1:pattern}, ${2:x}, ${3:ignore.case = ${4:FALSE}}, ${5:perl = ${6:FALSE}})",
        "doc": "Grep",
        "grammar": "lsp",
        "label": "grep",
        "matches": [
          "grep"
        ],
        "opts": []
      },
      {
        "content": "grep(${1:pattern}, ${2:x}, ${3:ignore.case = ${4:FALSE}}, ${5:perl = ${6:FALSE}}, ${7:value = ${8:FALSE}}, ${9:fixed = ${10:TRUE}})",
        "doc": "Grep",
        "grammar": "lsp",
        "label": "grep2",
        "matches": [
          "grep"
        ],
        "opts": []
      },
      {
        "content": "grep(${1:pattern}, ${2:x}, ${3:ignore.case = ${4:FALSE}}, ${5:perl = ${6:FALSE}}, ${7:fixed = ${8:TRUE}})",
        "doc": "Grep logical",
        "grammar": "lsp",
        "label": "grepl",
        "matches": [
          "grepl"
        ],
        "opts": []
      },
      {
        "content": "install.packages(${1:pkgs}, ${2:lib}, ${3:repos = ${4:getOption(\"repos\")}}, ${5:contriburl = ${6:contrib.url(repos, type)}})",
        "doc": "Install package",
        "grammar": "lsp",
        "label": "ins",
        "matches": [
          "insall"
        ],
        "opts": []
      },
      {
        "content": "kmeans(${1:x}, ${2:centers}, ${3:iter.max = ${4:10}}, ${5:nstart = ${6:1}}, ${7:algorithm = ${8:c(\"Hartigan-Wong\", \"Lloyd\", \"Forgy\",\"MacQueen\")}}, ${9:trace = ${10:FALSE}})",
        "doc": "Kmeans",
        "grammar": "lsp",
        "label": "km",
        "matches": [
          "kmeans"
        ],
        "opts": []
      },
      {
        "content": "kruskal.test(${1:formula}, ${2:data}, ${3:subset}, ${4:na.action}, ${5:...})",
        "doc": "Kruskal-Wallis Rank Sum test",
        "grammar": "lsp",
        "label": "kr",
        "matches": [
          "kruskal"
        ],
        "opts": []
      },
      {
        "content": "lapply(${1:X}, ${2:FUN}, ${3:...})",
        "doc": "Lapply",
        "grammar": "lsp",
        "label": "lap",
        "matches": [
          "lapply"
        ],
        "opts": []
      },
      {
        "content": "length(${1:x})",
        "doc": "Length",
        "grammar": "lsp",
        "label": "len",
        "matches": [
          "length"
        ],
        "opts": []
      },
      {
        "content": "library(${1:package}, ${2:help}, ${3:pos = ${4:2}}, ${5:lib.loc = ${6:NULL}})",
        "doc": "Library",
        "grammar": "lsp",
        "label": "lib",
        "matches": [
          "library"
        ],
        "opts": []
      },
      {
        "content": "lines(${1:x}${2:, color=${3:red}})",
        "doc": "Polygonal Line",
        "grammar": "lsp",
        "label": "lin",
        "matches": [
          "lines"
        ],
        "opts": []
      },
      {
        "content": "data(${1:name})",
        "doc": "Load Dataset",
        "grammar": "lsp",
        "label": "dat",
        "matches": [
          "data"
        ],
        "opts": []
      },
      {
        "content": "load(${1:file}, ${2:envir = ${3:parent.frame()}}, ${4:verbose = ${5:FALSE}})",
        "doc": "Load RData",
        "grammar": "lsp",
        "label": "loa",
        "matches": [
          "load"
        ],
        "opts": []
      },
      {
        "content": "mean(${1:x}${2:, na.rm=${3:FALSE}})",
        "doc": "Mean",
        "grammar": "lsp",
        "label": "mea",
        "matches": [
          "mean"
        ],
        "opts": []
      },
      {
        "content": "merge(${1:x}, ${2:y}, ${3:by = ${4:intersect(names(x), names(y))}}, ${5:all = ${6:FALSE}})",
        "doc": "Merge",
        "grammar": "lsp",
        "label": "mer",
        "matches": [
          "merge"
        ],
        "opts": []
      },
      {
        "content": "names(${1:x})",
        "doc": "Names",
        "grammar": "lsp",
        "label": "nam",
        "matches": [
          "names"
        ],
        "opts": []
      },
      {
        "content": "options(${1:...})",
        "doc": "Options",
        "grammar": "lsp",
        "label": "opt",
        "matches": [
          "option"
        ],
        "opts": []
      },
      {
        "content": "order(${1:...}, ${2:na.last = ${3:TRUE}}, ${4:decreasing = ${5:FALSE}})",
        "doc": "Order",
        "grammar": "lsp",
        "label": "ord",
        "matches": [
          "order"
        ],
        "opts": []
      },
      {
        "content": "outer(${1:X}, ${2:Y}, ${3:FUN = ${4:\"*\"}}, ${5:...})",
        "doc": "Outer",
        "grammar": "lsp",
        "label": "out",
        "matches": [
          "outer"
        ],
        "opts": []
      },
      {
        "content": "paste(${1:...}, ${2:sep = ${3:\" \"}}, ${3:collapse = ${4:NULL}})",
        "doc": "Paste",
        "grammar": "lsp",
        "label": "pas",
        "matches": [
          "paste"
        ],
        "opts": []
      },
      {
        "content": "paste(${1:...}, ${2:collapse = ${3:NULL}})",
        "doc": "Paste0",
        "grammar": "lsp",
        "label": "pas0",
        "matches": [
          "pas0"
        ],
        "opts": []
      },
      {
        "content": "plot(${1:x}, ${2:y}, ${3:...})",
        "doc": "Plot",
        "grammar": "lsp",
        "label": "plot",
        "matches": [
          "plot"
        ],
        "opts": []
      },
      {
        "content": "points(${1:x}, ${2:y = ${3:NULL}}, ${4:type = ${5:\"p\"}}, ${6:...})",
        "doc": "Points",
        "grammar": "lsp",
        "label": "poi",
        "matches": [
          "point"
        ],
        "opts": []
      },
      {
        "content": "print(${1:x}, ${2:...})",
        "doc": "Print",
        "grammar": "lsp",
        "label": "pri",
        "matches": [
          "print"
        ],
        "opts": []
      },
      {
        "content": "quantile(${1:x}, ${2:probs = ${3:seq(0, 1, 0.25)}}, ${4:na.rm = ${5:FALSE}}, ${6:names = ${7:TRUE}}, ${8:type = ${9:7}}, ${10:...})",
        "doc": "Quantile",
        "grammar": "lsp",
        "label": "qua",
        "matches": [
          "quantile"
        ],
        "opts": []
      },
      {
        "content": "read.table('${1:filename}'${2:, header = ${3:TRUE},  sep = '${4:\t}',  stringsAsFactors = ${5:FALSE}})",
        "doc": "Read From File",
        "grammar": "lsp",
        "label": "reat",
        "matches": [
          "read"
        ],
        "opts": []
      },
      {
        "content": "rep(${1:x}, ${2:...})",
        "doc": "Rep",
        "grammar": "lsp",
        "label": "rep",
        "matches": [
          "rep"
        ],
        "opts": []
      },
      {
        "content": "sample(${1:x}, ${2:size}, ${3:replace = ${4:FALSE}}, ${5:prob = ${6:NULL}})",
        "doc": "Sample",
        "grammar": "lsp",
        "label": "sam",
        "matches": [
          "sample"
        ],
        "opts": []
      },
      {
        "content": "seq(${1:from}, ${2:to}, ${3:by})",
        "doc": "Sequence (from,to,by)",
        "grammar": "lsp",
        "label": "seq",
        "matches": [
          "seq"
        ],
        "opts": []
      },
      {
        "content": "sort(${1:x})",
        "doc": "Sort",
        "grammar": "lsp",
        "label": "sor",
        "matches": [
          "sort"
        ],
        "opts": []
      },
      {
        "content": "source(${1:'${2:}'}${3:, chdir = ${4:TRUE}})",
        "doc": "Source",
        "grammar": "lsp",
        "label": "sou",
        "matches": [
          "source"
        ],
        "opts": []
      },
      {
        "content": "sd(${1:x}${2:, na.rm=${3:FALSE}})",
        "doc": "Standard deviation",
        "grammar": "lsp",
        "label": "sd",
        "matches": [
          "sd"
        ],
        "opts": []
      },
      {
        "content": "table(${1:...})",
        "doc": "Table",
        "grammar": "lsp",
        "label": "tab",
        "matches": [
          "table"
        ],
        "opts": []
      },
      {
        "content": "tapply(${1:X}, ${2:INDEX}, ${3:FUN = ${4:NULL}}, ${5:...}, ${6:simplify = ${7:TRUE}})",
        "doc": "Tapply",
        "grammar": "lsp",
        "label": "tap",
        "matches": [
          "tapply"
        ],
        "opts": []
      },
      {
        "content": "unique(${1:x}, ${2:incomparables = ${3:FALSE}}, ${4:...})",
        "doc": "Unique",
        "grammar": "lsp",
        "label": "uni",
        "matches": [
          "unique"
        ],
        "opts": []
      },
      {
        "content": "which(${1:x}, ${2:arr.ind = ${3:FALSE}}, ${4:useNames = ${5:TRUE}})",
        "doc": "Which",
        "grammar": "lsp",
        "label": "whi",
        "matches": [
          "which"
        ],
        "opts": []
      },
      {
        "content": "write.csv(${1:x}, ${2:file = ${3:\"\"}}, ${4:append = ${5:FALSE}}, ${6:quote = ${7:TRUE}}, ${8:sep = ${9:\" \"}}",
        "doc": "Write csv",
        "grammar": "lsp",
        "label": "wric",
        "matches": [
          "write"
        ],
        "opts": []
      },
      {
        "content": "${1:file = }file.choose()${0:}",
        "doc": "file.choose",
        "grammar": "lsp",
        "label": "fch",
        "matches": [
          "fch"
        ],
        "opts": []
      },
      {
        "content": "library(cluster)\nclara(${1:xData}, k = ${2:k}, metric = ${3:metric}, stand = ${4:stand}, samples = ${5:samples})",
        "doc": "Cluster data into k clusters (library: cluster)",
        "grammar": "lsp",
        "label": "Clustering",
        "matches": [
          "clara"
        ],
        "opts": []
      },
      {
        "content": "lmObj <- lm(${1:yCol} ~ {2:xCol}, data = ${3:data}, subset = ${4:subset}, weights = ${5:weights}, na.action = ${6:na.action})\nsummary(lmObj)",
        "doc": "Fit a linear model",
        "grammar": "lsp",
        "label": "Linear model",
        "matches": [
          "lm"
        ],
        "opts": []
      },
      {
        "content": "lmObj <- lm(${1:yCol} ~ {2:xCol}, data = ${3:data}, subset = ${4:subset}, weights = ${5:weights}, na.action = ${6:na.action})\nsummary(lmObj)\nplot(lmObj, which=c(1)) # Plot residuals versus fitted",
        "doc": "Fit a linear model and create a plot",
        "grammar": "lsp",
        "label": "Linear model with plot",
        "matches": [
          "lmplot"
        ],
        "opts": []
      },
      {
        "content": "loess(${1:yCol} ~ {2:xCol}, data = ${3:data}, subset = ${4:subset}, weights = ${5:weights}, span = ${6:span},\ndegree = ${7:degree}, na.action = {8:na.action})",
        "doc": "Local polynomial regression",
        "grammar": "lsp",
        "label": "loess",
        "matches": [
          "loess"
        ],
        "opts": []
      },
      {
        "content": "summary(${1:dataName}, digits = ${2:digits}, maxsum = ${3:maxsum})",
        "doc": "Mean, median, 25th and 75th quartiles, min, and max of variables",
        "grammar": "lsp",
        "label": "Descriptive statistics summary",
        "matches": [
          "summary"
        ],
        "opts": []
      },
      {
        "content": "crossTable <- xtabs(~${1:varNames}, data= ${2:dataName}, exclude = c(${3:exclude}), subset = ${4:subset})\nftable(crossTable)  # print crosstabs\nsummary(crossTable) # chi-square tests",
        "doc": "Crosstabulations for variables in a data frame",
        "grammar": "lsp",
        "label": "Crosstabs",
        "matches": [
          "xtabs"
        ],
        "opts": []
      },
      {
        "content": "${1:dfname} <- data.frame(${2:a} = character(), ${3:b} = character())",
        "doc": "Code snippet for an empty character data frame",
        "grammar": "lsp",
        "label": "Empty data frame (character)",
        "matches": [
          "df2c"
        ],
        "opts": []
      },
      {
        "content": "${1:dfname} <- data.frame(${2:x} = numeric(), ${3:y} = numeric())",
        "doc": "Code snippet for an empty numerical data frame",
        "grammar": "lsp",
        "label": "Empty data frame (numeric)",
        "matches": [
          "df2n"
        ],
        "opts": []
      },
      {
        "content": "${1:dfname} <- data.frame(${2:varlist})",
        "doc": "Create a data frame from vectors",
        "grammar": "lsp",
        "label": "Data frame",
        "matches": [
          "dfv"
        ],
        "opts": []
      },
      {
        "content": "${1:outFactor} <- factor(x = ${2:dataVec}, levels = ${3:levels}, exclude = ${4:exclude})",
        "doc": "Create a factor (categorical variable) from a vector",
        "grammar": "lsp",
        "label": "Categorical variable",
        "matches": [
          "factor"
        ],
        "opts": []
      },
      {
        "content": "${1:outMatrix} <- matrix(data = ${2:dataVec}, nrow = ${3:nrow}, ncol = ${4:ncol}, byrow = ${5:byrow})",
        "doc": "Create a matrix from a vector",
        "grammar": "lsp",
        "label": "Matrix",
        "matches": [
          "matrix"
        ],
        "opts": []
      },
      {
        "content": "${1:newdataframe} <- na.omit(${2:dataframe})",
        "doc": "Remove all rows with missing values from data frame",
        "grammar": "lsp",
        "label": "remove missings",
        "matches": [
          "naomit"
        ],
        "opts": []
      },
      {
        "content": "${1:dfname} <- read.csv(file = \"${2:file}\", header = ${3|TRUE,FALSE|},  sep = \"${4|\\,,;|}\", row.names = ${5:NULL},  stringsAsFactors = ${6|FALSE,TRUE|})",
        "doc": "Read a data table from a comma-separated file (CSV) and create a data frame",
        "grammar": "lsp",
        "label": "Read CSV",
        "matches": [
          "readc"
        ],
        "opts": []
      },
      {
        "content": "else {\n   ${1:selected}\n}",
        "doc": "Code snippet for 'else' conditional",
        "grammar": "lsp",
        "label": "else",
        "matches": [
          "else"
        ],
        "opts": []
      },
      {
        "content": "else if (${1:condition}) {\n   ${2:selected}\n}",
        "doc": "Code snippet for 'else' conditional",
        "grammar": "lsp",
        "label": "elseif",
        "matches": [
          "elseif"
        ],
        "opts": []
      },
      {
        "content": "for (${1:identifier} in ${2:collection}) {\n   ${3:selected}\n}",
        "doc": "Code snippet for 'for' loop",
        "grammar": "lsp",
        "label": "for",
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "${1:name} <- function(${2:parameters}) {\n   ${3:selected}\n}",
        "doc": "Named function",
        "grammar": "lsp",
        "label": "function",
        "matches": [
          "function"
        ],
        "opts": []
      },
      {
        "content": "if (${1:condition}) {\n   ${2:selected}\n}",
        "doc": "Code snippet for 'if' conditional",
        "grammar": "lsp",
        "label": "if",
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "if (${1:condition}) {\n   ${2:selected}\n} else {\n   \n}",
        "doc": "Code snippet for 'if-else' conditional block",
        "grammar": "lsp",
        "label": "if-else block",
        "matches": [
          "ifelse"
        ],
        "opts": []
      },
      {
        "content": "#region $0",
        "doc": "Folding Region Start",
        "grammar": "lsp",
        "label": "Region Start",
        "matches": [
          "#region"
        ],
        "opts": []
      },
      {
        "content": "#endregion",
        "doc": "Folding Region End",
        "grammar": "lsp",
        "label": "Region End",
        "matches": [
          "#endregion"
        ],
        "opts": []
      }
    ],
    "racket": [
      {
        "content": "#lang racket",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#r"
        ],
        "opts": []
      },
      {
        "content": "#lang typed/racket",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#tr"
        ],
        "opts": []
      },
      {
        "content": "#lang racket/gui",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#rg"
        ],
        "opts": []
      },
      {
        "content": "#lang scribble/base",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#sb"
        ],
        "opts": []
      },
      {
        "content": "#lang datalog",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#d"
        ],
        "opts": []
      },
      {
        "content": "#lang web-server/insta",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#wi"
        ],
        "opts": []
      },
      {
        "content": "(define ${1} ${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "def"
        ],
        "opts": []
      },
      {
        "content": "(define (${1})\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defun"
        ],
        "opts": []
      },
      {
        "content": "(define-values (${1}) (${0}))",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defv \"define-values\""
        ],
        "opts": []
      },
      {
        "content": "(define/match (${1})\n  [(${2}) ${3}]\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defm \"define/match\""
        ],
        "opts": []
      },
      {
        "content": "(define-syntax (${1})\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defs \"define-syntax\""
        ],
        "opts": []
      },
      {
        "content": "(if ${1} ${2} ${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "(if (not ${1}) ${2} ${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifn"
        ],
        "opts": []
      },
      {
        "content": "(if ${1}\n\t(let (${2})\n\t\t${3})\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifl"
        ],
        "opts": []
      },
      {
        "content": "(if (not ${1})\n\t(let (${2})\n\t\t${3})\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifnl"
        ],
        "opts": []
      },
      {
        "content": "(if ${1}\n\t(begin\n\t\t${2})\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifb"
        ],
        "opts": []
      },
      {
        "content": "(if (not ${1})\n\t(begin\n\t\t${2})\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifnb"
        ],
        "opts": []
      },
      {
        "content": "(when ${1}\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "when"
        ],
        "opts": []
      },
      {
        "content": "(unless ${1} ${2} ${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "unless"
        ],
        "opts": []
      },
      {
        "content": "(cond\n\t[(${1}) ${0}])",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cond"
        ],
        "opts": []
      },
      {
        "content": "(cond\n\t[(${1}) ${2}]\n\t[else ${0}])",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "conde"
        ],
        "opts": []
      },
      {
        "content": "(case ${1}\n\t[(${2}) ${0}])",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case"
        ],
        "opts": []
      },
      {
        "content": "(match ${1}\n\t[(${2}) ${0}])",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "match"
        ],
        "opts": []
      },
      {
        "content": "(for ([${1}])\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "(for/list ([${1}])\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forl \"for/list\""
        ],
        "opts": []
      },
      {
        "content": "(for/fold\n\t([${1}])\n\t([${2}])\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forf \"for/fold\""
        ],
        "opts": []
      },
      {
        "content": "(for/foldr\n\t([${1}])\n\t([${2}])\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forfr \"for/foldr\""
        ],
        "opts": []
      },
      {
        "content": "(for/and ([${1}])\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fora \"for/and\""
        ],
        "opts": []
      },
      {
        "content": "(for/or ([${1}])\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "foro \"for/or\""
        ],
        "opts": []
      },
      {
        "content": "(for/sum ([${1}])\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fors \"for/sum\""
        ],
        "opts": []
      },
      {
        "content": "(for/product ([${1}])\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forp \"for/product\""
        ],
        "opts": []
      },
      {
        "content": "(for/first ([${1}])\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forfi \"for/first\""
        ],
        "opts": []
      },
      {
        "content": "(for/last ([${1}])\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forla \"for/last\""
        ],
        "opts": []
      },
      {
        "content": "(lambda (${1}) ${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lambda"
        ],
        "opts": []
      },
      {
        "content": "(apply ${1} ${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "apply"
        ],
        "opts": []
      },
      {
        "content": "(map ${1} ${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "map"
        ],
        "opts": []
      },
      {
        "content": "(filter ${1} ${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "filter"
        ],
        "opts": []
      },
      {
        "content": "(require ${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "req"
        ],
        "opts": []
      },
      {
        "content": "(provide ${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prov"
        ],
        "opts": []
      },
      {
        "content": "(let ([${1}]) ${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "let"
        ],
        "opts": []
      },
      {
        "content": "(let/cc here (set! ${1} here) ${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "letcc"
        ],
        "opts": []
      },
      {
        "content": "(begin\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "begin"
        ],
        "opts": []
      }
    ],
    "rails": [
      {
        "content": "assert_redirected_to ${1:action}: '${2:index}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "art"
        ],
        "opts": []
      },
      {
        "content": "assert_redirected_to ${1:parent}_${2:child}_path(${3:@$1}, ${0:@$2})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "artnp"
        ],
        "opts": []
      },
      {
        "content": "assert_redirected_to ${1:parent}_${2:child}_path(${0:@$1})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "artnpp"
        ],
        "opts": []
      },
      {
        "content": "assert_redirected_to ${1:model}_path(${0:@$1})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "artp"
        ],
        "opts": []
      },
      {
        "content": "assert_redirected_to ${0:model}s_path",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "artpp"
        ],
        "opts": []
      },
      {
        "content": "assert_difference '${1:Model}.${2:count}', ${3:1} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asd"
        ],
        "opts": []
      },
      {
        "content": "assert_no_difference '${1:Model}.${2:count}' do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asnd"
        ],
        "opts": []
      },
      {
        "content": "assert_response :${1:success}, @response.body",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asre"
        ],
        "opts": []
      },
      {
        "content": "assert_rjs :${1:replace}, '${0:dom id}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asrj"
        ],
        "opts": []
      },
      {
        "content": "assert_select '${1:path}', ${2:text}: '${3:inner_html}' ${4:do}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ass assert_select(..)"
        ],
        "opts": []
      },
      {
        "content": "before_action :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ba"
        ],
        "opts": []
      },
      {
        "content": "before_filter :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bf"
        ],
        "opts": []
      },
      {
        "content": "belongs_to :${0:association}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bt"
        ],
        "opts": []
      },
      {
        "content": "belongs_to :${1:association}, polymorphic: true",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "btp"
        ],
        "opts": []
      },
      {
        "content": "cattr_accessor :${0:attr_names}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "crw"
        ],
        "opts": []
      },
      {
        "content": "def create\n\t@${1:model_class_name} = ${2:ModelClassName}.new($1_params)\n\trespond_to do |format|\n\t\tif @$1.save\n\t\t\tflash[:notice] = '$2 was successfully created.'\n\t\t\tformat.html { redirect_to(@$1) }\n\t\t\tformat.json  { render json: @$1, status: :created, location: @$1 }\n\t\telse\n\t\t\tformat.html { render action: 'new' }\n\t\t\tformat.json  { render json: @$1.errors, status: :unprocessable_entity }\n\t\tend\n\tend\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defcreate"
        ],
        "opts": []
      },
      {
        "content": "def destroy\n\t@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])\n\t@$1.destroy\n\trespond_to do |format|\n\t\tformat.html { redirect_to($1s_url) }\n\t\tformat.json  { head :ok }\n\tend\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defdestroy"
        ],
        "opts": []
      },
      {
        "content": "def edit\n\t@${1:model_class_name} = ${0:ModelClassName}.find(params[:id])\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defedit"
        ],
        "opts": []
      },
      {
        "content": "def index\n\t@${1:model_class_name} = ${2:ModelClassName}.all\n\trespond_to do |format|\n\t\tformat.html # index.html.erb\n\t\tformat.json  { render json: @$1s }\n\tend\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defindex"
        ],
        "opts": []
      },
      {
        "content": "def new\n\t@${1:model_class_name} = ${2:ModelClassName}.new\n\trespond_to do |format|\n\t\tformat.html # new.html.erb\n\t\tformat.json  { render json: @$1 }\n\tend\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defnew"
        ],
        "opts": []
      },
      {
        "content": "def show\n\t@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])\n\trespond_to do |format|\n\t\tformat.html # show.html.erb\n\t\tformat.json  { render json: @$1 }\n\tend\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defshow"
        ],
        "opts": []
      },
      {
        "content": "def update\n\t@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])\n\trespond_to do |format|\n\t\tif @$1.update($1_params)\n\t\t\tflash[:notice] = '$2 was successfully updated.'\n\t\t\tformat.html { redirect_to(@$1) }\n\t\t\tformat.json  { head :ok }\n\t\telse\n\t\t\tformat.html { render action: 'edit' }\n\t\t\tformat.json  { render json: @$1.errors, status: :unprocessable_entity }\n\t\tend\n\tend\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defupdate"
        ],
        "opts": []
      },
      {
        "content": "def ${1:model_class_name}_params\n\tparams.require(:$1).permit()\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defparams"
        ],
        "opts": []
      },
      {
        "content": "delegate :${1:methods}, to: :${0:object}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dele delegate .. to"
        ],
        "opts": []
      },
      {
        "content": "delegate :${1:methods}, to: :${2:object}, prefix: :${3:prefix}, allow_nil: ${0:allow_nil}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dele delegate .. to .. prefix .. allow_nil"
        ],
        "opts": []
      },
      {
        "content": "alias_method_chain :${1:method_name}, :${0:feature}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "amc"
        ],
        "opts": []
      },
      {
        "content": "flash[:${1:notice}] = '${0}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "flash"
        ],
        "opts": []
      },
      {
        "content": "has_and_belongs_to_many :${1:object}, join_table: '${2:table_name}', foreign_key: '${3}_id'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "habtm"
        ],
        "opts": []
      },
      {
        "content": "has_many :${0:object}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "hm"
        ],
        "opts": []
      },
      {
        "content": "has_many :${1:other}s, class_name: '${2:$1}', foreign_key: '${3:$1}_id', dependent: :destroy",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "hmd"
        ],
        "opts": []
      },
      {
        "content": "has_many :${1:object}, through: :${0:object}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "hmt"
        ],
        "opts": []
      },
      {
        "content": "has_one :${0:object}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ho"
        ],
        "opts": []
      },
      {
        "content": "has_one :${1:object}, dependent: :${0:destroy}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "hod"
        ],
        "opts": []
      },
      {
        "content": "I18n.t('${1:type.key}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "i18"
        ],
        "opts": []
      },
      {
        "content": "<%= image_submit_tag('${1:agree.png}', id: '${2:id}'${0}) %>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ist"
        ],
        "opts": []
      },
      {
        "content": "Rails.logger.${1:debug} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "log"
        ],
        "opts": []
      },
      {
        "content": "RAILS_DEFAULT_LOGGER.${1:debug} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "log2"
        ],
        "opts": []
      },
      {
        "content": "logger.debug { '${1:message}' }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "logd"
        ],
        "opts": []
      },
      {
        "content": "logger.error { '${1:message}' }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "loge"
        ],
        "opts": []
      },
      {
        "content": "logger.fatal { '${1:message}' }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "logf"
        ],
        "opts": []
      },
      {
        "content": "logger.info { '${1:message}' }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "logi"
        ],
        "opts": []
      },
      {
        "content": "logger.warn { '${1:message}' }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "logw"
        ],
        "opts": []
      },
      {
        "content": "${1:map}.${2:connect} '${0:controller/:action/:id}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mapc"
        ],
        "opts": []
      },
      {
        "content": "${1:map}.catch_all '*${2:anything}', controller: '${3:default}', action: '${4:error}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mapca"
        ],
        "opts": []
      },
      {
        "content": "${1:map}.resource :${0:resource}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mapr"
        ],
        "opts": []
      },
      {
        "content": "${1:map}.resources :${0:resource}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "maprs"
        ],
        "opts": []
      },
      {
        "content": "${1:map}.with_options ${2:controller}: '${3:thing}' do |$3|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mapwo"
        ],
        "opts": []
      },
      {
        "content": "before_validation :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mbv"
        ],
        "opts": []
      },
      {
        "content": "before_create :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mbc"
        ],
        "opts": []
      },
      {
        "content": "before_update :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mbu"
        ],
        "opts": []
      },
      {
        "content": "before_save :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mbs"
        ],
        "opts": []
      },
      {
        "content": "before_destroy :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mbd"
        ],
        "opts": []
      },
      {
        "content": "after_validation :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mav"
        ],
        "opts": []
      },
      {
        "content": "after_find :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "maf"
        ],
        "opts": []
      },
      {
        "content": "after_touch :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mat"
        ],
        "opts": []
      },
      {
        "content": "after_create :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "macr"
        ],
        "opts": []
      },
      {
        "content": "after_update :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mau"
        ],
        "opts": []
      },
      {
        "content": "after_save :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mas"
        ],
        "opts": []
      },
      {
        "content": "after_destroy :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mad"
        ],
        "opts": []
      },
      {
        "content": "around_create :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "marc"
        ],
        "opts": []
      },
      {
        "content": "around_update :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "maru"
        ],
        "opts": []
      },
      {
        "content": "around_save :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mars"
        ],
        "opts": []
      },
      {
        "content": "around_destroy :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mard"
        ],
        "opts": []
      },
      {
        "content": "change_table :${1:table_name} do |t|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mcht"
        ],
        "opts": []
      },
      {
        "content": "map(&:${0:id})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mp"
        ],
        "opts": []
      },
      {
        "content": "mattr_accessor :${0:attr_names}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mrw"
        ],
        "opts": []
      },
      {
        "content": "order('${0:field}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "oa"
        ],
        "opts": []
      },
      {
        "content": "order('${0:field} DESC')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "od"
        ],
        "opts": []
      },
      {
        "content": "params[:${1:id}]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pa"
        ],
        "opts": []
      },
      {
        "content": "render action: '${0:action}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ra"
        ],
        "opts": []
      },
      {
        "content": "render action: '${1:action}', layout: '${0:layoutname}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ral"
        ],
        "opts": []
      },
      {
        "content": "respond_to do |format|\n\tformat.${1:html} { ${0} }\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rest"
        ],
        "opts": []
      },
      {
        "content": "render file: '${0:filepath}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rf"
        ],
        "opts": []
      },
      {
        "content": "render file: '${1:filepath}', use_full_path: ${0:false}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rfu"
        ],
        "opts": []
      },
      {
        "content": "render inline: \"${0:<%= 'hello' %>}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ri"
        ],
        "opts": []
      },
      {
        "content": "render inline: \"${1:<%= 'hello' %>}\", locals: { ${2:name}: '${3:value}'${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ril"
        ],
        "opts": []
      },
      {
        "content": "render inline: \"${1:<%= 'hello' %>}\", type: ${0::rxml}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rit"
        ],
        "opts": []
      },
      {
        "content": "render json: '${0:text to render}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rjson"
        ],
        "opts": []
      },
      {
        "content": "render layout: '${0:layoutname}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rl"
        ],
        "opts": []
      },
      {
        "content": "render nothing: ${0:true}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rn"
        ],
        "opts": []
      },
      {
        "content": "render nothing: ${1:true}, status: ${0:401}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rns"
        ],
        "opts": []
      },
      {
        "content": "render partial: '${0:item}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rp"
        ],
        "opts": []
      },
      {
        "content": "render partial: '${1:item}', collection: ${0:@$1s}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rpc"
        ],
        "opts": []
      },
      {
        "content": "render partial: '${1:item}', locals: { ${2:$1}: ${0:@$1} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rpl"
        ],
        "opts": []
      },
      {
        "content": "render partial: '${1:item}', object: ${0:@$1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rpo"
        ],
        "opts": []
      },
      {
        "content": "render partial: '${1:item}', status: ${0:500}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rps"
        ],
        "opts": []
      },
      {
        "content": "render text: '${0:text to render}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rt"
        ],
        "opts": []
      },
      {
        "content": "render text: '${1:text to render}', layout: '${0:layoutname}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rtl"
        ],
        "opts": []
      },
      {
        "content": "render text: '${1:text to render}', layout: ${0:true}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rtlt"
        ],
        "opts": []
      },
      {
        "content": "render text: '${1:text to render}', status: ${0:401}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rts"
        ],
        "opts": []
      },
      {
        "content": "render :update do |${1:page}|\n\t$1.${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ru"
        ],
        "opts": []
      },
      {
        "content": "render xml: '${0:text to render}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rxml"
        ],
        "opts": []
      },
      {
        "content": "scope :${1:name}, -> { where(${2:field}: ${0:value}) }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sc"
        ],
        "opts": []
      },
      {
        "content": "scope :${1:name}, lambda do |${2:value}|\n\twhere('${3:field = ?}', ${0:value})\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sl"
        ],
        "opts": []
      },
      {
        "content": "Digest::SHA1.hexdigest(${0:string})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sha1"
        ],
        "opts": []
      },
      {
        "content": "class ${1:ModelClassName}Sweeper < ActionController::Caching::Sweeper\n\tobserve $1\n\tdef after_save(${0:model_class_name})\n\t\texpire_cache($2)\n\tend\n\tdef after_destroy($2)\n\t\texpire_cache($2)\n\tend\n\tdef expire_cache($2)\n\t\texpire_page\n\tend\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sweeper"
        ],
        "opts": []
      },
      {
        "content": "validates_associated :${0:attribute}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "va validates_associated"
        ],
        "opts": []
      },
      {
        "content": "validates :${0:terms}, acceptance: true",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "va validates .., acceptance: true"
        ],
        "opts": []
      },
      {
        "content": "validates :${0:attribute}, confirmation: true",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vc"
        ],
        "opts": []
      },
      {
        "content": "validates :${1:attribute}, exclusion: { in: ${0:%w( mov avi )} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ve"
        ],
        "opts": []
      },
      {
        "content": "validates :${1:attribute}, format: { with: /${0:regex}/ }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vf"
        ],
        "opts": []
      },
      {
        "content": "validates :${1:attribute}, inclusion: { in: %w(${0: mov avi }) }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vi"
        ],
        "opts": []
      },
      {
        "content": "validates :${1:attribute}, length: { in: ${2:3}..${0:20} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vl"
        ],
        "opts": []
      },
      {
        "content": "validates :${0:attribute}, numericality: true",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vn"
        ],
        "opts": []
      },
      {
        "content": "validates :${0:attribute}, presence: true",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vp"
        ],
        "opts": []
      },
      {
        "content": "validates :${0:attribute}, uniqueness: true",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vu"
        ],
        "opts": []
      },
      {
        "content": "format.${1:js|xml|html} { ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "format"
        ],
        "opts": []
      },
      {
        "content": "where(${1:'conditions'}${0:, bind_var})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wc"
        ],
        "opts": []
      },
      {
        "content": "where(${1:field}: ${0:value})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wf"
        ],
        "opts": []
      },
      {
        "content": "xhr :delete, :${1:destroy}, id: ${2:1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "xdelete"
        ],
        "opts": []
      },
      {
        "content": "xhr :get, :${1:show}, id: ${2:1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "xget"
        ],
        "opts": []
      },
      {
        "content": "xhr :post, :${1:create}, ${2:object}: ${3:object}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "xpost"
        ],
        "opts": []
      },
      {
        "content": "xhr :put, :${1:update}, id: ${2:1}, ${3:object}: ${4:object}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "xput"
        ],
        "opts": []
      },
      {
        "content": "test '${1:should do something}' do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "test"
        ],
        "opts": []
      },
      {
        "content": "add_column :${1:table_name}, :${2:column_name}, :${0:data_type}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mac"
        ],
        "opts": []
      },
      {
        "content": "add_index :${1:table_name}, :${0:column_name}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mai"
        ],
        "opts": []
      },
      {
        "content": "remove_column :${1:table_name}, :${0:column_name}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mrc"
        ],
        "opts": []
      },
      {
        "content": "rename_column :${1:table_name}, :${2:old_column_name}, :${0:new_column_name}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mrnc"
        ],
        "opts": []
      },
      {
        "content": "change_column :${1:table}, :${2:column}, :${0:type}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mcc"
        ],
        "opts": []
      },
      {
        "content": "t.${1:string} :${2:title}${3:, null: false}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mnc"
        ],
        "opts": []
      },
      {
        "content": "create_table :${1:table_name} do |t|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mct"
        ],
        "opts": []
      },
      {
        "content": "reversible do |dir|\n\tdir.up do\n\t\t${0}\n\tend\n\tdir.down do\n\tend\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mrev reversible do |dir| ... dir.up .. dir.down .. end"
        ],
        "opts": []
      },
      {
        "content": "class Migration${1:class_name} < ApplicationRecord\n\tself.table_name = :${2:model_name}s\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cmm class Migration... < ApplicationModel .. self.table_name .. end"
        ],
        "opts": []
      },
      {
        "content": "class `substitute( substitute(vim_snippets#Filename(), '^\\d\\+_', '',''), '\\(_\\|^\\)\\(.\\)', '\\u\\2', 'g')` < ActiveRecord::Migration\n\tdef up\n\t\t${0}\n\tend\n\tdef down\n\tend\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "migration class .. < ActiveRecord::Migration .. def up .. def down .. end"
        ],
        "opts": []
      },
      {
        "content": "class `substitute( substitute(vim_snippets#Filename(), '^\\d\\+_', '',''), '\\(_\\|^\\)\\(.\\)', '\\u\\2', 'g')` < ActiveRecord::Migration\n\tdef change\n\t\t${0}\n\tend\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "migration class .. < ActiveRecord::Migration .. def change .. end"
        ],
        "opts": []
      },
      {
        "content": "t.remove :${0:column}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "trc"
        ],
        "opts": []
      },
      {
        "content": "t.rename :${1:old_column_name}, :${2:new_column_name}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tre"
        ],
        "opts": []
      },
      {
        "content": "t.references :${0:model}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tref"
        ],
        "opts": []
      },
      {
        "content": "t.boolean :${1:title}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tcb"
        ],
        "opts": []
      },
      {
        "content": "t.binary :${1:title}, limit: ${2:2}.megabytes\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tcbi"
        ],
        "opts": []
      },
      {
        "content": "t.decimal :${1:title}, precision: ${2:10}, scale: ${3:2}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tcd"
        ],
        "opts": []
      },
      {
        "content": "t.date :${1:title}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tcda"
        ],
        "opts": []
      },
      {
        "content": "t.datetime :${1:title}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tcdt"
        ],
        "opts": []
      },
      {
        "content": "t.float :${1:title}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tcf"
        ],
        "opts": []
      },
      {
        "content": "t.change :${1:name}, :${2:string}, ${3:limit}: ${4:80}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tch"
        ],
        "opts": []
      },
      {
        "content": "t.integer :${1:title}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tci"
        ],
        "opts": []
      },
      {
        "content": "t.integer :lock_version, null: false, default: 0\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tcl"
        ],
        "opts": []
      },
      {
        "content": "t.references :${1:taggable}, polymorphic: { default: '${2:Photo}' }\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tcr"
        ],
        "opts": []
      },
      {
        "content": "t.string :${1:title}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tcs"
        ],
        "opts": []
      },
      {
        "content": "t.text :${1:title}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tct"
        ],
        "opts": []
      },
      {
        "content": "t.time :${1:title}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tcti"
        ],
        "opts": []
      },
      {
        "content": "t.timestamp :${1:title}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tcts"
        ],
        "opts": []
      },
      {
        "content": "t.timestamps\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tctss"
        ],
        "opts": []
      },
      {
        "content": "it { should filter_param :${0:key} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isfp"
        ],
        "opts": []
      },
      {
        "content": "it { should redirect_to ${0:url} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isrt"
        ],
        "opts": []
      },
      {
        "content": "it { should render_template ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isrtp"
        ],
        "opts": []
      },
      {
        "content": "it { should render_with_layout ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isrwl"
        ],
        "opts": []
      },
      {
        "content": "it { should rescue_from ${0:exception} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isrf"
        ],
        "opts": []
      },
      {
        "content": "it { should respond_with ${0:status} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isrw"
        ],
        "opts": []
      },
      {
        "content": "it { should route(:${1:method}, '${0:path}') }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isr"
        ],
        "opts": []
      },
      {
        "content": "it { should set_session :${0:key} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isss"
        ],
        "opts": []
      },
      {
        "content": "it { should set_the_flash('${0}') }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "issf"
        ],
        "opts": []
      },
      {
        "content": "it { should allow_mass_assignment_of :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isama"
        ],
        "opts": []
      },
      {
        "content": "it { should allow_value(${1}).for :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isav"
        ],
        "opts": []
      },
      {
        "content": "it { should ensure_exclusion_of :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isee"
        ],
        "opts": []
      },
      {
        "content": "it { should ensure_inclusion_of :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isei"
        ],
        "opts": []
      },
      {
        "content": "it { should ensure_length_of :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isel"
        ],
        "opts": []
      },
      {
        "content": "it { should validate_acceptance_of :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isva"
        ],
        "opts": []
      },
      {
        "content": "it { should validate_confirmation_of :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isvc"
        ],
        "opts": []
      },
      {
        "content": "it { should validate_numericality_of :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isvn"
        ],
        "opts": []
      },
      {
        "content": "it { should validate_presence_of :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isvp"
        ],
        "opts": []
      },
      {
        "content": "it { should validate_uniqueness_of :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isvu"
        ],
        "opts": []
      },
      {
        "content": "it { should accept_nested_attributes_for :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isana"
        ],
        "opts": []
      },
      {
        "content": "it { should belong_to :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isbt"
        ],
        "opts": []
      },
      {
        "content": "it { should belong_to(:${1}).counter_cache ${0:true} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isbtcc"
        ],
        "opts": []
      },
      {
        "content": "it { should have_and_belong_to_many :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ishbtm"
        ],
        "opts": []
      },
      {
        "content": "it { should be_valid }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isbv"
        ],
        "opts": []
      },
      {
        "content": "it { should have_db_column :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ishc"
        ],
        "opts": []
      },
      {
        "content": "it { should have_db_index :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ishi"
        ],
        "opts": []
      },
      {
        "content": "it { should have_many :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ishm"
        ],
        "opts": []
      },
      {
        "content": "it { should have_many(:${1}).through :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ishmt"
        ],
        "opts": []
      },
      {
        "content": "it { should have_one :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isho"
        ],
        "opts": []
      },
      {
        "content": "it { should have_readonly_attribute :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ishro"
        ],
        "opts": []
      },
      {
        "content": "it { should serialize :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "iss"
        ],
        "opts": []
      },
      {
        "content": "it { should respond_to :${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isres"
        ],
        "opts": []
      },
      {
        "content": "it { should respond_to(:${1}).with(${0}).arguments }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isresw"
        ],
        "opts": []
      },
      {
        "content": "${1:super_class}.instance_method(:${0:method}).bind(self).call",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "super_call"
        ],
        "opts": []
      },
      {
        "content": "render",
        "doc": "",
        "grammar": "snu",
        "label": "render",
        "matches": [
          "rr"
        ],
        "opts": []
      },
      {
        "content": "render action: ",
        "doc": "",
        "grammar": "snu",
        "label": "render :action",
        "matches": [
          "ra"
        ],
        "opts": []
      },
      {
        "content": "render controller: ",
        "doc": "",
        "grammar": "snu",
        "label": "render :controller",
        "matches": [
          "rc"
        ],
        "opts": []
      },
      {
        "content": "render file: ",
        "doc": "",
        "grammar": "snu",
        "label": "render :file",
        "matches": [
          "rf"
        ],
        "opts": []
      },
      {
        "content": "render inline: ",
        "doc": "",
        "grammar": "snu",
        "label": "render :inline",
        "matches": [
          "ri"
        ],
        "opts": []
      },
      {
        "content": "render json: ",
        "doc": "",
        "grammar": "snu",
        "label": "render :json",
        "matches": [
          "rj"
        ],
        "opts": []
      },
      {
        "content": "render layout: ",
        "doc": "",
        "grammar": "snu",
        "label": "render :layout",
        "matches": [
          "rl"
        ],
        "opts": []
      },
      {
        "content": "render partial: ",
        "doc": "",
        "grammar": "snu",
        "label": "render :partial",
        "matches": [
          "rp"
        ],
        "opts": []
      },
      {
        "content": "render text: ",
        "doc": "",
        "grammar": "snu",
        "label": "render :text",
        "matches": [
          "rt"
        ],
        "opts": []
      },
      {
        "content": "render xml: ",
        "doc": "",
        "grammar": "snu",
        "label": "render :xml",
        "matches": [
          "rx"
        ],
        "opts": []
      },
      {
        "content": "distance_of_time_in_words",
        "doc": "",
        "grammar": "snu",
        "label": "distance_of_time_in_words",
        "matches": [
          "dotiw"
        ],
        "opts": []
      },
      {
        "content": "time_ago_in_words",
        "doc": "",
        "grammar": "snu",
        "label": "time_ago_in_words",
        "matches": [
          "taiw"
        ],
        "opts": []
      },
      {
        "content": "redirect_to",
        "doc": "",
        "grammar": "snu",
        "label": "redirect_to",
        "matches": [
          "re"
        ],
        "opts": []
      },
      {
        "content": "redirect_to action: ",
        "doc": "",
        "grammar": "snu",
        "label": "redirect_to :action",
        "matches": [
          "rea"
        ],
        "opts": []
      },
      {
        "content": "redirect_to controller: ",
        "doc": "",
        "grammar": "snu",
        "label": "redirect_to :controller",
        "matches": [
          "rec"
        ],
        "opts": []
      },
      {
        "content": "respond_to",
        "doc": "",
        "grammar": "snu",
        "label": "respond_to",
        "matches": [
          "rst"
        ],
        "opts": []
      },
      {
        "content": "belongs_to",
        "doc": "",
        "grammar": "snu",
        "label": "belongs_to",
        "matches": [
          "bt"
        ],
        "opts": []
      },
      {
        "content": "has_one",
        "doc": "",
        "grammar": "snu",
        "label": "has_one",
        "matches": [
          "ho"
        ],
        "opts": []
      },
      {
        "content": "has_many",
        "doc": "",
        "grammar": "snu",
        "label": "has_many",
        "matches": [
          "hm"
        ],
        "opts": []
      },
      {
        "content": "has_and_belongs_to_many",
        "doc": "",
        "grammar": "snu",
        "label": "has_and_belongs_to_many",
        "matches": [
          "habtm"
        ],
        "opts": []
      },
      {
        "content": "composed_of",
        "doc": "",
        "grammar": "snu",
        "label": "composed_of",
        "matches": [
          "co"
        ],
        "opts": []
      },
      {
        "content": "validates_associated",
        "doc": "",
        "grammar": "snu",
        "label": "validates_associated",
        "matches": [
          "va"
        ],
        "opts": []
      },
      {
        "content": "validates_acceptance_of",
        "doc": "",
        "grammar": "snu",
        "label": "validates_acceptance_of",
        "matches": [
          "vb"
        ],
        "opts": []
      },
      {
        "content": "validates_confirmation_of",
        "doc": "",
        "grammar": "snu",
        "label": "validates_confirmation_of",
        "matches": [
          "vc"
        ],
        "opts": []
      },
      {
        "content": "validates_exclusion_of",
        "doc": "",
        "grammar": "snu",
        "label": "validates_exclusion_of",
        "matches": [
          "ve"
        ],
        "opts": []
      },
      {
        "content": "validates_format_of",
        "doc": "",
        "grammar": "snu",
        "label": "validates_format_of",
        "matches": [
          "vf"
        ],
        "opts": []
      },
      {
        "content": "validates_inclusion_of",
        "doc": "",
        "grammar": "snu",
        "label": "validates_inclusion_of",
        "matches": [
          "vi"
        ],
        "opts": []
      },
      {
        "content": "validates_length_of",
        "doc": "",
        "grammar": "snu",
        "label": "validates_length_of",
        "matches": [
          "vl"
        ],
        "opts": []
      },
      {
        "content": "validates_numericality_of",
        "doc": "",
        "grammar": "snu",
        "label": "validates_numericality_of",
        "matches": [
          "vn"
        ],
        "opts": []
      },
      {
        "content": "validates_presence_of",
        "doc": "",
        "grammar": "snu",
        "label": "validates_presence_of",
        "matches": [
          "vp"
        ],
        "opts": []
      },
      {
        "content": "validates_uniqueness_of",
        "doc": "",
        "grammar": "snu",
        "label": "validates_uniqueness_of",
        "matches": [
          "vu"
        ],
        "opts": []
      },
      {
        "content": "logger.debug",
        "doc": "",
        "grammar": "snu",
        "label": "logger.debug",
        "matches": [
          "logd"
        ],
        "opts": []
      },
      {
        "content": "logger.info",
        "doc": "",
        "grammar": "snu",
        "label": "logger.info",
        "matches": [
          "logi"
        ],
        "opts": []
      },
      {
        "content": "logger.warn",
        "doc": "",
        "grammar": "snu",
        "label": "logger.warn",
        "matches": [
          "logw"
        ],
        "opts": []
      },
      {
        "content": "logger.error",
        "doc": "",
        "grammar": "snu",
        "label": "logger.error",
        "matches": [
          "loge"
        ],
        "opts": []
      },
      {
        "content": "logger.fatal",
        "doc": "",
        "grammar": "snu",
        "label": "logger.fatal",
        "matches": [
          "logf"
        ],
        "opts": []
      },
      {
        "content": "action: ",
        "doc": "",
        "grammar": "snu",
        "label": "action:",
        "matches": [
          "action"
        ],
        "opts": []
      },
      {
        "content": "co________: ",
        "doc": "",
        "grammar": "snu",
        "label": "co________:",
        "matches": [
          "co_"
        ],
        "opts": []
      },
      {
        "content": "id: ",
        "doc": "",
        "grammar": "snu",
        "label": "id:",
        "matches": [
          "id"
        ],
        "opts": []
      },
      {
        "content": "object: ",
        "doc": "",
        "grammar": "snu",
        "label": "object:",
        "matches": [
          "object"
        ],
        "opts": []
      },
      {
        "content": "partial: ",
        "doc": "",
        "grammar": "snu",
        "label": "partial:",
        "matches": [
          "partial"
        ],
        "opts": []
      },
      {
        "content": "accepts_nested_attributes_for :${1:association_name}${2:${3:, allow_destroy: true}${4:, reject_if: proc \\{ |obj| ${5:obj.blank?} \\}}}\n",
        "doc": null,
        "grammar": "snu",
        "label": "accepts_nested_attributes_for",
        "matches": [
          "anaf"
        ],
        "opts": []
      },
      {
        "content": "t.binary :${1:title}${2:, limit: ${3:2}.megabytes}\n$0",
        "doc": null,
        "grammar": "snu",
        "label": "Create binary column",
        "matches": [
          "tcbi"
        ],
        "opts": []
      },
      {
        "content": "t.boolean :${1:title}\n$0",
        "doc": null,
        "grammar": "snu",
        "label": "Create boolean column",
        "matches": [
          "tcb"
        ],
        "opts": []
      },
      {
        "content": "class ${1:Model}Controller < ApplicationController\n\tbefore_action :find_${2:model}\n\n\t$0\n\n\tprivate\n\tdef find_$2\n\t\t@$2 = ${3:$1}.find(params[:id]) if params[:id]\n\tend\nend",
        "doc": null,
        "grammar": "snu",
        "label": "Create controller class",
        "matches": [
          "clac"
        ],
        "opts": []
      },
      {
        "content": "t.date :${1:title}\n$0",
        "doc": null,
        "grammar": "snu",
        "label": "Create date column",
        "matches": [
          "tcda"
        ],
        "opts": []
      },
      {
        "content": "t.datetime :${1:title}\n$0",
        "doc": null,
        "grammar": "snu",
        "label": "Create datetime column",
        "matches": [
          "tcdt"
        ],
        "opts": []
      },
      {
        "content": "t.decimal :${1:title}${2:${3:, precision: ${4:10}}${5:, scale: ${6:2}}}\n$0",
        "doc": null,
        "grammar": "snu",
        "label": "Create decimal column",
        "matches": [
          "tcd"
        ],
        "opts": []
      },
      {
        "content": "t.float :${1:title}\n$0",
        "doc": null,
        "grammar": "snu",
        "label": "Create float column",
        "matches": [
          "tcf"
        ],
        "opts": []
      },
      {
        "content": "require 'test_helper'\n\nclass ${1:Model}ControllerTest < ActionController::TestCase\n\ttest$0\nend\n",
        "doc": null,
        "grammar": "snu",
        "label": "Create functional test class",
        "matches": [
          "clact"
        ],
        "opts": []
      },
      {
        "content": "t.integer :${1:title}\n$0",
        "doc": null,
        "grammar": "snu",
        "label": "Create integer column",
        "matches": [
          "tci"
        ],
        "opts": []
      },
      {
        "content": "t.integer :lock_version, null: false, default: 0\n$0",
        "doc": null,
        "grammar": "snu",
        "label": "Create lock_version column",
        "matches": [
          "tcl"
        ],
        "opts": []
      },
      {
        "content": "t.references :${1:taggable}${2:, polymorphic: ${3:{ default: '${4:Photo}' }}}\n$0",
        "doc": null,
        "grammar": "snu",
        "label": "Create references column",
        "matches": [
          "tcr"
        ],
        "opts": []
      },
      {
        "content": "class ${1:Model}sController < ApplicationController\n\tbefore_action :find_${1/./\\l$0/}, only: [:show, :edit, :update, :destroy]\n\n\t# GET /${1/./\\l$0/}s\n\t# GET /${1/./\\l$0/}s.json\n\tdef index\n\t\t@${1/./\\l$0/}s = ${1:Model}.all\n\n\t\trespond_to do |wants|\n\t\t\twants.html # index.html.erb\n\t\t\twants.json  { render json: @${1/./\\l$0/}s }\n\t\tend\n\tend\n\n\t# GET /${1/./\\l$0/}s/1\n\t# GET /${1/./\\l$0/}s/1.json\n\tdef show\n\t\trespond_to do |wants|\n\t\t\twants.html # show.html.erb\n\t\t\twants.json  { render json: @${1/./\\l$0/} }\n\t\tend\n\tend\n\n\t# GET /${1/./\\l$0/}s/new\n\t# GET /${1/./\\l$0/}s/new.json\n\tdef new\n\t\t@${1/./\\l$0/} = ${1:Model}.new\n\n\t\trespond_to do |wants|\n\t\t\twants.html # new.html.erb\n\t\t\twants.json  { render json: @${1/./\\l$0/} }\n\t\tend\n\tend\n\n\t# GET /${1/./\\l$0/}s/1/edit\n\tdef edit\n\tend\n\n\t# POST /${1/./\\l$0/}s\n\t# POST /${1/./\\l$0/}s.json\n\tdef create\n\t\t@${1/./\\l$0/} = ${1:Model}.new(params[:${1/./\\l$0/}])\n\n\t\trespond_to do |wants|\n\t\t\tif @${1/./\\l$0/}.save\n\t\t\t\tflash[:notice] = '${1:Model} was successfully created.'\n\t\t\t\twants.html { redirect_to(@${1/./\\l$0/}) }\n\t\t\t\twants.json  { render json: @${1/./\\l$0/}, status: :created, location: @${1/./\\l$0/} }\n\t\t\telse\n\t\t\t\twants.html { render action: \"new\" }\n\t\t\t\twants.json  { render json: @${1/./\\l$0/}.errors, status: :unprocessable_entity }\n\t\t\tend\n\t\tend\n\tend\n\n\t# PUT /${1/./\\l$0/}s/1\n\t# PUT /${1/./\\l$0/}s/1.json\n\tdef update\n\t\trespond_to do |wants|\n\t\t\tif @${1/./\\l$0/}.update(params[:${1/./\\l$0/}])\n\t\t\t\tflash[:notice] = '${1:Model} was successfully updated.'\n\t\t\t\twants.html { redirect_to(@${1/./\\l$0/}) }\n\t\t\t\twants.json  { head :ok }\n\t\t\telse\n\t\t\t\twants.html { render action: \"edit\" }\n\t\t\t\twants.json  { render json: @${1/./\\l$0/}.errors, status: :unprocessable_entity }\n\t\t\tend\n\t\tend\n\tend\n\n\t# DELETE /${1/./\\l$0/}s/1\n\t# DELETE /${1/./\\l$0/}s/1.json\n\tdef destroy\n\t\t@${1/./\\l$0/}.destroy\n\n\t\trespond_to do |wants|\n\t\t\twants.html { redirect_to(${1/./\\l$0/}s_url) }\n\t\t\twants.json  { head :ok }\n\t\tend\n\tend\n\n\tprivate\n\t\tdef find_${1/./\\l$0/}\n\t\t\t@${1/./\\l$0/} = ${1:Model}.find(params[:id])\n\t\tend\n\nend\n",
        "doc": null,
        "grammar": "snu",
        "label": "Create resources controller class",
        "matches": [
          "resources"
        ],
        "opts": []
      },
      {
        "content": "t.string :${1:title}\n$0",
        "doc": null,
        "grammar": "snu",
        "label": "Create string column",
        "matches": [
          "tcs"
        ],
        "opts": []
      },
      {
        "content": "t.text :${1:title}\n$0",
        "doc": null,
        "grammar": "snu",
        "label": "Create text column",
        "matches": [
          "tct"
        ],
        "opts": []
      },
      {
        "content": "t.time :${1:title}\n$0",
        "doc": null,
        "grammar": "snu",
        "label": "Create time column",
        "matches": [
          "tcti"
        ],
        "opts": []
      },
      {
        "content": "t.timestamp :${1:title}\n$0",
        "doc": null,
        "grammar": "snu",
        "label": "Create timestamp column",
        "matches": [
          "tcts"
        ],
        "opts": []
      },
      {
        "content": "t.timestamps\n$0",
        "doc": null,
        "grammar": "snu",
        "label": "Create timestamps columns",
        "matches": [
          "tctss"
        ],
        "opts": []
      },
      {
        "content": "t.column ${1:title}, :${2:string}\n$0",
        "doc": null,
        "grammar": "snu",
        "label": "Migration Create Column (mcc)",
        "matches": [
          "mcol"
        ],
        "opts": []
      },
      {
        "content": "t.column ${1:title}, :${2:string}\nmccc$0",
        "doc": null,
        "grammar": "snu",
        "label": "Migration Create Column Continue (mccc)",
        "matches": [
          "mccc"
        ],
        "opts": []
      },
      {
        "content": "drop_table :${1:table}${2: [press tab twice to generate create_table]}",
        "doc": null,
        "grammar": "snu",
        "label": "Migration Drop Create Table (mdct)",
        "matches": [
          "mtab"
        ],
        "opts": []
      },
      {
        "content": "remove_column :${1:table}, :${2:column}${3: [press tab twice to generate add_column]}",
        "doc": null,
        "grammar": "snu",
        "label": "Migration Remove and Add Column (mrac)",
        "matches": [
          "mcol"
        ],
        "opts": []
      },
      {
        "content": "RAILS_DEFAULT_LOGGER.debug \"${1:message}\"$0",
        "doc": null,
        "grammar": "snu",
        "label": "RAILS_DEFAULT_LOGGER.debug (rdb)",
        "matches": [
          "rdb"
        ],
        "opts": []
      },
      {
        "content": "t.rename(:${1:old_column_name}, :${2:new_column_name})\n$0",
        "doc": null,
        "grammar": "snu",
        "label": "Table column(s) rename",
        "matches": [
          "tre"
        ],
        "opts": []
      },
      {
        "content": "assert_redirected_to ${2:action: \"${1:index}\"}",
        "doc": null,
        "grammar": "snu",
        "label": "Test Assert Redirected To (art)",
        "matches": [
          "art"
        ],
        "opts": []
      },
      {
        "content": "assert_response :${1:success}, @response.body$0",
        "doc": null,
        "grammar": "snu",
        "label": "Test Assert Response (are)",
        "matches": [
          "asre"
        ],
        "opts": []
      },
      {
        "content": "after_create $0",
        "doc": null,
        "grammar": "snu",
        "label": "after_create",
        "matches": [
          "aftc"
        ],
        "opts": []
      },
      {
        "content": "after_destroy $0",
        "doc": null,
        "grammar": "snu",
        "label": "after_destroy",
        "matches": [
          "aftd"
        ],
        "opts": []
      },
      {
        "content": "after_save $0",
        "doc": null,
        "grammar": "snu",
        "label": "after_save",
        "matches": [
          "afts"
        ],
        "opts": []
      },
      {
        "content": "after_update $0",
        "doc": null,
        "grammar": "snu",
        "label": "after_update",
        "matches": [
          "aftu"
        ],
        "opts": []
      },
      {
        "content": "after_validation $0",
        "doc": null,
        "grammar": "snu",
        "label": "after_validation",
        "matches": [
          "aftv"
        ],
        "opts": []
      },
      {
        "content": "after_validation_on_create $0",
        "doc": null,
        "grammar": "snu",
        "label": "after_validation_on_create",
        "matches": [
          "aftvoc"
        ],
        "opts": []
      },
      {
        "content": "after_validation_on_update $0",
        "doc": null,
        "grammar": "snu",
        "label": "after_validation_on_update",
        "matches": [
          "aftvou"
        ],
        "opts": []
      },
      {
        "content": "assert(${1:var} = assigns(:$1), \"Cannot find @$1\")\n$0",
        "doc": null,
        "grammar": "snu",
        "label": "assert(var = assigns(:var))",
        "matches": [
          "asg"
        ],
        "opts": []
      },
      {
        "content": "assert_difference \"${1:Model}.${2:count}\", ${3:1} do\n\t$0\nend",
        "doc": null,
        "grammar": "snu",
        "label": "assert_difference",
        "matches": [
          "asd"
        ],
        "opts": []
      },
      {
        "content": "assert_no_difference \"${1:Model}.${2:count}\" do\n\t$0\nend",
        "doc": null,
        "grammar": "snu",
        "label": "assert_no_difference",
        "matches": [
          "asnd"
        ],
        "opts": []
      },
      {
        "content": "assert_redirected_to ${10:${2:parent}_${3:child}_path(${4:@}${5:$2})}",
        "doc": null,
        "grammar": "snu",
        "label": "assert_redirected_to (nested path plural)",
        "matches": [
          "artnpp"
        ],
        "opts": []
      },
      {
        "content": "assert_redirected_to ${2:${12:parent}_${13:child}_path(${14:@}${15:$12}, ${16:@}${17:$13})}",
        "doc": null,
        "grammar": "snu",
        "label": "assert_redirected_to (nested path)",
        "matches": [
          "artnp"
        ],
        "opts": []
      },
      {
        "content": "assert_redirected_to ${10:${2:model}s_path}",
        "doc": null,
        "grammar": "snu",
        "label": "assert_redirected_to (path plural)",
        "matches": [
          "artpp"
        ],
        "opts": []
      },
      {
        "content": "assert_redirected_to ${2:${12:model}_path(${13:@}${14:$12})}",
        "doc": null,
        "grammar": "snu",
        "label": "assert_redirected_to (path)",
        "matches": [
          "artp"
        ],
        "opts": []
      },
      {
        "content": "assert_rjs :${1:replace}, ${2:\"${3:dom id}\"}",
        "doc": null,
        "grammar": "snu",
        "label": "assert_rjs",
        "matches": [
          "asrj"
        ],
        "opts": []
      },
      {
        "content": "assert_select '${1:path}'${2:, ${3:text}: ${4:'${5:inner_html}'}}${6: do\n\t$0\nend}",
        "doc": null,
        "grammar": "snu",
        "label": "assert_select",
        "matches": [
          "ass"
        ],
        "opts": []
      },
      {
        "content": "before_create $0",
        "doc": null,
        "grammar": "snu",
        "label": "before_create",
        "matches": [
          "befc"
        ],
        "opts": []
      },
      {
        "content": "before_destroy $0",
        "doc": null,
        "grammar": "snu",
        "label": "before_destroy",
        "matches": [
          "befd"
        ],
        "opts": []
      },
      {
        "content": "before_save $0",
        "doc": null,
        "grammar": "snu",
        "label": "before_save",
        "matches": [
          "befs"
        ],
        "opts": []
      },
      {
        "content": "before_update $0",
        "doc": null,
        "grammar": "snu",
        "label": "before_update",
        "matches": [
          "befu"
        ],
        "opts": []
      },
      {
        "content": "before_validation $0",
        "doc": null,
        "grammar": "snu",
        "label": "before_validation",
        "matches": [
          "befv"
        ],
        "opts": []
      },
      {
        "content": "before_validation_on_create $0",
        "doc": null,
        "grammar": "snu",
        "label": "before_validation_on_create",
        "matches": [
          "befvoc"
        ],
        "opts": []
      },
      {
        "content": "before_validation_on_update",
        "doc": null,
        "grammar": "snu",
        "label": "before_validation_on_update",
        "matches": [
          "befvou"
        ],
        "opts": []
      },
      {
        "content": "belongs_to :${1:object}${2:, class_name: \"${3:${1/[[:alpha:]]+|(_)/(?1::\\u$0)/g}}\", foreign_key: \"${4:$1_id}\"}",
        "doc": null,
        "grammar": "snu",
        "label": "belongs_to (bt)",
        "matches": [
          "bt"
        ],
        "opts": []
      },
      {
        "content": "cattr_accessor :${0:attr_names}",
        "doc": null,
        "grammar": "snu",
        "label": "cattr_accessor",
        "matches": [
          "crw"
        ],
        "opts": []
      },
      {
        "content": "def create\n\t@${1:model} = ${2:${1/[[:alpha:]]+|(_)/(?1::\\u$0)/g}}.new(params[:$1])\n\t$0\n\trespond_to do |wants|\n\t\tif @$1.save\n\t\t\tflash[:notice] = '$2 was successfully created.'\n\t\t\twants.html { redirect_to(@$1) }\n\t\t\twants.json { render json: @$1, status: :created, location: @$1 }\n\t\telse\n\t\t\twants.html { render action: \"new\" }\n\t\t\twants.json { render json: @$1.errors, status: :unprocessable_entity }\n\t\tend\n\tend\nend\n",
        "doc": null,
        "grammar": "snu",
        "label": "def create - resource",
        "matches": [
          "defcreate"
        ],
        "opts": []
      },
      {
        "content": "test \"${1:something interesting}\" do\n\t$0\nend",
        "doc": null,
        "grammar": "snu",
        "label": "test do..end",
        "matches": [
          "test"
        ],
        "opts": []
      },
      {
        "content": "def test_should_get_${1:action}\n\t${2:@${3:model} = ${4:$3s}(:${5:fixture_name})\n\t}get :$1${6:, id: @$3.to_param}\n\tassert_response :success\n\t$0\nend",
        "doc": null,
        "grammar": "snu",
        "label": "def get request",
        "matches": [
          "deftg"
        ],
        "opts": []
      },
      {
        "content": "def test_should_post_${1:action}\n\t${3:@$2 = ${4:$2s}(:${5:fixture_name})\n\t}post :$1${6:, id: @$2.to_param}, ${2:model}: { $0 }\n\tassert_response :redirect\n\nend",
        "doc": null,
        "grammar": "snu",
        "label": "def post request",
        "matches": [
          "deftp"
        ],
        "opts": []
      },
      {
        "content": "find(:all${1:, conditions: ['${2:${3:field} = ?}', ${5:true}]})",
        "doc": null,
        "grammar": "snu",
        "label": "find(:all)",
        "matches": [
          "fina"
        ],
        "opts": []
      },
      {
        "content": "find(:first${1:, conditions: ['${2:${3:field} = ?}', ${5:true}]})",
        "doc": null,
        "grammar": "snu",
        "label": "find(:first)",
        "matches": [
          "finf"
        ],
        "opts": []
      },
      {
        "content": "find(${1:id})",
        "doc": null,
        "grammar": "snu",
        "label": "find(id)",
        "matches": [
          "fini"
        ],
        "opts": []
      },
      {
        "content": "find_each(${1conditions: {:${2:field}: ${3:true}\\}}) do |${4:${TM_CURRENT_WORD/(\\w+)\\./\\L$1/g}}|\n\t$0\nend",
        "doc": null,
        "grammar": "snu",
        "label": "find_each",
        "matches": [
          "fine"
        ],
        "opts": []
      },
      {
        "content": "find_in_batches(${1conditions: {:${2:field}: ${3:true}\\}}) do |${4:${TM_CURRENT_WORD/(\\w+)\\./\\L$1/g}}s|\n\t$4s.each do |$4|\n\t\t$0\n\tend\nend",
        "doc": null,
        "grammar": "snu",
        "label": "find_in_batches",
        "matches": [
          "finb"
        ],
        "opts": []
      },
      {
        "content": "has_and_belongs_to_many :${1:object}${2:, join_table: \"${3:table_name}\", foreign_key: \"${4:$1_id}\"}",
        "doc": null,
        "grammar": "snu",
        "label": "has_and_belongs_to_many (habtm)",
        "matches": [
          "habtm"
        ],
        "opts": []
      },
      {
        "content": "has_many :${1:object}s${2:, class_name: \"$1\", foreign_key: \"${4:reference}_id\"}",
        "doc": null,
        "grammar": "snu",
        "label": "has_many (hm)",
        "matches": [
          "hm"
        ],
        "opts": []
      },
      {
        "content": "has_many :${1:objects}, through: :${2:join_association}${3:, source: :${4:$2_table_foreign_key_to_$1_table}}",
        "doc": null,
        "grammar": "snu",
        "label": "has_many (through)",
        "matches": [
          "hmt"
        ],
        "opts": []
      },
      {
        "content": "has_many :${1:object}s${2:, class_name: \"$1\", foreign_key: \"${4:reference}_id\"}, dependent: :destroy$0",
        "doc": null,
        "grammar": "snu",
        "label": "has_many dependent: :destroy",
        "matches": [
          "hmd"
        ],
        "opts": []
      },
      {
        "content": "has_one :${1:object}${2:, class_name: \"${3:${1/[[:alpha:]]+|(_)/(?1::\\u$0)/g}}\", foreign_key: \"${4:$1_id}\"}",
        "doc": null,
        "grammar": "snu",
        "label": "has_one (ho)",
        "matches": [
          "ho"
        ],
        "opts": []
      },
      {
        "content": "${1:Rails.}logger.debug { \"${1:message}\" }$0",
        "doc": null,
        "grammar": "snu",
        "label": "logger.debug",
        "matches": [
          "logd"
        ],
        "opts": []
      },
      {
        "content": "logger.error { \"${1:message}\" }$0",
        "doc": null,
        "grammar": "snu",
        "label": "logger.error",
        "matches": [
          "loge"
        ],
        "opts": []
      },
      {
        "content": "logger.fatal { \"${1:message}\" }$0",
        "doc": null,
        "grammar": "snu",
        "label": "logger.fatal",
        "matches": [
          "logf"
        ],
        "opts": []
      },
      {
        "content": "logger.info { \"${1:message}\" }$0",
        "doc": null,
        "grammar": "snu",
        "label": "logger.info",
        "matches": [
          "logi"
        ],
        "opts": []
      },
      {
        "content": "logger.warn { \"${1:message}\" }$0",
        "doc": null,
        "grammar": "snu",
        "label": "logger.warn",
        "matches": [
          "logw"
        ],
        "opts": []
      },
      {
        "content": "map(&:${1:id})",
        "doc": null,
        "grammar": "snu",
        "label": "map(&:sym_proc)",
        "matches": [
          "mp"
        ],
        "opts": []
      },
      {
        "content": "${1:map}.catch_all \"*${2:anything}\", controller: \"${3:default}\", action: \"${4:error}\"\n",
        "doc": null,
        "grammar": "snu",
        "label": "map.catch_all",
        "matches": [
          "mapca"
        ],
        "opts": []
      },
      {
        "content": "${1:map}.${2:connect} '${3::controller/:action/:id}'",
        "doc": null,
        "grammar": "snu",
        "label": "map.named_route",
        "matches": [
          "map"
        ],
        "opts": []
      },
      {
        "content": "${1:map}.resource :${2:resource}${10: do |${11:$2}|\n\t$0\nend}",
        "doc": null,
        "grammar": "snu",
        "label": "map.resource",
        "matches": [
          "mapr"
        ],
        "opts": []
      },
      {
        "content": "${1:map}.resources :${2:resource}${10: do |${11:$2}|\n\t$0\nend}",
        "doc": null,
        "grammar": "snu",
        "label": "map.resources",
        "matches": [
          "maprs"
        ],
        "opts": []
      },
      {
        "content": "${1map}.with_options :${2:controller}: '${3:thing}' do |${4:$3}|\n\t$0\nend\n",
        "doc": null,
        "grammar": "snu",
        "label": "map.with_options",
        "matches": [
          "mapwo"
        ],
        "opts": []
      },
      {
        "content": "mattr_accessor :${0:attr_names}",
        "doc": null,
        "grammar": "snu",
        "label": "mattr_accessor",
        "matches": [
          "mrw"
        ],
        "opts": []
      },
      {
        "content": "named_scope :name, lambda { |${1param}| { :conditions: ${3:['${4:${5:field} = ?}', ${6:$1}]} } }\n",
        "doc": null,
        "grammar": "snu",
        "label": "named_scope lambda",
        "matches": [
          "ncl"
        ],
        "opts": []
      },
      {
        "content": "named_scope :name${1:, joins: :${2:table}}, conditions: ${3:['${4:${5:field} = ?}', ${6:true}]}\n",
        "doc": null,
        "grammar": "snu",
        "label": "named_scope",
        "matches": [
          "nc"
        ],
        "opts": []
      },
      {
        "content": "default_scope ${1:order(${2:'${3:created_at DESC}'})}",
        "doc": null,
        "grammar": "snu",
        "label": "default_scope",
        "matches": [
          "dscope"
        ],
        "opts": []
      },
      {
        "content": "flash[:${1:notice}] = \"${2:Successfully created...}\"$0",
        "doc": null,
        "grammar": "snu",
        "label": "flash[...]",
        "matches": [
          "flash"
        ],
        "opts": []
      },
      {
        "content": "redirect_to action: \"${1:index}\"",
        "doc": null,
        "grammar": "snu",
        "label": "redirect_to (action)",
        "matches": [
          "rea"
        ],
        "opts": []
      },
      {
        "content": "redirect_to action: \"${1:show}\", id: ${0:@item}",
        "doc": null,
        "grammar": "snu",
        "label": "redirect_to (action, id)",
        "matches": [
          "reai"
        ],
        "opts": []
      },
      {
        "content": "redirect_to controller: \"${1:items}\"",
        "doc": null,
        "grammar": "snu",
        "label": "redirect_to (controller)",
        "matches": [
          "rec"
        ],
        "opts": []
      },
      {
        "content": "redirect_to controller: \"${1:items}\", action: \"${2:list}\"",
        "doc": null,
        "grammar": "snu",
        "label": "redirect_to (controller, action)",
        "matches": [
          "reca"
        ],
        "opts": []
      },
      {
        "content": "redirect_to controller: \"${1:items}\", action: \"${2:show}\", id: ${0:@item}",
        "doc": null,
        "grammar": "snu",
        "label": "redirect_to (controller, action, id)",
        "matches": [
          "recai"
        ],
        "opts": []
      },
      {
        "content": "redirect_to(${2:${10:parent}_${11:child}_path(${12:@}${13:$10})})",
        "doc": null,
        "grammar": "snu",
        "label": "redirect_to (nested path plural)",
        "matches": [
          "renpp"
        ],
        "opts": []
      },
      {
        "content": "redirect_to(${2:${12:parent}_${13:child}_path(${14:@}${15:$12}, ${16:@}${17:$13})})",
        "doc": null,
        "grammar": "snu",
        "label": "redirect_to (nested path)",
        "matches": [
          "renp"
        ],
        "opts": []
      },
      {
        "content": "redirect_to(${2:${10:model}s_path})",
        "doc": null,
        "grammar": "snu",
        "label": "redirect_to (path plural)",
        "matches": [
          "repp"
        ],
        "opts": []
      },
      {
        "content": "redirect_to(${2:${12:model}_path(${13:@}${14:$12})})",
        "doc": null,
        "grammar": "snu",
        "label": "redirect_to (path)",
        "matches": [
          "rep"
        ],
        "opts": []
      },
      {
        "content": "redirect_to :back",
        "doc": null,
        "grammar": "snu",
        "label": "redirect_to :back",
        "matches": [
          "reb"
        ],
        "opts": []
      },
      {
        "content": "render action: \"${1:action}\"",
        "doc": null,
        "grammar": "snu",
        "label": "render (action)... (ra)",
        "matches": [
          "ra"
        ],
        "opts": []
      },
      {
        "content": "render action: \"${1:action}\", layout: \"${2:layoutname}\"",
        "doc": null,
        "grammar": "snu",
        "label": "render (action,layout) (ral)",
        "matches": [
          "ral"
        ],
        "opts": []
      },
      {
        "content": "render file: \"${1:filepath}\"",
        "doc": null,
        "grammar": "snu",
        "label": "render (file) (rf)",
        "matches": [
          "rf"
        ],
        "opts": []
      },
      {
        "content": "render file: \"${1:filepath}\", use_full_path: ${2:false}",
        "doc": null,
        "grammar": "snu",
        "label": "render (file,use_full_path) (rfu)",
        "matches": [
          "rfu"
        ],
        "opts": []
      },
      {
        "content": "render inline: \"${1:<%= 'hello' %>}\"",
        "doc": null,
        "grammar": "snu",
        "label": "render (inline) (ri)",
        "matches": [
          "ri"
        ],
        "opts": []
      },
      {
        "content": "render inline: \"${1:<%= 'hello' %>}\", locals { ${2::name}: \"${3:value}\"$4 }",
        "doc": null,
        "grammar": "snu",
        "label": "render (inline,locals) (ril)",
        "matches": [
          "ril"
        ],
        "opts": []
      },
      {
        "content": "render inline: \"${1:<%= 'hello' %>}\", type: ${2::rjson}",
        "doc": null,
        "grammar": "snu",
        "label": "render (inline,type) (rit)",
        "matches": [
          "rit"
        ],
        "opts": []
      },
      {
        "content": "render layout: \"${1:layoutname}\"",
        "doc": null,
        "grammar": "snu",
        "label": "render (layout) (rl)",
        "matches": [
          "rl"
        ],
        "opts": []
      },
      {
        "content": "render nothing: ${1:true}",
        "doc": null,
        "grammar": "snu",
        "label": "render (nothing) (rn)",
        "matches": [
          "rn"
        ],
        "opts": []
      },
      {
        "content": "render nothing: ${1:true}, status: ${2:401}",
        "doc": null,
        "grammar": "snu",
        "label": "render (nothing,status) (rns)",
        "matches": [
          "rns"
        ],
        "opts": []
      },
      {
        "content": "render text: \"${1:text to render...}\"",
        "doc": null,
        "grammar": "snu",
        "label": "render (text) (rt)",
        "matches": [
          "rt"
        ],
        "opts": []
      },
      {
        "content": "render text: \"${1:text to render...}\", layout: \"${2:layoutname}\"",
        "doc": null,
        "grammar": "snu",
        "label": "render (text,layout) (rtl)",
        "matches": [
          "rtl"
        ],
        "opts": []
      },
      {
        "content": "render text: \"${1:text to render...}\", layout: ${2:true}",
        "doc": null,
        "grammar": "snu",
        "label": "render (text,layout => true) (rtlt)",
        "matches": [
          "rtlt"
        ],
        "opts": []
      },
      {
        "content": "render text: \"${1:text to render...}\", status: ${2:401}",
        "doc": null,
        "grammar": "snu",
        "label": "render (text,status) (rts)",
        "matches": [
          "rts"
        ],
        "opts": []
      },
      {
        "content": "render :update do |${2:page}|\n\t$2.$0\nend",
        "doc": null,
        "grammar": "snu",
        "label": "render (update)",
        "matches": [
          "ru"
        ],
        "opts": []
      },
      {
        "content": "respond_to do |wants|\n\twants.${1:html}${2: { $0 }}\nend",
        "doc": null,
        "grammar": "snu",
        "label": "respond_to",
        "matches": [
          "rest"
        ],
        "opts": []
      },
      {
        "content": "returning ${1:variable} do${2/(^(?<var>\\s*[a-z_][a-zA-Z0-9_]*\\s*)(,\\g<var>)*,?\\s*$)|.*/(?1: |)/}${2:v}${2/(^(?<var>\\s*[a-z_][a-zA-Z0-9_]*\\s*)(,\\g<var>)*,?\\s*$)|.*/(?1:|)/}\n\t$0\nend",
        "doc": null,
        "grammar": "snu",
        "label": "returning do |variable| ... end",
        "matches": [
          "returning"
        ],
        "opts": []
      },
      {
        "content": "class Migration${1/(?:^|_)(\\w)/\\u$1/g} < ApplicationRecord\n\tself.table_name = :${1:model_name}s\nend",
        "doc": null,
        "grammar": "snu",
        "label": "Create Migration Model Class",
        "matches": [
          "cmm"
        ],
        "opts": []
      },
      {
        "content": "t.binary :${1:title}${2:, limit: ${3:2}.megabytes}\nt.$0",
        "doc": null,
        "grammar": "snu",
        "label": "t.binary (tcbi)",
        "matches": [
          "t."
        ],
        "opts": []
      },
      {
        "content": "t.boolean :${1:title}\nt.$0",
        "doc": null,
        "grammar": "snu",
        "label": "t.boolean (tcb)",
        "matches": [
          "t."
        ],
        "opts": []
      },
      {
        "content": "t.date :${1:title}\nt.$0",
        "doc": null,
        "grammar": "snu",
        "label": "t.date (tcda)",
        "matches": [
          "t."
        ],
        "opts": []
      },
      {
        "content": "t.datetime :${1:title}\nt.$0",
        "doc": null,
        "grammar": "snu",
        "label": "t.datetime (tcdt)",
        "matches": [
          "t."
        ],
        "opts": []
      },
      {
        "content": "t.decimal :${1:title}${2:${3:, precision: ${4:10}}${5:, scale: ${6:2}}}\nt.$0",
        "doc": null,
        "grammar": "snu",
        "label": "t.decimal (tcd)",
        "matches": [
          "t."
        ],
        "opts": []
      },
      {
        "content": "t.float :${1:title}\nt.$0",
        "doc": null,
        "grammar": "snu",
        "label": "t.float (tcf)",
        "matches": [
          "t."
        ],
        "opts": []
      },
      {
        "content": "t.integer :${1:title}\nt.$0",
        "doc": null,
        "grammar": "snu",
        "label": "t.integer (tci)",
        "matches": [
          "t."
        ],
        "opts": []
      },
      {
        "content": "t.integer :lock_version, null: false, default: 0\nt.$0",
        "doc": null,
        "grammar": "snu",
        "label": "t.lock_version (tcl)",
        "matches": [
          "t."
        ],
        "opts": []
      },
      {
        "content": "t.references :${1:taggable}${2:, polymorphic: ${3:{ default: '${4:Photo}' }}}\nt.$0",
        "doc": null,
        "grammar": "snu",
        "label": "t.references (tcr)",
        "matches": [
          "t."
        ],
        "opts": []
      },
      {
        "content": "t.rename(:${1:old_column_name}, :${2:new_column_name})\nt.$0",
        "doc": null,
        "grammar": "snu",
        "label": "t.rename (tre)",
        "matches": [
          "t."
        ],
        "opts": []
      },
      {
        "content": "t.string :${1:title}\nt.$0",
        "doc": null,
        "grammar": "snu",
        "label": "t.string (tcs)",
        "matches": [
          "t."
        ],
        "opts": []
      },
      {
        "content": "t.text :${1:title}\nt.$0",
        "doc": null,
        "grammar": "snu",
        "label": "t.text (tct)",
        "matches": [
          "t."
        ],
        "opts": []
      },
      {
        "content": "t.time :${1:title}\nt.$0",
        "doc": null,
        "grammar": "snu",
        "label": "t.time (tcti)",
        "matches": [
          "t."
        ],
        "opts": []
      },
      {
        "content": "t.timestamp :${1:title}\nt.$0",
        "doc": null,
        "grammar": "snu",
        "label": "t.timestamp (tcts)",
        "matches": [
          "t."
        ],
        "opts": []
      },
      {
        "content": "t.timestamps\nt.$0",
        "doc": null,
        "grammar": "snu",
        "label": "t.timestamps (tctss)",
        "matches": [
          "t."
        ],
        "opts": []
      },
      {
        "content": "validates_acceptance_of :${1:terms}${2:${3:, accept: \"${4:1}\"}${5:, message: \"${6:You must accept the terms of service}\"}}, if: proc { |obj| ${7:obj.condition?} }}",
        "doc": null,
        "grammar": "snu",
        "label": "validates_acceptance_of if",
        "matches": [
          "vaoif"
        ],
        "opts": []
      },
      {
        "content": "validates :${1:terms}${2:, acceptance: ${3:{ accept: \"${4:1}\"${5:, message: \"${6:You must accept the terms of service}\"}}} }",
        "doc": null,
        "grammar": "snu",
        "label": "validates_acceptance_of",
        "matches": [
          "vao"
        ],
        "opts": []
      },
      {
        "content": "validates_associated :${1:attribute}${2:, on: :${3:create}}",
        "doc": null,
        "grammar": "snu",
        "label": "validates_associated (va)",
        "matches": [
          "va"
        ],
        "opts": []
      },
      {
        "content": "validates_associated :${1:attribute}${2:, on: :${3:create}, if: proc { |obj| ${5:obj.condition?} }}",
        "doc": null,
        "grammar": "snu",
        "label": "validates_associated if (vaif)",
        "matches": [
          "vaif"
        ],
        "opts": []
      },
      {
        "content": "validates_confirmation_of :${1:attribute}${2:, on: :${3:create}, message: \"${4:should match confirmation}\"}",
        "doc": null,
        "grammar": "snu",
        "label": "validates_confirmation_of (vc)",
        "matches": [
          "vc"
        ],
        "opts": []
      },
      {
        "content": "validates_confirmation_of :${1:attribute}${2:, on: :${3:create}, message: \"${4:should match confirmation}\", if: proc { |obj| ${5:obj.condition?} }}",
        "doc": null,
        "grammar": "snu",
        "label": "validates_confirmation_of if (vcif)",
        "matches": [
          "vcif"
        ],
        "opts": []
      },
      {
        "content": "validates_exclusion_of :${1:attribute}${2:, in: ${3:%w( ${4:mov avi} )}, on: :${5:create}, message: \"${6:extension %s is not allowed}\"}",
        "doc": null,
        "grammar": "snu",
        "label": "validates_exclusion_of (ve)",
        "matches": [
          "ve"
        ],
        "opts": []
      },
      {
        "content": "validates_exclusion_of :${1:attribute}${2:, in: ${3:%w( ${4:mov avi} )}, on: :${5:create}, message: \"${6:extension %s is not allowed}\"}, if: proc { |obj| ${7:obj.condition?} }}",
        "doc": null,
        "grammar": "snu",
        "label": "validates_exclusion_of if (veif)",
        "matches": [
          "veif"
        ],
        "opts": []
      },
      {
        "content": "validates_format_of :${1:attribute}, with: /${2:^[${3:\\w\\d}]+\\$}/${4:, on: :${5:create}, message: \"${6:is invalid}\"}, if: proc { |obj| ${7:obj.condition?} }}",
        "doc": null,
        "grammar": "snu",
        "label": "validates_format_of if",
        "matches": [
          "vfif"
        ],
        "opts": []
      },
      {
        "content": "validates_format_of :${1:attribute}, with: /${2:^[${3:\\w\\d}]+\\$}/${4:, on: :${5:create}, message: \"${6:is invalid}\"}",
        "doc": null,
        "grammar": "snu",
        "label": "validates_format_of",
        "matches": [
          "vf"
        ],
        "opts": []
      },
      {
        "content": "validates_inclusion_of :${1:attribute}${2:, in: ${3:%w( ${4:mov avi} )}, on: :${5:create}, message: \"${6:extension %s is not included in the list}\"}, if: proc { |obj| ${7:obj.condition?} }}",
        "doc": null,
        "grammar": "snu",
        "label": "validates_inclusion_of if",
        "matches": [
          "viif"
        ],
        "opts": []
      },
      {
        "content": "validates_inclusion_of :${1:attribute}${2:, in: ${3:%w( ${4:mov avi} )}, on: :${5:create}, message: \"${6:extension %s is not included in the list}\"}",
        "doc": null,
        "grammar": "snu",
        "label": "validates_inclusion_of",
        "matches": [
          "vi"
        ],
        "opts": []
      },
      {
        "content": "validates_length_of :${1:attribute}, within: ${2:3..20}${3:, on: :${4:create}, message: \"${5:must be present}\"}",
        "doc": null,
        "grammar": "snu",
        "label": "validates_length_of (vl)",
        "matches": [
          "vl"
        ],
        "opts": []
      },
      {
        "content": "validates_length_of :${1:attribute}, within: ${2:3..20}${3:, on: :${4:create}, message: \"${5:must be present}\"}, if: proc { |obj| ${6:obj.condition?} }}",
        "doc": null,
        "grammar": "snu",
        "label": "validates_length_of if",
        "matches": [
          "vlif"
        ],
        "opts": []
      },
      {
        "content": "validates_numericality_of :${1:attribute}${2:, on: :${3:create}, message: \"${4:is not a number}\"}, if: proc { |obj| ${5:obj.condition?} }}",
        "doc": null,
        "grammar": "snu",
        "label": "validates_numericality_of if",
        "matches": [
          "vnif"
        ],
        "opts": []
      },
      {
        "content": "validates_numericality_of :${1:attribute}${2:, on: :${3:create}, message: \"${4:is not a number}\"}",
        "doc": null,
        "grammar": "snu",
        "label": "validates_numericality_of",
        "matches": [
          "vn"
        ],
        "opts": []
      },
      {
        "content": "validates_presence_of :${1:attribute}${2:, on: :${3:create}, message: \"${4:can't be blank}\"}",
        "doc": null,
        "grammar": "snu",
        "label": "validates_presence_of (vp)",
        "matches": [
          "vp"
        ],
        "opts": []
      },
      {
        "content": "validates_presence_of :${1:attribute}${2:, on: :${3:create}, message: \"${4:can't be blank}\"}, if: proc { |obj| ${5:obj.condition?} }}",
        "doc": null,
        "grammar": "snu",
        "label": "validates_presence_of if (vpif) 2",
        "matches": [
          "vpif"
        ],
        "opts": []
      },
      {
        "content": "validates_uniqueness_of :${1:attribute}${2:, on: :${3:create}, message: \"${4:must be unique}\"}",
        "doc": null,
        "grammar": "snu",
        "label": "validates_uniqueness_of (vu)",
        "matches": [
          "vu"
        ],
        "opts": []
      },
      {
        "content": "validates_uniqueness_of :${1:attribute}${2:, on: :${3:create}, message: \"${4:must be unique}\", if: proc { |obj| ${6:obj.condition?} }}",
        "doc": null,
        "grammar": "snu",
        "label": "validates_uniqueness_of if (vuif)",
        "matches": [
          "vuif"
        ],
        "opts": []
      },
      {
        "content": "verify only: [:$1], method: :post, render {:status: 500, text: \"use HTTP-POST\"}\n",
        "doc": null,
        "grammar": "snu",
        "label": "verify -- render",
        "matches": [
          "verify"
        ],
        "opts": []
      },
      {
        "content": "verify only: [:$1], session: :user, params: :id, redirect_to {:action: '${2:index}'}\n",
        "doc": null,
        "grammar": "snu",
        "label": "verify -- redirect",
        "matches": [
          "verify"
        ],
        "opts": []
      },
      {
        "content": "wants.${1:js|json|html}${2: { $0 }}",
        "doc": null,
        "grammar": "snu",
        "label": "wants_format",
        "matches": [
          "wants"
        ],
        "opts": []
      },
      {
        "content": "xhr :delete, :${1:destroy}, id: ${2:1}$0",
        "doc": null,
        "grammar": "snu",
        "label": "xhr delete",
        "matches": [
          "xdelete"
        ],
        "opts": []
      },
      {
        "content": "xhr :get, :${1:show}${2:, id: ${3:1}}$0",
        "doc": null,
        "grammar": "snu",
        "label": "xhr get",
        "matches": [
          "xget"
        ],
        "opts": []
      },
      {
        "content": "xhr :post, :${1:create}, ${2:object}: { $3 }",
        "doc": null,
        "grammar": "snu",
        "label": "xhr post",
        "matches": [
          "xpost"
        ],
        "opts": []
      },
      {
        "content": "xhr :put, :${1:update}, id: ${2:1}, ${3:object}: { $4 }$0",
        "doc": null,
        "grammar": "snu",
        "label": "xhr put",
        "matches": [
          "xput"
        ],
        "opts": []
      },
      {
        "content": "class ${1:Model}Sweeper < ActionController::Caching::Sweeper\n\tobserve ${1:Model}\n\n\tdef after_save(${1/./\\l$0/})\n\t\texpire_cache(${1/./\\l$0/})\n\tend\n\n\tdef after_destroy(${1/./\\l$0/})\n\t\texpire_cache(${1/./\\l$0/})\n\tend\n\n\tprivate\n\n\t\tdef expire_cache(${1/./\\l$0/})\n\t\t\t${0:expire_page ${1/./\\l$0/}s_path\n\t\t\texpire_page ${1/./\\l$0/}_path(${1/./\\l$0/})}\n\t\tend\n\nend",
        "doc": null,
        "grammar": "snu",
        "label": "Create sweeper class",
        "matches": [
          "sweeper"
        ],
        "opts": []
      },
      {
        "content": "collection do\n\t${1:get :${2:action}}\n\t${3:put :${4:action}}\n\t${5:post :${6:action}}\n\t${7:delete :${8:action}}\nend",
        "doc": null,
        "grammar": "snu",
        "label": "collection routes",
        "matches": [
          "col"
        ],
        "opts": []
      },
      {
        "content": "format.${1:html|xml|json|js|any} { $0 }",
        "doc": null,
        "grammar": "snu",
        "label": "format (respond_with)",
        "matches": [
          "format"
        ],
        "opts": []
      },
      {
        "content": "gem '${1:name}'${2:${3:, \"${4:1.0}\"}${5:${6:, require: ${7:\"${8:$1}\"}}${9:, group: :${10:test}}}}",
        "doc": null,
        "grammar": "snu",
        "label": "gem",
        "matches": [
          "gem"
        ],
        "opts": []
      },
      {
        "content": "gem '${1:paperclip}', git: \"${2:git://github.com/thoughtbot/paperclip.git}\"${3:, branch: \"${4:rails3}\"}",
        "doc": null,
        "grammar": "snu",
        "label": "gem :git",
        "matches": [
          "gemg"
        ],
        "opts": []
      },
      {
        "content": "match '${1:${2::controller}${3:/${4::action}${5:/${6::id}${7:(.:format)}}}}'${8: '${9:$2}#${10:$4}'${11:, as: :${12:$10}}}",
        "doc": null,
        "grammar": "snu",
        "label": "match",
        "matches": [
          "match"
        ],
        "opts": []
      },
      {
        "content": "member do\n\t${1:get :${2:action}}\n\t${3:put :${4:action}}\n\t${5:post :${6:action}}\n\t${7:delete :${8:action}}\nend",
        "doc": null,
        "grammar": "snu",
        "label": "member routes",
        "matches": [
          "member"
        ],
        "opts": []
      },
      {
        "content": "resources :${1:posts}${2: do\n\t$3\nend}",
        "doc": null,
        "grammar": "snu",
        "label": "resources",
        "matches": [
          "res"
        ],
        "opts": []
      },
      {
        "content": "scope :${1:name}, { ${2:joins(:${3:table}).}where(${4:'${5:$3.${6:field}} = ?', ${7:'${8:value}'}}) }",
        "doc": null,
        "grammar": "snu",
        "label": "scope",
        "matches": [
          "scope"
        ],
        "opts": []
      },
      {
        "content": "scope :${1:name}, lambda { |${2:param}| ${3:where(${4::${5:field}: ${6:\"${7:value}\"}})} }",
        "doc": null,
        "grammar": "snu",
        "label": "scope lambda",
        "matches": [
          "scopel"
        ],
        "opts": []
      },
      {
        "content": "scope :${1:name}, { ${2:where(${3::${4:field}: ${5:'${6:value}'}})} } do\n\tdef ${7:method_name}\n\t\t$0\n\tend\nend",
        "doc": null,
        "grammar": "snu",
        "label": "scope with extension",
        "matches": [
          "scopee"
        ],
        "opts": []
      },
      {
        "content": "scoped_by_${1:attribute}(${2:id})",
        "doc": null,
        "grammar": "snu",
        "label": "scoped_by",
        "matches": [
          "sb"
        ],
        "opts": []
      },
      {
        "content": "setup do\n\t$0\nend",
        "doc": null,
        "grammar": "snu",
        "label": "setup do..end",
        "matches": [
          "setup"
        ],
        "opts": []
      },
      {
        "content": "I18n.t('`!v substitute(substitute(substitute(@%, substitute(getcwd() . \"/\", \"\\/\", \"\\\\\\\\/\", \"g\"), \"\", \"\"), \"\\\\(\\\\.\\\\(html\\\\|js\\\\)\\\\.\\\\(haml\\\\|erb\\\\)\\\\|\\\\(_controller\\\\)\\\\?\\\\.rb\\\\)$\", \"\", \"\"), \"/\", \".\", \"g\")`.${2:${1/[^\\w]/_/g}}$3', default: \"${1:some_text}\"$4)${5:$0}",
        "doc": null,
        "grammar": "snu",
        "label": "Translation snippet",
        "matches": [
          "trans"
        ],
        "opts": []
      },
      {
        "content": "it 'routes to #${1:action}' do\n\t${2:get}('/${3:url}').should route_to('`!v substitute(expand('%:t:r'), '_routing_spec$', '', '')`#$1'${4:, ${5:params}})$6\nend",
        "doc": null,
        "grammar": "snu",
        "label": null,
        "matches": [
          "route_spec"
        ],
        "opts": []
      }
    ],
    "react": [
      {
        "content": "import React from 'react'\n",
        "doc": "import React",
        "grammar": "lsp",
        "label": "import-react",
        "matches": [
          "react import",
          "imr"
        ],
        "opts": []
      },
      {
        "content": "import React, { Component } from 'react'\n",
        "doc": "",
        "grammar": "lsp",
        "label": "import-react-component",
        "matches": [
          "react import component",
          "imrc"
        ],
        "opts": []
      },
      {
        "content": "import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\n",
        "doc": null,
        "grammar": "lsp",
        "label": "import-react-component-prop-types",
        "matches": [
          "imrcp",
          "react import component proptypes"
        ],
        "opts": []
      },
      {
        "content": "import React, { PureComponent } from 'react'\n",
        "doc": null,
        "grammar": "lsp",
        "label": "import-react-purecomponent",
        "matches": [
          "react import purecomponent",
          "imrpc"
        ],
        "opts": []
      },
      {
        "content": "import React, { PureComponent } from 'react'\nimport PropTypes from 'prop-types'\n",
        "doc": null,
        "grammar": "lsp",
        "label": "import-react-pure-component-prop-types",
        "matches": [
          "react import purecomponent proptypes",
          "imrpcp"
        ],
        "opts": []
      },
      {
        "content": "import React, { memo } from 'react'\n",
        "doc": null,
        "grammar": "lsp",
        "label": "import-react-memo",
        "matches": [
          "imrm",
          "react import memo"
        ],
        "opts": []
      },
      {
        "content": "import React, { memo } from 'react'\nimport PropTypes from 'prop-types'\n",
        "doc": null,
        "grammar": "lsp",
        "label": "import-react-memo-prop-types",
        "matches": [
          "imrmp",
          "react import memo proptypes"
        ],
        "opts": []
      },
      {
        "content": "import React, { useState } from 'react'\n",
        "doc": null,
        "grammar": "lsp",
        "label": "import-react-usestate",
        "matches": [
          "react import usestate",
          "imrs"
        ],
        "opts": []
      },
      {
        "content": "import React, { useState, useEffect } from 'react'\n",
        "doc": null,
        "grammar": "lsp",
        "label": "import-react-usestate-useeffect",
        "matches": [
          "imrse",
          "react import usestate useeffect"
        ],
        "opts": []
      },
      {
        "content": "import React, { Component } from 'react'\n\nexport default class ${1:${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/g}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n",
        "doc": "Creates a React component class with ES7 module system",
        "grammar": "lsp",
        "label": "react-class-component",
        "matches": [
          "react component class",
          "rcc"
        ],
        "opts": []
      },
      {
        "content": "import React, { Component } from 'react'\n\nexport class ${1:${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/g}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n\nexport default ${1:${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/g}}\n",
        "doc": "Creates a React component class with ES7 module system",
        "grammar": "lsp",
        "label": "react-class-export-component",
        "matches": [
          "react component class export",
          "rce"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react'\n\nfunction ${1:${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/g}}() {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/g}}\n",
        "doc": "Creates a React Functional Component with ES7 module system",
        "grammar": "lsp",
        "label": "react-functional-export-component",
        "matches": [
          "rfce",
          "react component functional export"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react'\n\nexport default function ${1:${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/g}}() {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n",
        "doc": "Creates a React Functional Component with ES7 module system",
        "grammar": "lsp",
        "label": "react-functional-component",
        "matches": [
          "rfc",
          "react component functional"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react'\nimport PropTypes from 'prop-types'\n\nfunction ${1:${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/g}}(props) {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\n${1:${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/g}}.propTypes = {\n\n}\n\nexport default ${1:${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/g}}\n\n",
        "doc": "Creates a React Functional Component with ES7 module system with PropTypes",
        "grammar": "lsp",
        "label": "react-functional-component-with-proptypes",
        "matches": [
          "react component functional proptypes",
          "rfcp"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react'\n\nconst ${1:${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/g}} = () => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/g}}\n",
        "doc": "Creates a React Arrow Function Component with ES7 module system",
        "grammar": "lsp",
        "label": "react-arrow-function-export-component",
        "matches": [
          "react component arrow function export",
          "rafce"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react'\n\nexport const ${1:${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/g}} = () => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n",
        "doc": "Creates a React Arrow Function Component with ES7 module system",
        "grammar": "lsp",
        "label": "react-arrow-function-component",
        "matches": [
          "rafc",
          "react component arrow function"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react'\nimport PropTypes from 'prop-types'\n\nconst ${1:${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/g}} = props => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\n${1:${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/g}}.propTypes = {\n\n}\n\nexport default ${1:${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/g}}\n",
        "doc": "Creates a React Arrow Function Component with ES7 module system with PropTypes",
        "grammar": "lsp",
        "label": "react-arrow-function-component-proptypes",
        "matches": [
          "rafcp",
          "react component arrow function proptypes"
        ],
        "opts": []
      },
      {
        "content": "import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\n\nexport class ${1:${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/g}} extends Component {\n\tstatic propTypes = {\n\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n\nexport default ${1:${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/g}}\n",
        "doc": "Creates a React component class with ES7 module system",
        "grammar": "lsp",
        "label": "react-class-export-component-proptypes",
        "matches": [
          "react component class export proptypes",
          "rcep"
        ],
        "opts": []
      },
      {
        "content": "import React, { PureComponent } from 'react'\n\nexport default class ${1:${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/g}} extends PureComponent {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n",
        "doc": "Creates a React pure component class with ES7 module system",
        "grammar": "lsp",
        "label": "react-class-pure-component",
        "matches": [
          "react component class pure",
          "rpc"
        ],
        "opts": []
      },
      {
        "content": "import React, { PureComponent } from 'react'\n\nexport class ${1:${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/g}} extends PureComponent {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n\nexport default ${1:$TM_FILENAME_BASE}\n",
        "doc": "Creates a React pure component class with ES7 module system export",
        "grammar": "lsp",
        "label": "react-class-export-pure-component",
        "matches": [
          "react component class export pure",
          "rpce"
        ],
        "opts": []
      },
      {
        "content": "import React, { PureComponent } from 'react'\nimport PropTypes from 'prop-types'\n\nexport default class ${1:${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/g}} extends PureComponent {\n\tstatic propTypes = {\n\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n",
        "doc": "Creates a React component class with ES7 module system",
        "grammar": "lsp",
        "label": "react-class-pure-component-proptypes",
        "matches": [
          "rpcp",
          "react component class pure with proptypes"
        ],
        "opts": []
      },
      {
        "content": "import React, { memo } from 'react'\n\nexport default memo(function ${1:${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/g}}() {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n})\n",
        "doc": "Creates a React Memo Function Component with ES7 module system",
        "grammar": "lsp",
        "label": "react-function-memo-component",
        "matches": [
          "react component function memo",
          "rmc"
        ],
        "opts": []
      },
      {
        "content": "import React, { memo } from 'react'\nimport PropTypes from 'prop-types'\n\nconst ${1:${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/g}} = memo(function ${1:${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/g}}(props) {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n})\n\n${1:${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/g}}.propTypes = {\n\n}\n\nexport default ${1:${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/g}}\n",
        "doc": "Creates a React Memo Function Component with ES7 module system with PropTypes",
        "grammar": "lsp",
        "label": "react-function-memo-component-proptypes",
        "matches": [
          "rmcp",
          "react component function memo proptypes"
        ],
        "opts": []
      },
      {
        "content": "import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\n\nexport default class ${1:${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/g}} extends Component {\n\tstatic propTypes = {\n\t\t${2:prop}: ${3:PropTypes}\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n",
        "doc": "Creates a React component class with PropTypes and ES7 module system",
        "grammar": "lsp",
        "label": "react-class-component-proptypes",
        "matches": [
          "react component class proptypes",
          "rccp"
        ],
        "opts": []
      },
      {
        "content": "import React, { Component } from 'react'\nimport { connect } from 'react-redux'\n\nexport class ${1:${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/g}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n\nconst mapStateToProps = (state) => ({\n\t\n})\n\nconst mapDispatchToProps = {\n\t\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(${1:${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/g}})\n",
        "doc": "Creates a React component class with connected redux and ES7 module system",
        "grammar": "lsp",
        "label": "react-class-component-redux",
        "matches": [
          "react component class redux",
          "rcredux"
        ],
        "opts": []
      },
      {
        "content": "import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\nimport { connect } from 'react-redux'\n\nexport class ${1:${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/g}} extends Component {\n\tstatic propTypes = {\n\t\t${2:prop}: ${3:PropTypes}\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n\nconst mapStateToProps = (state) => ({\n\t\n})\n\nconst mapDispatchToProps = {\n\t\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(${1:${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/g}})\n",
        "doc": "Creates a React component class with PropTypes with connected redux and ES7 module system",
        "grammar": "lsp",
        "label": "react-class-component-redux-proptypes",
        "matches": [
          "rcreduxp",
          "react component class redux proptypes"
        ],
        "opts": []
      },
      {
        "content": "constructor(props) {\n\tsuper(props)\n\n\tthis.state = {\n\t\t $0\n\t}\n}\n",
        "doc": "Adds a default constructor for it('', () => {})the class that contains props as arguments",
        "grammar": "lsp",
        "label": "react-class-constructor",
        "matches": [
          "rconst",
          "react class constructor"
        ],
        "opts": []
      },
      {
        "content": "state = {\n\t$1\n}\n",
        "doc": "Creates empty state object. To be used in a constructor.",
        "grammar": "lsp",
        "label": "react-empty-state",
        "matches": [
          "est",
          "react empty state"
        ],
        "opts": []
      },
      {
        "content": "componentWillMount() {\n\t$0\n}\n",
        "doc": "DEPRECATED!!!. Invoked once, both on the client and server, immediately before the initial rendering occurs",
        "grammar": "lsp",
        "label": "react-componentwillmount",
        "matches": [
          "react componentwillmount",
          "cwm"
        ],
        "opts": []
      },
      {
        "content": "componentDidMount() {\n\t$0\n}\n",
        "doc": "Invoked once, only on the client (not on the server), immediately after the initial rendering occurs.",
        "grammar": "lsp",
        "label": "react-componentdidmount",
        "matches": [
          "react componentdidmount",
          "cdm"
        ],
        "opts": []
      },
      {
        "content": "componentWillReceiveProps(nextProps) {\n\t$0\n}\n",
        "doc": "DEPRECATED!!!. Invoked when a component is receiving new props. This method is not called for the initial render.",
        "grammar": "lsp",
        "label": "react-componentwillreceiveprops",
        "matches": [
          "react componentwillreceiveprops",
          "cwr"
        ],
        "opts": []
      },
      {
        "content": "shouldComponentUpdate(nextProps, nextState) {\n\t$0\n}\n",
        "doc": "Invoked before rendering when new props or state are being received. ",
        "grammar": "lsp",
        "label": "react-shouldcomponentupdate",
        "matches": [
          "react shouldcomponentupdate",
          "scu"
        ],
        "opts": []
      },
      {
        "content": "componentWillUpdate(nextProps, nextState) {\n\t$0\n}\n",
        "doc": "DEPRECATED!!!. Invoked immediately before rendering when new props or state are being received.",
        "grammar": "lsp",
        "label": "react-componentwillupdate",
        "matches": [
          "cwup",
          "react componentwillupdate"
        ],
        "opts": []
      },
      {
        "content": "componentDidUpdate(prevProps, prevState) {\n\t$0\n}\n",
        "doc": "Invoked immediately after the component's updates are flushed to the DOM.",
        "grammar": "lsp",
        "label": "react-componentdidupdate",
        "matches": [
          "cdup",
          "react componentdidupdate"
        ],
        "opts": []
      },
      {
        "content": "componentWillUnmount() {\n\t$0\n}\n",
        "doc": "Invoked immediately before a component is unmounted from the DOM.",
        "grammar": "lsp",
        "label": "react-componentwillunmount",
        "matches": [
          "react componentwillunmount",
          "cwun"
        ],
        "opts": []
      },
      {
        "content": "static getDerivedStateFromProps(props, state) {\n\t${1}\n}",
        "doc": "Invoked right before calling the render method, both on the initial mount and on subsequent updates.",
        "grammar": "lsp",
        "label": "react-getderivedstatefromprops",
        "matches": [
          "react getderivedstatefromprops",
          "gdsfp"
        ],
        "opts": []
      },
      {
        "content": "getSnapshotBeforeUpdate = (prevProps, prevState) => {\n\t$0\n}\n",
        "doc": "Called right before mutations are made (e.g. before the DOM is updated)",
        "grammar": "lsp",
        "label": "react-getsnapshotbeforeupdate",
        "matches": [
          "gsbu",
          "react getsnapshotbeforeupdate"
        ],
        "opts": []
      },
      {
        "content": "render() {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}",
        "doc": "Basic render.",
        "grammar": "lsp",
        "label": "react-component-render",
        "matches": [
          "ren",
          "react component render"
        ],
        "opts": []
      },
      {
        "content": "const ${1:contextName} = React.createContext()\n",
        "doc": "Create React context",
        "grammar": "lsp",
        "label": "react-createcontext",
        "matches": [
          "react createcontext",
          "rcontext"
        ],
        "opts": []
      },
      {
        "content": "this.${1:refName}Ref = React.createRef()\n",
        "doc": "Create ref statement used inside constructor",
        "grammar": "lsp",
        "label": "react-createref",
        "matches": [
          "react createref",
          "cref"
        ],
        "opts": []
      },
      {
        "content": "const ref = React.createRef()\n",
        "doc": "Forward ref statement used inside component",
        "grammar": "lsp",
        "label": "react-forwardref",
        "matches": [
          "fref",
          "react forwardref"
        ],
        "opts": []
      },
      {
        "content": "this.setState({$0})",
        "doc": "Performs a shallow merge of nextState into current state",
        "grammar": "lsp",
        "label": "react-component-set-state-object",
        "matches": [
          "react componentsetstateobject",
          "sst"
        ],
        "opts": []
      },
      {
        "content": "this.setState((state, props) => { return { $0 }})\n",
        "doc": "Performs a shallow merge of nextState into current state",
        "grammar": "lsp",
        "label": "react-component-set-state-func",
        "matches": [
          "ssf",
          "react component setstate func"
        ],
        "opts": []
      },
      {
        "content": "this.props.$0",
        "doc": "Access component's props",
        "grammar": "lsp",
        "label": "react-component-props",
        "matches": [
          "props",
          "react component props"
        ],
        "opts": []
      },
      {
        "content": "this.state.$0",
        "doc": null,
        "grammar": "lsp",
        "label": "react-component-state",
        "matches": [
          "react component state",
          "state"
        ],
        "opts": []
      },
      {
        "content": "this.${1:methodName} = this.${1:methodName}.bind(this)$0",
        "doc": "Binds this to a method",
        "grammar": "lsp",
        "label": "react-bind-this",
        "matches": [
          "bnd",
          "react bind this"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react'\nimport PropTypes from 'prop-types'\n\nexport default (WrappedComponent) => {\n\tconst hocComponent = ({ ...props }) => <WrappedComponent {...props} />\n\n\thocComponent.propTypes = {\n\t}\n\n\treturn hocComponent\n}\n",
        "doc": null,
        "grammar": "lsp",
        "label": "react-hoc",
        "matches": [
          "react hoc",
          "hoc"
        ],
        "opts": []
      },
      {
        "content": "const [${1:state}, set${1/(.*)/${1:/capitalize}/}] = useState(${2:initialState})",
        "doc": null,
        "grammar": "lsp",
        "label": "react-usestate",
        "matches": [
          "usestate",
          "react usestate"
        ],
        "opts": []
      },
      {
        "content": "useEffect(() => {\n\t${1:effect}\n\treturn () => {\n\t\t${2:cleanup}\n\t};\n}, [${3:input}])",
        "doc": null,
        "grammar": "lsp",
        "label": "react-useeffect",
        "matches": [
          "useeffect",
          "react useeffect"
        ],
        "opts": []
      },
      {
        "content": "const ${1:context} = useContext(${2:contextValue})",
        "doc": null,
        "grammar": "lsp",
        "label": "react-usecontext",
        "matches": [
          "usecontext",
          "react usecontext"
        ],
        "opts": []
      },
      {
        "content": "useCallback(\n\t() => {\n\t\t${1:callback}\n\t},\n\t[${2:input}],\n)",
        "doc": null,
        "grammar": "lsp",
        "label": "react-usecallback",
        "matches": [
          "usecallback",
          "react usecallback"
        ],
        "opts": []
      },
      {
        "content": "useMemo(() => ${1:function}, ${2:input})",
        "doc": null,
        "grammar": "lsp",
        "label": "react-usememo",
        "matches": [
          "usememo",
          "react usememo"
        ],
        "opts": []
      },
      {
        "content": "const ${1:ref} = useRef(${2:initialValue})",
        "doc": null,
        "grammar": "lsp",
        "label": "react-useref",
        "matches": [
          "react useref",
          "useref"
        ],
        "opts": []
      },
      {
        "content": "useImperativeHandle(\n\t${1:ref},\n\t() => {\n\t\t${2:handler}\n\t},\n\t[${3:input}],\n)",
        "doc": null,
        "grammar": "lsp",
        "label": "react-useimperativehandle",
        "matches": [
          "react useimperativehandle",
          "useimperativehandle"
        ],
        "opts": []
      },
      {
        "content": "useDebugValue(${1:value})",
        "doc": null,
        "grammar": "lsp",
        "label": "react-usedebugvalue",
        "matches": [
          "react usedebugvalue",
          "usedebugvalue"
        ],
        "opts": []
      },
      {
        "content": "useLayoutEffect(() => {\n\t${1:effect}\n\treturn () => {\n\t\t${2:cleanup}\n\t};\n}, [${3:input}])",
        "doc": null,
        "grammar": "lsp",
        "label": "react-uselayouteffect",
        "matches": [
          "react uselayouteffect",
          "uselayouteffect"
        ],
        "opts": []
      }
    ],
    "react-helmet": [
      {
        "content": "import { Helmet } from 'react-helmet';",
        "doc": null,
        "grammar": "lsp",
        "label": "react-helmet-import",
        "matches": [
          "react-helmet import"
        ],
        "opts": []
      },
      {
        "content": "<Helmet>\n  <title>${1:title}</title>\n</Helmet>",
        "doc": null,
        "grammar": "lsp",
        "label": "react-helmet-title",
        "matches": [
          "react-helmet title"
        ],
        "opts": []
      },
      {
        "content": "<Helmet>\n${1:example}\n</Helmet>",
        "doc": null,
        "grammar": "lsp",
        "label": "react-helmet-component",
        "matches": [
          "react-helmet component"
        ],
        "opts": []
      }
    ],
    "react-intersection-observer": [
      {
        "content": "const [ref, inView, entry] = useInView(options)",
        "doc": "The new React Hooks make it easier than ever to monitor the inView state of your components. Call the useInView hook with the (optional) options you need. It will return an array containing a ref, the inView status and the current IntersectionObserverEntry. Assign the ref to the DOM element you want to monitor, and the hook will report the status. \n\nOptions\nroot(type: Element, default: window, required: false)\nThe Element that is used as the viewport for checking visibility of the target. Defaults to the browser viewport (window) if not specified or if null.\n\nrootMargin(type: String, default: '0px', required: false)\nMargin around the root. Can have values similar to the CSS margin property.\n\nthreshold(type: Number, default: 0, required: false)\nNumber between 0 and 1 indicating the percentage that should be visible before triggering. Can also be an array of numbers, to create multiple trigger points.\n\ntriggerOnce(type: Boolean, default: false, required: false)\nOnly trigger this method once",
        "grammar": "lsp",
        "label": "react-intersection-observer-use-in-view",
        "matches": [
          "rio useinview",
          "react-intersection-observer useinview"
        ],
        "opts": []
      },
      {
        "content": "import { useInView } from 'react-intersection-observer';",
        "doc": null,
        "grammar": "lsp",
        "label": "react-intersection-observer-import",
        "matches": [
          "react-intersection-observer import",
          "rio import"
        ],
        "opts": []
      }
    ],
    "react-modal": [
      {
        "content": "import Modal from 'react-modal'",
        "doc": "import react-modal",
        "grammar": "lsp",
        "label": "react-modal-import",
        "matches": [
          "imrm",
          "react-modal import"
        ],
        "opts": []
      },
      {
        "content": "import React, { useState } from 'react';\nimport Modal from 'react-modal';\n\nconst ${1:CustomModal} = () => {\n  const [showModal, setShowModal] = useState(false);\n\n  const handleOpenModal = () => {\n    setShowModal(!showModal);\n  };\n\n  const handleCloseModal = () => {\n    setShowModal(!showModal);\n  };\n\n  return (\n    <>\n      <button onClick={handleOpenModal}>Open modal</button>\n      <Modal \n        open={showModal} \n        ${2:shouldCloseOnOverlayClick} \n        contentLabel={${3:contentLabel}} \n        onAfterOpen={${4:afterOpenModal}}\n        onRequestClose={${5:closeModal}}\n        style={${5:customStyles}}>\n        <button onClick={handleCloseModal}>Close modal</button>\n        ${:content}\n      </Modal>\n    </>\n  );\n};\n\nexport default ${1:CustomModal};",
        "doc": "Template for react modal",
        "grammar": "lsp",
        "label": "react-modal-component",
        "matches": [
          "react-modal component",
          "rmc"
        ],
        "opts": []
      }
    ],
    "reason": [
      {
        "content": "/*\n\t${0}\n */",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doc"
        ],
        "opts": []
      },
      {
        "content": "let ${1} = ${0};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "let"
        ],
        "opts": []
      },
      {
        "content": "let ${1} = (${2}) => {\n\t${0}\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fn"
        ],
        "opts": []
      },
      {
        "content": "fun ${1} => ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fun"
        ],
        "opts": []
      },
      {
        "content": "type ${1} = ${0};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ty"
        ],
        "opts": []
      },
      {
        "content": "module ${1} = {\n\t${0}\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mod"
        ],
        "opts": []
      },
      {
        "content": "module type ${1} = {\n\t${0}\n};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "modty"
        ],
        "opts": []
      },
      {
        "content": "switch (${1}) {\n| ${2} => ${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sw"
        ],
        "opts": []
      },
      {
        "content": "| ${1} => ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "|"
        ],
        "opts": []
      },
      {
        "content": "|> ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p"
        ],
        "opts": []
      },
      {
        "content": "if (${1}) {\n\t${2}\n} else {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      }
    ],
    "redux": [
      {
        "content": "import { connect } from 'react-redux'\n",
        "doc": "Import connect from Redux",
        "grammar": "lsp",
        "label": "redux-import-connect",
        "matches": [
          "redux import connect"
        ],
        "opts": []
      },
      {
        "content": "const mapStateToProps = (state) => ({\n\t${1}\n})\n\nconst mapDispatchToProps = {\n\t\n}\n",
        "doc": "Creates mapStateToProps function.",
        "grammar": "lsp",
        "label": "redux-map-to-props",
        "matches": [
          "redux map props"
        ],
        "opts": []
      },
      {
        "content": "export const ${1:constantName} = '${1:constantName}'",
        "doc": null,
        "grammar": "lsp",
        "label": "redux-const",
        "matches": [
          "redux const",
          "rxconst"
        ],
        "opts": []
      },
      {
        "content": "const initialState = {\n\n}\n\nexport default (state = initialState, { type, payload }) => {\n\tswitch (type) {\n\n\tcase ${1:typeName}:\n\t\treturn { ...state, ...payload }\n\n\tdefault:\n\t\treturn state\n\t}\n}\n",
        "doc": "Redux reducer template",
        "grammar": "lsp",
        "label": "redux-reducer",
        "matches": [
          "redux reducer",
          "rxreducer"
        ],
        "opts": []
      },
      {
        "content": "const ${1:actionCreatorName} = ${2:payload} => {\n  return {\n    type: '${3:ACTION_TYPE}',\n    payload: ${2:payload},\n  };\n};",
        "doc": "Redux action template",
        "grammar": "lsp",
        "label": "redux-action",
        "matches": [
          "rxaction",
          "redux action"
        ],
        "opts": []
      },
      {
        "content": "import { useSelector, useDispatch } from 'react-redux';",
        "doc": "Import Redux hooks (useSelector, useDispatch)",
        "grammar": "lsp",
        "label": "redux-import-hooks",
        "matches": [
          "irrh",
          "redux import hooks"
        ],
        "opts": []
      },
      {
        "content": "const $1 = useSelector(state => state.$1);",
        "doc": "Redux useSelector() hook",
        "grammar": "lsp",
        "label": "redux-useselector",
        "matches": [
          "redux useselector",
          "uss"
        ],
        "opts": []
      },
      {
        "content": "const dispatch = useDispatch();",
        "doc": "Redux useDispatch() hook",
        "grammar": "lsp",
        "label": "redux-usedispatch-hook",
        "matches": [
          "redux usedispatch",
          "rxusdh"
        ],
        "opts": []
      },
      {
        "content": "const $1 = $2 => dispatch($3);",
        "doc": "Redux dispatch hook",
        "grammar": "lsp",
        "label": "redux-dispatch-hook",
        "matches": [
          "rxd",
          "redux dispatch"
        ],
        "opts": []
      }
    ],
    "redux-thunk": [
      {
        "content": "import thunk from 'redux-thunk'",
        "doc": "Import thunk from redux-thunk",
        "grammar": "lsp",
        "label": "redux-thunk-import",
        "matches": [
          "redux-thunk import"
        ],
        "opts": []
      },
      {
        "content": "import { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport ${1:rootReducer} from '${1:./reducers/index}';\n\nconst store = createStore(\n  ${1:rootReducer},\n  applyMiddleware(thunk)\n);",
        "doc": "Create store with thunk template",
        "grammar": "lsp",
        "label": "redux-thunk-store",
        "matches": [
          "redux-thunk createstore"
        ],
        "opts": []
      }
    ],
    "requirejs_coffee": [
      {
        "content": "define [\"${1:#dependencies1}\"], (${2:#dependencies2}) ->\n\t${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "def"
        ],
        "opts": []
      },
      {
        "content": "define \"${1:#name}\", [\"${2:#dependencies1}\"], (${3:#dependencies2}) ->\n\t${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defn"
        ],
        "opts": []
      },
      {
        "content": "require [\"${1:#dependencies1}\"], (${2:#dependencies2}) ->\n\t${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "reqjs"
        ],
        "opts": []
      }
    ],
    "rmarkdown": [
      {
        "content": "**${1:${TM_SELECTED_TEXT}}**$0",
        "doc": "Insert bold text",
        "grammar": "lsp",
        "label": "Insert bold text",
        "matches": [
          "bold"
        ],
        "opts": []
      },
      {
        "content": "*${1:${TM_SELECTED_TEXT}}*$0",
        "doc": "Insert italic text",
        "grammar": "lsp",
        "label": "Insert italic text",
        "matches": [
          "italic"
        ],
        "opts": []
      },
      {
        "content": "> ${1:${TM_SELECTED_TEXT}}",
        "doc": "Insert quoted text",
        "grammar": "lsp",
        "label": "Insert quoted text",
        "matches": [
          "quote"
        ],
        "opts": []
      },
      {
        "content": "`${1:${TM_SELECTED_TEXT}}`$0",
        "doc": "Insert code",
        "grammar": "lsp",
        "label": "Insert code",
        "matches": [
          "code"
        ],
        "opts": []
      },
      {
        "content": "```${1:language}\n$0\n```",
        "doc": "Insert fenced code block",
        "grammar": "lsp",
        "label": "Insert fenced code block",
        "matches": [
          "fenced codeblock"
        ],
        "opts": []
      },
      {
        "content": "# ${1:text}",
        "doc": "Insert heading",
        "grammar": "lsp",
        "label": "Insert heading",
        "matches": [
          "heading"
        ],
        "opts": []
      },
      {
        "content": "- ${1:first}\n- ${2:second}\n- ${3:third}\n$0",
        "doc": "Insert unordered list",
        "grammar": "lsp",
        "label": "Insert unordered list",
        "matches": [
          "unordered list"
        ],
        "opts": []
      },
      {
        "content": "1. ${1:first}\n2. ${2:second}\n3. ${3:third}\n$0",
        "doc": "Insert ordered list",
        "grammar": "lsp",
        "label": "Insert ordered list",
        "matches": [
          "ordered list"
        ],
        "opts": []
      },
      {
        "content": "----------\n",
        "doc": "Insert horizontal rule",
        "grammar": "lsp",
        "label": "Insert horizontal rule",
        "matches": [
          "horizontal rule"
        ],
        "opts": []
      },
      {
        "content": "[${1:text}](http://${2:link})$0",
        "doc": "Insert link",
        "grammar": "lsp",
        "label": "Insert link",
        "matches": [
          "link"
        ],
        "opts": []
      },
      {
        "content": "![${1:alt}](http://${2:link})$0",
        "doc": "Insert image",
        "grammar": "lsp",
        "label": "Insert image",
        "matches": [
          "image"
        ],
        "opts": []
      },
      {
        "content": "```{${1:language}}\n$0\n```",
        "doc": "Insert code chunk",
        "grammar": "lsp",
        "label": "Insert code chunk",
        "matches": [
          "code chunk"
        ],
        "opts": []
      },
      {
        "content": "```{r}\n$0\n```",
        "doc": "Insert R code chunk",
        "grammar": "lsp",
        "label": "Insert R code chunk",
        "matches": [
          "r code chunk"
        ],
        "opts": []
      }
    ],
    "rmd": [
      {
        "content": "% ${1:`Filename('', 'title')`}\n% ${2:`g:snips_author`}\n% ${3:`strftime(\"%d %B %Y\")`}\n${4}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "%%"
        ],
        "opts": []
      },
      {
        "content": "% ${1:`Filename('', @*)`}\n% ${2:`g:snips_author`}\n% ${3:`strftime(\"%d %b %Y\")`}\n${4}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "%%*"
        ],
        "opts": []
      },
      {
        "content": "${1:term}\n  ~  ${2:definition}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "::"
        ],
        "opts": []
      },
      {
        "content": "`repeat('=', strlen(getline(line(\".\") - 1)))`\n${1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "==="
        ],
        "opts": []
      },
      {
        "content": "`repeat('-', strlen(getline(line(\".\") - 1)))`\n${1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "---"
        ],
        "opts": []
      },
      {
        "content": "[${1:link}](http://${2:url} \"${3:title}\")${4}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "["
        ],
        "opts": []
      },
      {
        "content": "[${1:link}](${2:`@*`} \"${3:title}\")${4}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "[*"
        ],
        "opts": []
      },
      {
        "content": "[${1:id}]: http://${2:url} \"${3:title}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "[:"
        ],
        "opts": []
      },
      {
        "content": "[${1:id}]: ${2:`@*`} \"${3:title}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "[:*"
        ],
        "opts": []
      },
      {
        "content": "[${1:link}](mailto:${2:email})${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "[@"
        ],
        "opts": []
      },
      {
        "content": "[${1:link}](mailto:${2:`@*`})${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "[@*"
        ],
        "opts": []
      },
      {
        "content": "[${1:id}]: mailto:${2:email} \"${3:title}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "[:@"
        ],
        "opts": []
      },
      {
        "content": "[${1:id}]: mailto:${2:`@*`} \"${3:title}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "[:@*"
        ],
        "opts": []
      },
      {
        "content": "![${1:alt}](${2:url} \"${3:title}\")${4}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "!["
        ],
        "opts": []
      },
      {
        "content": "![${1:alt}](${2:`@*`} \"${3:title}\")${4}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "![*"
        ],
        "opts": []
      },
      {
        "content": "![${1:id}]: ${2:url} \"${3:title}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "![:"
        ],
        "opts": []
      },
      {
        "content": "![${1:id}]: ${2:`@*`} \"${3:title}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "![:*"
        ],
        "opts": []
      },
      {
        "content": "[^${1:id}]: ${2:note}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "[^:"
        ],
        "opts": []
      },
      {
        "content": "[^${1:id}]: ${2:`@*`}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "[^:*"
        ],
        "opts": []
      },
      {
        "content": "require(${1:}, quietly = TRUE)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "req"
        ],
        "opts": []
      },
      {
        "content": "if ( ${1:condition} )\n{\n\t${2:}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "else\n{\n\t${1:}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "el"
        ],
        "opts": []
      },
      {
        "content": "${1:funname} <- \t\t\t# ${2:}\n\tfunction\n(\n \t${3:}\n)\n{\n  ${4:}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fun"
        ],
        "opts": []
      },
      {
        "content": "repeat{\n  ${2:}\n  if(${1:condition}) break\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "re"
        ],
        "opts": []
      },
      {
        "content": "matrix(NA, nrow = ${1:}, ncol = ${2:})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ma"
        ],
        "opts": []
      },
      {
        "content": "data.frame(${1:}, header = TRUE)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "df"
        ],
        "opts": []
      },
      {
        "content": "args <- commandArgs(TRUE)\nif (length(args) == 0)\n    stop(\"Please give ${1:}!\")\nif (!all(file.exists(args)))\n     stop(\"Couln't find input files!\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cmdarg"
        ],
        "opts": []
      },
      {
        "content": "require('getopt', quietly = TRUE)\nopt_spec <- matrix(c(\n\t\t\t\t'help',     'h', 0, \"logical\", \t\"Getting help\",\n\t\t\t\t'file',     'f', 1, \"character\",\"File to process\"\n                ), ncol = 5, byrow = TRUE)\nopt <- getopt(spec = opt_spec)\nif ( !is.null(opt$help) || is.null(commandArgs()) )   {\n    cat(getopt(spec = opt_spec, usage = TRUE, command = \"yourCmd\"))\n    q(status=0)\n}\n# some inital value\nif ( is.null(opt$???) )    { opt$??? <- ??? }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "getopt"
        ],
        "opts": []
      },
      {
        "content": "require(\"optparse\", quietly = TRUE)\noption_list <-\n    list(make_option(c(\"-n\", \"--add_numbers\"), action=\"store_true\", default=FALSE,\n                     help=\"Print line number at the beginning of each line [default]\")\n         )\nparser <- OptionParser(usage = \"%prog [options] file\", option_list=option_list)\narguments <- parse_args(parser, positional_arguments = TRUE)\nopt <- arguments$options\nif(length(arguments$args) != 1) {\n    cat(\"Incorrect number of required positional arguments\\n\\n\")\n    print_help(parser)\n    stop()\n} else {\n    file <- arguments$args\n}\nif( file.access(file) == -1) {\n    stop(sprintf(\"Specified file ( %s ) does not exist\", file))\n} else {\n    file_text <- readLines(file)\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "optparse"
        ],
        "opts": []
      },
      {
        "content": "#!/usr/bin/env Rscript",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#!"
        ],
        "opts": []
      },
      {
        "content": "# Development & Debugging, don't forget to uncomment afterwards!\n#--------------------------------------------------------------------------------\n#setwd(\"~/Projekte/${1:}\")\n#opt <- list(${2:}\n#            )\n#--------------------------------------------------------------------------------",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "debug"
        ],
        "opts": []
      },
      {
        "content": "#`repeat('=', strlen(getline(line(\".\") - 1)))`\n${1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#==="
        ],
        "opts": []
      },
      {
        "content": "#`repeat('-', strlen(getline(line(\".\") - 1)))`\n${1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#---"
        ],
        "opts": []
      },
      {
        "content": "\\`\\`\\`{r ${1:chung_tag}, echo = FALSE ${2:options}}\n${3:}\n\\`\\`\\`",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "r"
        ],
        "opts": []
      },
      {
        "content": "\\`{r ${1:}}\\`",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ri"
        ],
        "opts": []
      },
      {
        "content": "\\`\\`\\` {r setup, echo = FALSE}\n\topts_chunk$set(fig.path='../figures/${1:}', cache.path='../cache/-'\n\t, fig.align='center', fig.show='hold', par=TRUE)\t\n\t#opts_knit$set(upload.fun = imgur_upload) # upload images\n\\`\\`\\`",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "copt"
        ],
        "opts": []
      }
    ],
    "rnoweb": [],
    "robot": [
      {
        "content": "\\${${1:name}}=    Catenate    SEPARATOR=${2:---}    ${3:Hello}    ${4:world}",
        "doc": null,
        "grammar": "snu",
        "label": "Catenate",
        "matches": [
          "cat"
        ],
        "opts": []
      },
      {
        "content": "\\${${1:val}}=    Evaluate    ${2:${x} - 10}",
        "doc": null,
        "grammar": "snu",
        "label": "Evaluate",
        "matches": [
          "eval"
        ],
        "opts": []
      },
      {
        "content": ":FOR    ${${1:element}}    IN    ${2:@{ELEMENTS}}\n\\    ${0:${VISUAL:Start Element}}    ${$1}",
        "doc": null,
        "grammar": "snu",
        "label": "FOR loop",
        "matches": [
          "for"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "No Operation",
        "doc": null,
        "grammar": "snu",
        "label": "No Operation",
        "matches": [
          "nop"
        ],
        "opts": []
      },
      {
        "content": "Return From Keyword    ${1:${optional return value}}",
        "doc": null,
        "grammar": "snu",
        "label": "Return From Keyword",
        "matches": [
          "rfk"
        ],
        "opts": []
      },
      {
        "content": "Return From Keyword If    '\\${${1:rc}}' != '${2:abc}'    ${3:${optional return value}}",
        "doc": null,
        "grammar": "snu",
        "label": "Return From Keyword If",
        "matches": [
          "rfki"
        ],
        "opts": []
      },
      {
        "content": "Run Keyword    ${1:${kw}}    ${2:${args}}",
        "doc": null,
        "grammar": "snu",
        "label": "Run Keyword",
        "matches": [
          "rk"
        ],
        "opts": []
      },
      {
        "content": "Run Keyword And Continue On Failure    ${1:${kw}}    ${2:${args}}",
        "doc": null,
        "grammar": "snu",
        "label": "Run Keyword And Continue On Failure",
        "matches": [
          "rkacof"
        ],
        "opts": []
      },
      {
        "content": "Run Keyword And Expect Error    ${1:My error}    ${2:${kw}}    ${3:${args}}",
        "doc": null,
        "grammar": "snu",
        "label": "Run Keyword And Expect Error",
        "matches": [
          "rkaee"
        ],
        "opts": []
      },
      {
        "content": "Run Keyword And Ignore Error    ${1:${kw}}    ${2:${args}}\n\\${${3:result}}    \\${${4:return_value}}=    Run Keyword And Ignore Error    ${1:${kw}}    ${2:${args}}",
        "doc": null,
        "grammar": "snu",
        "label": "Run Keyword And Ignore Error",
        "matches": [
          "rkaie"
        ],
        "opts": []
      },
      {
        "content": "Run Keyword And Return    ${1:${kw}}    ${2:${args}}",
        "doc": null,
        "grammar": "snu",
        "label": "Run Keyword And Return",
        "matches": [
          "rkar"
        ],
        "opts": []
      },
      {
        "content": "Run Keyword And Return If    '\\${${1:rc}}' != '${2:abc}'    ${3:${kw}}    ${4:${args}}",
        "doc": null,
        "grammar": "snu",
        "label": "Run Keyword And Return If",
        "matches": [
          "rkari"
        ],
        "opts": []
      },
      {
        "content": "\\${${3:result}}=    Run Keyword And Return Status    ${1:${kw}}    ${2:${args}}",
        "doc": null,
        "grammar": "snu",
        "label": "Run Keyword And Return Status",
        "matches": [
          "rkars"
        ],
        "opts": []
      },
      {
        "content": "Run Keyword If    '\\${${1:rc}}' != '${2:abc}'\n...               ${3:${VISUAL:Some keyword returning a value}}\n...    ELSE IF    '\\${${4:str}}' != '${5:def}'\n...               ${6:Another keyword}\n...    ELSE\n...               ${7:Final keyword}",
        "doc": null,
        "grammar": "snu",
        "label": "Run Keyword If",
        "matches": [
          "rki"
        ],
        "opts": []
      },
      {
        "content": "Run Keyword If Any Critical Tests Failed    ${1:${kw}}    ${2:${args}}",
        "doc": null,
        "grammar": "snu",
        "label": "Run Keyword If Any Critical Tests Failed",
        "matches": [
          "rkiactf"
        ],
        "opts": []
      },
      {
        "content": "Run Keyword If All Critical Tests Passed    ${1:${kw}}    ${2:${args}}",
        "doc": null,
        "grammar": "snu",
        "label": "Run Keyword If All Critical Tests Passed",
        "matches": [
          "rkiactp"
        ],
        "opts": []
      },
      {
        "content": "Run Keyword If Any Tests Failed    ${1:${kw}}    ${2:${args}}",
        "doc": null,
        "grammar": "snu",
        "label": "Run Keyword If Any Tests Failed",
        "matches": [
          "rkiatf"
        ],
        "opts": []
      },
      {
        "content": "Run Keyword If All Tests Passed    ${1:${kw}}    ${2:${args}}",
        "doc": null,
        "grammar": "snu",
        "label": "Run Keyword If All Tests Passed",
        "matches": [
          "rkiatp"
        ],
        "opts": []
      },
      {
        "content": "Run Keyword If Test Failed    ${1:${kw}}    ${2:${args}}",
        "doc": null,
        "grammar": "snu",
        "label": "Run Keyword If Test Failed",
        "matches": [
          "rkitf"
        ],
        "opts": []
      },
      {
        "content": "Run Keyword If Test Passed    ${1:${kw}}    ${2:${args}}",
        "doc": null,
        "grammar": "snu",
        "label": "Run Keyword If Test Passed",
        "matches": [
          "rkitp"
        ],
        "opts": []
      },
      {
        "content": "Run Keyword If Timeout Occurred    ${1:${kw}}    ${2:${args}}",
        "doc": null,
        "grammar": "snu",
        "label": "Run Keyword If Timeout Occurred",
        "matches": [
          "rkito"
        ],
        "opts": []
      },
      {
        "content": "Run Keywords\n...    ${1:${VISUAL:Initialize database    $\\{DB NAME\\}}}    AND\n...    ${2:Clear logs}",
        "doc": null,
        "grammar": "snu",
        "label": "Run Keywords",
        "matches": [
          "rks"
        ],
        "opts": []
      },
      {
        "content": "Run Keyword Unless    '\\${${1:rc}}' != '${2:abc}'    ${3:${kw}}    ${4:${args}}",
        "doc": null,
        "grammar": "snu",
        "label": "Run Keyword Unless",
        "matches": [
          "rku"
        ],
        "opts": []
      },
      {
        "content": "Set Global Variable    \\${${1:name}}    ${2:${value}}",
        "doc": null,
        "grammar": "snu",
        "label": "Set Global Variable",
        "matches": [
          "sgv"
        ],
        "opts": []
      },
      {
        "content": "Should Be Equal    \"\\${${1:var}}\"    \"${2:expected value}\"    ${3:\"optional error msg\"}\t${4:ignore_case=True}",
        "doc": null,
        "grammar": "snu",
        "label": "Should Be Equal",
        "matches": [
          "sbe"
        ],
        "opts": []
      },
      {
        "content": "Sleep    ${1:2 minutes 10 seconds}",
        "doc": null,
        "grammar": "snu",
        "label": "Sleep",
        "matches": [
          "sleep"
        ],
        "opts": []
      },
      {
        "content": "Set Suite Variable    \\${${1:name}}    ${2:${value}}",
        "doc": null,
        "grammar": "snu",
        "label": "Set Suite Variable",
        "matches": [
          "ssv"
        ],
        "opts": []
      },
      {
        "content": "Set Test Variable    \\${${1:name}}    ${2:${value}}",
        "doc": null,
        "grammar": "snu",
        "label": "Set Test Variable",
        "matches": [
          "stv"
        ],
        "opts": []
      },
      {
        "content": "\\${${1:name}}=    Set Variable    ${2:${value}}",
        "doc": null,
        "grammar": "snu",
        "label": "Set Variable",
        "matches": [
          "sv"
        ],
        "opts": []
      },
      {
        "content": "\\${${1:var}}=    Set Variable If    '\\${${2:rc}}' != '${3:abc}'\n`!p snip.rv = '...' + ' ' * (len(t[1]) + 23)` ${4:${value true}}\n`!p snip.rv = '...' + ' ' * (len(t[1]) + 23)` ${5:${value false}}",
        "doc": null,
        "grammar": "snu",
        "label": "Set Variable If",
        "matches": [
          "svi"
        ],
        "opts": []
      },
      {
        "content": "Wait Until Keyword Succeeds    ${1:10x}    ${2:2s}    ${3:${VISUAL:Some Keyword}}",
        "doc": null,
        "grammar": "snu",
        "label": "Wait Until Keyword Succeeds",
        "matches": [
          "wuks"
        ],
        "opts": []
      },
      {
        "content": "Import library    Dialogs\nPause execution",
        "doc": null,
        "grammar": "snu",
        "label": "Pause test execution",
        "matches": [
          "pause"
        ],
        "opts": []
      },
      {
        "content": "[Teardown]    Run Keyword If Test Failed    Run Keywords\n...    Import library    Dialogs    AND\n...    Pause execution",
        "doc": null,
        "grammar": "snu",
        "label": "Teardown Pause - pause test execution only on failure",
        "matches": [
          "tpause"
        ],
        "opts": []
      },
      {
        "content": "Capture Page Screenshot    ${1:${optional filename}}",
        "doc": null,
        "grammar": "snu",
        "label": "Capture Page Screenshot",
        "matches": [
          "cps"
        ],
        "opts": []
      },
      {
        "content": "Element Should Be Disabled    \\${${1:locator}}",
        "doc": null,
        "grammar": "snu",
        "label": "Element Should Be Disabled",
        "matches": [
          "esbd"
        ],
        "opts": []
      },
      {
        "content": "Element Should Be Enabled    ${${1:locator}}",
        "doc": null,
        "grammar": "snu",
        "label": "Element Should Be Enabled",
        "matches": [
          "esbe"
        ],
        "opts": []
      },
      {
        "content": "Element Should Be Focused    ${${1:locator}}",
        "doc": null,
        "grammar": "snu",
        "label": "Element Should Be Focused",
        "matches": [
          "esbf"
        ],
        "opts": []
      },
      {
        "content": "Element Should Be Visible    ${${1:locator}}    ${2:${optional message}}",
        "doc": null,
        "grammar": "snu",
        "label": "Element Should Be Visible",
        "matches": [
          "esbv"
        ],
        "opts": []
      },
      {
        "content": "Element Should Contain    ${${1:locator}}    ${2:${expected}}    ${3:${optional message}}",
        "doc": null,
        "grammar": "snu",
        "label": "Element Should Contain",
        "matches": [
          "esc"
        ],
        "opts": []
      },
      {
        "content": "Element Should Not Be Visible    ${${1:locator}}    ${2:${optional message}}",
        "doc": null,
        "grammar": "snu",
        "label": "Element Should Not Be Visible",
        "matches": [
          "esnbv"
        ],
        "opts": []
      },
      {
        "content": "Element Should Not Contain    ${${1:locator}}    ${2:${expected}}    ${3:${optional message}}",
        "doc": null,
        "grammar": "snu",
        "label": "Element Should Not Contain",
        "matches": [
          "esnc"
        ],
        "opts": []
      },
      {
        "content": "Element Text Should Be    ${${1:locator}}    ${2:${expected}}    ${3:${optional message}}",
        "doc": null,
        "grammar": "snu",
        "label": "Element Text Should Be",
        "matches": [
          "etsb"
        ],
        "opts": []
      },
      {
        "content": "Execute Async Javascript    ${1:${code line 1}}    ${2:${code line 2}}",
        "doc": null,
        "grammar": "snu",
        "label": "Execute Async Javascript",
        "matches": [
          "eaj"
        ],
        "opts": []
      },
      {
        "content": "Execute Javascript    ${1:${code line 1}}    ${2:${code line 2}}",
        "doc": null,
        "grammar": "snu",
        "label": "Execute Javascript",
        "matches": [
          "ej"
        ],
        "opts": []
      },
      {
        "content": "\\${${1:x}}    \\${${2:y}}=    Get Window Position",
        "doc": null,
        "grammar": "snu",
        "label": "Get Window Position",
        "matches": [
          "gwp"
        ],
        "opts": []
      },
      {
        "content": "\\${${1:width}}    \\${${2:height}}=    Get Window Size",
        "doc": null,
        "grammar": "snu",
        "label": "Get Window Size",
        "matches": [
          "gws"
        ],
        "opts": []
      },
      {
        "content": "Maximize Browser Window",
        "doc": null,
        "grammar": "snu",
        "label": "Maximize Browser Window",
        "matches": [
          "mbw"
        ],
        "opts": []
      },
      {
        "content": "Mouse Down    ${${1:locator}}",
        "doc": null,
        "grammar": "snu",
        "label": "Mouse Down",
        "matches": [
          "md"
        ],
        "opts": []
      },
      {
        "content": "Mouse Down On Image    ${1:${locator}}",
        "doc": null,
        "grammar": "snu",
        "label": "Mouse Down On Image",
        "matches": [
          "mdoi"
        ],
        "opts": []
      },
      {
        "content": "Mouse Down On Link    ${1:${locator}}",
        "doc": null,
        "grammar": "snu",
        "label": "Mouse Down On Link",
        "matches": [
          "mdol"
        ],
        "opts": []
      },
      {
        "content": "Mouse Out    ${1:${locator}}",
        "doc": null,
        "grammar": "snu",
        "label": "Mouse Out",
        "matches": [
          "mout"
        ],
        "opts": []
      },
      {
        "content": "Mouse Over    ${1:${locator}}",
        "doc": null,
        "grammar": "snu",
        "label": "Mouse Over",
        "matches": [
          "mover"
        ],
        "opts": []
      },
      {
        "content": "Mouse Up    ${1:${locator}}",
        "doc": null,
        "grammar": "snu",
        "label": "Mouse Up",
        "matches": [
          "mu"
        ],
        "opts": []
      },
      {
        "content": "Open Browser    ${1:${url}}    ${2:${browser=firefox}}    ${3:${alias=None}}    ${4:${remote_url=False}}    ${5:${desired_capabilities=None}}    ${6:${ff_profile_dir=None}}",
        "doc": null,
        "grammar": "snu",
        "label": "Open Browser",
        "matches": [
          "ob"
        ],
        "opts": []
      },
      {
        "content": "Open Context Menu    ${1:${locator}}",
        "doc": null,
        "grammar": "snu",
        "label": "Open Context Menu",
        "matches": [
          "ocm"
        ],
        "opts": []
      },
      {
        "content": "Page Should Contain    ${1:${text}}    ${2:loglevel=INFO}",
        "doc": null,
        "grammar": "snu",
        "label": "Page Should Contain",
        "matches": [
          "psc"
        ],
        "opts": []
      },
      {
        "content": "Page Should Contain Button    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}",
        "doc": null,
        "grammar": "snu",
        "label": "Page Should Contain Button",
        "matches": [
          "pscb"
        ],
        "opts": []
      },
      {
        "content": "Page Should Contain Checkbox    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}",
        "doc": null,
        "grammar": "snu",
        "label": "Page Should Contain Checkbox",
        "matches": [
          "pscc"
        ],
        "opts": []
      },
      {
        "content": "Page Should Contain Element    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}",
        "doc": null,
        "grammar": "snu",
        "label": "Page Should Contain Element",
        "matches": [
          "psce"
        ],
        "opts": []
      },
      {
        "content": "Page Should Contain Image    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}",
        "doc": null,
        "grammar": "snu",
        "label": "Page Should Contain Image",
        "matches": [
          "psci"
        ],
        "opts": []
      },
      {
        "content": "Page Should Contain Link    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}",
        "doc": null,
        "grammar": "snu",
        "label": "Page Should Contain Link",
        "matches": [
          "pscl"
        ],
        "opts": []
      },
      {
        "content": "Page Should Contain Radio Button    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}",
        "doc": null,
        "grammar": "snu",
        "label": "Page Should Contain Radio Button",
        "matches": [
          "pscrb"
        ],
        "opts": []
      },
      {
        "content": "Page Should Contain Textfield    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}",
        "doc": null,
        "grammar": "snu",
        "label": "Page Should Contain Textfield",
        "matches": [
          "psct"
        ],
        "opts": []
      },
      {
        "content": "Page Should Not Contain    ${1:${text}}    ${2:loglevel=INFO}",
        "doc": null,
        "grammar": "snu",
        "label": "Page Should Not Contain",
        "matches": [
          "psnc"
        ],
        "opts": []
      },
      {
        "content": "Page Should Not Contain Button    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}",
        "doc": null,
        "grammar": "snu",
        "label": "Page Should Not Contain Button",
        "matches": [
          "psncb"
        ],
        "opts": []
      },
      {
        "content": "Page Should Not Contain Checkbox    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}",
        "doc": null,
        "grammar": "snu",
        "label": "Page Should Not Contain Checkbox",
        "matches": [
          "psncc"
        ],
        "opts": []
      },
      {
        "content": "Page Should Not Contain Element    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}",
        "doc": null,
        "grammar": "snu",
        "label": "Page Should Not Contain Element",
        "matches": [
          "psnce"
        ],
        "opts": []
      },
      {
        "content": "Page Should Not Contain Image    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}",
        "doc": null,
        "grammar": "snu",
        "label": "Page Should Not Contain Image",
        "matches": [
          "psnci"
        ],
        "opts": []
      },
      {
        "content": "Page Should Not Contain Link    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}",
        "doc": null,
        "grammar": "snu",
        "label": "Page Should Not Contain Link",
        "matches": [
          "psncl"
        ],
        "opts": []
      },
      {
        "content": "Page Should Not Contain Radio Button    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}",
        "doc": null,
        "grammar": "snu",
        "label": "Page Should Not Contain Radio Button",
        "matches": [
          "psncrb"
        ],
        "opts": []
      },
      {
        "content": "Page Should Not Contain Textfield    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}",
        "doc": null,
        "grammar": "snu",
        "label": "Page Should Not Contain Textfield",
        "matches": [
          "psnct"
        ],
        "opts": []
      },
      {
        "content": "Register Keyword To Run On Failure    ${1:${kw}}",
        "doc": null,
        "grammar": "snu",
        "label": "Register Keyword To Run On Failure",
        "matches": [
          "rktrof"
        ],
        "opts": []
      },
      {
        "content": "Wait Until Element Contains    ${1:${locator}}    ${2:${text}}    ${3:${timeout=None}}    ${4:${error=None}}",
        "doc": null,
        "grammar": "snu",
        "label": "Wait Until Element Contains",
        "matches": [
          "wuec"
        ],
        "opts": []
      },
      {
        "content": "Wait Until Element Does Not Contain    ${1:${locator}}    ${2:${text}}    ${3:${timeout=None}}    ${4:${error=None}}",
        "doc": null,
        "grammar": "snu",
        "label": "Wait Until Element Does Not Contain",
        "matches": [
          "wuednc"
        ],
        "opts": []
      },
      {
        "content": "Wait Until Element Is Enabled    ${1:${locator}}    ${2:${timeout=None}}    ${3:${error=None}}",
        "doc": null,
        "grammar": "snu",
        "label": "Wait Until Element Is Enabled",
        "matches": [
          "wueie"
        ],
        "opts": []
      },
      {
        "content": "Wait Until Element Is Not Visible    ${1:${locator}}    ${2:${timeout=None}}    ${3:${error=None}}",
        "doc": null,
        "grammar": "snu",
        "label": "Wait Until Element Is Not Visible",
        "matches": [
          "wueinv"
        ],
        "opts": []
      },
      {
        "content": "Wait Until Element Is Visible    ${1:${locator}}    ${2:${timeout=None}}    ${3:${error=None}}",
        "doc": null,
        "grammar": "snu",
        "label": "Wait Until Element Is Visible",
        "matches": [
          "wueiv"
        ],
        "opts": []
      },
      {
        "content": "Wait Until Page Contains    ${1:${text}}    ${2:${timeout=None}}    ${3:${error=None}}",
        "doc": null,
        "grammar": "snu",
        "label": "Wait Until Page Contains",
        "matches": [
          "wupc"
        ],
        "opts": []
      },
      {
        "content": "Wait Until Page Contains Element    ${1:${locator}}    ${2:${timeout=None}}    ${3:${error=None}}",
        "doc": null,
        "grammar": "snu",
        "label": "Wait Until Page Contains Element",
        "matches": [
          "wupce"
        ],
        "opts": []
      },
      {
        "content": "Wait Until Page Does Not Contain    ${1:${text}}    ${2:${timeout=None}}    ${3:${error=None}}",
        "doc": null,
        "grammar": "snu",
        "label": "Wait Until Page Does Not Contain",
        "matches": [
          "wupdnc"
        ],
        "opts": []
      },
      {
        "content": "Wait Until Page Does Not Contain Element    ${1:${locator}}    ${2:${timeout=None}}    ${3:${error=None}}",
        "doc": null,
        "grammar": "snu",
        "label": "Wait Until Page Does Not Contain Element",
        "matches": [
          "wupdnce"
        ],
        "opts": []
      }
    ],
    "rst": [
      {
        "content": "===========================\n${1:#:content_name}\n===========================\n.. contents:: contents_name\ntitle1\n====================================\nsubtitle1\n-----------------------------------\nsubtitle2\n-----------------------------------\nsubtitle3\n-----------------------------------\ntitle2\n====================================\nsubtitle1\n-----------------------------------\nsubtitle2\n-----------------------------------\nsubtitle3\n-----------------------------------\ntitle3\n====================================\nsubtitle1\n-----------------------------------\nsubtitle2\n-----------------------------------\nsubtitle3\n-----------------------------------",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "quickstart"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": ".. contents:: ${1:#:contents_name}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "contnents"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "${1:#:title}\n====================================",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "title"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "${1:#:subtitle}\n-----------------------------------",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "subtitle"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": ".. code-block:: ${1:#:filetype}\n${2:#:content}",
        "doc": "",
        "grammar": "snu",
        "label": "code",
        "matches": [
          "code_block"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "\\`${1:#:link}\\`_",
        "doc": "",
        "grammar": "snu",
        "label": "link_as_raw",
        "matches": [
          "link_raw"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "\\`${1:#:title} <${2:#:link}>\\`_",
        "doc": "",
        "grammar": "snu",
        "label": "link_and_label",
        "matches": [
          "link_label"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "+------------------+------------+-----------------------+------------+\n|${1:#:cel} | | | |\n+==================+============+=======================+============+\n| | | | |\n+------------------+------------+-----------------------+------------+\n| | | | |\n+------------------+------------+-----------------------+------------+",
        "doc": "",
        "grammar": "snu",
        "label": "grid_table",
        "matches": [
          "table_grid"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": ":${1:#:text}:\n: :\n: :\n: :",
        "doc": "",
        "grammar": "snu",
        "label": "simple_table",
        "matches": [
          "table_simple"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "-\n-\n-\n-",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "list"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "- ${1:#:text}\n-\n-\n-",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nested_list"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "[#]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "caption"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": ".. image:: ${1:#:path}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "image"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "**${1:#:text}**",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "strong"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": ".. toctree::\n\t:maxdepth: ${1:2}\n\t${2:#:FILES}",
        "doc": "",
        "grammar": "snu",
        "label": "directive_toctree",
        "matches": [
          "toctree"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": ":doc:\\`${1:#:PageName}\\` ${0:#:CURSOR}",
        "doc": "",
        "grammar": "snu",
        "label": "link_to_doc",
        "matches": [
          "link_doc"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": ".. code-block:: ${1:python}\n\t${1:#:TERGET}",
        "doc": "",
        "grammar": "snu",
        "label": "syntax",
        "matches": [
          "syntax"
        ],
        "opts": [
          "indent"
        ]
      },
      {
        "content": ".. _${1:#:NAME}:\n${2:#:CURSOR}",
        "doc": "",
        "grammar": "snu",
        "label": "label",
        "matches": [
          "label"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": ":ref:\\`${1:#:NAME}\\`\n${2:#:CURSOR}",
        "doc": "",
        "grammar": "snu",
        "label": "role_ref",
        "matches": [
          "ref"
        ],
        "opts": []
      },
      {
        "content": ".. contents::\n\t:depth: ${1:2}\n\t${2::local:}",
        "doc": "",
        "grammar": "snu",
        "label": "directive_content",
        "matches": [
          "content"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": ":guilabel:\\`${1:#:NAME}\\` ${0:#:CURSOR}",
        "doc": "",
        "grammar": "snu",
        "label": "role_guilabel",
        "matches": [
          "guilabel"
        ],
        "opts": []
      },
      {
        "content": ":menuselection:\\`${1:#:NAME} --> ${2:#:NAME}\\` ${0:#:CURSOR}",
        "doc": "",
        "grammar": "snu",
        "label": "role_menuselection",
        "matches": [
          "menuselection"
        ],
        "opts": []
      },
      {
        "content": ".. table:: ${1:#:TITLE}\n\t${0:#:CURSOR}",
        "doc": "",
        "grammar": "snu",
        "label": "directive_table",
        "matches": [
          "table"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": ".. csv-table:: ${1:#:TITLE}\n\t:header: \"${2:#:Header1}\", \"${3:#:Header2}\"${4:#:Headers}\n\t\"${5:#:Column1}\", \"${6:#:Column2}\"${0:#:CURSOR}",
        "doc": "",
        "grammar": "snu",
        "label": "directive_csvtable",
        "matches": [
          "csvtable"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": ".. ${1:#:NAME}:: ${0:#:CURSOR}",
        "doc": "",
        "grammar": "snu",
        "label": "directive",
        "matches": [
          "directive"
        ],
        "opts": []
      },
      {
        "content": ".. note:: ${0:#:CURSOR}",
        "doc": "",
        "grammar": "snu",
        "label": "note",
        "matches": [
          "note"
        ],
        "opts": []
      },
      {
        "content": ".. tip:: ${0:#:CURSOR}",
        "doc": "",
        "grammar": "snu",
        "label": "tip",
        "matches": [
          "tip"
        ],
        "opts": []
      },
      {
        "content": ".. warning:: ${0:#:CURSOR}",
        "doc": "",
        "grammar": "snu",
        "label": "warning",
        "matches": [
          "warning"
        ],
        "opts": []
      },
      {
        "content": ".. attention:: ${0:#:CURSOR}",
        "doc": "",
        "grammar": "snu",
        "label": "attention",
        "matches": [
          "attention"
        ],
        "opts": []
      },
      {
        "content": ".. caution:: ${0:#:CURSOR}",
        "doc": "",
        "grammar": "snu",
        "label": "caution",
        "matches": [
          "caution"
        ],
        "opts": []
      },
      {
        "content": ".. danger:: ${0:#:CURSOR}",
        "doc": "",
        "grammar": "snu",
        "label": "danger",
        "matches": [
          "danger"
        ],
        "opts": []
      },
      {
        "content": ".. error:: ${0:#:CURSOR}",
        "doc": "",
        "grammar": "snu",
        "label": "error",
        "matches": [
          "error"
        ],
        "opts": []
      },
      {
        "content": ".. hint:: ${0:#:CURSOR}",
        "doc": "",
        "grammar": "snu",
        "label": "hint",
        "matches": [
          "hint"
        ],
        "opts": []
      },
      {
        "content": ".. important:: ${0:#:CURSOR}",
        "doc": "",
        "grammar": "snu",
        "label": "important",
        "matches": [
          "important"
        ],
        "opts": []
      },
      {
        "content": ".. seealso:: ${0:#:CURSOR}",
        "doc": "",
        "grammar": "snu",
        "label": "seealso",
        "matches": [
          "seealso"
        ],
        "opts": []
      },
      {
        "content": ":${1:field name}: ${0:field body}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ":"
        ],
        "opts": []
      },
      {
        "content": "*${1:Emphasis}* ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "*"
        ],
        "opts": []
      },
      {
        "content": "**${1:Strong emphasis}** ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "**"
        ],
        "opts": []
      },
      {
        "content": "\\`${1:hyperlink-name}\\`_\n.. _\\`$1\\`: ${0:link-block}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "_"
        ],
        "opts": []
      },
      {
        "content": "${1:Title}\n=====${2:=}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "="
        ],
        "opts": []
      },
      {
        "content": "${1:Title}\n-----${2:-}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "-"
        ],
        "opts": []
      },
      {
        "content": ".. |${1:alias}| image:: ${0:img}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "img:"
        ],
        "opts": []
      },
      {
        "content": ".. figure:: ${1:img}\n\t:alt: ${2:alter text}\n\t$0",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fig:"
        ],
        "opts": []
      },
      {
        "content": ".. contents:: ${1:Table of Contents}\n\t${0:content}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "con:"
        ],
        "opts": []
      },
      {
        "content": ".. code:: ${1:type}\n\t${0:write some code}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cod:"
        ],
        "opts": []
      },
      {
        "content": ".. tip::\n\t${0:my tips}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tip:"
        ],
        "opts": []
      },
      {
        "content": ".. note::\n\t${0:my notes}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "not:"
        ],
        "opts": []
      },
      {
        "content": ".. warning::\n\t${0:attention!}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "war:"
        ],
        "opts": []
      },
      {
        "content": ".. important::\n\t${0:this is importatnt}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "imp:"
        ],
        "opts": []
      },
      {
        "content": ".. attention::\n\t${0:hey!}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "att:"
        ],
        "opts": []
      },
      {
        "content": ".. danger::\n\t${0:ah!}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dan:"
        ],
        "opts": []
      },
      {
        "content": ".. error::\n\t${0:Error occur}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "err:"
        ],
        "opts": []
      },
      {
        "content": ".. caution::\n\t${0:Watch out!}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cau:"
        ],
        "opts": []
      },
      {
        "content": ".. sidebar:: ${1:Title}\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sid:"
        ],
        "opts": []
      },
      {
        "content": ".. todo::\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tod:"
        ],
        "opts": []
      },
      {
        "content": ".. list-table:: ${1:Title}\n\t:header-rows: 1\n\t:stub-columns: 0\n\t* - ${0:R1C1}\n\t  - R1C2\n\t* - R2C1\n\t  - R2C2",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lis:"
        ],
        "opts": []
      },
      {
        "content": ".. csv-table:: ${1:Title}\n\t:header-rows: 1\n\t:stub-columns: 0\n\t${0:R1C1}, R1C2\n\tR2C1, R2C2",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "csv:"
        ],
        "opts": []
      },
      {
        "content": ".. toctree::\n\t:maxdepth: 2\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "toc:"
        ],
        "opts": []
      },
      {
        "content": ":download:\\`${1:text} <${0:path}>\\`",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dow:"
        ],
        "opts": []
      },
      {
        "content": ":ref:\\`${1:text} <${0:path}>\\`",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ref:"
        ],
        "opts": []
      },
      {
        "content": ":doc:\\`${1:text} <${0:path}>\\`",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "doc:"
        ],
        "opts": []
      },
      {
        "content": "\\ *${1:Emphasis}*\\ ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "*c"
        ],
        "opts": []
      },
      {
        "content": "\\ **${1:Strong emphasis}**\\ ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "**c"
        ],
        "opts": []
      }
    ],
    "ruby": [
      {
        "content": "# encoding: utf-8",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "enc"
        ],
        "opts": []
      },
      {
        "content": "# frozen_string_literal: true",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "frozen"
        ],
        "opts": []
      },
      {
        "content": "#!/usr/bin/env ruby",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#!"
        ],
        "opts": []
      },
      {
        "content": "=begin rdoc\n\t${0}\n=end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "=b"
        ],
        "opts": []
      },
      {
        "content": "protected\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prot"
        ],
        "opts": []
      },
      {
        "content": "private\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "priv"
        ],
        "opts": []
      },
      {
        "content": ":yields: ${0:arguments}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "y"
        ],
        "opts": []
      },
      {
        "content": "#!/usr/bin/env ruby -wKU",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rb"
        ],
        "opts": []
      },
      {
        "content": "begin\n\t${0}\nrescue ${1:StandardError} => ${2:e}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "beg"
        ],
        "opts": []
      },
      {
        "content": "require '${1}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "req require"
        ],
        "opts": []
      },
      {
        "content": "require_relative '${1}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "reqr"
        ],
        "opts": []
      },
      {
        "content": "# =>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#"
        ],
        "opts": []
      },
      {
        "content": "case ${1:object}\nwhen ${2:condition}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case"
        ],
        "opts": []
      },
      {
        "content": "when ${1:condition}\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "when"
        ],
        "opts": []
      },
      {
        "content": "def ${1:method_name}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "def"
        ],
        "opts": []
      },
      {
        "content": "def test_${1:case_name}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "deft"
        ],
        "opts": []
      },
      {
        "content": "class Class\n\tdef descendants\n\t\tObjectSpace.each_object(::Class).select { |klass| klass < self }\n\tend\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "descendants"
        ],
        "opts": []
      },
      {
        "content": "if ${1:condition}\n\t${0:${VISUAL}}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "if ${1:condition}\n\t${2:${VISUAL}}\nelse\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "elsif ${1:condition}\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eif"
        ],
        "opts": []
      },
      {
        "content": "if ${1:condition}\n\t$2\nelsif ${3:condition}\n\t$4\nelse\n\t$0\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifee"
        ],
        "opts": []
      },
      {
        "content": "unless ${1:condition}\n\t${0:${VISUAL}}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "unless"
        ],
        "opts": []
      },
      {
        "content": "unless ${1:condition}\n\t$2\nelse\n\t$0\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "unlesse"
        ],
        "opts": []
      },
      {
        "content": "unless ${1:condition}\n\t$2\nelsif ${3:condition}\n\t$4\nelse\n\t$0\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "unlesee"
        ],
        "opts": []
      },
      {
        "content": "while ${1:condition}\n\t${0:${VISUAL}}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh"
        ],
        "opts": []
      },
      {
        "content": "for ${1:e} in ${2:c}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "until ${1:condition}\n\t${0:${VISUAL}}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "until"
        ],
        "opts": []
      },
      {
        "content": "class ${1:`substitute(vim_snippets#Filename(), '\\(_\\|^\\)\\(.\\)', '\\u\\2', 'g')`}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cla class .. end"
        ],
        "opts": []
      },
      {
        "content": "class ${1:`substitute(vim_snippets#Filename(), '\\(_\\|^\\)\\(.\\)', '\\u\\2', 'g')`}\n\tdef initialize(${2:args})\n\t\t${0}\n\tend\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "clai class .. initialize .. end"
        ],
        "opts": []
      },
      {
        "content": "class ${1:`substitute(vim_snippets#Filename(), '\\(_\\|^\\)\\(.\\)', '\\u\\2', 'g')`} < ${2:ParentClass}\n\tdef initialize(${3:args})\n\t\t${0}\n\tend\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cla< class .. < ParentClass .. initialize .. end"
        ],
        "opts": []
      },
      {
        "content": "class ${0:BlankSlate}\n\tinstance_methods.each { |meth| undef_method(meth) unless meth =~ /\\A__/ }\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "blankslate class BlankSlate .. initialize .. end"
        ],
        "opts": []
      },
      {
        "content": "class << ${1:self}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "claself class << self .. end"
        ],
        "opts": []
      },
      {
        "content": "class ${1:`substitute(vim_snippets#Filename(), '\\(_\\|^\\)\\(.\\)', '\\u\\2', 'g')`} < DelegateClass(${2:ParentClass})\n\tdef initialize(${3:args})\n\t\tsuper(${4:del_obj})\n\t\t${0}\n\tend\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cla-"
        ],
        "opts": []
      },
      {
        "content": "module ${1:`substitute(vim_snippets#Filename(), '\\(_\\|^\\)\\(.\\)', '\\u\\2', 'g')`}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mod module .. end"
        ],
        "opts": []
      },
      {
        "content": "attr_reader :${0:attr_names}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "r"
        ],
        "opts": []
      },
      {
        "content": "attr_writer :${0:attr_names}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "w"
        ],
        "opts": []
      },
      {
        "content": "attr_accessor :${0:attr_names}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rw"
        ],
        "opts": []
      },
      {
        "content": "attr_protected :${0:attr_names}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "atp"
        ],
        "opts": []
      },
      {
        "content": "attr_accessible :${0:attr_names}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ata"
        ],
        "opts": []
      },
      {
        "content": "accepts_nested_attributes_for :${0:association}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ana"
        ],
        "opts": []
      },
      {
        "content": "@${1:variable_name} ||= ${0:cached_value}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ivc"
        ],
        "opts": []
      },
      {
        "content": "include Enumerable\ndef each(&block)\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Enum"
        ],
        "opts": []
      },
      {
        "content": "include Comparable\ndef <=>(other)\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Comp"
        ],
        "opts": []
      },
      {
        "content": "extend Forwardable",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Forw-"
        ],
        "opts": []
      },
      {
        "content": "def self.${1:class_method_name}\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defs"
        ],
        "opts": []
      },
      {
        "content": "def initialize(${1:args})\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "definit"
        ],
        "opts": []
      },
      {
        "content": "def method_missing(meth, *args, &blk)\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defmm"
        ],
        "opts": []
      },
      {
        "content": "def_delegator :${1:@del_obj}, :${2:del_meth}, :${0:new_name}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defd"
        ],
        "opts": []
      },
      {
        "content": "def_delegators :${1:@del_obj}, :${0:del_methods}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defds"
        ],
        "opts": []
      },
      {
        "content": "alias_method :${1:new_name}, :${0:old_name}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "am"
        ],
        "opts": []
      },
      {
        "content": "if __FILE__ == $PROGRAM_NAME\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "app"
        ],
        "opts": []
      },
      {
        "content": "if ARGV.${1}\n\tabort \"Usage: #{$PROGRAM_NAME} ${2:ARGS_GO_HERE}\"${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "usai"
        ],
        "opts": []
      },
      {
        "content": "unless ARGV.${1}\n\tabort \"Usage: #{$PROGRAM_NAME} ${2:ARGS_GO_HERE}\"${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "usau"
        ],
        "opts": []
      },
      {
        "content": "Array.new(${1:10}) { |${2:i}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "array"
        ],
        "opts": []
      },
      {
        "content": "Hash.new { |${1:hash}, ${2:key}| $1[$2] = ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "hash"
        ],
        "opts": []
      },
      {
        "content": "File.foreach(${1:'path/to/file'}) { |${2:line}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "file File.foreach() { |line| .. }"
        ],
        "opts": []
      },
      {
        "content": "File.read(${1:'path/to/file'})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "file File.read()"
        ],
        "opts": []
      },
      {
        "content": "Dir.glob(${1:'dir/glob/*'}) { |${2:file}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Dir Dir.global() { |file| .. }"
        ],
        "opts": []
      },
      {
        "content": "Dir[${1:'glob/**/*.rb'}]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Dir Dir[\"..\"]"
        ],
        "opts": []
      },
      {
        "content": "Filename.dirname(__FILE__)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dir"
        ],
        "opts": []
      },
      {
        "content": "delete_if { |${1:e}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "deli"
        ],
        "opts": []
      },
      {
        "content": "fill(${1:range}) { |${2:i}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fil"
        ],
        "opts": []
      },
      {
        "content": "reduce(Array.new) { |${1:arr}, ${2:a}| $1.push(*$2) }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "flao"
        ],
        "opts": []
      },
      {
        "content": "zip(${1:enums}) { |${2:row}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "zip"
        ],
        "opts": []
      },
      {
        "content": "downto(${1:0}) { |${2:n}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dow"
        ],
        "opts": []
      },
      {
        "content": "step(${1:2}) { |${2:n}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ste"
        ],
        "opts": []
      },
      {
        "content": "times { |${1:n}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tim"
        ],
        "opts": []
      },
      {
        "content": "upto(${1:1.0/0.0}) { |${2:n}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "upt"
        ],
        "opts": []
      },
      {
        "content": "loop { ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "loo"
        ],
        "opts": []
      },
      {
        "content": "each { |${1:e}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ea"
        ],
        "opts": []
      },
      {
        "content": "each do |${1:e}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ead"
        ],
        "opts": []
      },
      {
        "content": "each_byte { |${1:byte}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eab"
        ],
        "opts": []
      },
      {
        "content": "each_char { |${1:chr}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eac- each_char { |chr| .. }"
        ],
        "opts": []
      },
      {
        "content": "each_cons(${1:2}) { |${2:group}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eac- each_cons(..) { |group| .. }"
        ],
        "opts": []
      },
      {
        "content": "each_index { |${1:i}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eai"
        ],
        "opts": []
      },
      {
        "content": "each_index do |${1:i}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eaid"
        ],
        "opts": []
      },
      {
        "content": "each_key { |${1:key}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eak"
        ],
        "opts": []
      },
      {
        "content": "each_key do |${1:key}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eakd"
        ],
        "opts": []
      },
      {
        "content": "each_line { |${1:line}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eal"
        ],
        "opts": []
      },
      {
        "content": "each_line do |${1:line}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eald"
        ],
        "opts": []
      },
      {
        "content": "each_pair { |${1:name}, ${2:val}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eap"
        ],
        "opts": []
      },
      {
        "content": "each_pair do |${1:name}, ${2:val}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eapd"
        ],
        "opts": []
      },
      {
        "content": "each_slice(${1:2}) { |${2:group}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eas-"
        ],
        "opts": []
      },
      {
        "content": "each_slice(${1:2}) do |${2:group}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "easd-"
        ],
        "opts": []
      },
      {
        "content": "each_value { |${1:val}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eav"
        ],
        "opts": []
      },
      {
        "content": "each_value do |${1:val}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eavd"
        ],
        "opts": []
      },
      {
        "content": "each_with_index { |${1:e}, ${2:i}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eawi"
        ],
        "opts": []
      },
      {
        "content": "each_with_index do |${1:e}, ${2:i}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eawid"
        ],
        "opts": []
      },
      {
        "content": "each_with_object(${1:init}) { |${2:e}, ${3:var}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eawo"
        ],
        "opts": []
      },
      {
        "content": "each_with_object(${1:init}) do |${2:e}, ${3:var}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eawod"
        ],
        "opts": []
      },
      {
        "content": "reverse_each { |${1:e}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "reve"
        ],
        "opts": []
      },
      {
        "content": "reverse_each do |${1:e}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "reved"
        ],
        "opts": []
      },
      {
        "content": "inject(${1:init}) { |${2:mem}, ${3:var}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "inj"
        ],
        "opts": []
      },
      {
        "content": "inject(${1:init}) do |${2:mem}, ${3:var}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "injd"
        ],
        "opts": []
      },
      {
        "content": "reduce(${1:init}) { |${2:mem}, ${3:var}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "red"
        ],
        "opts": []
      },
      {
        "content": "reduce(${1:init}) do |${2:mem}, ${3:var}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "redd"
        ],
        "opts": []
      },
      {
        "content": "map { |${1:e}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "map"
        ],
        "opts": []
      },
      {
        "content": "map do |${1:e}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mapd"
        ],
        "opts": []
      },
      {
        "content": "enum_with_index.map { |${1:e}, ${2:i}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mapwi-"
        ],
        "opts": []
      },
      {
        "content": "sort { |a, b| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sor"
        ],
        "opts": []
      },
      {
        "content": "sort_by { |${1:e}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sorb"
        ],
        "opts": []
      },
      {
        "content": "sort_by { rand }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ran"
        ],
        "opts": []
      },
      {
        "content": "all? { |${1:e}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "all"
        ],
        "opts": []
      },
      {
        "content": "any? { |${1:e}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "any"
        ],
        "opts": []
      },
      {
        "content": "classify { |${1:e}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cl"
        ],
        "opts": []
      },
      {
        "content": "collect { |${1:e}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "col"
        ],
        "opts": []
      },
      {
        "content": "collect do |${1:e}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cold"
        ],
        "opts": []
      },
      {
        "content": "detect { |${1:e}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "det"
        ],
        "opts": []
      },
      {
        "content": "detect do |${1:e}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "detd"
        ],
        "opts": []
      },
      {
        "content": "fetch(${1:name}) { |${2:key}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fet"
        ],
        "opts": []
      },
      {
        "content": "find { |${1:e}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fin"
        ],
        "opts": []
      },
      {
        "content": "find do |${1:e}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "find"
        ],
        "opts": []
      },
      {
        "content": "find_all { |${1:e}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fina"
        ],
        "opts": []
      },
      {
        "content": "find_all do |${1:e}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "finad"
        ],
        "opts": []
      },
      {
        "content": "grep(${1:/pattern/}) { |${2:match}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gre"
        ],
        "opts": []
      },
      {
        "content": "${1:g}sub(${2:/pattern/}) { |${3:match}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sub"
        ],
        "opts": []
      },
      {
        "content": "scan(${1:/pattern/}) { |${2:match}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sca"
        ],
        "opts": []
      },
      {
        "content": "scan(${1:/pattern/}) do |${2:match}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "scad"
        ],
        "opts": []
      },
      {
        "content": "max { |a, b| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "max"
        ],
        "opts": []
      },
      {
        "content": "min { |a, b| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "min"
        ],
        "opts": []
      },
      {
        "content": "partition { |${1:e}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "par"
        ],
        "opts": []
      },
      {
        "content": "partition do |${1:e}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pard"
        ],
        "opts": []
      },
      {
        "content": "reject { |${1:e}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rej"
        ],
        "opts": []
      },
      {
        "content": "reject do |${1:e}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rejd"
        ],
        "opts": []
      },
      {
        "content": "select { |${1:e}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sel"
        ],
        "opts": []
      },
      {
        "content": "select do |${1:e}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "seld"
        ],
        "opts": []
      },
      {
        "content": "lambda { |${1:args}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lam"
        ],
        "opts": []
      },
      {
        "content": "-> { ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "->"
        ],
        "opts": []
      },
      {
        "content": "->(${1:args}) { ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "->a"
        ],
        "opts": []
      },
      {
        "content": "do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "do"
        ],
        "opts": []
      },
      {
        "content": "do |${1:v}|\n\t${2}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dov"
        ],
        "opts": []
      },
      {
        "content": "${1:key}: ${2:'value'}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ":"
        ],
        "opts": []
      },
      {
        "content": "open('${1:path/or/url/or/pipe}', '${2:w}') { |${3:io}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ope"
        ],
        "opts": []
      },
      {
        "content": "File.join(File.dirname(__FILE__), *['${1:rel path here}'])",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fpath"
        ],
        "opts": []
      },
      {
        "content": "ARGF.each_line${1} do |${2:line}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "unif"
        ],
        "opts": []
      },
      {
        "content": "require 'optparse'\noptions = { ${0:default: 'args'} }\nARGV.options do |opts|\n\topts.banner = \"Usage: #{File.basename($PROGRAM_NAME)}\"\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "optp"
        ],
        "opts": []
      },
      {
        "content": "opts.on('-${1:o}', '--${2:long-option-name}', ${3:String}, '${4:Option description.}') do |${5:opt}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "opt"
        ],
        "opts": []
      },
      {
        "content": "require 'test/unit'\nrequire '${1:library_file_name}'\nclass Test${2:$1} < Test::Unit::TestCase\n\tdef test_${3:case_name}\n\t\t${0}\n\tend\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tc"
        ],
        "opts": []
      },
      {
        "content": "require 'test/unit'\nrequire 'tc_${1:test_case_file}'\nrequire 'tc_${2:test_case_file}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ts"
        ],
        "opts": []
      },
      {
        "content": "assert ${1:test}, '${2:Failure message.}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as"
        ],
        "opts": []
      },
      {
        "content": "assert_equal ${1:expected}, ${2:actual}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ase"
        ],
        "opts": []
      },
      {
        "content": "assert_not_equal ${1:unexpected}, ${2:actual}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asne"
        ],
        "opts": []
      },
      {
        "content": "assert_in_delta ${1:expected_float}, ${2:actual_float}, ${3:2**-20}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asid"
        ],
        "opts": []
      },
      {
        "content": "assert_includes ${1:collection}, ${2:object}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asi"
        ],
        "opts": []
      },
      {
        "content": "assert_instance_of ${1:ExpectedClass}, ${2:actual_instance}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asio"
        ],
        "opts": []
      },
      {
        "content": "assert_kind_of ${1:ExpectedKind}, ${2:actual_instance}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asko"
        ],
        "opts": []
      },
      {
        "content": "assert_nil ${1:instance}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asn"
        ],
        "opts": []
      },
      {
        "content": "assert_not_nil ${1:instance}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asnn"
        ],
        "opts": []
      },
      {
        "content": "assert_match(/${1:expected_pattern}/, ${2:actual_string})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asm"
        ],
        "opts": []
      },
      {
        "content": "assert_no_match(/${1:unexpected_pattern}/, ${2:actual_string})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asnm"
        ],
        "opts": []
      },
      {
        "content": "assert_operator ${1:left}, :${2:operator}, ${3:right}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "aso"
        ],
        "opts": []
      },
      {
        "content": "assert_raises(${1:StandardError}) { ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asr"
        ],
        "opts": []
      },
      {
        "content": "assert_raises ${1:StandardError} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asrd"
        ],
        "opts": []
      },
      {
        "content": "assert_nothing_raised(${1:StandardError}) { ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asnr"
        ],
        "opts": []
      },
      {
        "content": "assert_nothing_raised ${1:StandardError} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asnrd"
        ],
        "opts": []
      },
      {
        "content": "assert_respond_to ${1:object}, :${2:method}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asrt"
        ],
        "opts": []
      },
      {
        "content": "assert_same ${1:expected}, ${2:actual}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ass assert_same(..)"
        ],
        "opts": []
      },
      {
        "content": "assert_send [${1:object}, :${2:message}, ${3:args}]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asss assert_send(..)"
        ],
        "opts": []
      },
      {
        "content": "assert_not_same ${1:unexpected}, ${2:actual}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asns"
        ],
        "opts": []
      },
      {
        "content": "assert_throws :${1:expected}, -> { ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ast"
        ],
        "opts": []
      },
      {
        "content": "assert_throws :${1:expected} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "astd"
        ],
        "opts": []
      },
      {
        "content": "assert_nothing_thrown { ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asnt"
        ],
        "opts": []
      },
      {
        "content": "assert_nothing_thrown do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asntd"
        ],
        "opts": []
      },
      {
        "content": "flunk '${1:Failure message.}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fl"
        ],
        "opts": []
      },
      {
        "content": "refute ${1:test}, '${2:Failure message.}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rf"
        ],
        "opts": []
      },
      {
        "content": "refute_equal ${1:unexpected}, ${2:actual}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rfe"
        ],
        "opts": []
      },
      {
        "content": "refute_kind_of ${1:UnexpectedKind}, ${2:actual_instance}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rfko"
        ],
        "opts": []
      },
      {
        "content": "refute_nil ${1:instance}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rfn"
        ],
        "opts": []
      },
      {
        "content": "refute_operator ${1:left}, :${2:operator}, ${3:right}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rfo"
        ],
        "opts": []
      },
      {
        "content": "refute_includes ${1:collection}, ${2:object}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rfi"
        ],
        "opts": []
      },
      {
        "content": "refute_in_delta ${1:unexpected_float}, ${2:actual_float}, ${3:2**-20}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rfid"
        ],
        "opts": []
      },
      {
        "content": "refute_instance_of ${1:UnexpectedClass}, ${2:actual_instance}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rfio"
        ],
        "opts": []
      },
      {
        "content": "refute_same ${1:unexpected}, ${2:actual}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rfs"
        ],
        "opts": []
      },
      {
        "content": "TESTS = ${1:10_000}\nBenchmark.bmbm do |results|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bm-"
        ],
        "opts": []
      },
      {
        "content": "results.report('${1:name}:') { TESTS.times { ${0} } }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rep"
        ],
        "opts": []
      },
      {
        "content": "File.open('${1:path/to/file.dump}', 'wb') { |${2:file}| Marshal.dump(${3:obj}, $2) }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Md"
        ],
        "opts": []
      },
      {
        "content": "File.open('${1:path/to/file.dump}', 'rb') { |${2:file}| Marshal.load($2) }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Ml"
        ],
        "opts": []
      },
      {
        "content": "Marshal.load(Marshal.dump(${1:obj_to_copy}))",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "deec"
        ],
        "opts": []
      },
      {
        "content": "PStore.new('${1:file_name.pstore}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Pn-"
        ],
        "opts": []
      },
      {
        "content": "transaction(${1:true}) { ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tra"
        ],
        "opts": []
      },
      {
        "content": "REXML::Document.new(File.read('${1:path/to/file}'))",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "xml-"
        ],
        "opts": []
      },
      {
        "content": "elements.each('${1://Xpath}') do |${2:node}|\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "xpa"
        ],
        "opts": []
      },
      {
        "content": "split('::').inject(Object) { |par, const| par.const_get(const) }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "clafn"
        ],
        "opts": []
      },
      {
        "content": "class << self; self end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sinc"
        ],
        "opts": []
      },
      {
        "content": "namespace :${1:`vim_snippets#Filename()`} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nam"
        ],
        "opts": []
      },
      {
        "content": "desc '${1:Task description}'\ntask ${2:task_name: [:dependent, :tasks]} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tas"
        ],
        "opts": []
      },
      {
        "content": "{ |${1:var}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "b"
        ],
        "opts": []
      },
      {
        "content": "begin\n\tfail 'A test exception.'\nrescue StandardError => e\n\tputs e.message\n\tputs e.backtrace.inspect\nelse\n\t# other exception\nensure\n\t# always executed\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "begin"
        ],
        "opts": []
      },
      {
        "content": "require 'byebug'; byebug",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "debug"
        ],
        "opts": []
      },
      {
        "content": "require 'debugger'; debugger",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "debug19"
        ],
        "opts": []
      },
      {
        "content": "require 'ruby-debug'; debugger",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "debug18"
        ],
        "opts": []
      },
      {
        "content": "require 'pry'; binding.pry",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pry"
        ],
        "opts": []
      },
      {
        "content": "strftime('${1:%Y-%m-%d %H:%M:%S %z}')${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "strf"
        ],
        "opts": []
      },
      {
        "content": "must_be ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mb"
        ],
        "opts": []
      },
      {
        "content": "wont_be ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wb"
        ],
        "opts": []
      },
      {
        "content": "must_be_empty",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mbe"
        ],
        "opts": []
      },
      {
        "content": "wont_be_empty",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wbe"
        ],
        "opts": []
      },
      {
        "content": "must_be_instance_of ${0:Class}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mbio"
        ],
        "opts": []
      },
      {
        "content": "wont_be_instance_of ${0:Class}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wbio"
        ],
        "opts": []
      },
      {
        "content": "must_be_kind_of ${0:Class}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mbko"
        ],
        "opts": []
      },
      {
        "content": "wont_be_kind_of ${0:Class}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wbko"
        ],
        "opts": []
      },
      {
        "content": "must_be_nil",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mbn"
        ],
        "opts": []
      },
      {
        "content": "wont_be_nil",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wbn"
        ],
        "opts": []
      },
      {
        "content": "must_be_same_as ${0:other}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mbsa"
        ],
        "opts": []
      },
      {
        "content": "wont_be_same_as ${0:other}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wbsa"
        ],
        "opts": []
      },
      {
        "content": "-> { ${0} }.must_be_silent",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mbsi"
        ],
        "opts": []
      },
      {
        "content": "must_be_within_delta ${1:0.1}, ${2:0.1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mbwd"
        ],
        "opts": []
      },
      {
        "content": "wont_be_within_delta ${1:0.1}, ${2:0.1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wbwd"
        ],
        "opts": []
      },
      {
        "content": "must_be_within_epsilon ${1:0.1}, ${2:0.1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mbwe"
        ],
        "opts": []
      },
      {
        "content": "wont_be_within_epsilon ${1:0.1}, ${2:0.1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wbwe"
        ],
        "opts": []
      },
      {
        "content": "must_equal ${0:other}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "me"
        ],
        "opts": []
      },
      {
        "content": "wont_equal ${0:other}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "we"
        ],
        "opts": []
      },
      {
        "content": "must_include ${0:what}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mi"
        ],
        "opts": []
      },
      {
        "content": "wont_include ${0:what}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wi"
        ],
        "opts": []
      },
      {
        "content": "must_match /${0:regex}/",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mm"
        ],
        "opts": []
      },
      {
        "content": "wont_match /${0:regex}/",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wm"
        ],
        "opts": []
      },
      {
        "content": "-> { ${1} }.must_output '${0}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mout"
        ],
        "opts": []
      },
      {
        "content": "-> { ${1} }.must_raise ${0:StandardError}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mra"
        ],
        "opts": []
      },
      {
        "content": "must_respond_to :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mrt"
        ],
        "opts": []
      },
      {
        "content": "wont_respond_to :${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wrt"
        ],
        "opts": []
      },
      {
        "content": "must_send [ ${1:what}, :${2:method}, ${3:args} ]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "msend"
        ],
        "opts": []
      },
      {
        "content": "-> { throw :${1:error} }.must_throw :${2:error}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mthrow"
        ],
        "opts": []
      },
      {
        "content": "describe ${1:`substitute(substitute(vim_snippets#Filename(), '_spec$', '', ''), '\\(_\\|^\\)\\(.\\)', '\\u\\2', 'g')`} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "desc"
        ],
        "opts": []
      },
      {
        "content": "RSpec.describe ${1:`substitute(substitute(vim_snippets#Filename(), '_spec$', '', ''), '\\(_\\|^\\)\\(.\\)', '\\u\\2', 'g')`} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rdesc"
        ],
        "opts": []
      },
      {
        "content": "describe '${1:#method}' do\n\t${0:pending 'Not implemented'}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "descm"
        ],
        "opts": []
      },
      {
        "content": "context '${1:message}' do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cont"
        ],
        "opts": []
      },
      {
        "content": "before :${1:each} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bef"
        ],
        "opts": []
      },
      {
        "content": "after :${1:each} do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "aft"
        ],
        "opts": []
      },
      {
        "content": "let(:${1:object}) { ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "let"
        ],
        "opts": []
      },
      {
        "content": "let!(:${1:object}) { ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "let!"
        ],
        "opts": []
      },
      {
        "content": "subject { ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "subj"
        ],
        "opts": []
      },
      {
        "content": "subject.${0:method}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "s."
        ],
        "opts": []
      },
      {
        "content": "specify { subject.${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "spec"
        ],
        "opts": []
      },
      {
        "content": "expect(${1:object}).to ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "exp"
        ],
        "opts": []
      },
      {
        "content": "expect { ${1:object} }.to ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "expb"
        ],
        "opts": []
      },
      {
        "content": "expect { ${1:object} }.to raise_error ${2:StandardError}, /${0:message_regex}/",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "experr"
        ],
        "opts": []
      },
      {
        "content": "allow(${1:object}).to ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "allow"
        ],
        "opts": []
      },
      {
        "content": "shared_examples ${0:'shared examples name'}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "shared"
        ],
        "opts": []
      },
      {
        "content": "it_behaves_like ${0:'shared examples name'}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ibl"
        ],
        "opts": []
      },
      {
        "content": "it '${1:spec_name}' do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "it"
        ],
        "opts": []
      },
      {
        "content": "its(:${1:method}) { should ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "its"
        ],
        "opts": []
      },
      {
        "content": "it { should ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "is"
        ],
        "opts": []
      },
      {
        "content": "it { should_not ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isn"
        ],
        "opts": []
      },
      {
        "content": "it { expect(${1:object}).${2} ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "iexp"
        ],
        "opts": []
      },
      {
        "content": "it { expect { ${1:object} }.${2} ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "iexpb"
        ],
        "opts": []
      },
      {
        "content": "it { is_expected.to ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "iiexp"
        ],
        "opts": []
      },
      {
        "content": "it { is_expected.not_to ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "iiexpn"
        ],
        "opts": []
      },
      {
        "content": "aggregate_failures '${1:message}' do\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "agg"
        ],
        "opts": []
      },
      {
        "content": "#!/usr/bin/env ruby\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "#!/usr/bin/env ruby",
        "matches": [
          "#!",
          "shebang"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "if ${1:#:condition}\n  ${0:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "if ... end",
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "unless ${1:#:condition}\n  ${0:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "unless ... end",
        "matches": [
          "unless"
        ],
        "opts": []
      },
      {
        "content": "def ${1:#:method_name}\n  ${0:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "def ... end",
        "matches": [
          "def"
        ],
        "opts": []
      },
      {
        "content": "def ${1:#:method_name}\n  ${2:TARGET}\nrescue ${3:#:StandardError} => ${4:error}\n  ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "def ... rescue ... end",
        "matches": [
          "defrescue",
          "defr"
        ],
        "opts": []
      },
      {
        "content": "do\n  ${0:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "do ... end",
        "matches": [
          "do"
        ],
        "opts": []
      },
      {
        "content": "do |${1:#:var}|\n  ${0:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "do |var| ... end",
        "matches": [
          "dovar"
        ],
        "opts": []
      },
      {
        "content": "{\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "{ ... }",
        "matches": [
          "block"
        ],
        "opts": []
      },
      {
        "content": "{|${1:#:var}|\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "{|var| ... }",
        "matches": [
          "blockvar"
        ],
        "opts": []
      },
      {
        "content": "File.open(${1:#:filename}, '${2:#:mode}') do |${3:io}|\n  ${0:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "File.open(filename) do ... end",
        "matches": [
          "fileopen",
          "open"
        ],
        "opts": []
      },
      {
        "content": "end",
        "doc": "",
        "grammar": "snu",
        "label": "=> end?",
        "matches": [
          "edn"
        ],
        "opts": []
      },
      {
        "content": "# coding: utf-8\nrequire 'erb'\nputs ERB::Util.url_encode '${1}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "urlencode"
        ],
        "opts": []
      },
      {
        "content": "# coding: utf-8\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "enc",
          "encoding"
        ],
        "opts": []
      },
      {
        "content": "each do |${1:#:variable}|\n  ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "each"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "each_byte {|${1:#:variable}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "each_byte"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "each_char {|${1:#:variable}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "each_char"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "each_index {|${1:#:variable}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "each_index"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "each_key {|${1:#:variable}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "each_key"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "each_line {|${1:#:variable}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "each_line"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "each_with_index {|${1:#:variable}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "each_with_index"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "each_pair {|${1:#:key}, ${2:value}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "each_pair"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "each_pair do |${1:key}, ${2:value}|\n  ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "each_pair_do"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "map {|${1:#:variable}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "map"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "sort {|${1:x}, ${2:y}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sort"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "sort_by {|${1:#:variable}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sort_by"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "-> (${1:#:args}) { ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lambda"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "lambda {|${1:#:args}| ${0} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lambda-keyword"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "if __FILE__ == \\$0\n  ${0:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "main"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "File.dirname(File.expand_path(__FILE__))",
        "doc": "",
        "grammar": "snu",
        "label": "File.dirname(...)",
        "matches": [
          "filedir-legacy-compatibility",
          "__dir__"
        ],
        "opts": []
      },
      {
        "content": "Dir.glob(${1:'**/*'}) do |fname|\n  ${0:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "glob"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "case ${1}\nwhen ${2}\n  ${3}\nelse\n  ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "case ... when ... else ... end",
        "matches": [
          "case"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "class ${1:`substitute(expand('%:t:r:r:r'), '\\v%(^(.)|_(.))', '\\u\\1\\u\\2', 'g')`}\n  ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "class"
        ],
        "opts": []
      },
      {
        "content": "module ${1:`substitute(expand('%:t:r:r:r'), '\\v%(^(.)|_(.))', '\\u\\1\\u\\2', 'g')`}\n  ${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "module"
        ],
        "opts": []
      }
    ],
    "rust": [
      {
        "content": "fn ${1:function_name}(${2})${3} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fn \"Function definition\""
        ],
        "opts": []
      },
      {
        "content": "pub fn ${1:function_name}(${2})${3} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pfn \"Function definition\""
        ],
        "opts": []
      },
      {
        "content": "async fn ${1:function_name}(${2})${3} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "afn \"Async function definition\""
        ],
        "opts": []
      },
      {
        "content": "pub async fn ${1:function_name}(${2})${3} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pafn \"Async function definition\""
        ],
        "opts": []
      },
      {
        "content": "#[bench]\nfn ${1:bench_function_name}(b: &mut test::Bencher) {\n\tb.iter(|| {\n\t\t${0}\n\t})\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bench \"Bench function\" b"
        ],
        "opts": []
      },
      {
        "content": "pub fn new(${2}) -> ${1:Self} {\n\t$1 { ${3} }\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "new \"Constructor function\""
        ],
        "opts": []
      },
      {
        "content": "pub fn main() {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "main \"Main function\""
        ],
        "opts": []
      },
      {
        "content": "let ${1} = ${2};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "let \"let variable declaration with type inference\""
        ],
        "opts": []
      },
      {
        "content": "let ${1}: ${2} = ${3};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lett \"let variable declaration with explicit type annotation\""
        ],
        "opts": []
      },
      {
        "content": "let mut ${1} = ${2};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "letm \"let mut variable declaration with type inference\""
        ],
        "opts": []
      },
      {
        "content": "let mut ${1}: ${2} = ${3};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lettm \"let mut variable declaration with explicit type annotation\""
        ],
        "opts": []
      },
      {
        "content": "print!(\"${1}\");",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pri \"print!\""
        ],
        "opts": []
      },
      {
        "content": "print!(\"${1}{${2}}\", ${3});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pri, \"print! with format param\""
        ],
        "opts": []
      },
      {
        "content": "println!(\"${1}\");",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pln \"println!\""
        ],
        "opts": []
      },
      {
        "content": "println!(\"${1}{${2}}\", ${3});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pln, \"println! with format param\""
        ],
        "opts": []
      },
      {
        "content": "format!(\"${1}{${2}}\", ${3});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fmt \"format!\""
        ],
        "opts": []
      },
      {
        "content": "dbg!(${0:${VISUAL}})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d \"dbg! debugging macro\""
        ],
        "opts": []
      },
      {
        "content": "dbg!(&${1});\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d; \"dbg! debugging macro statement\""
        ],
        "opts": []
      },
      {
        "content": "extern crate ${1:sync};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ec \"extern crate\""
        ],
        "opts": []
      },
      {
        "content": "#[macro_use]\nextern crate log;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ecl \"extern crate log\""
        ],
        "opts": []
      },
      {
        "content": "mod ${1:`substitute(vim_snippets#Filename(), '\\(_\\|^\\)\\(.\\)', '\\u\\2', 'g')`} {\n\t${0}\n} /* $1 */",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mod"
        ],
        "opts": []
      },
      {
        "content": "assert!(${1:predicate});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as \"assert!\""
        ],
        "opts": []
      },
      {
        "content": "assert_eq!(${1:expected}, ${2:actual});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ase \"assert_eq!\""
        ],
        "opts": []
      },
      {
        "content": "#[test]\nfn ${1:function_name}_test() {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "test \"Unit test function\""
        ],
        "opts": []
      },
      {
        "content": "#[cfg(test)]\nmod tests {\n\tuse super::${1:*};\n\ttest${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "testmod \"Test module\" b"
        ],
        "opts": []
      },
      {
        "content": "#[ignore]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ig \"#[ignore]\""
        ],
        "opts": []
      },
      {
        "content": "#[allow(${1:unused_variables})]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "allow \"allow lint attribute\" b"
        ],
        "opts": []
      },
      {
        "content": "#[cfg(${1:target_os = \"linux\"})]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cfg \"cfg attribute\" b"
        ],
        "opts": []
      },
      {
        "content": "#![feature(${1:plugin})]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "feat \"feature attribute\" b"
        ],
        "opts": []
      },
      {
        "content": "#[derive(${1:Debug})]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "der \"#[derive(..)]\" b"
        ],
        "opts": []
      },
      {
        "content": "#[${1:inline}]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "attr \"#[..]\" b"
        ],
        "opts": []
      },
      {
        "content": "// Crate name\n#![crate_name = \"${1:crate_name}\"]\n// Additional metadata attributes\n#![desc = \"${2:Description.}\"]\n#![license = \"${3:BSD}\"]\n#![comment = \"${4:Comment.}\"]\n// Specify the output type\n#![crate_type = \"${5:lib}\"]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "crate \"Define create meta attributes\""
        ],
        "opts": []
      },
      {
        "content": "Option<${1:i32}>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "opt \"Option<T>\""
        ],
        "opts": []
      },
      {
        "content": "Result<${1:&str}, ${2:()}>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "res \"Result<T, E>\""
        ],
        "opts": []
      },
      {
        "content": "if ${1} {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "if ${1} {\n\t${2:${VISUAL}}\n} else {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife \"if / else\""
        ],
        "opts": []
      },
      {
        "content": "if let ${1:Some($2)} = $3 {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifl \"if let (...)\""
        ],
        "opts": []
      },
      {
        "content": "else {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "el \"else\""
        ],
        "opts": []
      },
      {
        "content": "else if ${1} {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eli \"else if\""
        ],
        "opts": []
      },
      {
        "content": "match ${1} {\n\t${2} => ${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mat \"match pattern\""
        ],
        "opts": []
      },
      {
        "content": "${1:_} => ${2:expression}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case \"Case clause of pattern match\""
        ],
        "opts": []
      },
      {
        "content": "=> $0",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "= \"=> \""
        ],
        "opts": []
      },
      {
        "content": "loop {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "loop \"loop {}\" b"
        ],
        "opts": []
      },
      {
        "content": "while ${1:condition} {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh \"while loop\""
        ],
        "opts": []
      },
      {
        "content": "while let ${1:Some($2)} = $3 {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whl \"while let (...)\""
        ],
        "opts": []
      },
      {
        "content": "for ${1:i} in ${2} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for \"for ... in ... loop\""
        ],
        "opts": []
      },
      {
        "content": "// TODO: $0",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "todo \"TODO comment\""
        ],
        "opts": []
      },
      {
        "content": "// FIXME: $0",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fixme \"FIXME comment\""
        ],
        "opts": []
      },
      {
        "content": "struct ${1:`substitute(vim_snippets#Filename(), '\\(_\\|^\\)\\(.\\)', '\\u\\2', 'g')`} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "st \"Struct definition\""
        ],
        "opts": []
      },
      {
        "content": "impl ${1:Type/Trait}${2: for $3} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "impl \"Struct/Trait implementation\""
        ],
        "opts": []
      },
      {
        "content": "pub struct ${1:`substitute(vim_snippets#Filename(), '\\(_\\|^\\)\\(.\\)', '\\u\\2', 'g')`} {\n\t${0}\n}\nimpl$2 $1$2 {\n\tpub fn new(${4}) -> Self {\n\t\t$1 { ${5} }\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "stn \"Struct with new constructor\""
        ],
        "opts": []
      },
      {
        "content": "type ${1:NewName} = $2;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ty \"Type alias\""
        ],
        "opts": []
      },
      {
        "content": "enum ${1:Name} {\n\t${2},\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "enum \"enum definition\""
        ],
        "opts": []
      },
      {
        "content": "pub enum ${1:Name} {\n\t${2},\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "penum \"pub enum definition\""
        ],
        "opts": []
      },
      {
        "content": "trait ${1:Name} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "trait \"Trait definition\""
        ],
        "opts": []
      },
      {
        "content": "impl Drop for $1 {\n\tfn drop(&mut self) {\n\t\t${0}\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "drop \"Drop trait implementation (destructor)\""
        ],
        "opts": []
      },
      {
        "content": "static ${1}: &'static str = \"${0}\";",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ss \"static string declaration\""
        ],
        "opts": []
      },
      {
        "content": "static ${1}: ${2:usize} = ${0};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "stat \"static item declaration\""
        ],
        "opts": []
      },
      {
        "content": "thread::spawn(${1:move }|| {\n\t${0}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "spawn \"spawn a thread\""
        ],
        "opts": []
      },
      {
        "content": "let (${1:tx}, ${2:rx}): (Sender<${3:i32}>, Receiver<${4:i32}>) = channel();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "chan \"Declare (Sender, Receiver) pair of asynchronous channel()\""
        ],
        "opts": []
      },
      {
        "content": "impl AsRef<${1:Ref}> for ${2:Type} {\n\tfn as_ref(&self) -> &${3:$1} {\n\t\t&self.${0:field}\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asref \"AsRef trait implementation\""
        ],
        "opts": []
      },
      {
        "content": "impl AsMut<${1:Ref}> for ${2:Type} {\n\tfn as_mut(&mut self) -> &mut ${3:$1} {\n\t\t&mut self.${0:field}\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "asmut \"AsMut trait implementation\""
        ],
        "opts": []
      },
      {
        "content": "${1:name}: ${2:Type},",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fd \"Struct field definition\" w"
        ],
        "opts": []
      },
      {
        "content": "${1:move }|$2| { $3 }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "|| \"Closure, anonymous function (inline)\" i"
        ],
        "opts": []
      },
      {
        "content": "${1:move }|$2| {\n\t$3\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "|} \"Closure, anonymous function (block)\" i"
        ],
        "opts": []
      },
      {
        "content": "macro_rules! ${1:name} {\n\t(${2:matcher}) => (\n\t\t$3\n\t)\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "macro \"macro_rules!\" b"
        ],
        "opts": []
      },
      {
        "content": "Box::new(${0:${VISUAL}})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "boxp \"Box::new()\""
        ],
        "opts": []
      },
      {
        "content": "Rc::new(${0:${VISUAL}})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rc \"Rc::new()\""
        ],
        "opts": []
      },
      {
        "content": "unimplemented!()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "unim \"unimplemented!()\""
        ],
        "opts": []
      },
      {
        "content": "use ${1:std::$2};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "use \"use ...;\" b"
        ],
        "opts": []
      },
      {
        "content": "fn ${1:#:func_name}(${2:#:args}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "fn () {}",
        "matches": [
          "fn"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "fn ${1:#:func_name}(${2:#:args}) -> ${3:#:()} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "fn () {}",
        "matches": [
          "fn-"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "pub fn ${1:#:func_name}(${2:#:args}) -> ${3:#:()} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "pubfn () {}",
        "matches": [
          "pubfn"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "#[test]\nfn ${1:#:test_function_name}() {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "test"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "pub fn new(${1}) -> ${2:#:Name} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "pub fn new() {}",
        "matches": [
          "pubnew"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "impl ${1} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "impl"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "impl ${1} for ${2} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "implfor"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "trait ${1} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "trait"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "${1:#:macro_name}!(${2})${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "macro"
        ],
        "opts": []
      },
      {
        "content": "bitflags! {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "bitflags!",
        "matches": [
          "bfl"
        ],
        "opts": []
      },
      {
        "content": "println!(${1:\"\\{\\}\"}, ${0:TARGET});",
        "doc": "",
        "grammar": "snu",
        "label": "println!",
        "matches": [
          "pln"
        ],
        "opts": []
      },
      {
        "content": "format!(\"${1:\\{\\}}\", ${0:TARGET});",
        "doc": "",
        "grammar": "snu",
        "label": "format!",
        "matches": [
          "fm"
        ],
        "opts": []
      },
      {
        "content": "extern crate ${0:TARGET};",
        "doc": "",
        "grammar": "snu",
        "label": "extern crate",
        "matches": [
          "ec"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "#![feature(phase)]\n#[phase(plugin, link)] extern crate log;",
        "doc": "",
        "grammar": "snu",
        "label": "extern crate log",
        "matches": [
          "ecl"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "#![crate_name=${1:#:crate_name}]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "crate"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "#[derive(${1:TARGET})]${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "derive"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "mod ${1:#:mod_name} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mod"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "let ${1:TARGET} = ${2};${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "let"
        ],
        "opts": []
      },
      {
        "content": "if ${1:#:condition} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if {}",
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "else {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "else"
        ],
        "opts": []
      },
      {
        "content": "} else if (${1:#:condition}) {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "elseif"
        ],
        "opts": []
      },
      {
        "content": "if ${1:#:condition} {\n    ${2:TARGET}\n} else {\n    ${3}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "if () {} else {}",
        "matches": [
          "ifelse"
        ],
        "opts": []
      },
      {
        "content": "for ${1} in ${2} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "forin  {}",
        "matches": [
          "forin"
        ],
        "opts": []
      },
      {
        "content": "match ${1:TARGET} {\n    ${2:#:pattern} => ${3:#expr},${4}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "match"
        ],
        "opts": []
      },
      {
        "content": "${1:TARGET} => ${2:#expr},${3}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case",
          "mcase"
        ],
        "opts": []
      },
      {
        "content": "struct ${1} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "struct"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "pub struct ${1} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "pub struct",
        "matches": [
          "pubstruct"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "enum ${1} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "enum"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "Option<${1:()}>${2}",
        "doc": "",
        "grammar": "snu",
        "label": "Option<A>",
        "matches": [
          "opt"
        ],
        "opts": []
      },
      {
        "content": "Result<${1:#:~str}, ${2:#:()}>${3}",
        "doc": "",
        "grammar": "snu",
        "label": "Result<A, B>",
        "matches": [
          "res"
        ],
        "opts": []
      },
      {
        "content": "fn ${1:function_name}($2)${3/..*/ -> /}$3 {\n\t${VISUAL}$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "fn name(?) -> ? {}",
        "matches": [
          "fn"
        ],
        "opts": []
      },
      {
        "content": "pub fn ${1:function_name}($2)${3/..*/ -> /}$3 {\n\t${VISUAL}$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "pub fn name(?) -> ? {}",
        "matches": [
          "pfn"
        ],
        "opts": []
      },
      {
        "content": "async fn ${1:function_name}($2)${3/..*/ -> /}$3 {\n\t${VISUAL}$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "async fn name(?) -> ? {}",
        "matches": [
          "afn"
        ],
        "opts": []
      },
      {
        "content": "pub async fn ${1:function_name}($2)${3/..*/ -> /}$3 {\n\t${VISUAL}$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": "pub async fn name(?) -> ? {}",
        "matches": [
          "pafn"
        ],
        "opts": []
      },
      {
        "content": "print!(\"$1\"${2/..*/, /}$2);",
        "doc": null,
        "grammar": "snu",
        "label": "print!(..)",
        "matches": [
          "pri"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "println!(\"$1\"${2/..*/, /}$2);",
        "doc": null,
        "grammar": "snu",
        "label": "println!(..)",
        "matches": [
          "pln"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "format!(\"$1\"${2/..*/, /}$2);",
        "doc": null,
        "grammar": "snu",
        "label": "format!(..)",
        "matches": [
          "fmt"
        ],
        "opts": []
      },
      {
        "content": ".iter()$0",
        "doc": null,
        "grammar": "snu",
        "label": ".iter()",
        "matches": [
          ".it"
        ],
        "opts": [
          "i"
        ]
      },
      {
        "content": "impl$4 ${1:Type/Trait}${2: for ${3:Type}}${4:<${5:T}>} {\n\t${0}\n}",
        "doc": null,
        "grammar": "snu",
        "label": "Struct/Trait implementation",
        "matches": [
          "impl"
        ],
        "opts": [
          "b"
        ]
      }
    ],
    "sass": [
      {
        "content": "$${1:variable}: ${0:value}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "$"
        ],
        "opts": []
      },
      {
        "content": "@import '${0}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "imp"
        ],
        "opts": []
      },
      {
        "content": "=${1:name}(${2})\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mix"
        ],
        "opts": []
      },
      {
        "content": "+${1:mixin}(${2})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "inc"
        ],
        "opts": []
      },
      {
        "content": "@extend ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ext"
        ],
        "opts": []
      },
      {
        "content": "@function ${1:name}(${2:args})\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fun"
        ],
        "opts": []
      },
      {
        "content": "@if ${1:condition}\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "@if ${1:condition}\n\t${2:${VISUAL}}\n@else\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "@else if ${1:condition}\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eif"
        ],
        "opts": []
      },
      {
        "content": "@for ${1:$i} from ${2:1} through ${3:3}\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "@each ${1:$item} in ${2:items}\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "each"
        ],
        "opts": []
      },
      {
        "content": "@while ${1:$i} ${2:>} ${3:0}\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "while"
        ],
        "opts": []
      },
      {
        "content": "!important",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "!"
        ],
        "opts": []
      },
      {
        "content": "align-content: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac"
        ],
        "opts": []
      },
      {
        "content": "align-content: start",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:s"
        ],
        "opts": []
      },
      {
        "content": "align-content: end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:e"
        ],
        "opts": []
      },
      {
        "content": "align-content: center",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:c"
        ],
        "opts": []
      },
      {
        "content": "align-content: flex-start",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:fs"
        ],
        "opts": []
      },
      {
        "content": "align-content: flex-end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:fe"
        ],
        "opts": []
      },
      {
        "content": "align-content: space-between",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:sb"
        ],
        "opts": []
      },
      {
        "content": "align-content: space-around",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:sa"
        ],
        "opts": []
      },
      {
        "content": "align-content: space-evenly",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:se"
        ],
        "opts": []
      },
      {
        "content": "align-content: stretch",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:st"
        ],
        "opts": []
      },
      {
        "content": "align-content: baseline",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:b"
        ],
        "opts": []
      },
      {
        "content": "align-content: first baseline",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:fb"
        ],
        "opts": []
      },
      {
        "content": "align-content: last baseline",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:lb"
        ],
        "opts": []
      },
      {
        "content": "align-items: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ai"
        ],
        "opts": []
      },
      {
        "content": "align-items: start",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ai:s"
        ],
        "opts": []
      },
      {
        "content": "align-items: end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ai:e"
        ],
        "opts": []
      },
      {
        "content": "align-items: center",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ai:c"
        ],
        "opts": []
      },
      {
        "content": "align-items: flex-start",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ai:fs"
        ],
        "opts": []
      },
      {
        "content": "align-items: flex-end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ai:fe"
        ],
        "opts": []
      },
      {
        "content": "align-items: stretch",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ai:st"
        ],
        "opts": []
      },
      {
        "content": "align-items: baseline",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ai:b"
        ],
        "opts": []
      },
      {
        "content": "align-items: first baseline",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ai:fb"
        ],
        "opts": []
      },
      {
        "content": "align-items: last baseline",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ai:lb"
        ],
        "opts": []
      },
      {
        "content": "align-self: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as"
        ],
        "opts": []
      },
      {
        "content": "align-self: start",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as:s"
        ],
        "opts": []
      },
      {
        "content": "align-self: end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as:e"
        ],
        "opts": []
      },
      {
        "content": "align-self: center",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as:c"
        ],
        "opts": []
      },
      {
        "content": "align-self: stretch",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as:st"
        ],
        "opts": []
      },
      {
        "content": "align-self: flex-start",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as:fs"
        ],
        "opts": []
      },
      {
        "content": "align-self: flex-end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as:fe"
        ],
        "opts": []
      },
      {
        "content": "align-self: baseline",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as:b"
        ],
        "opts": []
      },
      {
        "content": "align-self: first baseline",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as:fb"
        ],
        "opts": []
      },
      {
        "content": "align-self: last baseline",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as:lb"
        ],
        "opts": []
      },
      {
        "content": "-moz-border-image: url('${1}') ${2:0} ${3:0} ${4:0} ${5:0} ${6:stretch} ${0:stretch}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdi:m+"
        ],
        "opts": []
      },
      {
        "content": "-moz-border-image: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdi:m"
        ],
        "opts": []
      },
      {
        "content": "-moz-border-radius: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdrz:m"
        ],
        "opts": []
      },
      {
        "content": "-moz-box-shadow: ${1:0} ${2:0} ${3:0} #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bxsh:m+"
        ],
        "opts": []
      },
      {
        "content": "-moz-box-shadow: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bxsh:m"
        ],
        "opts": []
      },
      {
        "content": "-webkit-border-image: url('${1}') ${2:0} ${3:0} ${4:0} ${5:0} ${6:stretch} ${0:stretch}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdi:w+"
        ],
        "opts": []
      },
      {
        "content": "-webkit-border-image: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdi:w"
        ],
        "opts": []
      },
      {
        "content": "-webkit-border-radius: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdrz:w"
        ],
        "opts": []
      },
      {
        "content": "-webkit-box-shadow: ${1:0} ${2:0} ${3:0} #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bxsh:w+"
        ],
        "opts": []
      },
      {
        "content": "-webkit-box-shadow: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bxsh:w"
        ],
        "opts": []
      },
      {
        "content": "@font-face\n\tfont-family: ${1}\n\tsrc: url('${0}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@f"
        ],
        "opts": []
      },
      {
        "content": "@import url('${0}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@i"
        ],
        "opts": []
      },
      {
        "content": "@media ${1:print}\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@m"
        ],
        "opts": []
      },
      {
        "content": "background: #${1:fff} url('${2}') ${3:0} ${4:0} ${0:no-repeat}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bg+"
        ],
        "opts": []
      },
      {
        "content": "background-attachment: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bga"
        ],
        "opts": []
      },
      {
        "content": "background-attachment: fixed",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bga:f"
        ],
        "opts": []
      },
      {
        "content": "background-attachment: scroll",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bga:s"
        ],
        "opts": []
      },
      {
        "content": "background-break: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgbk"
        ],
        "opts": []
      },
      {
        "content": "background-break: bounding-box",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgbk:bb"
        ],
        "opts": []
      },
      {
        "content": "background-break: continuous",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgbk:c"
        ],
        "opts": []
      },
      {
        "content": "background-break: each-box",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgbk:eb"
        ],
        "opts": []
      },
      {
        "content": "background-clip: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgcp"
        ],
        "opts": []
      },
      {
        "content": "background-clip: border-box",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgcp:bb"
        ],
        "opts": []
      },
      {
        "content": "background-clip: content-box",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgcp:cb"
        ],
        "opts": []
      },
      {
        "content": "background-clip: no-clip",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgcp:nc"
        ],
        "opts": []
      },
      {
        "content": "background-clip: padding-box",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgcp:pb"
        ],
        "opts": []
      },
      {
        "content": "background-color: #${0:fff}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgc"
        ],
        "opts": []
      },
      {
        "content": "background-color: transparent",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgc:t"
        ],
        "opts": []
      },
      {
        "content": "background-image: url('${0}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgi"
        ],
        "opts": []
      },
      {
        "content": "background-image: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgi:n"
        ],
        "opts": []
      },
      {
        "content": "background-origin: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgo"
        ],
        "opts": []
      },
      {
        "content": "background-origin: border-box",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgo:bb"
        ],
        "opts": []
      },
      {
        "content": "background-origin: content-box",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgo:cb"
        ],
        "opts": []
      },
      {
        "content": "background-origin: padding-box",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgo:pb"
        ],
        "opts": []
      },
      {
        "content": "background-position-x: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgpx"
        ],
        "opts": []
      },
      {
        "content": "background-position-y: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgpy"
        ],
        "opts": []
      },
      {
        "content": "background-position: ${1:0} ${0:0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgp"
        ],
        "opts": []
      },
      {
        "content": "background-repeat: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgr"
        ],
        "opts": []
      },
      {
        "content": "background-repeat: no-repeat",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgr:n"
        ],
        "opts": []
      },
      {
        "content": "background-repeat: repeat-x",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgr:x"
        ],
        "opts": []
      },
      {
        "content": "background-repeat: repeat-y",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgr:y"
        ],
        "opts": []
      },
      {
        "content": "background-repeat: repeat",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgr:r"
        ],
        "opts": []
      },
      {
        "content": "background-size: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgz"
        ],
        "opts": []
      },
      {
        "content": "background-size: auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgz:a"
        ],
        "opts": []
      },
      {
        "content": "background-size: contain",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgz:ct"
        ],
        "opts": []
      },
      {
        "content": "background-size: cover",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgz:cv"
        ],
        "opts": []
      },
      {
        "content": "background: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bg"
        ],
        "opts": []
      },
      {
        "content": "filter: progid:DXImageTransform.Microsoft.AlphaImageLoader(src='${1}',sizingMethod='${0:crop}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bg:ie"
        ],
        "opts": []
      },
      {
        "content": "background: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bg:n"
        ],
        "opts": []
      },
      {
        "content": "border: ${1:1px} ${2:solid} #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bd+"
        ],
        "opts": []
      },
      {
        "content": "border-bottom: ${1:1px} ${2:solid} #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdb+"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-color: #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbc"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-image: url('${0}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbi"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-image: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbi:n"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-left-image: url('${0}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbli"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-left-image: continue",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbli:c"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-left-image: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbli:n"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-left-radius: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdblrz"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-right-image: url('${0}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbri"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-right-image: continue",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbri:c"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-right-image: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbri:n"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-right-radius: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbrrz"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-style: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbs"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-style: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbs:n"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-width: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbw"
        ],
        "opts": []
      },
      {
        "content": "border-bottom: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdb"
        ],
        "opts": []
      },
      {
        "content": "border-bottom: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdb:n"
        ],
        "opts": []
      },
      {
        "content": "border-break: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbk"
        ],
        "opts": []
      },
      {
        "content": "border-break: close",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbk:c"
        ],
        "opts": []
      },
      {
        "content": "border-collapse: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdcl"
        ],
        "opts": []
      },
      {
        "content": "border-collapse: collapse",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdcl:c"
        ],
        "opts": []
      },
      {
        "content": "border-collapse: separate",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdcl:s"
        ],
        "opts": []
      },
      {
        "content": "border-color: #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdc"
        ],
        "opts": []
      },
      {
        "content": "border-corner-image: url('${0}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdci"
        ],
        "opts": []
      },
      {
        "content": "border-corner-image: continue",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdci:c"
        ],
        "opts": []
      },
      {
        "content": "border-corner-image: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdci:n"
        ],
        "opts": []
      },
      {
        "content": "border-fit: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdf"
        ],
        "opts": []
      },
      {
        "content": "border-fit: clip",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdf:c"
        ],
        "opts": []
      },
      {
        "content": "border-fit: overwrite",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdf:of"
        ],
        "opts": []
      },
      {
        "content": "border-fit: overwrite",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdf:ow"
        ],
        "opts": []
      },
      {
        "content": "border-fit: repeat",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdf:r"
        ],
        "opts": []
      },
      {
        "content": "border-fit: scale",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdf:sc"
        ],
        "opts": []
      },
      {
        "content": "border-fit: space",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdf:sp"
        ],
        "opts": []
      },
      {
        "content": "border-fit: stretch",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdf:st"
        ],
        "opts": []
      },
      {
        "content": "border-image: url('${1}') ${2:0} ${3:0} ${4:0} ${5:0} ${6:stretch} ${0:stretch}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdi"
        ],
        "opts": []
      },
      {
        "content": "border-image: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdi:n"
        ],
        "opts": []
      },
      {
        "content": "border-left: ${1:1px} ${2:solid} #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdl+"
        ],
        "opts": []
      },
      {
        "content": "border-left-color: #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdlc"
        ],
        "opts": []
      },
      {
        "content": "border-left-image: url('${0}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdli"
        ],
        "opts": []
      },
      {
        "content": "border-left-image: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdli:n"
        ],
        "opts": []
      },
      {
        "content": "border-left-style: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdls"
        ],
        "opts": []
      },
      {
        "content": "border-left-style: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdls:n"
        ],
        "opts": []
      },
      {
        "content": "border-left-width: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdlw"
        ],
        "opts": []
      },
      {
        "content": "border-left: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdl"
        ],
        "opts": []
      },
      {
        "content": "border-left: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdl:n"
        ],
        "opts": []
      },
      {
        "content": "border-length: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdlt"
        ],
        "opts": []
      },
      {
        "content": "border-length: auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdlt:a"
        ],
        "opts": []
      },
      {
        "content": "border-radius: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdrz"
        ],
        "opts": []
      },
      {
        "content": "border-right: ${1:1px} ${2:solid} #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdr+"
        ],
        "opts": []
      },
      {
        "content": "border-right-color: #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdrc"
        ],
        "opts": []
      },
      {
        "content": "border-right-image: url('${0}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdri"
        ],
        "opts": []
      },
      {
        "content": "border-right-image: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdri:n"
        ],
        "opts": []
      },
      {
        "content": "border-right-style: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdrs"
        ],
        "opts": []
      },
      {
        "content": "border-right-style: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdrs:n"
        ],
        "opts": []
      },
      {
        "content": "border-right-width: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdrw"
        ],
        "opts": []
      },
      {
        "content": "border-right: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdr"
        ],
        "opts": []
      },
      {
        "content": "border-right: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdr:n"
        ],
        "opts": []
      },
      {
        "content": "border-spacing: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdsp"
        ],
        "opts": []
      },
      {
        "content": "border-style: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds"
        ],
        "opts": []
      },
      {
        "content": "border-style: dashed",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:ds"
        ],
        "opts": []
      },
      {
        "content": "border-style: dot-dash",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:dtds"
        ],
        "opts": []
      },
      {
        "content": "border-style: dot-dot-dash",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:dtdtds"
        ],
        "opts": []
      },
      {
        "content": "border-style: dotted",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:dt"
        ],
        "opts": []
      },
      {
        "content": "border-style: double",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:db"
        ],
        "opts": []
      },
      {
        "content": "border-style: groove",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:g"
        ],
        "opts": []
      },
      {
        "content": "border-style: hidden",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:h"
        ],
        "opts": []
      },
      {
        "content": "border-style: inset",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:i"
        ],
        "opts": []
      },
      {
        "content": "border-style: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:n"
        ],
        "opts": []
      },
      {
        "content": "border-style: outset",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:o"
        ],
        "opts": []
      },
      {
        "content": "border-style: ridge",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:r"
        ],
        "opts": []
      },
      {
        "content": "border-style: solid",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:s"
        ],
        "opts": []
      },
      {
        "content": "border-style: wave",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:w"
        ],
        "opts": []
      },
      {
        "content": "border-top: ${1:1px} ${2:solid} #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdt+"
        ],
        "opts": []
      },
      {
        "content": "border-top-color: #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdtc"
        ],
        "opts": []
      },
      {
        "content": "border-top-image: url('${0}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdti"
        ],
        "opts": []
      },
      {
        "content": "border-top-image: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdti:n"
        ],
        "opts": []
      },
      {
        "content": "border-top-left-image: url('${0}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdtli"
        ],
        "opts": []
      },
      {
        "content": "border-corner-image: continue",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdtli:c"
        ],
        "opts": []
      },
      {
        "content": "border-corner-image: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdtli:n"
        ],
        "opts": []
      },
      {
        "content": "border-top-left-radius: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdtlrz"
        ],
        "opts": []
      },
      {
        "content": "border-top-right-image: url('${0}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdtri"
        ],
        "opts": []
      },
      {
        "content": "border-top-right-image: continue",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdtri:c"
        ],
        "opts": []
      },
      {
        "content": "border-top-right-image: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdtri:n"
        ],
        "opts": []
      },
      {
        "content": "border-top-right-radius: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdtrrz"
        ],
        "opts": []
      },
      {
        "content": "border-top-style: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdts"
        ],
        "opts": []
      },
      {
        "content": "border-top-style: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdts:n"
        ],
        "opts": []
      },
      {
        "content": "border-top-width: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdtw"
        ],
        "opts": []
      },
      {
        "content": "border-top: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdt"
        ],
        "opts": []
      },
      {
        "content": "border-top: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdt:n"
        ],
        "opts": []
      },
      {
        "content": "border-width: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdw"
        ],
        "opts": []
      },
      {
        "content": "border: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bd"
        ],
        "opts": []
      },
      {
        "content": "border: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bd:n"
        ],
        "opts": []
      },
      {
        "content": "bottom: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "b"
        ],
        "opts": []
      },
      {
        "content": "bottom: auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "b:a"
        ],
        "opts": []
      },
      {
        "content": "box-shadow: ${1:0} ${2:0} ${3:0} #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bxsh+"
        ],
        "opts": []
      },
      {
        "content": "box-shadow: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bxsh"
        ],
        "opts": []
      },
      {
        "content": "box-shadow: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bxsh:n"
        ],
        "opts": []
      },
      {
        "content": "box-sizing: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bxz"
        ],
        "opts": []
      },
      {
        "content": "box-sizing: border-box",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bxz:bb"
        ],
        "opts": []
      },
      {
        "content": "box-sizing: content-box",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bxz:cb"
        ],
        "opts": []
      },
      {
        "content": "caption-side: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cps"
        ],
        "opts": []
      },
      {
        "content": "caption-side: bottom",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cps:b"
        ],
        "opts": []
      },
      {
        "content": "caption-side: top",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cps:t"
        ],
        "opts": []
      },
      {
        "content": "clear: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cl"
        ],
        "opts": []
      },
      {
        "content": "clear: both",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cl:b"
        ],
        "opts": []
      },
      {
        "content": "clear: left",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cl:l"
        ],
        "opts": []
      },
      {
        "content": "clear: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cl:n"
        ],
        "opts": []
      },
      {
        "content": "clear: right",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cl:r"
        ],
        "opts": []
      },
      {
        "content": "clip: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cp"
        ],
        "opts": []
      },
      {
        "content": "clip: auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cp:a"
        ],
        "opts": []
      },
      {
        "content": "clip: rect(${1:0} ${2:0} ${3:0} ${0:0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cp:r"
        ],
        "opts": []
      },
      {
        "content": "color: #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "c"
        ],
        "opts": []
      },
      {
        "content": "content: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ct"
        ],
        "opts": []
      },
      {
        "content": "content: attr(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ct:a"
        ],
        "opts": []
      },
      {
        "content": "content: close-quote",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ct:cq"
        ],
        "opts": []
      },
      {
        "content": "content: counter(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ct:c"
        ],
        "opts": []
      },
      {
        "content": "content: counters(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ct:cs"
        ],
        "opts": []
      },
      {
        "content": "content: no-close-quote",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ct:ncq"
        ],
        "opts": []
      },
      {
        "content": "content: no-open-quote",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ct:noq"
        ],
        "opts": []
      },
      {
        "content": "content: normal",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ct:n"
        ],
        "opts": []
      },
      {
        "content": "content: open-quote",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ct:oq"
        ],
        "opts": []
      },
      {
        "content": "counter-increment: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "coi"
        ],
        "opts": []
      },
      {
        "content": "counter-reset: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cor"
        ],
        "opts": []
      },
      {
        "content": "cursor: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cur"
        ],
        "opts": []
      },
      {
        "content": "cursor: auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cur:a"
        ],
        "opts": []
      },
      {
        "content": "cursor: crosshair",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cur:c"
        ],
        "opts": []
      },
      {
        "content": "cursor: default",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cur:d"
        ],
        "opts": []
      },
      {
        "content": "cursor: hand",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cur:ha"
        ],
        "opts": []
      },
      {
        "content": "cursor: help",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cur:he"
        ],
        "opts": []
      },
      {
        "content": "cursor: move",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cur:m"
        ],
        "opts": []
      },
      {
        "content": "cursor: pointer",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cur:p"
        ],
        "opts": []
      },
      {
        "content": "cursor: text",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cur:t"
        ],
        "opts": []
      },
      {
        "content": "display: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d"
        ],
        "opts": []
      },
      {
        "content": "display: -moz-inline-box",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:mib"
        ],
        "opts": []
      },
      {
        "content": "display: -moz-inline-stack",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:mis"
        ],
        "opts": []
      },
      {
        "content": "display: block",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:b"
        ],
        "opts": []
      },
      {
        "content": "display: compact",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:cp"
        ],
        "opts": []
      },
      {
        "content": "display: grid",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:g"
        ],
        "opts": []
      },
      {
        "content": "display: flex",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:f"
        ],
        "opts": []
      },
      {
        "content": "display: inline-block",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:ib"
        ],
        "opts": []
      },
      {
        "content": "display: inline-table",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:itb"
        ],
        "opts": []
      },
      {
        "content": "display: inline",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:i"
        ],
        "opts": []
      },
      {
        "content": "display: list-item",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:li"
        ],
        "opts": []
      },
      {
        "content": "display: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:n"
        ],
        "opts": []
      },
      {
        "content": "display: run-in",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:ri"
        ],
        "opts": []
      },
      {
        "content": "display: table-caption",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:tbcp"
        ],
        "opts": []
      },
      {
        "content": "display: table-cell",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:tbc"
        ],
        "opts": []
      },
      {
        "content": "display: table-column-group",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:tbclg"
        ],
        "opts": []
      },
      {
        "content": "display: table-column",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:tbcl"
        ],
        "opts": []
      },
      {
        "content": "display: table-footer-group",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:tbfg"
        ],
        "opts": []
      },
      {
        "content": "display: table-header-group",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:tbhg"
        ],
        "opts": []
      },
      {
        "content": "display: table-row-group",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:tbrg"
        ],
        "opts": []
      },
      {
        "content": "display: table-row",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:tbr"
        ],
        "opts": []
      },
      {
        "content": "display: table",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:tb"
        ],
        "opts": []
      },
      {
        "content": "empty-cells: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ec"
        ],
        "opts": []
      },
      {
        "content": "empty-cells: hide",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ec:h"
        ],
        "opts": []
      },
      {
        "content": "empty-cells: show",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ec:s"
        ],
        "opts": []
      },
      {
        "content": "expression()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "exp"
        ],
        "opts": []
      },
      {
        "content": "float: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fl"
        ],
        "opts": []
      },
      {
        "content": "float: left",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fl:l"
        ],
        "opts": []
      },
      {
        "content": "float: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fl:n"
        ],
        "opts": []
      },
      {
        "content": "float: right",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fl:r"
        ],
        "opts": []
      },
      {
        "content": "font: ${1:1em} ${2:Arial},${0:sans-serif}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "f+"
        ],
        "opts": []
      },
      {
        "content": "font-effect: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fef"
        ],
        "opts": []
      },
      {
        "content": "font-effect: emboss",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fef:eb"
        ],
        "opts": []
      },
      {
        "content": "font-effect: engrave",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fef:eg"
        ],
        "opts": []
      },
      {
        "content": "font-effect: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fef:n"
        ],
        "opts": []
      },
      {
        "content": "font-effect: outline",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fef:o"
        ],
        "opts": []
      },
      {
        "content": "font-emphasize-position: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "femp"
        ],
        "opts": []
      },
      {
        "content": "font-emphasize-position: after",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "femp:a"
        ],
        "opts": []
      },
      {
        "content": "font-emphasize-position: before",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "femp:b"
        ],
        "opts": []
      },
      {
        "content": "font-emphasize-style: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fems"
        ],
        "opts": []
      },
      {
        "content": "font-emphasize-style: accent",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fems:ac"
        ],
        "opts": []
      },
      {
        "content": "font-emphasize-style: circle",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fems:c"
        ],
        "opts": []
      },
      {
        "content": "font-emphasize-style: disc",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fems:ds"
        ],
        "opts": []
      },
      {
        "content": "font-emphasize-style: dot",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fems:dt"
        ],
        "opts": []
      },
      {
        "content": "font-emphasize-style: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fems:n"
        ],
        "opts": []
      },
      {
        "content": "font-emphasize: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fem"
        ],
        "opts": []
      },
      {
        "content": "font-family: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ff"
        ],
        "opts": []
      },
      {
        "content": "font-family: ${0:'Monotype Corsiva','Comic Sans MS'},cursive",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ff:c"
        ],
        "opts": []
      },
      {
        "content": "font-family: ${0:Capitals,Impact},fantasy",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ff:f"
        ],
        "opts": []
      },
      {
        "content": "font-family: ${0:Monaco,'Courier New'},monospace",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ff:m"
        ],
        "opts": []
      },
      {
        "content": "font-family: ${0:Helvetica,Arial},sans-serif",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ff:ss"
        ],
        "opts": []
      },
      {
        "content": "font-family: ${0:Georgia,'Times New Roman'},serif",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ff:s"
        ],
        "opts": []
      },
      {
        "content": "font-size-adjust: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fza"
        ],
        "opts": []
      },
      {
        "content": "font-size-adjust: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fza:n"
        ],
        "opts": []
      },
      {
        "content": "font-size: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fz"
        ],
        "opts": []
      },
      {
        "content": "font-smooth: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fsm"
        ],
        "opts": []
      },
      {
        "content": "font-smooth: always",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fsm:aw"
        ],
        "opts": []
      },
      {
        "content": "font-smooth: auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fsm:a"
        ],
        "opts": []
      },
      {
        "content": "font-smooth: never",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fsm:n"
        ],
        "opts": []
      },
      {
        "content": "font-stretch: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fst"
        ],
        "opts": []
      },
      {
        "content": "font-stretch: condensed",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fst:c"
        ],
        "opts": []
      },
      {
        "content": "font-stretch: expanded",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fst:e"
        ],
        "opts": []
      },
      {
        "content": "font-stretch: extra-condensed",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fst:ec"
        ],
        "opts": []
      },
      {
        "content": "font-stretch: extra-expanded",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fst:ee"
        ],
        "opts": []
      },
      {
        "content": "font-stretch: normal",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fst:n"
        ],
        "opts": []
      },
      {
        "content": "font-stretch: semi-condensed",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fst:sc"
        ],
        "opts": []
      },
      {
        "content": "font-stretch: semi-expanded",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fst:se"
        ],
        "opts": []
      },
      {
        "content": "font-stretch: ultra-condensed",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fst:uc"
        ],
        "opts": []
      },
      {
        "content": "font-stretch: ultra-expanded",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fst:ue"
        ],
        "opts": []
      },
      {
        "content": "font-style: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fs"
        ],
        "opts": []
      },
      {
        "content": "font-style: italic",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fs:i"
        ],
        "opts": []
      },
      {
        "content": "font-style: normal",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fs:n"
        ],
        "opts": []
      },
      {
        "content": "font-style: oblique",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fs:o"
        ],
        "opts": []
      },
      {
        "content": "font-variant: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fv"
        ],
        "opts": []
      },
      {
        "content": "font-variant: normal",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fv:n"
        ],
        "opts": []
      },
      {
        "content": "font-variant: small-caps",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fv:sc"
        ],
        "opts": []
      },
      {
        "content": "font-weight: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fw"
        ],
        "opts": []
      },
      {
        "content": "font-weight: bold",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fw:b"
        ],
        "opts": []
      },
      {
        "content": "font-weight: bolder",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fw:br"
        ],
        "opts": []
      },
      {
        "content": "font-weight: lighter",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fw:lr"
        ],
        "opts": []
      },
      {
        "content": "font-weight: normal",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fw:n"
        ],
        "opts": []
      },
      {
        "content": "font: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "f"
        ],
        "opts": []
      },
      {
        "content": "grid: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "g"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-flow: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gaf"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-flow: ${1:row} ${0:dense}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gaf+"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-flow: row",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gaf:r"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-flow: column",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gaf:c"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-flow: dense",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gaf:d"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-flow: row dense",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gaf:rd"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-flow: column dense",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gaf:cd"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-rows: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gar"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-rows: auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gar:a"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-rows: max-content",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gar:mac"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-rows: min-content",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gar:mic"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-columns: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gac"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-columns: auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gac:a"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-columns: max-content",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gac:mac"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-columns: min-content",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gac:mic"
        ],
        "opts": []
      },
      {
        "content": "grid-template: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gt"
        ],
        "opts": []
      },
      {
        "content": "grid-template: ${1} / ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gt+"
        ],
        "opts": []
      },
      {
        "content": "grid-template-rows: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gtr"
        ],
        "opts": []
      },
      {
        "content": "grid-template-columns: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gtc"
        ],
        "opts": []
      },
      {
        "content": "grid-template-areas: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gta"
        ],
        "opts": []
      },
      {
        "content": "grid-gap: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gg"
        ],
        "opts": []
      },
      {
        "content": "grid-gap: ${1} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gg+"
        ],
        "opts": []
      },
      {
        "content": "grid-gap: 0",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gg:0"
        ],
        "opts": []
      },
      {
        "content": "grid-row-gap: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "grg"
        ],
        "opts": []
      },
      {
        "content": "grid-row-gap: 0",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "grg:0"
        ],
        "opts": []
      },
      {
        "content": "grid-column-gap: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gcg"
        ],
        "opts": []
      },
      {
        "content": "grid-column-gap: 0",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gcg:0"
        ],
        "opts": []
      },
      {
        "content": "grid-row: ${1} / ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gr"
        ],
        "opts": []
      },
      {
        "content": "grid-row-start: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "grs"
        ],
        "opts": []
      },
      {
        "content": "grid-row-end: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gre"
        ],
        "opts": []
      },
      {
        "content": "grid-column: ${1} / ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gc"
        ],
        "opts": []
      },
      {
        "content": "grid-column-start: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gcs"
        ],
        "opts": []
      },
      {
        "content": "grid-column-end: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gce"
        ],
        "opts": []
      },
      {
        "content": "height: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "h"
        ],
        "opts": []
      },
      {
        "content": "height: auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "h:a"
        ],
        "opts": []
      },
      {
        "content": "justify-content: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc"
        ],
        "opts": []
      },
      {
        "content": "justify-content: start",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc:s"
        ],
        "opts": []
      },
      {
        "content": "justify-content: end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc:e"
        ],
        "opts": []
      },
      {
        "content": "justify-content: center",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc:c"
        ],
        "opts": []
      },
      {
        "content": "justify-content: flex-start",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc:fs"
        ],
        "opts": []
      },
      {
        "content": "justify-content: flex-end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc:fe"
        ],
        "opts": []
      },
      {
        "content": "justify-content: space-between",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc:sb"
        ],
        "opts": []
      },
      {
        "content": "justify-content: space-around",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc:sa"
        ],
        "opts": []
      },
      {
        "content": "justify-content: space-evenly",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc:se"
        ],
        "opts": []
      },
      {
        "content": "justify-content: stretch",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc:st"
        ],
        "opts": []
      },
      {
        "content": "justify-content: left",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc:l"
        ],
        "opts": []
      },
      {
        "content": "justify-content: right",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc:r"
        ],
        "opts": []
      },
      {
        "content": "justify-items: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ji"
        ],
        "opts": []
      },
      {
        "content": "justify-items: start",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ji:s"
        ],
        "opts": []
      },
      {
        "content": "justify-items: end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ji:e"
        ],
        "opts": []
      },
      {
        "content": "justify-items: center",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ji:c"
        ],
        "opts": []
      },
      {
        "content": "justify-items: stretch",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ji:st"
        ],
        "opts": []
      },
      {
        "content": "justify-self: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "js"
        ],
        "opts": []
      },
      {
        "content": "justify-self: start",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "js:s"
        ],
        "opts": []
      },
      {
        "content": "justify-self: end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "js:e"
        ],
        "opts": []
      },
      {
        "content": "justify-self: center",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "js:c"
        ],
        "opts": []
      },
      {
        "content": "justify-self: stretch",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "js:st"
        ],
        "opts": []
      },
      {
        "content": "left: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "l"
        ],
        "opts": []
      },
      {
        "content": "left: auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "l:a"
        ],
        "opts": []
      },
      {
        "content": "letter-spacing: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lts"
        ],
        "opts": []
      },
      {
        "content": "line-height: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lh"
        ],
        "opts": []
      },
      {
        "content": "list-style-image: url('${0}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lisi"
        ],
        "opts": []
      },
      {
        "content": "list-style-image: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lisi:n"
        ],
        "opts": []
      },
      {
        "content": "list-style-position: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lisp"
        ],
        "opts": []
      },
      {
        "content": "list-style-position: inside",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lisp:i"
        ],
        "opts": []
      },
      {
        "content": "list-style-position: outside",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lisp:o"
        ],
        "opts": []
      },
      {
        "content": "list-style-type: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "list"
        ],
        "opts": []
      },
      {
        "content": "list-style-type: circle",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "list:c"
        ],
        "opts": []
      },
      {
        "content": "list-style-type: decimal-leading-zero",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "list:dclz"
        ],
        "opts": []
      },
      {
        "content": "list-style-type: decimal",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "list:dc"
        ],
        "opts": []
      },
      {
        "content": "list-style-type: disc",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "list:d"
        ],
        "opts": []
      },
      {
        "content": "list-style-type: lower-roman",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "list:lr"
        ],
        "opts": []
      },
      {
        "content": "list-style-type: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "list:n"
        ],
        "opts": []
      },
      {
        "content": "list-style-type: square",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "list:s"
        ],
        "opts": []
      },
      {
        "content": "list-style-type: upper-roman",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "list:ur"
        ],
        "opts": []
      },
      {
        "content": "list-style: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lis"
        ],
        "opts": []
      },
      {
        "content": "list-style: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lis:n"
        ],
        "opts": []
      },
      {
        "content": "margin-bottom: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mb"
        ],
        "opts": []
      },
      {
        "content": "margin-bottom: auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mb:a"
        ],
        "opts": []
      },
      {
        "content": "margin-left: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ml"
        ],
        "opts": []
      },
      {
        "content": "margin-left: auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ml:a"
        ],
        "opts": []
      },
      {
        "content": "margin-right: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mr"
        ],
        "opts": []
      },
      {
        "content": "margin-right: auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mr:a"
        ],
        "opts": []
      },
      {
        "content": "margin-top: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mt"
        ],
        "opts": []
      },
      {
        "content": "margin-top: auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mt:a"
        ],
        "opts": []
      },
      {
        "content": "margin: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "m"
        ],
        "opts": []
      },
      {
        "content": "margin: ${1:0} ${2:0} ${3:0} ${0:0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "m:4"
        ],
        "opts": []
      },
      {
        "content": "margin: ${1:0} ${2:0} ${0:0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "m:3"
        ],
        "opts": []
      },
      {
        "content": "margin: ${1:0} ${0:0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "m:2"
        ],
        "opts": []
      },
      {
        "content": "margin: 0",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "m:0"
        ],
        "opts": []
      },
      {
        "content": "margin: auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "m:a"
        ],
        "opts": []
      },
      {
        "content": "max-height: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mah"
        ],
        "opts": []
      },
      {
        "content": "max-height: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mah:n"
        ],
        "opts": []
      },
      {
        "content": "max-width: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "maw"
        ],
        "opts": []
      },
      {
        "content": "max-width: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "maw:n"
        ],
        "opts": []
      },
      {
        "content": "min-height: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mih"
        ],
        "opts": []
      },
      {
        "content": "min-width: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "miw"
        ],
        "opts": []
      },
      {
        "content": "opacity: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "op"
        ],
        "opts": []
      },
      {
        "content": "filter: progid:DXImageTransform.Microsoft.Alpha(Opacity=${0:100})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "op:ie"
        ],
        "opts": []
      },
      {
        "content": "-ms-filter: 'progid:DXImageTransform.Microsoft.Alpha(Opacity=${0:100})'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "op:ms"
        ],
        "opts": []
      },
      {
        "content": "orphans: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "orp"
        ],
        "opts": []
      },
      {
        "content": "outline: ${1:1px} ${2:solid} #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "o+"
        ],
        "opts": []
      },
      {
        "content": "outline-color: ${0:#000}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "oc"
        ],
        "opts": []
      },
      {
        "content": "outline-color: invert",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "oc:i"
        ],
        "opts": []
      },
      {
        "content": "outline-offset: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "oo"
        ],
        "opts": []
      },
      {
        "content": "outline-style: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "os"
        ],
        "opts": []
      },
      {
        "content": "outline-width: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ow"
        ],
        "opts": []
      },
      {
        "content": "outline: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "o"
        ],
        "opts": []
      },
      {
        "content": "outline: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "o:n"
        ],
        "opts": []
      },
      {
        "content": "overflow-style: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovs"
        ],
        "opts": []
      },
      {
        "content": "overflow-style: auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovs:a"
        ],
        "opts": []
      },
      {
        "content": "overflow-style: marquee",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovs:mq"
        ],
        "opts": []
      },
      {
        "content": "overflow-style: move",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovs:mv"
        ],
        "opts": []
      },
      {
        "content": "overflow-style: panner",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovs:p"
        ],
        "opts": []
      },
      {
        "content": "overflow-style: scrollbar",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovs:s"
        ],
        "opts": []
      },
      {
        "content": "overflow-x: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovx"
        ],
        "opts": []
      },
      {
        "content": "overflow-x: auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovx:a"
        ],
        "opts": []
      },
      {
        "content": "overflow-x: hidden",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovx:h"
        ],
        "opts": []
      },
      {
        "content": "overflow-x: scroll",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovx:s"
        ],
        "opts": []
      },
      {
        "content": "overflow-x: visible",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovx:v"
        ],
        "opts": []
      },
      {
        "content": "overflow-y: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovy"
        ],
        "opts": []
      },
      {
        "content": "overflow-y: auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovy:a"
        ],
        "opts": []
      },
      {
        "content": "overflow-y: hidden",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovy:h"
        ],
        "opts": []
      },
      {
        "content": "overflow-y: scroll",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovy:s"
        ],
        "opts": []
      },
      {
        "content": "overflow-y: visible",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovy:v"
        ],
        "opts": []
      },
      {
        "content": "overflow: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ov"
        ],
        "opts": []
      },
      {
        "content": "overflow: auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ov:a"
        ],
        "opts": []
      },
      {
        "content": "overflow: hidden",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ov:h"
        ],
        "opts": []
      },
      {
        "content": "overflow: scroll",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ov:s"
        ],
        "opts": []
      },
      {
        "content": "overflow: visible",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ov:v"
        ],
        "opts": []
      },
      {
        "content": "padding-bottom: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pb"
        ],
        "opts": []
      },
      {
        "content": "padding-left: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pl"
        ],
        "opts": []
      },
      {
        "content": "padding-right: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pr"
        ],
        "opts": []
      },
      {
        "content": "padding-top: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pt"
        ],
        "opts": []
      },
      {
        "content": "padding: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p"
        ],
        "opts": []
      },
      {
        "content": "padding: ${1:0} ${2:0} ${3:0} ${0:0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p:4"
        ],
        "opts": []
      },
      {
        "content": "padding: ${1:0} ${2:0} ${0:0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p:3"
        ],
        "opts": []
      },
      {
        "content": "padding: ${1:0} ${0:0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p:2"
        ],
        "opts": []
      },
      {
        "content": "padding: 0",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p:0"
        ],
        "opts": []
      },
      {
        "content": "place-content: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc"
        ],
        "opts": []
      },
      {
        "content": "place-content: ${1} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc+"
        ],
        "opts": []
      },
      {
        "content": "place-content: start",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc:s"
        ],
        "opts": []
      },
      {
        "content": "place-content: end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc:e"
        ],
        "opts": []
      },
      {
        "content": "place-content: center",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc:c"
        ],
        "opts": []
      },
      {
        "content": "place-content: flex-start",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc:fs"
        ],
        "opts": []
      },
      {
        "content": "place-content: flex-end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc:fe"
        ],
        "opts": []
      },
      {
        "content": "place-content: space-between",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc:sb"
        ],
        "opts": []
      },
      {
        "content": "place-content: space-around",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc:sa"
        ],
        "opts": []
      },
      {
        "content": "place-content: space-evenly",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc:se"
        ],
        "opts": []
      },
      {
        "content": "place-content: stretch",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc:st"
        ],
        "opts": []
      },
      {
        "content": "page-break-after: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgba"
        ],
        "opts": []
      },
      {
        "content": "page-break-after: always",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgba:aw"
        ],
        "opts": []
      },
      {
        "content": "page-break-after: auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgba:a"
        ],
        "opts": []
      },
      {
        "content": "page-break-after: left",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgba:l"
        ],
        "opts": []
      },
      {
        "content": "page-break-after: right",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgba:r"
        ],
        "opts": []
      },
      {
        "content": "page-break-before: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgbb"
        ],
        "opts": []
      },
      {
        "content": "page-break-before: always",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgbb:aw"
        ],
        "opts": []
      },
      {
        "content": "page-break-before: auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgbb:a"
        ],
        "opts": []
      },
      {
        "content": "page-break-before: left",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgbb:l"
        ],
        "opts": []
      },
      {
        "content": "page-break-before: right",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgbb:r"
        ],
        "opts": []
      },
      {
        "content": "page-break-inside: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgbi"
        ],
        "opts": []
      },
      {
        "content": "page-break-inside: auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgbi:a"
        ],
        "opts": []
      },
      {
        "content": "page-break-inside: avoid",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgbi:av"
        ],
        "opts": []
      },
      {
        "content": "place-items: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pi"
        ],
        "opts": []
      },
      {
        "content": "place-items: ${1:stretch} ${0:stretch}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pi+"
        ],
        "opts": []
      },
      {
        "content": "place-items: start",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pi:s"
        ],
        "opts": []
      },
      {
        "content": "place-items: end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pi:e"
        ],
        "opts": []
      },
      {
        "content": "place-items: center",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pi:c"
        ],
        "opts": []
      },
      {
        "content": "place-items: stretch",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pi:st"
        ],
        "opts": []
      },
      {
        "content": "position: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pos"
        ],
        "opts": []
      },
      {
        "content": "position: absolute",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pos:a"
        ],
        "opts": []
      },
      {
        "content": "position: fixed",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pos:f"
        ],
        "opts": []
      },
      {
        "content": "position: relative",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pos:r"
        ],
        "opts": []
      },
      {
        "content": "position: static",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pos:s"
        ],
        "opts": []
      },
      {
        "content": "place-self: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ps"
        ],
        "opts": []
      },
      {
        "content": "place-self: ${1:stretch} ${0:stretch}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ps+"
        ],
        "opts": []
      },
      {
        "content": "place-self: start",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ps:s"
        ],
        "opts": []
      },
      {
        "content": "place-self: end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ps:e"
        ],
        "opts": []
      },
      {
        "content": "place-self: center",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ps:c"
        ],
        "opts": []
      },
      {
        "content": "place-self: stretch",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ps:st"
        ],
        "opts": []
      },
      {
        "content": "quotes: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "q"
        ],
        "opts": []
      },
      {
        "content": "quotes: '\\201C' '\\201D' '\\2018' '\\2019'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "q:en"
        ],
        "opts": []
      },
      {
        "content": "quotes: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "q:n"
        ],
        "opts": []
      },
      {
        "content": "quotes: '\\00AB' '\\00BB' '\\201E' '\\201C'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "q:ru"
        ],
        "opts": []
      },
      {
        "content": "resize: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rz"
        ],
        "opts": []
      },
      {
        "content": "resize: both",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rz:b"
        ],
        "opts": []
      },
      {
        "content": "resize: horizontal",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rz:h"
        ],
        "opts": []
      },
      {
        "content": "resize: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rz:n"
        ],
        "opts": []
      },
      {
        "content": "resize: vertical",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rz:v"
        ],
        "opts": []
      },
      {
        "content": "right: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "r"
        ],
        "opts": []
      },
      {
        "content": "right: auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "r:a"
        ],
        "opts": []
      },
      {
        "content": "table-layout: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tbl"
        ],
        "opts": []
      },
      {
        "content": "table-layout: auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tbl:a"
        ],
        "opts": []
      },
      {
        "content": "table-layout: fixed",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tbl:f"
        ],
        "opts": []
      },
      {
        "content": "text-align-last: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tal"
        ],
        "opts": []
      },
      {
        "content": "text-align-last: auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tal:a"
        ],
        "opts": []
      },
      {
        "content": "text-align-last: center",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tal:c"
        ],
        "opts": []
      },
      {
        "content": "text-align-last: left",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tal:l"
        ],
        "opts": []
      },
      {
        "content": "text-align-last: right",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tal:r"
        ],
        "opts": []
      },
      {
        "content": "text-align: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ta"
        ],
        "opts": []
      },
      {
        "content": "text-align: center",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ta:c"
        ],
        "opts": []
      },
      {
        "content": "text-align: left",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ta:l"
        ],
        "opts": []
      },
      {
        "content": "text-align: right",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ta:r"
        ],
        "opts": []
      },
      {
        "content": "text-decoration: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "td"
        ],
        "opts": []
      },
      {
        "content": "text-decoration: line-through",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "td:l"
        ],
        "opts": []
      },
      {
        "content": "text-decoration: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "td:n"
        ],
        "opts": []
      },
      {
        "content": "text-decoration: overline",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "td:o"
        ],
        "opts": []
      },
      {
        "content": "text-decoration: underline",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "td:u"
        ],
        "opts": []
      },
      {
        "content": "text-emphasis: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "te"
        ],
        "opts": []
      },
      {
        "content": "text-emphasis: accent",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "te:ac"
        ],
        "opts": []
      },
      {
        "content": "text-emphasis: after",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "te:a"
        ],
        "opts": []
      },
      {
        "content": "text-emphasis: before",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "te:b"
        ],
        "opts": []
      },
      {
        "content": "text-emphasis: circle",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "te:c"
        ],
        "opts": []
      },
      {
        "content": "text-emphasis: disc",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "te:ds"
        ],
        "opts": []
      },
      {
        "content": "text-emphasis: dot",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "te:dt"
        ],
        "opts": []
      },
      {
        "content": "text-emphasis: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "te:n"
        ],
        "opts": []
      },
      {
        "content": "text-height: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "th"
        ],
        "opts": []
      },
      {
        "content": "text-height: auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "th:a"
        ],
        "opts": []
      },
      {
        "content": "text-height: font-size",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "th:f"
        ],
        "opts": []
      },
      {
        "content": "text-height: max-size",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "th:m"
        ],
        "opts": []
      },
      {
        "content": "text-height: text-size",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "th:t"
        ],
        "opts": []
      },
      {
        "content": "text-indent: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ti"
        ],
        "opts": []
      },
      {
        "content": "text-indent: -9999px",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ti:-"
        ],
        "opts": []
      },
      {
        "content": "text-justify: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tj"
        ],
        "opts": []
      },
      {
        "content": "text-justify: auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tj:a"
        ],
        "opts": []
      },
      {
        "content": "text-justify: distribute",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tj:d"
        ],
        "opts": []
      },
      {
        "content": "text-justify: inter-cluster",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tj:ic"
        ],
        "opts": []
      },
      {
        "content": "text-justify: inter-ideograph",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tj:ii"
        ],
        "opts": []
      },
      {
        "content": "text-justify: inter-word",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tj:iw"
        ],
        "opts": []
      },
      {
        "content": "text-justify: kashida",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tj:k"
        ],
        "opts": []
      },
      {
        "content": "text-justify: tibetan",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tj:t"
        ],
        "opts": []
      },
      {
        "content": "text-outline: ${1:0} ${2:0} #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "to+"
        ],
        "opts": []
      },
      {
        "content": "text-outline: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "to"
        ],
        "opts": []
      },
      {
        "content": "text-outline: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "to:n"
        ],
        "opts": []
      },
      {
        "content": "text-replace: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tr"
        ],
        "opts": []
      },
      {
        "content": "text-replace: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tr:n"
        ],
        "opts": []
      },
      {
        "content": "text-shadow: ${1:0} ${2:0} ${3:0} #${0:000}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tsh+"
        ],
        "opts": []
      },
      {
        "content": "text-shadow: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tsh"
        ],
        "opts": []
      },
      {
        "content": "text-shadow: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tsh:n"
        ],
        "opts": []
      },
      {
        "content": "text-transform: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tt"
        ],
        "opts": []
      },
      {
        "content": "text-transform: capitalize",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tt:c"
        ],
        "opts": []
      },
      {
        "content": "text-transform: lowercase",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tt:l"
        ],
        "opts": []
      },
      {
        "content": "text-transform: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tt:n"
        ],
        "opts": []
      },
      {
        "content": "text-transform: uppercase",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tt:u"
        ],
        "opts": []
      },
      {
        "content": "text-wrap: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tw"
        ],
        "opts": []
      },
      {
        "content": "text-wrap: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tw:no"
        ],
        "opts": []
      },
      {
        "content": "text-wrap: normal",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tw:n"
        ],
        "opts": []
      },
      {
        "content": "text-wrap: suppress",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tw:s"
        ],
        "opts": []
      },
      {
        "content": "text-wrap: unrestricted",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tw:u"
        ],
        "opts": []
      },
      {
        "content": "top: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "t"
        ],
        "opts": []
      },
      {
        "content": "top: auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "t:a"
        ],
        "opts": []
      },
      {
        "content": "vertical-align: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "va"
        ],
        "opts": []
      },
      {
        "content": "vertical-align: baseline",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "va:bl"
        ],
        "opts": []
      },
      {
        "content": "vertical-align: bottom",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "va:b"
        ],
        "opts": []
      },
      {
        "content": "vertical-align: middle",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "va:m"
        ],
        "opts": []
      },
      {
        "content": "vertical-align: sub",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "va:sub"
        ],
        "opts": []
      },
      {
        "content": "vertical-align: super",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "va:sup"
        ],
        "opts": []
      },
      {
        "content": "vertical-align: text-bottom",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "va:tb"
        ],
        "opts": []
      },
      {
        "content": "vertical-align: text-top",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "va:tt"
        ],
        "opts": []
      },
      {
        "content": "vertical-align: top",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "va:t"
        ],
        "opts": []
      },
      {
        "content": "visibility: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "v"
        ],
        "opts": []
      },
      {
        "content": "visibility: collapse",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "v:c"
        ],
        "opts": []
      },
      {
        "content": "visibility: hidden",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "v:h"
        ],
        "opts": []
      },
      {
        "content": "visibility: visible",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "v:v"
        ],
        "opts": []
      },
      {
        "content": "white-space-collapse: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whsc"
        ],
        "opts": []
      },
      {
        "content": "white-space-collapse: break-all",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whsc:ba"
        ],
        "opts": []
      },
      {
        "content": "white-space-collapse: break-strict",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whsc:bs"
        ],
        "opts": []
      },
      {
        "content": "white-space-collapse: keep-all",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whsc:k"
        ],
        "opts": []
      },
      {
        "content": "white-space-collapse: loose",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whsc:l"
        ],
        "opts": []
      },
      {
        "content": "white-space-collapse: normal",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whsc:n"
        ],
        "opts": []
      },
      {
        "content": "white-space: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whs"
        ],
        "opts": []
      },
      {
        "content": "white-space: normal",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whs:n"
        ],
        "opts": []
      },
      {
        "content": "white-space: nowrap",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whs:nw"
        ],
        "opts": []
      },
      {
        "content": "white-space: pre-line",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whs:pl"
        ],
        "opts": []
      },
      {
        "content": "white-space: pre-wrap",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whs:pw"
        ],
        "opts": []
      },
      {
        "content": "white-space: pre",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whs:p"
        ],
        "opts": []
      },
      {
        "content": "widows: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wid"
        ],
        "opts": []
      },
      {
        "content": "width: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "w"
        ],
        "opts": []
      },
      {
        "content": "width: auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "w:a"
        ],
        "opts": []
      },
      {
        "content": "word-break: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wob"
        ],
        "opts": []
      },
      {
        "content": "word-break: break-all",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wob:ba"
        ],
        "opts": []
      },
      {
        "content": "word-break: break-strict",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wob:bs"
        ],
        "opts": []
      },
      {
        "content": "word-break: keep-all",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wob:k"
        ],
        "opts": []
      },
      {
        "content": "word-break: loose",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wob:l"
        ],
        "opts": []
      },
      {
        "content": "word-break: normal",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wob:n"
        ],
        "opts": []
      },
      {
        "content": "word-spacing: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wos"
        ],
        "opts": []
      },
      {
        "content": "word-wrap: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wow"
        ],
        "opts": []
      },
      {
        "content": "word-wrap: none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wow:no"
        ],
        "opts": []
      },
      {
        "content": "word-wrap: normal",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wow:n"
        ],
        "opts": []
      },
      {
        "content": "word-wrap: suppress",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wow:s"
        ],
        "opts": []
      },
      {
        "content": "word-wrap: unrestricted",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wow:u"
        ],
        "opts": []
      },
      {
        "content": "z-index: ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "z"
        ],
        "opts": []
      },
      {
        "content": "z-index: auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "z:a"
        ],
        "opts": []
      },
      {
        "content": "zoom: 1",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "zoo"
        ],
        "opts": []
      },
      {
        "content": ":hover",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ":h"
        ],
        "opts": []
      },
      {
        "content": ":first-child",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ":fc"
        ],
        "opts": []
      },
      {
        "content": ":last-child",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ":lc"
        ],
        "opts": []
      },
      {
        "content": ":nth-child(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ":nc"
        ],
        "opts": []
      },
      {
        "content": ":nth-last-child(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ":nlc"
        ],
        "opts": []
      },
      {
        "content": ":only-child",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ":oc"
        ],
        "opts": []
      },
      {
        "content": ":after",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ":a"
        ],
        "opts": []
      },
      {
        "content": ":before",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ":b"
        ],
        "opts": []
      },
      {
        "content": "::after",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "::a"
        ],
        "opts": []
      },
      {
        "content": "::before",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "::b"
        ],
        "opts": []
      }
    ],
    "scala": [
      {
        "content": "if (${1})\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "if (!${1})\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifn"
        ],
        "opts": []
      },
      {
        "content": "if (${1})\n\t${2:${VISUAL}}\nelse\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "if (${1})\n\t${2:${VISUAL}}\nelse if (${3})\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifelif"
        ],
        "opts": []
      },
      {
        "content": "else if (${3})\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eif"
        ],
        "opts": []
      },
      {
        "content": "while (${1:obj}) {\n\t${0:${VISUAL}}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh"
        ],
        "opts": []
      },
      {
        "content": "for (${1:item} <- ${2:obj}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "for (${1:i} <- ${2:0} to ${3:obj}.length) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fori"
        ],
        "opts": []
      },
      {
        "content": "for {\n\t${1:item} <- ${2:obj}\n} yield ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fory"
        ],
        "opts": []
      },
      {
        "content": "try {\n\t${1:${VISUAL}}\n} catch {\n\tcase e: FileNotFoundException => ${2}\n\tcase e: IOException => ${3}\n} finally {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "try"
        ],
        "opts": []
      },
      {
        "content": "${1:${VISUAL}} match {\n\tcase ${2} => ${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mat"
        ],
        "opts": []
      },
      {
        "content": "${1: obj} match {\n\tcase ${2:e} => ${3}\n\tcase _ => ${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "match"
        ],
        "opts": []
      },
      {
        "content": "case ${1:${VISUAL}} => ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case"
        ],
        "opts": []
      },
      {
        "content": "${1:a}: ${2:T}${0:, arg}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "arg"
        ],
        "opts": []
      },
      {
        "content": "${1:args}: ${0:T}*",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "args"
        ],
        "opts": []
      },
      {
        "content": "def ${1:name}(${2:arg}) = ${0:}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "def"
        ],
        "opts": []
      },
      {
        "content": "private def ${1:name}(${2:arg}) = ${0:}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prdef"
        ],
        "opts": []
      },
      {
        "content": "override def ${1:name}(${2:arg}) = ${0:}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovdef"
        ],
        "opts": []
      },
      {
        "content": "(${1:a}: ${2:T}) => $1 ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fcf"
        ],
        "opts": []
      },
      {
        "content": "${1:name} => ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "=>"
        ],
        "opts": []
      },
      {
        "content": "def ${1:name}(${0:arg}) =\n\tif($2) $2\n\telse $1($2)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rec"
        ],
        "opts": []
      },
      {
        "content": "def ${1:name}(${2:arg})(${3:arg}) = ${0:}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "crdef"
        ],
        "opts": []
      },
      {
        "content": "def main(args: Array[String]):${1:T} = ${0:}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "main"
        ],
        "opts": []
      },
      {
        "content": "dbl",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "T Double"
        ],
        "opts": []
      },
      {
        "content": "int",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "T Int"
        ],
        "opts": []
      },
      {
        "content": "lng",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "T Long"
        ],
        "opts": []
      },
      {
        "content": "chr",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "T Char"
        ],
        "opts": []
      },
      {
        "content": "str",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "T String"
        ],
        "opts": []
      },
      {
        "content": "arr",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "T Array"
        ],
        "opts": []
      },
      {
        "content": "buf",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "T Buffer"
        ],
        "opts": []
      },
      {
        "content": "list",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "T List"
        ],
        "opts": []
      },
      {
        "content": "tpl",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "T Tuple"
        ],
        "opts": []
      },
      {
        "content": "set",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "T Set"
        ],
        "opts": []
      },
      {
        "content": "map",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "T Map"
        ],
        "opts": []
      },
      {
        "content": "hset",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "T HashSet"
        ],
        "opts": []
      },
      {
        "content": "hmap",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "T HashMap"
        ],
        "opts": []
      },
      {
        "content": "bool",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "T Boolean"
        ],
        "opts": []
      },
      {
        "content": "Boolean",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bool"
        ],
        "opts": []
      },
      {
        "content": "AnyRef",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "anyr"
        ],
        "opts": []
      },
      {
        "content": "Double",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dbl"
        ],
        "opts": []
      },
      {
        "content": "Int",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "int"
        ],
        "opts": []
      },
      {
        "content": "String",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "str"
        ],
        "opts": []
      },
      {
        "content": "Char",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "chr"
        ],
        "opts": []
      },
      {
        "content": "Long",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lng"
        ],
        "opts": []
      },
      {
        "content": "Array${1:[T]}${0:()}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "arr"
        ],
        "opts": []
      },
      {
        "content": "Buffer${1:[T]}${0:()}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "buf"
        ],
        "opts": []
      },
      {
        "content": "List${1:[T]}${0:()}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "list"
        ],
        "opts": []
      },
      {
        "content": "Tuple${1:2}[${2:T},${0:T}]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tpl"
        ],
        "opts": []
      },
      {
        "content": "Set${1:[T]}${0:()}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "set"
        ],
        "opts": []
      },
      {
        "content": "HashSet${1:[T]}${0:()}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "hset"
        ],
        "opts": []
      },
      {
        "content": "mutable.HashSet${1:[T]}${0:()}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mhset"
        ],
        "opts": []
      },
      {
        "content": "${1:key}->${2:val}${0:, keyval}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "keyval"
        ],
        "opts": []
      },
      {
        "content": "Map[${1:T},${2:T}]${0:(keyval)}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "map"
        ],
        "opts": []
      },
      {
        "content": "HashMap[${1:T},${2:T}]${0:(keyval)}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "hmap"
        ],
        "opts": []
      },
      {
        "content": "mutable.Map[${1:T},${2:T}]${0:(keyval)}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mmap"
        ],
        "opts": []
      },
      {
        "content": "mutable.HashMap[${1:T},${2:T}]${0:(keyval)}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mhmap"
        ],
        "opts": []
      },
      {
        "content": "${1:name}.asInstanceOf[${2:T}]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as"
        ],
        "opts": []
      },
      {
        "content": "${1:name}.isInstanceOf[${2:T}]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "is"
        ],
        "opts": []
      },
      {
        "content": "(${1:a} => ${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "(a"
        ],
        "opts": []
      },
      {
        "content": "{(${1:a},${2:b}) =>\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "{("
        ],
        "opts": []
      },
      {
        "content": "${0:name}.filter (a",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "filter"
        ],
        "opts": []
      },
      {
        "content": "${0:name}.map (a",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mapf"
        ],
        "opts": []
      },
      {
        "content": "${1:name}.flatMap${0:[T]}(a",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "flatmap"
        ],
        "opts": []
      },
      {
        "content": "${1:name}.foldLeft(${0:first}) {(",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fldl"
        ],
        "opts": []
      },
      {
        "content": "${1:name}.foldRight(${0:first}) {(",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fldr"
        ],
        "opts": []
      },
      {
        "content": "(${1:first}/:${2:name})(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "/:"
        ],
        "opts": []
      },
      {
        "content": "(${1:first}:\\${2:name})(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ":\\"
        ],
        "opts": []
      },
      {
        "content": "${1:name}.reduceLeft[${0:T}] {(",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "redl"
        ],
        "opts": []
      },
      {
        "content": "${1:name}.reduceRight[${0:T}] {(",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "redr"
        ],
        "opts": []
      },
      {
        "content": "${0:name}.view.zipWithIndex",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "zipwi"
        ],
        "opts": []
      },
      {
        "content": "${1:name}.split(\"${0:,}\")",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "spl"
        ],
        "opts": []
      },
      {
        "content": "val ${1:name}${2:: T} = ${0:value}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "val"
        ],
        "opts": []
      },
      {
        "content": "var ${1:name}${2:: T} = ${0:value}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "var"
        ],
        "opts": []
      },
      {
        "content": "extends ${0:what}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "extends"
        ],
        "opts": []
      },
      {
        "content": "with ${1:what}${0: with}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "with"
        ],
        "opts": []
      },
      {
        "content": "def this(arg) = this(arg)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "athis"
        ],
        "opts": []
      },
      {
        "content": "abstract class ${1:name}${2:(arg)}${3: extends }${4: with} {\n\t${5:override def toString = \"$1\"}\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "abstract"
        ],
        "opts": []
      },
      {
        "content": "class ${1:name}${2:(arg)}${3: extends }${4: with} {\n\t${5:override def toString = \"$1\"}\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "class"
        ],
        "opts": []
      },
      {
        "content": "object ${1:name}${2:(arg)}${3: extends }${4: with} ${0:}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "object"
        ],
        "opts": []
      },
      {
        "content": "trait ${1:name}${2: extends }${3: with} {\n\t${0:}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "trait"
        ],
        "opts": []
      },
      {
        "content": "class ${1:name}${2:(arg)} extends Ordered[$1] ${3: with} {\n\t${4:override def toString = \"$1\"}\n\tdef compare(that: $1) = ${5:this - that}\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ordered"
        ],
        "opts": []
      },
      {
        "content": "case class ${1:name}${2:(arg)}${3: extends }${4: with} ${0:}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "casecl"
        ],
        "opts": []
      },
      {
        "content": "${1:import org.scalatest.Suite}\n${0:import org.scalatest.FunSuite}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "scalatest"
        ],
        "opts": []
      },
      {
        "content": "assert(${1:a} === ${0:b})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "assert"
        ],
        "opts": []
      },
      {
        "content": "ifel ensuring(${1:a}==${0:b})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ensuring"
        ],
        "opts": []
      },
      {
        "content": "expect(${1:what}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "expect"
        ],
        "opts": []
      },
      {
        "content": "intercept[${1:IllegalArgumentException}] {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "intercept"
        ],
        "opts": []
      },
      {
        "content": "test(\"${1:description}\") {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "test"
        ],
        "opts": []
      },
      {
        "content": "class ${0:name} extends Suite {\n\tdef test() {\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "suite"
        ],
        "opts": []
      },
      {
        "content": "class ${1:name} extends FunSuite {\n\ttest(\"${0:description}\") {\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fsuite"
        ],
        "opts": []
      },
      {
        "content": "import sbt._\nclass ${1:Name}(info: ProjectInfo) extends DefaultWebProject(info) {\n\tval liftVersion = \"${0:2.3}\"\n\toverride def libraryDependencies = Set(\n\t) ++ super.libraryDependencies\n\tval snapshots = ScalaToolsSnapshots\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "webproject"
        ],
        "opts": []
      },
      {
        "content": "\"net.liftweb\" %% \"${0:lib}\" % liftVersion % \"compile->default\",",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "liftjar"
        ],
        "opts": []
      },
      {
        "content": "\"org.mortbay.jetty\" % \"jetty\" % \"${0:version}\" % \"test->default\",",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jettyjar"
        ],
        "opts": []
      },
      {
        "content": "import _root_.net.liftweb.http._\nimport S._\nimport _root_.net.liftweb.util._\nimport Helpers._\nimport _root_.scala.xml._",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "liftimports"
        ],
        "opts": []
      },
      {
        "content": "match {\n\tcase ${1} => ${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "match {\\n  case .. => ..",
        "matches": [
          "match"
        ],
        "opts": []
      },
      {
        "content": "case ${1} => ${0}",
        "doc": "",
        "grammar": "snu",
        "label": "case .. => ..",
        "matches": [
          "case"
        ],
        "opts": []
      },
      {
        "content": "try {\n\t${1:TARGET}\n} catch {\n\tcase e${2:: Exception} => ${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "try {} catch { case ... }",
        "matches": [
          "try"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "for {\n\t${1}\n} yield ${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "if (${1}) {\n\t${2}\n}${3: else}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "println(${1})",
        "doc": "",
        "grammar": "snu",
        "label": "println()",
        "matches": [
          "p"
        ],
        "opts": []
      },
      {
        "content": "println('${1:#:name}, $1)",
        "doc": "",
        "grammar": "snu",
        "label": "println('name, name)",
        "matches": [
          "pn"
        ],
        "opts": []
      },
      {
        "content": "_ = println(${1})",
        "doc": "",
        "grammar": "snu",
        "label": "p in for",
        "matches": [
          "pf"
        ],
        "opts": []
      },
      {
        "content": "object ${1:`expand('%:t:r') ==# '' ? 'HelloWorld' : expand('%:t:r')`} {\n\tdef main(args: Array[String]) {\n\t\t${0:TARGET}\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "def main(args: Array[String]) {",
        "matches": [
          "main"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "object ${1:`expand('%:t:r') ==# '' ? 'HelloWorld' : expand('%:t:r')`} {\n\tdef main(args: Array[String]) {\n\t\tprintln(\"Hello, world!\")\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "object HelloWorld { def main(...) }",
        "matches": [
          "hello"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "object ${1:X} {\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "object"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "class ${1:X()} {\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "class"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "should \"${1}\" in {\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "should-scalatest"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "import akka.actor.{ActorSystem, Actor, ActorLogging, Props}\nobject ${1:X} {\n\tdef props(${2}) = Props(new X($2))\n}\nclass $1($2) extends Actor with ActorLogging {\n\tdef receive = {\n\t\tcase e =>\n\t\t\t${0:TARGET:println(e)}\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "akka-actor"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "package `substitute(substitute(expand('%:h'), '.*\\<src/\\(main\\|test\\)/scala/', '', ''), '/', '.', 'g')`",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "package"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "case class ${1}(${2}: ${0})",
        "doc": "",
        "grammar": "snu",
        "label": "case class ..(..: ..)",
        "matches": [
          "cclass"
        ],
        "opts": [
          "head"
        ]
      }
    ],
    "scheme": [
      {
        "content": "(+ ${1}\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "+"
        ],
        "opts": []
      },
      {
        "content": "(- ${1}\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "-"
        ],
        "opts": []
      },
      {
        "content": "(/ ${1}\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "/"
        ],
        "opts": []
      },
      {
        "content": "(* ${1}\n\t${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "*"
        ],
        "opts": []
      },
      {
        "content": "(define (${1:name})\n\t\t(${0:definition}))",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "def"
        ],
        "opts": []
      },
      {
        "content": "(define ${1:name}\n\t(lambda (x)(${0:definition})))",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defl"
        ],
        "opts": []
      },
      {
        "content": "(cond ((${1:predicate}) (${2:action}))\n\t((${3:predicate}) (${0:action})))",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cond"
        ],
        "opts": []
      },
      {
        "content": "(if (${1:predicate})\n\t(${2:true-action})\n\t(${0:false-action}))",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "(cond\n  ((${1}) ${2})\n  (${0:else}))",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cond"
        ],
        "opts": []
      },
      {
        "content": "(case ${1}\n  ((${2}) ${3})\n  (${0:else}))",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case"
        ],
        "opts": []
      },
      {
        "content": "(use gauche.test)\n(test-start \"${1}.scm\")\n(load \"$1.scm\")\n(test* \"${2}\" ${3:expected} ${4:actual})",
        "doc": "",
        "grammar": "snu",
        "label": "(use gauche.test)(test-start ...",
        "matches": [
          "gauche-testsuite"
        ],
        "opts": [
          "head"
        ]
      }
    ],
    "scss": [
      {
        "content": "$${1:variable}: ${0:value};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "$"
        ],
        "opts": []
      },
      {
        "content": "@import '${0}';",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "imp"
        ],
        "opts": []
      },
      {
        "content": "@mixin ${1:name}(${2}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mix"
        ],
        "opts": []
      },
      {
        "content": "@include ${1:mixin}(${2});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "inc"
        ],
        "opts": []
      },
      {
        "content": "@extend ${0};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ext"
        ],
        "opts": []
      },
      {
        "content": "@function ${1:name}(${2:args}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fun"
        ],
        "opts": []
      },
      {
        "content": "@if ${1:condition} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "@if ${1:condition} {\n\t${2}\n} @else {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "@else if ${1:condition} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eif"
        ],
        "opts": []
      },
      {
        "content": "@for ${1:$i} from ${2:1} through ${3:3} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "@each ${1:$item} in ${2:items} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "each"
        ],
        "opts": []
      },
      {
        "content": "@while ${1:$i} ${2:>} ${3:0} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "while"
        ],
        "opts": []
      },
      {
        "content": "@mixin ${1:NAME}(${2:#:ARGS}) {\n  ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "@mixin(...){...}",
        "matches": [
          "mixin"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "@include ${1:NAME}(${2:#:ARGS});",
        "doc": "",
        "grammar": "snu",
        "label": "@include ...",
        "matches": [
          "include"
        ],
        "opts": []
      },
      {
        "content": "@import '${0:TARGET}';",
        "doc": "",
        "grammar": "snu",
        "label": "@import '...';",
        "matches": [
          "import"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "@extend ${0:TARGET};",
        "doc": "",
        "grammar": "snu",
        "label": "@extend ...;",
        "matches": [
          "extend"
        ],
        "opts": [
          "head"
        ]
      }
    ],
    "sh": [
      {
        "content": "#!/usr/bin/env sh",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#!"
        ],
        "opts": []
      },
      {
        "content": "#!/usr/bin/env sh\nset -eu",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "s#!"
        ],
        "opts": []
      },
      {
        "content": "set -eu",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "safe"
        ],
        "opts": []
      },
      {
        "content": "#!/usr/bin/env bash",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bash"
        ],
        "opts": []
      },
      {
        "content": "#!/usr/bin/env bash\nset -euo pipefail\nIFS=$'\\n\\t'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sbash"
        ],
        "opts": []
      },
      {
        "content": "if [[ ${1:condition} ]]; then\n\t${0:${VISUAL}}\nfi",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "elif [[ ${1:condition} ]]; then\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "elif"
        ],
        "opts": []
      },
      {
        "content": "for (( ${2:i} = 0; $2 < ${1:count}; $2++ )); do\n\t${0:${VISUAL}}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "for ${1:needle} in ${2:haystack} ; do\n\t${0:${VISUAL}}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fori"
        ],
        "opts": []
      },
      {
        "content": "while [[ ${1:condition} ]]; do\n\t${0:${VISUAL}}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh"
        ],
        "opts": []
      },
      {
        "content": "until [[ ${1:condition} ]]; do\n\t${0:${VISUAL}}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "until"
        ],
        "opts": []
      },
      {
        "content": "case ${1:word} in\n\t${2:pattern})\n\t\t${0};;\nesac",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case"
        ],
        "opts": []
      },
      {
        "content": "while getopts '${1:o}' ${2:opts}\ndo\n\tcase $$2 in\n\t${3:o0})\n\t\t${0:#staments};;\n\tesac\ndone",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "go"
        ],
        "opts": []
      },
      {
        "content": "SCRIPT_DIR=\"$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" && pwd )\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sdir"
        ],
        "opts": []
      },
      {
        "content": "__ScriptVersion=\"${1:version}\"\n#===  FUNCTION  ================================================================\n#         NAME:  usage\n#  DESCRIPTION:  Display usage information.\n#===============================================================================\nfunction usage ()\n{\n\techo \"Usage :  $${0:0} [options] [--]\n    Options:\n    -h|help       Display this message\n    -v|version    Display script version\"\n}    # ----------  end of function usage  ----------\n#-----------------------------------------------------------------------\n#  Handle command line arguments\n#-----------------------------------------------------------------------\nwhile getopts \":hv\" opt\ndo\n  case $opt in\n\th|help     )  usage; exit 0   ;;\n\tv|version  )  echo \"$${0:0} -- Version $__ScriptVersion\"; exit 0   ;;\n\t* )  echo -e \"\\n  Option does not exist : $OPTARG\\n\"\n\t\t  usage; exit 1   ;;\n  esac    # --- end of case ---\ndone\nshift $(($OPTIND-1))",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "getopt"
        ],
        "opts": []
      },
      {
        "content": "if [ \\$(id -u) -ne 0 ]; then exec sudo \\$0; fi",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "root"
        ],
        "opts": []
      },
      {
        "content": "${1:function_name}() {\n\t${0:#function_body}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fun-sh"
        ],
        "opts": []
      },
      {
        "content": "function ${1:function_name}() {\n\t${0:#function_body}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fun"
        ],
        "opts": []
      },
      {
        "content": "#!/bin/${1:sh}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "#!/bin/sh",
        "matches": [
          "#!",
          "shebang"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "if [ ${1:#:condition} ]; then\n\t${0:TARGET}\nfi",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "else\n\t${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "el"
        ],
        "opts": []
      },
      {
        "content": "elif [ ${1:#:condition} ]; then\n\t${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "elif"
        ],
        "opts": []
      },
      {
        "content": "for ${1:i} in ${2:#:words}; do\n\t${0:TARGET}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "while ${1:#:condition} ; do\n\t${0:TARGET}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "while",
          "wh"
        ],
        "opts": []
      },
      {
        "content": "until ${1:#:condition} ; do\n\t${0:TARGET}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "until"
        ],
        "opts": []
      },
      {
        "content": "<< ${1:EOF}\n\t${0:#:TARGET}\n$1",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "h <<",
          "heredoc"
        ],
        "opts": []
      },
      {
        "content": "#!/usr/bin/env ${1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "env"
        ],
        "opts": []
      },
      {
        "content": "${1:TMPFILE}=$(mktemp ${2:XXX})\ntrap \"rm -f '${$1}'\" 0               # EXIT\ntrap \"rm -f '${$1}'; exit 1\" 2       # INT\ntrap \"rm -f '${$1}'; exit 1\" 1 15    # HUP TERM\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tmp"
        ],
        "opts": []
      },
      {
        "content": "${1:#:name}()\n{\n\t${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "func",
          "function"
        ],
        "opts": []
      },
      {
        "content": "if [[ $${1:string} =~ ${2:^regexp.*} ]]; then\n\t${0}\nfi",
        "doc": "",
        "grammar": "snu",
        "label": "=~",
        "matches": [
          "match-regexp"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "${1:name}=\"${2:something}\"",
        "doc": "",
        "grammar": "snu",
        "label": "var-assign",
        "matches": [
          "assign"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "case \"$${1:{name\\}}\" in\n\t${2:pattern*})\n\t\t${0}\n\t\t;;\n\t*)\n\t\t${3:echo \"$$1 Didn't match anything\"}\nesac",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "echo \"${0:TARGET}\" 1>&2",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "warn"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "echo \"${0:TARGET}\" 1>&2\nexit 1",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "abort"
        ],
        "opts": [
          "head"
        ]
      }
    ],
    "simplemvcf": [
      {
        "content": "<?php\n\tnamespace Controllers;\n\tuse Core\\View;\n\tuse Core\\Controller;\n\tclass ${1:class_name} extends Controller\n\t{\n\t\tpublic function __construct()\n\t\t{\n\t\t\tparent::__construct();\n\t\t}\n\t\tpublic function index()\n\t\t{\n\t\t\t${2:}\n\t\t}\n\t}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sm_controller"
        ],
        "opts": []
      },
      {
        "content": "<?php \n\tnamespace Models;\n\tuse Core\\Model;\n\tclass ${1:class_name} extends Model \n\t{    \n\t\tfunction __construct()\n\t\t{\n\t\t\tparent::__construct();\n\t\t}  \n\t}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sm_model"
        ],
        "opts": []
      },
      {
        "content": "<?php \n\tnamespace Models;\n\tuse Core\\Model;\n\tclass ${1:class_name} extends Model \n\t{    \n\t\tprivate $${2:table};\n\t\tfunction __construct()\n\t\t{\n\t\t\tparent::__construct();\n\t\t}  \n\t\tpublic function getRow($where)\n\t\t{\n\t\t\treturn $this->db->select('SELECT * FROM '.$table.' WHERE ${3:where}', $data);\n\t\t}\n\t\tpublic function getRows($where)\n\t\t{\n\t\t\treturn $this->db->select('SELECT * FROM '.$table.');\n\t\t}\n\t\tpublic function insert($data)\n\t\t{\n\t\t\t$this->db->insert($table, $data);\n\t\t}\n\t\tpublic function update($data, $where)\n\t\t{\n\t\t\t$this->db->update($table ,$data, $where);\n\t\t}\n\t\tpublic function delete($where)\n\t\t{\n\t\t\t$this->db->delete($table, $where);\n\t\t}\n\t}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sm_model_crud"
        ],
        "opts": []
      },
      {
        "content": "View::render('${1:view}', $${2:array});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sm_render"
        ],
        "opts": []
      },
      {
        "content": "View::renderTemplate('${1:part}', $${2:array});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sm_render_template"
        ],
        "opts": []
      },
      {
        "content": "$this->db->select(${1:sql}, ${2:where});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sm_db_select"
        ],
        "opts": []
      },
      {
        "content": "$this->db->insert(${1:table}, ${2:data});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sm_db_insert"
        ],
        "opts": []
      },
      {
        "content": "$this->db->update(${1:table}, ${2:data}, ${3:where});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sm_db_update"
        ],
        "opts": []
      },
      {
        "content": "$this->db->delete(${1:table}, ${2:where});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sm_db_delete"
        ],
        "opts": []
      },
      {
        "content": "$this->db->delete(${1:table});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sm_db_truncate"
        ],
        "opts": []
      },
      {
        "content": "Session::set(${1:key}, ${2:value});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sm_session_set"
        ],
        "opts": []
      },
      {
        "content": "Session::get(${1:key});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sm_session_get"
        ],
        "opts": []
      },
      {
        "content": "Session::pull(${1:key});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sm_session_pull"
        ],
        "opts": []
      },
      {
        "content": "Session::id();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sm_session_id"
        ],
        "opts": []
      },
      {
        "content": "Session::set(${1:key});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sm_session_destroy"
        ],
        "opts": []
      },
      {
        "content": "Session::display();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sm_session_display"
        ],
        "opts": []
      },
      {
        "content": "Url:redirect('${1:path}');",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sm_url_redirect"
        ],
        "opts": []
      },
      {
        "content": "Url:previous();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sm_url_previous"
        ],
        "opts": []
      },
      {
        "content": "Url:templatePath();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sm_url_templatepath"
        ],
        "opts": []
      },
      {
        "content": "Url:autolink('${1:string}');",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sm_url_autolink"
        ],
        "opts": []
      }
    ],
    "slim": [
      {
        "content": "- binding.pry",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pry"
        ],
        "opts": []
      },
      {
        "content": "= render partial: '${0}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "renp"
        ],
        "opts": []
      },
      {
        "content": "fieldset\n\tlegend ${1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fieldset"
        ],
        "opts": []
      },
      {
        "content": "link rel=\"stylesheet\" href=\"${1:style.css}\" type=\"text/css\" media=\"${2:all}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "css"
        ],
        "opts": []
      },
      {
        "content": "script src=\"${1:script.js}\" type=\"text/javascript\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "script"
        ],
        "opts": []
      },
      {
        "content": "&nbsp;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nbs"
        ],
        "opts": []
      },
      {
        "content": "&#x2190;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "left"
        ],
        "opts": []
      },
      {
        "content": "&#x2192;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "right"
        ],
        "opts": []
      },
      {
        "content": "&#x2191;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "up"
        ],
        "opts": []
      },
      {
        "content": "&#x2193;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "down"
        ],
        "opts": []
      },
      {
        "content": "&#x21A9;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "return"
        ],
        "opts": []
      },
      {
        "content": "&#x21E4;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "backtab"
        ],
        "opts": []
      },
      {
        "content": "&#x21E5;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tab"
        ],
        "opts": []
      },
      {
        "content": "&#x21E7;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "shift"
        ],
        "opts": []
      },
      {
        "content": "&#x2303;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ctrl"
        ],
        "opts": []
      },
      {
        "content": "&#x2305;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "enter"
        ],
        "opts": []
      },
      {
        "content": "&#x2318;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cmd"
        ],
        "opts": []
      },
      {
        "content": "&#x2325;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "option"
        ],
        "opts": []
      },
      {
        "content": "&#x2326;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "delete"
        ],
        "opts": []
      },
      {
        "content": "&#x232B;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "backspace"
        ],
        "opts": []
      },
      {
        "content": "&#x238B;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "esc"
        ],
        "opts": []
      }
    ],
    "snippets": [
      {
        "content": "import styled from 'styled-components/native';\n\nexport const ${1:Container} = styled.${2:View}`\n  ${3}\n`;\n",
        "doc": "Create React Native Styled Components file",
        "grammar": "lsp",
        "label": "styles",
        "matches": [
          "styled-react-native"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react';\nimport { View } from 'react-native';\n\n// import { Container } from './styles';\n\nconst ${1:${TM_DIRECTORY/^.*(\\/|\\\\)([^(\\/|\\\\)]+)$/$2/}} = () => {\n  return <View />;\n}\n\nexport default ${1:${TM_DIRECTORY/^.*(\\/|\\\\)([^(\\/|\\\\)]+)$/$2/}};",
        "doc": "Create React Native Functional Component",
        "grammar": "lsp",
        "label": "componentFunctionalTypescript",
        "matches": [
          "rnfc"
        ],
        "opts": []
      },
      {
        "content": "import ${2:moduleName} from '${1:module}';$0",
        "doc": "Imports entire module statement in ES6 syntax",
        "grammar": "lsp",
        "label": "import",
        "matches": [
          "imp"
        ],
        "opts": []
      },
      {
        "content": "import '${1:module}';$0",
        "doc": "Imports entire module in ES6 syntax without module name",
        "grammar": "lsp",
        "label": "importNoModuleName",
        "matches": [
          "imn"
        ],
        "opts": []
      },
      {
        "content": "import { $2 } from '${1:module}';$0",
        "doc": "Imports only a portion of the module in ES6 syntax",
        "grammar": "lsp",
        "label": "importDestructing",
        "matches": [
          "imd"
        ],
        "opts": []
      },
      {
        "content": "import * as ${2:alias} from '${1:module}';$0",
        "doc": "Imports everything as alias from the module in ES6 syntax",
        "grammar": "lsp",
        "label": "importEverything",
        "matches": [
          "ime"
        ],
        "opts": []
      },
      {
        "content": "import { ${2:originalName} as ${3:alias} } from '${1:module}';$0",
        "doc": "Imports a specific portion of the module by assigning a local alias in ES6 syntax",
        "grammar": "lsp",
        "label": "importAs",
        "matches": [
          "ima"
        ],
        "opts": []
      },
      {
        "content": "require('${1:package}');",
        "doc": "Require a package",
        "grammar": "lsp",
        "label": "require",
        "matches": [
          "rqr"
        ],
        "opts": []
      },
      {
        "content": "const ${1:packageName} = require('${1:package}');$0",
        "doc": "Require a package to const",
        "grammar": "lsp",
        "label": "requireToConst",
        "matches": [
          "req"
        ],
        "opts": []
      },
      {
        "content": "module.exports = {\n\t$0\n};\n",
        "doc": "Module exports from Common JS, node syntax at ES6",
        "grammar": "lsp",
        "label": "moduleExports",
        "matches": [
          "mde"
        ],
        "opts": []
      },
      {
        "content": "export const ${1:exportVariable} = ${2:localVariable};\n",
        "doc": "Export named variable in ES6 syntax",
        "grammar": "lsp",
        "label": "exportNamedVariable",
        "matches": [
          "env"
        ],
        "opts": []
      },
      {
        "content": "export const ${1:functionName} = (${2:params}) => {\n\t$0\n};\n",
        "doc": "Export named function in ES6 syntax",
        "grammar": "lsp",
        "label": "exportNamedFunction",
        "matches": [
          "enf"
        ],
        "opts": []
      },
      {
        "content": "export default function ${1:${TM_FILENAME_BASE}}(${2:params}) {\n\t$0\n};\n",
        "doc": "Export default function in ES6 syntax",
        "grammar": "lsp",
        "label": "exportDefaultFunction",
        "matches": [
          "edf"
        ],
        "opts": []
      },
      {
        "content": "export default class ${1:className} {\n\t$0\n};\n",
        "doc": "Export default class in ES6 syntax",
        "grammar": "lsp",
        "label": "exportClass",
        "matches": [
          "ecl"
        ],
        "opts": []
      },
      {
        "content": "export default class ${1:className} extends ${2:baseclassName} {\n\t$0\n};\n",
        "doc": "Export default class which extends a base one in ES6 syntax",
        "grammar": "lsp",
        "label": "exportClassExtends",
        "matches": [
          "ece"
        ],
        "opts": []
      },
      {
        "content": "constructor(${1:params}) {\n\t${0}\n}",
        "doc": "Add default constructor in a class in ES6 syntax",
        "grammar": "lsp",
        "label": "constructor",
        "matches": [
          "con"
        ],
        "opts": []
      },
      {
        "content": "${1:methodName}(${2:params}) {\n\t${0}\n}",
        "doc": "Creates a method inside a class in ES6 syntax",
        "grammar": "lsp",
        "label": "method",
        "matches": [
          "met"
        ],
        "opts": []
      },
      {
        "content": "get ${1:propertyName}() {\n\treturn this.${0};\n}",
        "doc": "Creates a getter property inside a class in ES6 syntax",
        "grammar": "lsp",
        "label": "propertyGet",
        "matches": [
          "pge"
        ],
        "opts": []
      },
      {
        "content": "set ${1:propertyName}(${2:value}) {\n\t${0};\n}",
        "doc": "Creates a setter property inside a class in ES6 syntax",
        "grammar": "lsp",
        "label": "propertyset",
        "matches": [
          "pse"
        ],
        "opts": []
      },
      {
        "content": "${1:array}.forEach(${2:currentItem} => {\n\t${0}\n});",
        "doc": "Creates a forEach statement in ES6 syntax",
        "grammar": "lsp",
        "label": "forEach",
        "matches": [
          "fre"
        ],
        "opts": []
      },
      {
        "content": "for (const ${1:item} of ${2:object}) {\n\t${0}\n}",
        "doc": "Iterating over property names of iterable objects",
        "grammar": "lsp",
        "label": "forOf",
        "matches": [
          "fof"
        ],
        "opts": []
      },
      {
        "content": "for (const ${1:item} in ${2:object}) {\n\t${0}\n}",
        "doc": "Iterating over property values of iterable objects",
        "grammar": "lsp",
        "label": "forIn",
        "matches": [
          "fin"
        ],
        "opts": []
      },
      {
        "content": "(${1:params}) => {\n\t${2}\n}",
        "doc": "Creates an anonymous function in ES6 syntax",
        "grammar": "lsp",
        "label": "anonymousFunction",
        "matches": [
          "anfn"
        ],
        "opts": []
      },
      {
        "content": "const ${1:name} = (${2:params}) => {\n\t${3}\n}",
        "doc": "Creates a named function in ES6 syntax",
        "grammar": "lsp",
        "label": "namedFunction",
        "matches": [
          "nfn"
        ],
        "opts": []
      },
      {
        "content": "const {${2:propertyName}} = ${1:objectToDestruct};",
        "doc": "Creates and assigns a local variable using object destructing",
        "grammar": "lsp",
        "label": "destructingObject",
        "matches": [
          "dob"
        ],
        "opts": []
      },
      {
        "content": "const [${2:propertyName}] = ${1:arrayToDestruct};",
        "doc": "Creates and assigns a local variable using array destructing",
        "grammar": "lsp",
        "label": "destructingArray",
        "matches": [
          "dar"
        ],
        "opts": []
      },
      {
        "content": "setInterval(() => {\n\t${2}\n}, ${0:intervalInms});",
        "doc": "Executes the given function at specified intervals in ES6 syntax",
        "grammar": "lsp",
        "label": "setInterval",
        "matches": [
          "sti"
        ],
        "opts": []
      },
      {
        "content": "setTimeout(() => {\n\t${2}\n}, ${1:delayInms});",
        "doc": "Executes the given function after the specified delay in ES6 syntax",
        "grammar": "lsp",
        "label": "setTimeOut",
        "matches": [
          "sto"
        ],
        "opts": []
      },
      {
        "content": "return new Promise((resolve, reject) => {\n\t${1}\n});",
        "doc": "Creates and returns a new Promise in the standard ES6 syntax",
        "grammar": "lsp",
        "label": "promise",
        "matches": [
          "prom"
        ],
        "opts": []
      },
      {
        "content": ".then((${1:result}) => {\n\t${2}\n}).catch((${3:err}) => {\n\t${4}\n});",
        "doc": "Add the .then and .catch methods to handle promises",
        "grammar": "lsp",
        "label": "thenCatch",
        "matches": [
          "thenc"
        ],
        "opts": []
      },
      {
        "content": "console.assert(${1:expression}, ${2:object});",
        "doc": "If the specified expression is false, the message is written to the console along with a stack trace",
        "grammar": "lsp",
        "label": "consoleAssert",
        "matches": [
          "cas"
        ],
        "opts": []
      },
      {
        "content": "console.clear();",
        "doc": "Clears the console",
        "grammar": "lsp",
        "label": "consoleClear",
        "matches": [
          "ccl"
        ],
        "opts": []
      },
      {
        "content": "console.count(${1:label});",
        "doc": "Writes the the number of times that count() has been invoked at the same line and with the same label",
        "grammar": "lsp",
        "label": "consoleCount",
        "matches": [
          "cco"
        ],
        "opts": []
      },
      {
        "content": "console.debug(${1:object});",
        "doc": "Displays a message in the console. Also display a blue right arrow icon along with the logged message in Safari",
        "grammar": "lsp",
        "label": "consoleDebug",
        "matches": [
          "cdb"
        ],
        "opts": []
      },
      {
        "content": "console.dir(${1:object});",
        "doc": "Prints a JavaScript representation of the specified object",
        "grammar": "lsp",
        "label": "consoleDir",
        "matches": [
          "cdi"
        ],
        "opts": []
      },
      {
        "content": "console.error(${1:object});",
        "doc": "Displays a message in the console and also includes a stack trace from where the method was called",
        "grammar": "lsp",
        "label": "consoleError",
        "matches": [
          "cer"
        ],
        "opts": []
      },
      {
        "content": "console.group('${1:label}');",
        "doc": "Groups and indents all following output by an additional level, until console.groupEnd() is called.",
        "grammar": "lsp",
        "label": "consoleGroup",
        "matches": [
          "cgr"
        ],
        "opts": []
      },
      {
        "content": "console.groupEnd();",
        "doc": "Closes out the corresponding console.group().",
        "grammar": "lsp",
        "label": "consoleGroupEnd",
        "matches": [
          "cge"
        ],
        "opts": []
      },
      {
        "content": "console.log(${1:object});",
        "doc": "Displays a message in the console",
        "grammar": "lsp",
        "label": "consoleLog",
        "matches": [
          "clg"
        ],
        "opts": []
      },
      {
        "content": "console.log('${1:object} :>> ', ${1:object});",
        "doc": "Displays an object in the console with its name",
        "grammar": "lsp",
        "label": "consoleLogObject",
        "matches": [
          "clo"
        ],
        "opts": []
      },
      {
        "content": "console.trace(${1:object});",
        "doc": "Prints a stack trace from the point where the method was called",
        "grammar": "lsp",
        "label": "consoleTrace",
        "matches": [
          "ctr"
        ],
        "opts": []
      },
      {
        "content": "console.warn(${1:object});",
        "doc": "Displays a message in the console but also displays a yellow warning icon along with the logged message",
        "grammar": "lsp",
        "label": "consoleWarn",
        "matches": [
          "cwa"
        ],
        "opts": []
      },
      {
        "content": "console.info(${1:object});",
        "doc": "Displays a message in the console but also displays a blue information icon along with the logged message",
        "grammar": "lsp",
        "label": "consoleInfo",
        "matches": [
          "cin"
        ],
        "opts": []
      },
      {
        "content": "console.table(${1:object});",
        "doc": "Displays tabular data as a table.",
        "grammar": "lsp",
        "label": "consoleTable",
        "matches": [
          "clt"
        ],
        "opts": []
      },
      {
        "content": "console.time(${1:object});",
        "doc": "Sets starting point for execution time measurement",
        "grammar": "lsp",
        "label": "consoleTime",
        "matches": [
          "cti"
        ],
        "opts": []
      },
      {
        "content": "console.timeEnd(${1:object});",
        "doc": "Sets end point for execution time measurement",
        "grammar": "lsp",
        "label": "consoleTimeEnd",
        "matches": [
          "cte"
        ],
        "opts": []
      },
      {
        "content": "import React, { Component } from 'react';\n\nclass ${1:${TM_FILENAME_BASE}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t);\n\t}\n}\n\nexport default ${1:${TM_FILENAME_BASE}};",
        "doc": "Creates a React component class with ES6 module system",
        "grammar": "lsp",
        "label": "reactClassComponent",
        "matches": [
          "rcc"
        ],
        "opts": []
      },
      {
        "content": "import React, { Component } from 'react';\nimport { connect } from 'react-redux';\n\nfunction mapStateToProps(state) {\n\treturn {\n\n\t};\n}\n\nclass ${1:${TM_FILENAME_BASE}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t);\n\t}\n}\n\nexport default connect(\n\tmapStateToProps,\n)(${1:${TM_FILENAME_BASE}});",
        "doc": "Creates a React component class connected to redux",
        "grammar": "lsp",
        "label": "reactReduxComponent",
        "matches": [
          "rrc"
        ],
        "opts": []
      },
      {
        "content": "import React, { Component } from 'react';\nimport { connect } from 'react-redux';\n\nfunction mapStateToProps(state) {\n\treturn {\n\n\t};\n}\n\nfunction mapDispatchToProps(dispatch) {\n\treturn {\n\n\t};\n}\n\nclass ${1:${TM_FILENAME_BASE}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t);\n\t}\n}\n\nexport default connect(\n\tmapStateToProps,\n)(${1:${TM_FILENAME_BASE}});",
        "doc": "Creates a React component class connected to redux with dispatch",
        "grammar": "lsp",
        "label": "reactReduxDispatchComponent",
        "matches": [
          "rrdc"
        ],
        "opts": []
      },
      {
        "content": "class ${1:${TM_FILENAME_BASE}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t);\n\t}\n}\n",
        "doc": "Creates a React component class with ES6 module system",
        "grammar": "lsp",
        "label": "reactJustClassComponent",
        "matches": [
          "rcjc"
        ],
        "opts": []
      },
      {
        "content": "import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nclass ${1:${TM_FILENAME_BASE}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t);\n\t}\n}\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\n};\n\nexport default ${1:${TM_FILENAME_BASE}};",
        "doc": "Creates a React component class with PropTypes and ES6 module system",
        "grammar": "lsp",
        "label": "reactClassComponentPropTypes",
        "matches": [
          "rccp"
        ],
        "opts": []
      },
      {
        "content": "import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nclass ${1:${TM_FILENAME_BASE}} extends Component {\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tthis.state = {\n\t\t\t\n\t\t}\n\t}\n\n\tstatic getDerivedStateFromProps() {\n\t\treturn null\n\t}\n\n\tcomponentDidMount() {\n\t\t\n\t}\n\n\t// shouldComponentUpdate(nextProps, nextState) {}\n\n\tgetSnapshotBeforeUpdate(prevProps, prevState) {\n\t\treturn null\n\t}\n\n\tcomponentDidUpdate(prevProps, prevState, snapshot) {\n\t\t\n\t}\n\n\tcomponentWillUnmount() {\n\t\t\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t\n\t\t\t</div>\n\t\t);\n\t}\n}\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\t\n};\n\nexport default ${1:${TM_FILENAME_BASE}};",
        "doc": "Creates a React component class with PropTypes and all lifecycle methods and ES6 module system",
        "grammar": "lsp",
        "label": "reactClassComponentWithMethods",
        "matches": [
          "rcfc"
        ],
        "opts": []
      },
      {
        "content": "class ${1:${TM_FILENAME_BASE}} extends React.Component {\n\tconstructor(props) {\n\t\tsuper(props);\n\n\t\tthis.state = {};\n\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t);\n\t}\n}\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\n};\n\nexport default ${1:${TM_FILENAME_BASE}};",
        "doc": "Creates a React component class with constructor, empty state, proptypes and export in ES6 module system without imports. (Mostly used when React, Proptypes are provided by webpack provide plugin)",
        "grammar": "lsp",
        "label": "reactWithWebpackDefaults",
        "matches": [
          "rwwd"
        ],
        "opts": []
      },
      {
        "content": "import React, { PureComponent } from 'react';\nimport PropTypes from 'prop-types';\n\nclass ${1:${TM_FILENAME_BASE}} extends PureComponent {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t);\n\t}\n}\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\n};\n\nexport default ${1:${TM_FILENAME_BASE}};",
        "doc": "Creates a React pure component class with PropTypes and ES6 module system",
        "grammar": "lsp",
        "label": "reactPureComponent",
        "matches": [
          "rpc"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react';\n\nconst ${1:${TM_FILENAME_BASE}} = () => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t);\n};\n\nexport default ${1:${TM_FILENAME_BASE}};",
        "doc": "Creates a stateless React component without PropTypes and ES6 module system",
        "grammar": "lsp",
        "label": "reactStateless",
        "matches": [
          "rsc"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react';\nimport PropTypes from 'prop-types';\n\nconst ${1:${TM_FILENAME_BASE}} = props => {\n\treturn (\n\t\t<div>\n\t\t\t\n\t\t</div>\n\t);\n};\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\t$0\n};\n\nexport default ${1:${TM_FILENAME_BASE}};",
        "doc": "Creates a stateless React component with PropTypes and ES6 module system",
        "grammar": "lsp",
        "label": "reactStatelessProps",
        "matches": [
          "rscp"
        ],
        "opts": []
      },
      {
        "content": "import React,{ useState } from 'react';\nimport PropTypes from 'prop-types';\n\nconst ${1:${TM_FILENAME_BASE}} = props => {\n\treturn (\n\t\t<div>\n\t\t\t\n\t\t</div>\n\t);\n};\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\t$0\n};\n\nexport default ${1:${TM_FILENAME_BASE}};",
        "doc": "Creates a stateless React component with PropTypes and ES6 module system",
        "grammar": "lsp",
        "label": "reactHookProps",
        "matches": [
          "rhc"
        ],
        "opts": []
      },
      {
        "content": "import React, { memo } from 'react';\n\nconst ${1:${TM_FILENAME_BASE}} = memo(() => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t);\n});\n\nexport default ${1:${TM_FILENAME_BASE}};",
        "doc": "Creates a memoized stateless React component without PropTypes and ES6 module system",
        "grammar": "lsp",
        "label": "reactMemo",
        "matches": [
          "rscm"
        ],
        "opts": []
      },
      {
        "content": "import React, { memo } from 'react';\nimport PropTypes from 'prop-types';\n\nconst ${1:${TM_FILENAME_BASE}} = memo((props) => {\n\treturn (\n\t\t<div>\n\t\t\t\n\t\t</div>\n\t);\n});\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\t$0\n};\n\nexport default ${1:${TM_FILENAME_BASE}};",
        "doc": "Creates a memoized stateless React component with PropTypes and ES6 module system",
        "grammar": "lsp",
        "label": "reactMemoProps",
        "matches": [
          "rscpm"
        ],
        "opts": []
      },
      {
        "content": "// @flow \nimport * as React from 'react';\ntype Props = {\n\t$0\n};\nexport const ${1:${TM_FILENAME_BASE}} = (props: Props) => {\n\treturn (\n\t\t<div>\n\t\t\t\n\t\t</div>\n\t);\n};",
        "doc": "Creates a stateless React component with FlowTypes and ES6 module system",
        "grammar": "lsp",
        "label": "flowStatelessComponent",
        "matches": [
          "fsc"
        ],
        "opts": []
      },
      {
        "content": "// @flow\nimport * as React from 'react';\ntype Props = {\n  $0\n};\nexport function ${1:${TM_FILENAME_BASE}}(props: Props) {\n  return (\n    <div>\n      \n    </div>\n  );\n};",
        "doc": "Creates a stateless React component as a named function with FlowTypes",
        "grammar": "lsp",
        "label": "flowStatelessFunction",
        "matches": [
          "fsf"
        ],
        "opts": []
      },
      {
        "content": "// @flow\nimport * as React from 'react';\ntype Props = {\n  $0\n};\ntype State = {\n  $1\n};\nexport class ${2:${TM_FILENAME_BASE}} extends React.Component<Props, State>{\n  render() {\n    return (\n      <div>\n        \n      </div>\n    );\n  };\n};",
        "doc": "Creates a React component class with FlowTypes",
        "grammar": "lsp",
        "label": "flowClassComponent",
        "matches": [
          "fcc"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react';\n\nfunction ${1:${TM_FILENAME_BASE}}(props) {\n\treturn (\n\t\t<div>\n\t\t\t\n\t\t</div>\n\t);\n}\n\nexport default ${1:${TM_FILENAME_BASE}};",
        "doc": "Creates a stateless React component as a named function without PropTypes",
        "grammar": "lsp",
        "label": "reactStatelessFunction",
        "matches": [
          "rsf"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react';\nimport PropTypes from 'prop-types';\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\t$0\n};\n\nfunction ${1:${TM_FILENAME_BASE}}(props) {\n\treturn (\n\t\t<div>\n\t\t\t\n\t\t</div>\n\t);\n}\n\nexport default ${1:${TM_FILENAME_BASE}};",
        "doc": "Creates a stateless React component as a named function with PropTypes",
        "grammar": "lsp",
        "label": "reactStatelessFunctionProps",
        "matches": [
          "rsfp"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react';\n\nconst ${1:${TM_FILENAME_BASE}} = (props) => (\n\t\t\t$0\n\t);\n\nexport default ${1:${TM_FILENAME_BASE}};",
        "doc": "Creates a stateless React component without PropTypes and ES6 module system but with Implicit Return and props",
        "grammar": "lsp",
        "label": "reactStatelessImplicitReturn",
        "matches": [
          "rsi"
        ],
        "opts": []
      },
      {
        "content": "constructor(props) {\n\tsuper(props);\n\t$0\n}\n",
        "doc": "Adds a default constructor for the class that contains props as arguments",
        "grammar": "lsp",
        "label": "classConstructor",
        "matches": [
          "con"
        ],
        "opts": []
      },
      {
        "content": "constructor(props, context) {\n\tsuper(props, context);\n\t$0\n}\n",
        "doc": "Adds a default constructor for the class that contains props and context as arguments",
        "grammar": "lsp",
        "label": "classConstructorContext",
        "matches": [
          "conc"
        ],
        "opts": []
      },
      {
        "content": "this.state = {\n\t$1\n};",
        "doc": "Creates empty state object. To be used in a constructor.",
        "grammar": "lsp",
        "label": "emptyState",
        "matches": [
          "est"
        ],
        "opts": []
      },
      {
        "content": "\ncomponentWillMount() {\n\t$0\n}\n",
        "doc": "Invoked once, both on the client and server, immediately before the initial rendering occurs",
        "grammar": "lsp",
        "label": "componentWillMount",
        "matches": [
          "cwm"
        ],
        "opts": []
      },
      {
        "content": "componentDidMount() {\n\t$0\n}\n",
        "doc": "Invoked once, only on the client (not on the server), immediately after the initial rendering occurs.",
        "grammar": "lsp",
        "label": "componentDidMount",
        "matches": [
          "cdm"
        ],
        "opts": []
      },
      {
        "content": "componentWillReceiveProps(nextProps) {\n\t$0\n}\n",
        "doc": "Invoked when a component is receiving new props. This method is not called for the initial render. [DEPRECATION NOTE]: This method is deprecated in React 16.3",
        "grammar": "lsp",
        "label": "componentWillReceiveProps",
        "matches": [
          "cwr"
        ],
        "opts": []
      },
      {
        "content": "shouldComponentUpdate(nextProps, nextState) {\n\t$0\n}\n",
        "doc": "Invoked before rendering when new props or state are being received. ",
        "grammar": "lsp",
        "label": "shouldComponentUpdate",
        "matches": [
          "scu"
        ],
        "opts": []
      },
      {
        "content": "componentWillUpdate(nextProps, nextState) {\n\t$0\n}\n",
        "doc": "Invoked immediately before rendering when new props or state are being received. [DEPRECATION NOTE]: This method is deprecated in React 16.3",
        "grammar": "lsp",
        "label": "componentWillUpdate",
        "matches": [
          "cwup"
        ],
        "opts": []
      },
      {
        "content": "componentDidUpdate(prevProps, prevState) {\n\t$0\n}\n",
        "doc": "Invoked immediately after the component's updates are flushed to the DOM.",
        "grammar": "lsp",
        "label": "componentDidUpdate",
        "matches": [
          "cdup"
        ],
        "opts": []
      },
      {
        "content": "componentWillUnmount() {\n\t$0\n}\n",
        "doc": "Invoked immediately before a component is unmounted from the DOM.",
        "grammar": "lsp",
        "label": "componentWillUnmount",
        "matches": [
          "cwun"
        ],
        "opts": []
      },
      {
        "content": "render() {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t);\n}",
        "doc": "When called, it should examine this.props and this.state and return a single child element.",
        "grammar": "lsp",
        "label": "componentRender",
        "matches": [
          "ren"
        ],
        "opts": []
      },
      {
        "content": "this.setState($0);",
        "doc": "Performs a shallow merge of nextState into current state",
        "grammar": "lsp",
        "label": "componentSetStateObject",
        "matches": [
          "sst"
        ],
        "opts": []
      },
      {
        "content": "this.setState((state, props) => { return { $0 }});\n",
        "doc": "Performs a shallow merge of nextState into current state",
        "grammar": "lsp",
        "label": "componentSetStateFunc",
        "matches": [
          "ssf"
        ],
        "opts": []
      },
      {
        "content": "this.props.$0",
        "doc": "Access component's props",
        "grammar": "lsp",
        "label": "componentProps",
        "matches": [
          "props"
        ],
        "opts": []
      },
      {
        "content": "this.state.$0",
        "doc": "Access component's state",
        "grammar": "lsp",
        "label": "componentState",
        "matches": [
          "state"
        ],
        "opts": []
      },
      {
        "content": "this.$1 = this.$1.bind(this);$0",
        "doc": "Binds the this of a method. To be used inside a constructor",
        "grammar": "lsp",
        "label": "bindThis",
        "matches": [
          "bnd"
        ],
        "opts": []
      },
      {
        "content": "${1:$TM_FILENAME_BASE}.propTypes = {\n\t$2\n};",
        "doc": "Creates empty propTypes declaration",
        "grammar": "lsp",
        "label": "propTypes",
        "matches": [
          "rpt"
        ],
        "opts": []
      },
      {
        "content": "${1:$TM_FILENAME_BASE}.defaultProps = {\n\t$2\n};",
        "doc": "Creates empty defaultProps declaration",
        "grammar": "lsp",
        "label": "defaultProps",
        "matches": [
          "rdp"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.array,",
        "doc": "Array prop type",
        "grammar": "lsp",
        "label": "propTypeArray",
        "matches": [
          "pta"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.array.isRequired,",
        "doc": "Array prop type required",
        "grammar": "lsp",
        "label": "propTypeArrayRequired",
        "matches": [
          "ptar"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.bool,",
        "doc": "Bool prop type",
        "grammar": "lsp",
        "label": "propTypeBool",
        "matches": [
          "ptb"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.bool.isRequired,",
        "doc": "Bool prop type required",
        "grammar": "lsp",
        "label": "propTypeBoolRequired",
        "matches": [
          "ptbr"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.func,",
        "doc": "Func prop type",
        "grammar": "lsp",
        "label": "propTypeFunc",
        "matches": [
          "ptf"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.func.isRequired,",
        "doc": "Func prop type required",
        "grammar": "lsp",
        "label": "propTypeFuncRequired",
        "matches": [
          "ptfr"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.number,",
        "doc": "Number prop type",
        "grammar": "lsp",
        "label": "propTypeNumber",
        "matches": [
          "ptn"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.number.isRequired,",
        "doc": "Number prop type required",
        "grammar": "lsp",
        "label": "propTypeNumberRequired",
        "matches": [
          "ptnr"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.object,",
        "doc": "Object prop type",
        "grammar": "lsp",
        "label": "propTypeObject",
        "matches": [
          "pto"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.object.isRequired,",
        "doc": "Object prop type required",
        "grammar": "lsp",
        "label": "propTypeObjectRequired",
        "matches": [
          "ptor"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.string,",
        "doc": "String prop type",
        "grammar": "lsp",
        "label": "propTypeString",
        "matches": [
          "pts"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.string.isRequired,",
        "doc": "String prop type required",
        "grammar": "lsp",
        "label": "propTypeStringRequired",
        "matches": [
          "ptsr"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.symbol,",
        "doc": "Symbol prop type",
        "grammar": "lsp",
        "label": "propTypeSymbol",
        "matches": [
          "ptsm"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.symbol.isRequired,",
        "doc": "Symbol prop type required",
        "grammar": "lsp",
        "label": "propTypeSymbolRequired",
        "matches": [
          "ptsmr"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.any,",
        "doc": "Any prop type",
        "grammar": "lsp",
        "label": "propTypeAny",
        "matches": [
          "ptan"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.any.isRequired,",
        "doc": "Any prop type required",
        "grammar": "lsp",
        "label": "propTypeAnyRequired",
        "matches": [
          "ptanr"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.node,",
        "doc": "Anything that can be rendered: numbers, strings, elements or an array",
        "grammar": "lsp",
        "label": "propTypeNode",
        "matches": [
          "ptnd"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.node.isRequired,",
        "doc": "Anything that can be rendered: numbers, strings, elements or an array required",
        "grammar": "lsp",
        "label": "propTypeNodeRequired",
        "matches": [
          "ptndr"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.element,",
        "doc": "React element prop type",
        "grammar": "lsp",
        "label": "propTypeElement",
        "matches": [
          "ptel"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.element.isRequired,",
        "doc": "React element prop type required",
        "grammar": "lsp",
        "label": "propTypeElementRequired",
        "matches": [
          "ptelr"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.instanceOf($0),",
        "doc": "Is an instance of a class prop type",
        "grammar": "lsp",
        "label": "propTypeInstanceOf",
        "matches": [
          "pti"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.instanceOf($0).isRequired,",
        "doc": "Is an instance of a class prop type required",
        "grammar": "lsp",
        "label": "propTypeInstanceOfRequired",
        "matches": [
          "ptir"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.oneOf(['$0']),",
        "doc": "Prop type limited to specific values by treating it as an enum",
        "grammar": "lsp",
        "label": "propTypeEnum",
        "matches": [
          "pte"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.oneOf(['$0']).isRequired,",
        "doc": "Prop type limited to specific values by treating it as an enum required",
        "grammar": "lsp",
        "label": "propTypeEnumRequired",
        "matches": [
          "pter"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.oneOfType([\n\t$0\n]),",
        "doc": "An object that could be one of many types",
        "grammar": "lsp",
        "label": "propTypeOneOfType",
        "matches": [
          "ptet"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.oneOfType([\n\t$0\n]).isRequired,",
        "doc": "An object that could be one of many types required",
        "grammar": "lsp",
        "label": "propTypeOneOfTypeRequired",
        "matches": [
          "ptetr"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.arrayOf($0),",
        "doc": "An array of a certain type",
        "grammar": "lsp",
        "label": "propTypeArrayOf",
        "matches": [
          "ptao"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.arrayOf($0).isRequired,",
        "doc": "An array of a certain type required",
        "grammar": "lsp",
        "label": "propTypeArrayOfRequired",
        "matches": [
          "ptaor"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.objectOf($0),",
        "doc": "An object with property values of a certain type",
        "grammar": "lsp",
        "label": "propTypeObjectOf",
        "matches": [
          "ptoo"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.objectOf($0).isRequired,",
        "doc": "An object with property values of a certain type required",
        "grammar": "lsp",
        "label": "propTypeObjectOfRequired",
        "matches": [
          "ptoor"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.objectOf(PropTypes.shape($0)),",
        "doc": "An object whose keys are known ahead of time",
        "grammar": "lsp",
        "label": "propTypeObjectOfShape",
        "matches": [
          "ptoos"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.objectOf(PropTypes.shape($0)).isRequired,",
        "doc": "An object whose keys are known ahead of time required",
        "grammar": "lsp",
        "label": "propTypeObjectOfShapeRequired",
        "matches": [
          "ptoosr"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.shape({\n\t$0\n}),",
        "doc": "An object taking on a particular shape",
        "grammar": "lsp",
        "label": "propTypeShape",
        "matches": [
          "ptsh"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.shape({\n\t$0\n}).isRequired,",
        "doc": "An object taking on a particular shape required",
        "grammar": "lsp",
        "label": "propTypeShapeRequired",
        "matches": [
          "ptshr"
        ],
        "opts": []
      },
      {
        "content": "getSnapshotBeforeUpdate(prevProps, prevState) {\n\t$0\n}\n",
        "doc": "Invoked right before the most recently rendered output is committed to e.g. the DOM. It enables your component to capture current values",
        "grammar": "lsp",
        "label": "getSnapshotBeforeUpdate",
        "matches": [
          "gsbu"
        ],
        "opts": []
      },
      {
        "content": "static getDerivedStateFromProps(nextProps, prevState) {\n\t$0\n}\n",
        "doc": "Invoked after a component is instantiated as well as when it receives new props.",
        "grammar": "lsp",
        "label": "getDerivedStateFromProps",
        "matches": [
          "gdsfp"
        ],
        "opts": []
      },
      {
        "content": "componentDidCatch(error, info) {\n\t$0\n}\n",
        "doc": "Error boundaries catch errors during rendering, in lifecycle methods, and in constructors of the whole tree below them.",
        "grammar": "lsp",
        "label": "componentDidCatch",
        "matches": [
          "cdc"
        ],
        "opts": []
      },
      {
        "content": "function mapDispatchToProps(dispatch) {\n\treturn {\n\t}\n\n}",
        "doc": "Adds the redux mapDispatchToProps function",
        "grammar": "lsp",
        "label": "dispatchRedux",
        "matches": [
          "disp"
        ],
        "opts": []
      },
      {
        "content": "useEffect(() => {\n$0\n})",
        "doc": "Adds use effect",
        "grammar": "lsp",
        "label": "useEffect",
        "matches": [
          "usf"
        ],
        "opts": []
      },
      {
        "content": "useEffect(() => {\n$0 return () => {\n$0\n\t}\n})",
        "doc": "Adds use effect",
        "grammar": "lsp",
        "label": "useEffectUnMount",
        "matches": [
          "usfu"
        ],
        "opts": []
      },
      {
        "content": "useEffect(() => {\n$0\n},[])",
        "doc": "Adds use effect",
        "grammar": "lsp",
        "label": "useEffectDidMount",
        "matches": [
          "usfd"
        ],
        "opts": []
      },
      {
        "content": "import ${2:moduleName} from '${1:module}'$0",
        "doc": null,
        "grammar": "lsp",
        "label": "import",
        "matches": [
          "imp"
        ],
        "opts": []
      },
      {
        "content": "import '${1:module}'$0",
        "doc": null,
        "grammar": "lsp",
        "label": "importNoModuleName",
        "matches": [
          "imn"
        ],
        "opts": []
      },
      {
        "content": "import { $2 } from '${1:module}'$0",
        "doc": null,
        "grammar": "lsp",
        "label": "importDestructing",
        "matches": [
          "imd"
        ],
        "opts": []
      },
      {
        "content": "import * as ${2:alias} from '${1:module}'$0",
        "doc": null,
        "grammar": "lsp",
        "label": "importEverything",
        "matches": [
          "ime"
        ],
        "opts": []
      },
      {
        "content": "import { ${2:originalName} as ${3:alias} } from '${1:module}'$0",
        "doc": null,
        "grammar": "lsp",
        "label": "importAs",
        "matches": [
          "ima"
        ],
        "opts": []
      },
      {
        "content": "export default $1$0",
        "doc": null,
        "grammar": "lsp",
        "label": "exportDefault",
        "matches": [
          "exp"
        ],
        "opts": []
      },
      {
        "content": "export { $2 } from '${1:module}'$0",
        "doc": null,
        "grammar": "lsp",
        "label": "exportDestructing",
        "matches": [
          "exd"
        ],
        "opts": []
      },
      {
        "content": "export { ${2:originalName} as ${3:alias} } from '${1:module}'$0",
        "doc": null,
        "grammar": "lsp",
        "label": "exportAs",
        "matches": [
          "exa"
        ],
        "opts": []
      },
      {
        "content": "export const ${1:functionName} = (${2:params}) => {\n\t$0\n}\n",
        "doc": "Export named function in ES7 syntax",
        "grammar": "lsp",
        "label": "exportNamedFunction",
        "matches": [
          "enf"
        ],
        "opts": []
      },
      {
        "content": "export default (${1:params}) => {\n\t$0\n}\n",
        "doc": "Export default function in ES7 syntax",
        "grammar": "lsp",
        "label": "exportDefaultFunction",
        "matches": [
          "edf"
        ],
        "opts": []
      },
      {
        "content": "${1:methodName} = (${2:params}) => {\n\t${0}\n}\n",
        "doc": "Creates a method inside a class in ES7 syntax",
        "grammar": "lsp",
        "label": "method",
        "matches": [
          "met"
        ],
        "opts": []
      },
      {
        "content": "get ${1:propertyName}() {\n\treturn this.${0}\n}\n",
        "doc": "Creates a getter property inside a class in ES7 syntax",
        "grammar": "lsp",
        "label": "propertyGet",
        "matches": [
          "pge"
        ],
        "opts": []
      },
      {
        "content": "set ${1:propertyName}(${2:value}) {\n\t${0}\n}\n",
        "doc": "Creates a setter property inside a class in ES7 syntax",
        "grammar": "lsp",
        "label": "propertySet",
        "matches": [
          "pse"
        ],
        "opts": []
      },
      {
        "content": "${1:array}.forEach(${2:currentItem} => {\n\t${0}\n})\n",
        "doc": "Creates a forEach statement in ES7 syntax",
        "grammar": "lsp",
        "label": "forEach",
        "matches": [
          "fre"
        ],
        "opts": []
      },
      {
        "content": "for(let ${1:item} of ${2:object}) {\n\t${0}\n}\n",
        "doc": "Iterating over property names of iterable objects",
        "grammar": "lsp",
        "label": "forOf",
        "matches": [
          "fof"
        ],
        "opts": []
      },
      {
        "content": "for(let ${1:item} in ${2:object}) {\n\t${0}\n}\n",
        "doc": "Iterating over property values of iterable objects",
        "grammar": "lsp",
        "label": "forIn",
        "matches": [
          "fin"
        ],
        "opts": []
      },
      {
        "content": "(${1:params}) => {\n\t${2}\n}",
        "doc": "Creates an anonymous function in ES7 syntax",
        "grammar": "lsp",
        "label": "anonymousFunction",
        "matches": [
          "anfn"
        ],
        "opts": []
      },
      {
        "content": "const ${1:name} = (${2:params}) => {\n\t${3}\n}\n",
        "doc": "Creates a named function in ES7 syntax",
        "grammar": "lsp",
        "label": "namedFunction",
        "matches": [
          "nfn"
        ],
        "opts": []
      },
      {
        "content": "const {${1:propertyName}} = ${2:objectToDestruct}",
        "doc": "Creates and assigns a local variable using object destructing",
        "grammar": "lsp",
        "label": "destructingObject",
        "matches": [
          "dob"
        ],
        "opts": []
      },
      {
        "content": "const [${1:propertyName}] = ${2:arrayToDestruct}",
        "doc": "Creates and assigns a local variable using array destructing",
        "grammar": "lsp",
        "label": "destructingArray",
        "matches": [
          "dar"
        ],
        "opts": []
      },
      {
        "content": "setInterval(() => {\n\t${2}\n}, ${0:intervalInms})\n",
        "doc": "Executes the given function at specified intervals in ES7 syntax",
        "grammar": "lsp",
        "label": "setInterval",
        "matches": [
          "sti"
        ],
        "opts": []
      },
      {
        "content": "setTimeout(() => {\n\t${2}\n}, ${1:delayInms})\n",
        "doc": "Executes the given function after the specified delay in ES7 syntax",
        "grammar": "lsp",
        "label": "setTimeOut",
        "matches": [
          "sto"
        ],
        "opts": []
      },
      {
        "content": "return new Promise((resolve, reject) => {\n\t${1}\n})\n",
        "doc": "Creates and returns a new Promise in the standard ES7 syntax",
        "grammar": "lsp",
        "label": "promise",
        "matches": [
          "prom"
        ],
        "opts": []
      },
      {
        "content": "console.assert(${1:expression}, ${2:object})",
        "doc": "If the specified expression is false, the message is written to the console along with a stack trace",
        "grammar": "lsp",
        "label": "consoleAssert",
        "matches": [
          "cas"
        ],
        "opts": []
      },
      {
        "content": "console.clear()",
        "doc": "Clears the console",
        "grammar": "lsp",
        "label": "consoleClear",
        "matches": [
          "ccl"
        ],
        "opts": []
      },
      {
        "content": "console.count(${1:label})",
        "doc": "Writes the the number of times that count() has been invoked at the same line and with the same label",
        "grammar": "lsp",
        "label": "consoleCount",
        "matches": [
          "cco"
        ],
        "opts": []
      },
      {
        "content": "console.dir(${1:object})",
        "doc": "Prints a JavaScript representation of the specified object",
        "grammar": "lsp",
        "label": "consoleDir",
        "matches": [
          "cdi"
        ],
        "opts": []
      },
      {
        "content": "console.error(${1:object})",
        "doc": "Displays a message in the console and also includes a stack trace from where the method was called",
        "grammar": "lsp",
        "label": "consoleError",
        "matches": [
          "cer"
        ],
        "opts": []
      },
      {
        "content": "console.group(\"${1:label}\")",
        "doc": "Groups and indents all following output by an additional level, until console.groupEnd() is called.",
        "grammar": "lsp",
        "label": "consoleGroup",
        "matches": [
          "cgr"
        ],
        "opts": []
      },
      {
        "content": "console.groupEnd()",
        "doc": "Closes out the corresponding console.group().",
        "grammar": "lsp",
        "label": "consoleGroupEnd",
        "matches": [
          "cge"
        ],
        "opts": []
      },
      {
        "content": "console.log(${1:object})",
        "doc": "Displays a message in the console",
        "grammar": "lsp",
        "label": "consoleLog",
        "matches": [
          "clg"
        ],
        "opts": []
      },
      {
        "content": "console.trace(${1:object})",
        "doc": "Prints a stack trace from the point where the method was called",
        "grammar": "lsp",
        "label": "consoleTrace",
        "matches": [
          "ctr"
        ],
        "opts": []
      },
      {
        "content": "console.log(`${1:object}`, ${1:object})",
        "doc": "Logs property with name.",
        "grammar": "lsp",
        "label": "consoleLogObject",
        "matches": [
          "clo"
        ],
        "opts": []
      },
      {
        "content": "console.time(`${1:object}`)",
        "doc": "Console time wrapper",
        "grammar": "lsp",
        "label": "consoleTime",
        "matches": [
          "ctm"
        ],
        "opts": []
      },
      {
        "content": "console.timeEnd(`${1:object}`)",
        "doc": "Console time end wrapper",
        "grammar": "lsp",
        "label": "consoleTimeEnd",
        "matches": [
          "cte"
        ],
        "opts": []
      },
      {
        "content": "console.warn(${1:object})",
        "doc": "Displays a message in the console but also displays a yellow warning icon along with the logged message",
        "grammar": "lsp",
        "label": "consoleWarn",
        "matches": [
          "cwa"
        ],
        "opts": []
      },
      {
        "content": "console.info(${1:object})",
        "doc": "Displays a message in the console but also displays a blue information icon along with the logged message",
        "grammar": "lsp",
        "label": "consoleInfo",
        "matches": [
          "cin"
        ],
        "opts": []
      },
      {
        "content": "const { $1 } = this.props",
        "doc": "Creates and assigns a local variable using props destructing",
        "grammar": "lsp",
        "label": "destructProps",
        "matches": [
          "cp"
        ],
        "opts": []
      },
      {
        "content": "const { $1 } = this.state",
        "doc": "Creates and assigns a local variable using state destructing",
        "grammar": "lsp",
        "label": "destructState",
        "matches": [
          "cs"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react'\n",
        "doc": null,
        "grammar": "lsp",
        "label": "import React",
        "matches": [
          "imr"
        ],
        "opts": []
      },
      {
        "content": "import ReactDOM from 'react-dom'\n",
        "doc": null,
        "grammar": "lsp",
        "label": "import ReactDOM",
        "matches": [
          "imrd"
        ],
        "opts": []
      },
      {
        "content": "import React, { Component } from 'react'\n",
        "doc": null,
        "grammar": "lsp",
        "label": "import React, { Component }",
        "matches": [
          "imrc"
        ],
        "opts": []
      },
      {
        "content": "import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\n",
        "doc": null,
        "grammar": "lsp",
        "label": "import React, { Component } & PropTypes",
        "matches": [
          "imrcp"
        ],
        "opts": []
      },
      {
        "content": "import React, { PureComponent } from 'react'\n",
        "doc": null,
        "grammar": "lsp",
        "label": "import React, { PureComponent }",
        "matches": [
          "imrpc"
        ],
        "opts": []
      },
      {
        "content": "import React, { PureComponent } from 'react'\nimport PropTypes from 'prop-types'\n",
        "doc": null,
        "grammar": "lsp",
        "label": "import React, { PureComponent } & PropTypes",
        "matches": [
          "imrpcp"
        ],
        "opts": []
      },
      {
        "content": "import React, { memo } from 'react'\n",
        "doc": null,
        "grammar": "lsp",
        "label": "import React, { memo }",
        "matches": [
          "imrm"
        ],
        "opts": []
      },
      {
        "content": "import React, { memo } from 'react'\nimport PropTypes from 'prop-types'\n",
        "doc": null,
        "grammar": "lsp",
        "label": "import React, { memo } & PropTypes",
        "matches": [
          "imrmp"
        ],
        "opts": []
      },
      {
        "content": "import React, { useState } from 'react'\n",
        "doc": null,
        "grammar": "lsp",
        "label": "import React, {useState}",
        "matches": [
          "imrs"
        ],
        "opts": []
      },
      {
        "content": "import React, { useEffect } from 'react'\n",
        "doc": null,
        "grammar": "lsp",
        "label": "import React, {useEffect}",
        "matches": [
          "imre"
        ],
        "opts": []
      },
      {
        "content": "import React, { useRef } from 'react'\n",
        "doc": null,
        "grammar": "lsp",
        "label": "import React, {useRef}",
        "matches": [
          "imrr"
        ],
        "opts": []
      },
      {
        "content": "import React, { useState, useEffect } from 'react'\n",
        "doc": null,
        "grammar": "lsp",
        "label": "import React, {useState, useEffect}",
        "matches": [
          "imrse"
        ],
        "opts": []
      },
      {
        "content": "import PropTypes from 'prop-types'\n",
        "doc": null,
        "grammar": "lsp",
        "label": "import PropTypes",
        "matches": [
          "impt"
        ],
        "opts": []
      },
      {
        "content": "import { BrowserRouter as Router, Route, NavLink } from 'react-router-dom'\n",
        "doc": null,
        "grammar": "lsp",
        "label": "import React Router",
        "matches": [
          "imrr"
        ],
        "opts": []
      },
      {
        "content": "import { BrowserRouter as Router } from 'react-router-dom'\n",
        "doc": null,
        "grammar": "lsp",
        "label": "import React Browser Router",
        "matches": [
          "imbr"
        ],
        "opts": []
      },
      {
        "content": "import { Route } from 'react-router-dom'\n",
        "doc": null,
        "grammar": "lsp",
        "label": "import React Browser Router - Route",
        "matches": [
          "imbrr"
        ],
        "opts": []
      },
      {
        "content": "import { Route, Switch, NavLink, Link } from 'react-router-dom'\n",
        "doc": null,
        "grammar": "lsp",
        "label": "import React Browser Router - Route Combo",
        "matches": [
          "imbrc"
        ],
        "opts": []
      },
      {
        "content": "import { Switch } from 'react-router-dom'\n",
        "doc": null,
        "grammar": "lsp",
        "label": "import React Browser Router - Switch",
        "matches": [
          "imbrs"
        ],
        "opts": []
      },
      {
        "content": "import { Link } from 'react-router-dom'\n",
        "doc": null,
        "grammar": "lsp",
        "label": "import React Browser Router - Link",
        "matches": [
          "imbrl"
        ],
        "opts": []
      },
      {
        "content": "import { NavLink } from 'react-router-dom'\n",
        "doc": null,
        "grammar": "lsp",
        "label": "import React Browser Router - NavLink",
        "matches": [
          "imbrnl"
        ],
        "opts": []
      },
      {
        "content": "import { connect } from 'react-redux'\n",
        "doc": null,
        "grammar": "lsp",
        "label": "import redux statement",
        "matches": [
          "redux"
        ],
        "opts": []
      },
      {
        "content": "import React, { Component } from 'react'\n\nexport default class ${1:${TM_FILENAME_BASE}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n",
        "doc": "Creates a React component class with ES7 module system",
        "grammar": "lsp",
        "label": "reactClassComponent",
        "matches": [
          "rcc"
        ],
        "opts": []
      },
      {
        "content": "import React, { Component } from 'react'\n\nexport class ${1:${TM_FILENAME_BASE}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "Creates a React component class with ES7 module system",
        "grammar": "lsp",
        "label": "reactClassExportComponent",
        "matches": [
          "rce"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react'\n\nfunction ${1:${TM_FILENAME_BASE}}() {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "Creates a React Functional Component with ES7 module system",
        "grammar": "lsp",
        "label": "reactFunctionalExportComponent",
        "matches": [
          "rfce"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react'\n\nexport default function ${1:${TM_FILENAME_BASE}}() {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n",
        "doc": "Creates a React Functional Component with ES7 module system",
        "grammar": "lsp",
        "label": "reactFunctionalComponent",
        "matches": [
          "rfc"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react'\nimport PropTypes from 'prop-types'\n\nfunction ${1:${TM_FILENAME_BASE}}(props) {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n\n",
        "doc": "Creates a React Functional Component with ES7 module system with PropTypes",
        "grammar": "lsp",
        "label": "reactFunctionalComponentWithPropTypes",
        "matches": [
          "rfcp"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react'\n\nconst ${1:${TM_FILENAME_BASE}} = () => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "Creates a React Arrow Function Component with ES7 module system",
        "grammar": "lsp",
        "label": "reactArrowFunctionExportComponent",
        "matches": [
          "rafce"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react'\n\nexport const ${1:${TM_FILENAME_BASE}} = () => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n",
        "doc": "Creates a React Arrow Function Component with ES7 module system",
        "grammar": "lsp",
        "label": "reactArrowFunctionComponent",
        "matches": [
          "rafc"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react'\nimport PropTypes from 'prop-types'\n\nconst ${1:${TM_FILENAME_BASE}} = props => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "Creates a React Arrow Function Component with ES7 module system with PropTypes",
        "grammar": "lsp",
        "label": "reactArrowFunctionComponentWithPropTypes",
        "matches": [
          "rafcp"
        ],
        "opts": []
      },
      {
        "content": "import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\n\nexport class ${1:${TM_FILENAME_BASE}} extends Component {\n\tstatic propTypes = {\n\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "Creates a React component class with ES7 module system",
        "grammar": "lsp",
        "label": "reactClassExportComponentWithPropTypes",
        "matches": [
          "rcep"
        ],
        "opts": []
      },
      {
        "content": "import React, { PureComponent } from 'react'\n\nexport default class ${1:${TM_FILENAME_BASE}} extends PureComponent {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n",
        "doc": "Creates a React pure component class with ES7 module system",
        "grammar": "lsp",
        "label": "reactClassPureComponent",
        "matches": [
          "rpc"
        ],
        "opts": []
      },
      {
        "content": "import React, { PureComponent } from 'react'\n\nexport class ${1:${TM_FILENAME_BASE}} extends PureComponent {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n\nexport default ${1:$TM_FILENAME_BASE}\n",
        "doc": "Creates a React pure component class with ES7 module system export",
        "grammar": "lsp",
        "label": "reactClassExportPureComponent",
        "matches": [
          "rpce"
        ],
        "opts": []
      },
      {
        "content": "import React, { PureComponent } from 'react'\nimport PropTypes from 'prop-types'\n\nexport default class ${1:${TM_FILENAME_BASE}} extends PureComponent {\n\tstatic propTypes = {\n\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n",
        "doc": "Creates a React component class with ES7 module system",
        "grammar": "lsp",
        "label": "reactClassPureComponentWithPropTypes",
        "matches": [
          "rpcp"
        ],
        "opts": []
      },
      {
        "content": "import React, { memo } from 'react'\n\nexport default memo(function ${1:${TM_FILENAME_BASE}}() {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n})\n",
        "doc": "Creates a React Memo Function Component with ES7 module system",
        "grammar": "lsp",
        "label": "reactFunctionMemoComponent",
        "matches": [
          "rmc"
        ],
        "opts": []
      },
      {
        "content": "import React, { memo } from 'react'\nimport PropTypes from 'prop-types'\n\nconst ${1:${TM_FILENAME_BASE}} = memo(function ${1:${TM_FILENAME_BASE}}(props) {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n})\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "Creates a React Memo Function Component with ES7 module system with PropTypes",
        "grammar": "lsp",
        "label": "reactFunctionMemoComponentWithPropTypes",
        "matches": [
          "rmcp"
        ],
        "opts": []
      },
      {
        "content": "import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\n\nexport default class ${1:${TM_FILENAME_BASE}} extends Component {\n\tstatic propTypes = {\n\t\t${2:prop}: ${3:PropTypes}\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n",
        "doc": "Creates a React component class with PropTypes and ES7 module system",
        "grammar": "lsp",
        "label": "reactClassCompomentPropTypes",
        "matches": [
          "rccp"
        ],
        "opts": []
      },
      {
        "content": "import React, { Component } from 'react'\nimport { connect } from 'react-redux'\n\nexport class ${1:${TM_FILENAME_BASE}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n\nconst mapStateToProps = (state) => ({\n\t\n})\n\nconst mapDispatchToProps = {\n\t\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(${1:${TM_FILENAME_BASE}})\n",
        "doc": "Creates a React component class with connected redux and ES7 module system",
        "grammar": "lsp",
        "label": "reactClassCompomentRedux",
        "matches": [
          "rcredux"
        ],
        "opts": []
      },
      {
        "content": "import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\nimport { connect } from 'react-redux'\n\nexport class ${1:${TM_FILENAME_BASE}} extends Component {\n\tstatic propTypes = {\n\t\t${2:prop}: ${3:PropTypes}\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n\nconst mapStateToProps = (state) => ({\n\t\n})\n\nconst mapDispatchToProps = {\n\t\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(${1:${TM_FILENAME_BASE}})\n",
        "doc": "Creates a React component class with PropTypes with connected redux and ES7 module system",
        "grammar": "lsp",
        "label": "reactClassCompomentReduxPropTypes",
        "matches": [
          "rcreduxp"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react'\nimport { connect } from 'react-redux'\n\nexport const ${1:${TM_FILENAME_BASE}} = (props) => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\nconst mapStateToProps = (state) => ({\n\t\n})\n\nconst mapDispatchToProps = {\n\t\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(${1:${TM_FILENAME_BASE}})\n",
        "doc": "Creates a React functional component with connected redux and ES7 module system",
        "grammar": "lsp",
        "label": "reactFunctionalCompomentRedux",
        "matches": [
          "rfcredux"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react'\nimport PropTypes from 'prop-types'\nimport { connect } from 'react-redux'\n\nexport const ${1:${TM_FILENAME_BASE}} = (props) => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\t${2:props}: ${3:PropTypes}\n}\n\nconst mapStateToProps = (state) => ({\n\t\n})\n\nconst mapDispatchToProps = {\n\t\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(${1:${TM_FILENAME_BASE}})\n",
        "doc": "Creates a React functional component with PropTypes with connected redux and ES7 module system",
        "grammar": "lsp",
        "label": "reactFunctionalCompomentReduxPropTypes",
        "matches": [
          "rfcreduxp"
        ],
        "opts": []
      },
      {
        "content": "const mapStateToProps = (state) => ({\n\t${1}\n})\n\nconst mapDispatchToProps = {\n\t\n}\n",
        "doc": null,
        "grammar": "lsp",
        "label": "mappingToProps",
        "matches": [
          "reduxmap"
        ],
        "opts": []
      },
      {
        "content": "constructor(props) {\n\tsuper(props)\n\n\tthis.state = {\n\t\t $0\n\t}\n}\n",
        "doc": "Adds a default constructor for it('', () => {})the class that contains props as arguments",
        "grammar": "lsp",
        "label": "classConstructor",
        "matches": [
          "rconst"
        ],
        "opts": []
      },
      {
        "content": "state = {\n\t$1\n}\n",
        "doc": "Creates empty state object. To be used in a constructor.",
        "grammar": "lsp",
        "label": "emptyState",
        "matches": [
          "est"
        ],
        "opts": []
      },
      {
        "content": "componentWillMount() {\n\t$0\n}\n",
        "doc": "DEPRECATED!!!. Invoked once, both on the client and server, immediately before the initial rendering occurs",
        "grammar": "lsp",
        "label": "componentWillMount",
        "matches": [
          "cwm"
        ],
        "opts": []
      },
      {
        "content": "componentDidMount() {\n\t$0\n}\n",
        "doc": "Invoked once, only on the client (not on the server), immediately after the initial rendering occurs.",
        "grammar": "lsp",
        "label": "componentDidMount",
        "matches": [
          "cdm"
        ],
        "opts": []
      },
      {
        "content": "componentWillReceiveProps(nextProps) {\n\t$0\n}\n",
        "doc": "DEPRECATED!!!. Invoked when a component is receiving new props. This method is not called for the initial render.",
        "grammar": "lsp",
        "label": "componentWillReceiveProps",
        "matches": [
          "cwr"
        ],
        "opts": []
      },
      {
        "content": "shouldComponentUpdate(nextProps, nextState) {\n\t$0\n}\n",
        "doc": "Invoked before rendering when new props or state are being received. ",
        "grammar": "lsp",
        "label": "shouldComponentUpdate",
        "matches": [
          "scu"
        ],
        "opts": []
      },
      {
        "content": "componentWillUpdate(nextProps, nextState) {\n\t$0\n}\n",
        "doc": "DEPRECATED!!!. Invoked immediately before rendering when new props or state are being received.",
        "grammar": "lsp",
        "label": "componentWillUpdate",
        "matches": [
          "cwup"
        ],
        "opts": []
      },
      {
        "content": "componentDidUpdate(prevProps, prevState) {\n\t$0\n}\n",
        "doc": "Invoked immediately after the component's updates are flushed to the DOM.",
        "grammar": "lsp",
        "label": "componentDidUpdate",
        "matches": [
          "cdup"
        ],
        "opts": []
      },
      {
        "content": "componentWillUnmount() {\n\t$0\n}\n",
        "doc": "Invoked immediately before a component is unmounted from the DOM.",
        "grammar": "lsp",
        "label": "componentWillUnmount",
        "matches": [
          "cwun"
        ],
        "opts": []
      },
      {
        "content": "static getDerivedStateFromProps(props, state) {\n\t${1}\n}",
        "doc": "Invoked right before calling the render method, both on the initial mount and on subsequent updates.",
        "grammar": "lsp",
        "label": "getDerivedStateFromProps",
        "matches": [
          "gdsfp"
        ],
        "opts": []
      },
      {
        "content": "getSnapshotBeforeUpdate = (prevProps, prevState) => {\n\t$0\n}\n",
        "doc": "Called right before mutations are made (e.g. before the DOM is updated)",
        "grammar": "lsp",
        "label": "getSnapshotBeforeUpdate",
        "matches": [
          "gsbu"
        ],
        "opts": []
      },
      {
        "content": "render() {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}",
        "doc": "Basic render.",
        "grammar": "lsp",
        "label": "componentRender",
        "matches": [
          "ren"
        ],
        "opts": []
      },
      {
        "content": "const ${1:contextName} = React.createContext()\n",
        "doc": "Create React context",
        "grammar": "lsp",
        "label": "createContext",
        "matches": [
          "rcontext"
        ],
        "opts": []
      },
      {
        "content": "this.${1:refName}Ref = React.createRef()\n",
        "doc": "Create ref statement used inside constructor",
        "grammar": "lsp",
        "label": "createRef",
        "matches": [
          "cref"
        ],
        "opts": []
      },
      {
        "content": "const ref = React.createRef()\n",
        "doc": "Forward ref statement used inside component",
        "grammar": "lsp",
        "label": "forwardRef",
        "matches": [
          "fref"
        ],
        "opts": []
      },
      {
        "content": "this.setState({$0})",
        "doc": "Performs a shallow merge of nextState into current state",
        "grammar": "lsp",
        "label": "componentSetStateObject",
        "matches": [
          "sst"
        ],
        "opts": []
      },
      {
        "content": "this.setState((state, props) => { return { $0 }})\n",
        "doc": "Performs a shallow merge of nextState into current state",
        "grammar": "lsp",
        "label": "componentSetStateFunc",
        "matches": [
          "ssf"
        ],
        "opts": []
      },
      {
        "content": "this.props.$0",
        "doc": "Access component's props",
        "grammar": "lsp",
        "label": "componentProps",
        "matches": [
          "props"
        ],
        "opts": []
      },
      {
        "content": "this.state.$0",
        "doc": null,
        "grammar": "lsp",
        "label": "componentState",
        "matches": [
          "state"
        ],
        "opts": []
      },
      {
        "content": "this.${1:methodName} = this.${1:methodName}.bind(this)$0",
        "doc": "Binds this to a method",
        "grammar": "lsp",
        "label": "bindThis",
        "matches": [
          "bnd"
        ],
        "opts": []
      },
      {
        "content": "export const ${1:actionName} = (payload) => ({\n\ttype: ${3:type},\n\tpayload\n})\n",
        "doc": null,
        "grammar": "lsp",
        "label": "reduxAction",
        "matches": [
          "rxaction"
        ],
        "opts": []
      },
      {
        "content": "export const ${1:constantName} = '${1:constantName}'",
        "doc": null,
        "grammar": "lsp",
        "label": "reduxConst",
        "matches": [
          "rxconst"
        ],
        "opts": []
      },
      {
        "content": "const initialState = {\n\n}\n\nexport default (state = initialState, { type, payload }) => {\n\tswitch (type) {\n\n\tcase ${1:typeName}:\n\t\treturn { ...state, ...payload }\n\n\tdefault:\n\t\treturn state\n\t}\n}\n",
        "doc": null,
        "grammar": "lsp",
        "label": "reduxReducer",
        "matches": [
          "rxreducer"
        ],
        "opts": []
      },
      {
        "content": "import { createSelector } from 'reselect'\n\nexport const ${1:selectorName} = state => state.${2:selector}\n",
        "doc": null,
        "grammar": "lsp",
        "label": "reduxSelector",
        "matches": [
          "rxselect"
        ],
        "opts": []
      },
      {
        "content": "import { createSlice } from '@reduxjs/toolkit'\n\nconst initialState = {\n\n}\n\nconst ${1:${TM_FILENAME_BASE}} = createSlice({\n\tname: ${2:sliceName},\n\tinitialState,\n\treducers: {\n\t\n\t}\n});\n\nexport const {\n\n} = ${1:${TM_FILENAME_BASE}}.actions\nexport default ${1:${TM_FILENAME_BASE}}.reducer",
        "doc": null,
        "grammar": "lsp",
        "label": "reduxSlice",
        "matches": [
          "rxslice"
        ],
        "opts": []
      },
      {
        "content": "import React, { Component } from 'react'\nimport { Text, View } from 'react-native'\n\nexport default class ${1:${TM_FILENAME_BASE}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<View>\n\t\t\t\t<Text> ${2:textInComponent} </Text>\n\t\t\t</View>\n\t\t)\n\t}\n}\n",
        "doc": null,
        "grammar": "lsp",
        "label": "reactNativeComponent",
        "matches": [
          "rnc"
        ],
        "opts": []
      },
      {
        "content": "import React, { Component } from 'react'\nimport { Text, StyleSheet, View } from 'react-native'\n\nexport default class ${1:${TM_FILENAME_BASE}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<View>\n\t\t\t\t<Text> ${2:textInComponent} </Text>\n\t\t\t</View>\n\t\t)\n\t}\n}\n\nconst styles = StyleSheet.create({})\n",
        "doc": null,
        "grammar": "lsp",
        "label": "reactNativeComponentWithStyles",
        "matches": [
          "rncs"
        ],
        "opts": []
      },
      {
        "content": "import React, { Component } from 'react'\nimport { Text, View } from 'react-native'\n\nexport class ${1:${TM_FILENAME_BASE}} extends Component {\n\trender() {\n\t\treturn (\n\t\t\t<View>\n\t\t\t\t<Text> ${2:textInComponent} </Text>\n\t\t\t</View>\n\t\t)\n\t}\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": null,
        "grammar": "lsp",
        "label": "reactNativeComponentExport",
        "matches": [
          "rnce"
        ],
        "opts": []
      },
      {
        "content": "import React, { PureComponent } from 'react'\nimport { Text, View } from 'react-native'\n\nexport default class ${1:${TM_FILENAME_BASE}} extends PureComponent {\n\trender() {\n\t\treturn (\n\t\t\t<View>\n\t\t\t\t<Text> ${2:textInComponent} </Text>\n\t\t\t</View>\n\t\t)\n\t}\n}\n",
        "doc": null,
        "grammar": "lsp",
        "label": "reactNativePureComponent",
        "matches": [
          "rnpc"
        ],
        "opts": []
      },
      {
        "content": "import React, { PureComponent } from 'react'\nimport { Text, View } from 'react-native'\n\nexport class ${1:${TM_FILENAME_BASE}} extends PureComponent {\n\trender() {\n\t\treturn (\n\t\t\t<View>\n\t\t\t\t<Text> ${2:textInComponent} </Text>\n\t\t\t</View>\n\t\t)\n\t}\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": null,
        "grammar": "lsp",
        "label": "reactNativePureComponentExport",
        "matches": [
          "rnpce"
        ],
        "opts": []
      },
      {
        "content": "import React, { Component } from 'react'\nimport { View, Text } from 'react-native'\nimport PropTypes from 'prop-types'\nimport { connect } from 'react-redux'\n\nexport class ${1:${TM_FILENAME_BASE}} extends Component {\n\tstatic propTypes = {\n\t\t${2:prop}: ${3:PropTypes}\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<View>\n\t\t\t\t<Text> ${2:textInComponent} </Text>\n\t\t\t</View>\n\t\t)\n\t}\n}\n\nconst mapStateToProps = (state) => ({\n\t\n})\n\nconst mapDispatchToProps = {\n\t\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(${1:${TM_FILENAME_BASE}})\n",
        "doc": "Creates a React Native component class with PropTypes with connected redux and ES7 module system",
        "grammar": "lsp",
        "label": "reactNativeClassComponentRedux",
        "matches": [
          "rncredux"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react'\nimport { View, Text } from 'react-native'\n\nconst ${1:${TM_FILENAME_BASE}} = () => {\n\treturn (\n\t\t<View>\n\t\t\t<Text>$0</Text>\n\t\t</View>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": null,
        "grammar": "lsp",
        "label": "reactNativeFunctionalExportComponent",
        "matches": [
          "rnfe"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react'\nimport { StyleSheet, Text, View } from 'react-native'\n\nconst ${1:${TM_FILENAME_BASE}} = () => {\n\treturn (\n\t\t<View>\n\t\t\t<Text>$0</Text>\n\t\t</View>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n\nconst styles = StyleSheet.create({})\n",
        "doc": null,
        "grammar": "lsp",
        "label": "reactNativeFunctionalExportComponentWithStyles",
        "matches": [
          "rnfes"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react'\nimport { View, Text } from 'react-native'\n\nexport default function ${1:${TM_FILENAME_BASE}}() {\n\treturn (\n\t\t<View>\n\t\t\t<Text>$0</Text>\n\t\t</View>\n\t)\n}\n",
        "doc": null,
        "grammar": "lsp",
        "label": "reactNativeFunctionalComponent",
        "matches": [
          "rnf"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react'\nimport { StyleSheet, Text, View } from 'react-native'\n\nexport default function ${1:${TM_FILENAME_BASE}}() {\n\treturn (\n\t\t<View>\n\t\t\t<Text>$0</Text>\n\t\t</View>\n\t)\n}\n\nconst styles = StyleSheet.create({})\n",
        "doc": null,
        "grammar": "lsp",
        "label": "reactNativeFunctionalComponentWithStyles",
        "matches": [
          "rnfs"
        ],
        "opts": []
      },
      {
        "content": "import { ${1:moduleName} } from 'react-native'",
        "doc": null,
        "grammar": "lsp",
        "label": "reactNativeImport",
        "matches": [
          "imrn"
        ],
        "opts": []
      },
      {
        "content": "const styles = StyleSheet.create({\n\t${1:style}\n})\n",
        "doc": null,
        "grammar": "lsp",
        "label": "reactNativeStyles",
        "matches": [
          "rnstyle"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.array,",
        "doc": "Array prop type",
        "grammar": "lsp",
        "label": "propTypeArray",
        "matches": [
          "pta"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.array.isRequired,",
        "doc": "Array prop type required",
        "grammar": "lsp",
        "label": "propTypeArrayRequired",
        "matches": [
          "ptar"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.bool,",
        "doc": "Bool prop type",
        "grammar": "lsp",
        "label": "propTypeBool",
        "matches": [
          "ptb"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.bool.isRequired,",
        "doc": "Bool prop type required",
        "grammar": "lsp",
        "label": "propTypeBoolRequired",
        "matches": [
          "ptbr"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.func,",
        "doc": "Func prop type",
        "grammar": "lsp",
        "label": "propTypeFunc",
        "matches": [
          "ptf"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.func.isRequired,",
        "doc": "Func prop type required",
        "grammar": "lsp",
        "label": "propTypeFuncRequired",
        "matches": [
          "ptfr"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.number,",
        "doc": "Number prop type",
        "grammar": "lsp",
        "label": "propTypeNumber",
        "matches": [
          "ptn"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.number.isRequired,",
        "doc": "Number prop type required",
        "grammar": "lsp",
        "label": "propTypeNumberRequired",
        "matches": [
          "ptnr"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.object,",
        "doc": "Object prop type",
        "grammar": "lsp",
        "label": "propTypeObject",
        "matches": [
          "pto"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.object.isRequired,",
        "doc": "Object prop type required",
        "grammar": "lsp",
        "label": "propTypeObjectRequired",
        "matches": [
          "ptor"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.string,",
        "doc": "String prop type",
        "grammar": "lsp",
        "label": "propTypeString",
        "matches": [
          "pts"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.string.isRequired,",
        "doc": "String prop type required",
        "grammar": "lsp",
        "label": "propTypeStringRequired",
        "matches": [
          "ptsr"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.node,",
        "doc": "Anything that can be rendered: numbers, strings, elements or an array",
        "grammar": "lsp",
        "label": "propTypeNode",
        "matches": [
          "ptnd"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.node.isRequired,",
        "doc": "Anything that can be rendered: numbers, strings, elements or an array required",
        "grammar": "lsp",
        "label": "propTypeNodeRequired",
        "matches": [
          "ptndr"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.element,",
        "doc": "React element prop type",
        "grammar": "lsp",
        "label": "propTypeElement",
        "matches": [
          "ptel"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.element.isRequired,",
        "doc": "React element prop type required",
        "grammar": "lsp",
        "label": "propTypeElementRequired",
        "matches": [
          "ptelr"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.instanceOf($0),",
        "doc": "Is an instance of a class prop type",
        "grammar": "lsp",
        "label": "propTypeInstanceOf",
        "matches": [
          "pti"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.instanceOf($0).isRequired,",
        "doc": "Is an instance of a class prop type required",
        "grammar": "lsp",
        "label": "propTypeInstanceOfRequired",
        "matches": [
          "ptir"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.oneOf(['$0']),",
        "doc": "Prop type limited to specific values by treating it as an enum",
        "grammar": "lsp",
        "label": "propTypeEnum",
        "matches": [
          "pte"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.oneOf(['$0']).isRequired,",
        "doc": "Prop type limited to specific values by treating it as an enum required",
        "grammar": "lsp",
        "label": "propTypeEnumRequired",
        "matches": [
          "pter"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.oneOfType([\n\t$0\n]),",
        "doc": "An object that could be one of many types",
        "grammar": "lsp",
        "label": "propTypeOneOfType",
        "matches": [
          "ptet"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.oneOfType([\n\t$0\n]).isRequired,",
        "doc": "An object that could be one of many types required",
        "grammar": "lsp",
        "label": "propTypeOneOfTypeRequired",
        "matches": [
          "ptetr"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.arrayOf($0),",
        "doc": "An array of a certain type",
        "grammar": "lsp",
        "label": "propTypeArrayOf",
        "matches": [
          "ptao"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.arrayOf($0).isRequired,",
        "doc": "An array of a certain type required",
        "grammar": "lsp",
        "label": "propTypeArrayOfRequired",
        "matches": [
          "ptaor"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.objectOf($0),",
        "doc": "An object with property values of a certain type",
        "grammar": "lsp",
        "label": "propTypeObjectOf",
        "matches": [
          "ptoo"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.objectOf($0).isRequired,",
        "doc": "An object with property values of a certain type required",
        "grammar": "lsp",
        "label": "propTypeObjectOfRequired",
        "matches": [
          "ptoor"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.shape({\n\t$0\n}),",
        "doc": "An object taking on a particular shape",
        "grammar": "lsp",
        "label": "propTypeShape",
        "matches": [
          "ptsh"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.shape({\n\t$0\n}).isRequired,",
        "doc": "An object taking on a particular shape required",
        "grammar": "lsp",
        "label": "propTypeShapeRequired",
        "matches": [
          "ptshr"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.exact({\n\t$0\n}),",
        "doc": "An object with warnings on extra properties",
        "grammar": "lsp",
        "label": "propTypeExact",
        "matches": [
          "ptex"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.exact({\n\t$0\n}).isRequired,",
        "doc": "An object with warnings on extra properties required",
        "grammar": "lsp",
        "label": "propTypeExactRequired",
        "matches": [
          "ptexr"
        ],
        "opts": []
      },
      {
        "content": "static propTypes = {\n$0\n}\n",
        "doc": null,
        "grammar": "lsp",
        "label": "staticPropTpyes",
        "matches": [
          "ptypes"
        ],
        "opts": []
      },
      {
        "content": "PropTypes.any,",
        "doc": "Any prop type",
        "grammar": "lsp",
        "label": "propTypeAny",
        "matches": [
          "ptany"
        ],
        "opts": []
      },
      {
        "content": "/**\n * ${0}\n */",
        "doc": null,
        "grammar": "lsp",
        "label": "Comment Big Block",
        "matches": [
          "cmmb"
        ],
        "opts": []
      },
      {
        "content": "describe('$1', () => {\n\t$0\n})\n",
        "doc": "Testing `describe` block",
        "grammar": "lsp",
        "label": "describeBlock",
        "matches": [
          "desc"
        ],
        "opts": []
      },
      {
        "content": "test('should $1', () => {\n\t$0\n})\n",
        "doc": "Testing `test` block",
        "grammar": "lsp",
        "label": "testBlock",
        "matches": [
          "test"
        ],
        "opts": []
      },
      {
        "content": "test('should $1', async () => {\n\t$0\n})\n",
        "doc": "Testing `asynchronous test` block",
        "grammar": "lsp",
        "label": "testAsyncBlock",
        "matches": [
          "testa"
        ],
        "opts": []
      },
      {
        "content": "it('should $1', () => {\n\t$0\n})\n",
        "doc": "Testing `it` block",
        "grammar": "lsp",
        "label": "itBlock",
        "matches": [
          "tit"
        ],
        "opts": []
      },
      {
        "content": "it('should $1', async () => {\n\t$0\n})\n",
        "doc": "Testing asynchronous `it` block",
        "grammar": "lsp",
        "label": "itAsyncBlock",
        "matches": [
          "tita"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react'\nimport renderer from 'react-test-renderer'\n\nimport { ${1:${TM_FILENAME_BASE}} } from '../${1:${TM_FILENAME_BASE}}'\n\ndescribe('<${1:${TM_FILENAME_BASE}} />', () => {\n\tconst defaultProps = {}\n\tconst wrapper = renderer.create(<${1:${TM_FILENAME_BASE}} {...defaultProps} />)\n\n\ttest('render', () => {\n\t\texpect(wrapper).toMatchSnapshot()\n\t})\n})\n",
        "doc": null,
        "grammar": "lsp",
        "label": "setupReactTest",
        "matches": [
          "stest"
        ],
        "opts": []
      },
      {
        "content": "import 'react-native'\nimport React from 'react'\nimport renderer from 'react-test-renderer'\n\nimport ${1:${TM_FILENAME_BASE}} from '../${1:${TM_FILENAME_BASE}}'\n\ndescribe('<${1:${TM_FILENAME_BASE}} />', () => {\n\tconst defaultProps = {}\n\tconst wrapper = renderer.create(<${1:${TM_FILENAME_BASE}} {...defaultProps} />)\n\n\ttest('render', () => {\n\t\texpect(wrapper).toMatchSnapshot()\n\t})\n})\n",
        "doc": null,
        "grammar": "lsp",
        "label": "setupReactNativeTest",
        "matches": [
          "sntest"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react'\nimport renderer from 'react-test-renderer'\nimport { Provider } from 'react-redux'\n\nimport store from 'src/store'\nimport { ${1:${TM_FILENAME_BASE}} } from '../${1:${TM_FILENAME_BASE}}'\n\ndescribe('<${1:${TM_FILENAME_BASE}} />', () => {\n\tconst defaultProps = {}\n\tconst wrapper = renderer.create(\n\t\t<Provider store={store}>\n\t\t <${1:${TM_FILENAME_BASE}} {...defaultProps} />\n\t\t</Provider>,\n\t)\n\n\ttest('render', () => {\n\t\texpect(wrapper).toMatchSnapshot()\n\t})\n})\n",
        "doc": "Create test component",
        "grammar": "lsp",
        "label": "setupReactComponentTestWithRedux",
        "matches": [
          "srtest"
        ],
        "opts": []
      },
      {
        "content": "import 'react-native'\nimport React from 'react'\nimport renderer from 'react-test-renderer'\nimport { Provider } from 'react-redux'\n\nimport store from 'src/store'\nimport ${1:${TM_FILENAME_BASE}} from '../${1:${TM_FILENAME_BASE}}'\n\ndescribe('<${1:${TM_FILENAME_BASE}} />', () => {\n\tconst defaultProps = {}\n\tconst wrapper = renderer.create(\n\t\t<Provider store={store}>\n\t\t\t<${1:${TM_FILENAME_BASE}} {...defaultProps} />\n\t\t</Provider>,\n\t)\n\n\ttest('render', () => {\n\t\texpect(wrapper).toMatchSnapshot()\n\t})\n})\n",
        "doc": null,
        "grammar": "lsp",
        "label": "setupReactNativeTestWithRedux",
        "matches": [
          "snrtest"
        ],
        "opts": []
      },
      {
        "content": "import { compose, graphql } from 'react-apollo'\n",
        "doc": null,
        "grammar": "lsp",
        "label": "graphQLForComponent",
        "matches": [
          "graphql"
        ],
        "opts": []
      },
      {
        "content": "export default compose(\n\tgraphql(${1:queryOrMutation}, { name: ${2:name} }),\n)(${1:${TM_FILENAME_BASE}})",
        "doc": null,
        "grammar": "lsp",
        "label": "exportGraphQL",
        "matches": [
          "expgql"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react'\nimport PropTypes from 'prop-types'\nimport { connect } from 'react-redux'\n\nexport const mapStateToProps = state => ({\n\n})\n\nexport const mapDispatchToProps = {\n \n}\n\nexport const ${1:hocComponentName} = (WrappedComponent) => {\n\tconst hocComponent = ({ ...props }) => <WrappedComponent {...props} />\n\n\thocComponent.propTypes = {\n\t}\n\n\treturn hocComponent\n}\n\nexport default WrapperComponent => connect(mapStateToProps, mapDispatchToProps)(${1:hocComponentName}(WrapperComponent))\n",
        "doc": null,
        "grammar": "lsp",
        "label": "hocComponentWithRedux",
        "matches": [
          "hocredux"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react'\nimport PropTypes from 'prop-types'\n\nexport default (WrappedComponent) => {\n\tconst hocComponent = ({ ...props }) => <WrappedComponent {...props} />\n\n\thocComponent.propTypes = {\n\t}\n\n\treturn hocComponent\n}\n",
        "doc": null,
        "grammar": "lsp",
        "label": "hocComponent",
        "matches": [
          "hoc"
        ],
        "opts": []
      },
      {
        "content": "const [${1:state}, set${1/(.*)/${1:/capitalize}/}] = useState(${2:initialState})",
        "doc": null,
        "grammar": "lsp",
        "label": "useState",
        "matches": [
          "useState"
        ],
        "opts": []
      },
      {
        "content": "useEffect(() => {\n\t${1:effect}\n\treturn () => {\n\t\t${2:cleanup}\n\t}\n}, [${3:input}])",
        "doc": null,
        "grammar": "lsp",
        "label": "useEffect",
        "matches": [
          "useEffect"
        ],
        "opts": []
      },
      {
        "content": "const ${1:context} = useContext(${2:contextValue})",
        "doc": null,
        "grammar": "lsp",
        "label": "useContext",
        "matches": [
          "useContext"
        ],
        "opts": []
      },
      {
        "content": "const [state, dispatch] = useReducer(${1:reducer}, ${2:initialState}, ${3:init})",
        "doc": null,
        "grammar": "lsp",
        "label": "useReducer",
        "matches": [
          "useReducer"
        ],
        "opts": []
      },
      {
        "content": "useCallback(\n\t() => {\n\t\t${1:callback}\n\t},\n\t[${2:input}],\n)",
        "doc": null,
        "grammar": "lsp",
        "label": "useCallback",
        "matches": [
          "useCallback"
        ],
        "opts": []
      },
      {
        "content": "useMemo(() => ${1:function}, ${2:input})",
        "doc": null,
        "grammar": "lsp",
        "label": "useMemo",
        "matches": [
          "useMemo"
        ],
        "opts": []
      },
      {
        "content": "const ${1:ref} = useRef(${2:initialValue})",
        "doc": null,
        "grammar": "lsp",
        "label": "useRef",
        "matches": [
          "useRef"
        ],
        "opts": []
      },
      {
        "content": "useImperativeHandle(\n\t${1:ref},\n\t() => {\n\t\t${2:handler}\n\t},\n\t[${3:input}],\n)",
        "doc": null,
        "grammar": "lsp",
        "label": "useImperativeHandle",
        "matches": [
          "useImperativeHandle"
        ],
        "opts": []
      },
      {
        "content": "useDebugValue(${1:value})",
        "doc": null,
        "grammar": "lsp",
        "label": "useDebugValue",
        "matches": [
          "useDebugValue"
        ],
        "opts": []
      },
      {
        "content": "useLayoutEffect(() => {\n\t${1:effect}\n\treturn () => {\n\t\t${2:cleanup}\n\t};\n}, [${3:input}])",
        "doc": null,
        "grammar": "lsp",
        "label": "useLayoutEffect",
        "matches": [
          "useLayoutEffect"
        ],
        "opts": []
      },
      {
        "content": "const ${1:state} = useSelector(state => state.${1:state})",
        "doc": null,
        "grammar": "lsp",
        "label": "useSelector",
        "matches": [
          "useSelector"
        ],
        "opts": []
      },
      {
        "content": "const dispatch = useDispatch(${1:function})",
        "doc": null,
        "grammar": "lsp",
        "label": "useDispatch",
        "matches": [
          "useDispatch"
        ],
        "opts": []
      },
      {
        "content": "typeof ${0}",
        "doc": null,
        "grammar": "lsp",
        "label": "typeof",
        "matches": [
          "tpf"
        ],
        "opts": []
      },
      {
        "content": "function ${1:${TM_FILENAME_BASE}}() {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "Creates a React 17 Functional Component with ES7 module system",
        "grammar": "lsp",
        "label": "_reactFunctionalExportComponent",
        "matches": [
          "_rfce"
        ],
        "opts": []
      },
      {
        "content": "export default function ${1:${TM_FILENAME_BASE}}() {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n",
        "doc": "Creates a React 17 Functional Component with ES7 module system",
        "grammar": "lsp",
        "label": "_reactFunctionalComponent",
        "matches": [
          "_rfc"
        ],
        "opts": []
      },
      {
        "content": "import PropTypes from 'prop-types'\n\nfunction ${1:${TM_FILENAME_BASE}}(props) {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n\n",
        "doc": "Creates a React 17 Functional Component with ES7 module system with PropTypes",
        "grammar": "lsp",
        "label": "_reactFunctionalComponentWithPropTypes",
        "matches": [
          "_rfcp"
        ],
        "opts": []
      },
      {
        "content": "const ${1:${TM_FILENAME_BASE}} = () => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "Creates a React 17 Arrow Function Component with ES7 module system",
        "grammar": "lsp",
        "label": "_reactArrowFunctionExportComponent",
        "matches": [
          "_rafce"
        ],
        "opts": []
      },
      {
        "content": "export const ${1:${TM_FILENAME_BASE}} = () => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n",
        "doc": "Creates a React 17 Arrow Function Component with ES7 module system",
        "grammar": "lsp",
        "label": "_reactArrowFunctionComponent",
        "matches": [
          "_rafc"
        ],
        "opts": []
      },
      {
        "content": "import PropTypes from 'prop-types'\n\nconst ${1:${TM_FILENAME_BASE}} = props => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\n${1:${TM_FILENAME_BASE}}.propTypes = {\n\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "Creates a React 17 Arrow Function Component with ES7 module system with PropTypes",
        "grammar": "lsp",
        "label": "_reactArrowFunctionComponentWithPropTypes",
        "matches": [
          "_rafcp"
        ],
        "opts": []
      },
      {
        "content": "import { View, Text } from 'react-native'\n\nconst ${1:${TM_FILENAME_BASE}} = () => {\n\treturn (\n\t\t<View>\n\t\t\t<Text>$0</Text>\n\t\t</View>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": null,
        "grammar": "lsp",
        "label": "_reactNativeFunctionalExportComponent",
        "matches": [
          "_rnfe"
        ],
        "opts": []
      },
      {
        "content": "import { StyleSheet, Text, View } from 'react-native'\n\nconst ${1:${TM_FILENAME_BASE}} = () => {\n\treturn (\n\t\t<View>\n\t\t\t<Text>$0</Text>\n\t\t</View>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n\nconst styles = StyleSheet.create({})\n",
        "doc": null,
        "grammar": "lsp",
        "label": "_reactNativeFunctionalExportComponentWithStyles",
        "matches": [
          "_rnfes"
        ],
        "opts": []
      },
      {
        "content": "import { View, Text } from 'react-native'\n\nexport default function ${1:${TM_FILENAME_BASE}}() {\n\treturn (\n\t\t<View>\n\t\t\t<Text>$0</Text>\n\t\t</View>\n\t)\n}\n",
        "doc": null,
        "grammar": "lsp",
        "label": "_reactNativeFunctionalComponent",
        "matches": [
          "_rnf"
        ],
        "opts": []
      },
      {
        "content": "import { StyleSheet, Text, View } from 'react-native'\n\nexport default function ${1:${TM_FILENAME_BASE}}() {\n\treturn (\n\t\t<View>\n\t\t\t<Text>$0</Text>\n\t\t</View>\n\t)\n}\n\nconst styles = StyleSheet.create({})\n",
        "doc": null,
        "grammar": "lsp",
        "label": "_reactNativeFunctionalComponentWithStyles",
        "matches": [
          "_rnfs"
        ],
        "opts": []
      },
      {
        "content": "import renderer from 'react-test-renderer'\n\nimport { ${1:${TM_FILENAME_BASE}} } from '../${1:${TM_FILENAME_BASE}}'\n\ndescribe('<${1:${TM_FILENAME_BASE}} />', () => {\n\tconst defaultProps = {}\n\tconst wrapper = renderer.create(<${1:${TM_FILENAME_BASE}} {...defaultProps} />)\n\n\ttest('render', () => {\n\t\texpect(wrapper).toMatchSnapshot()\n\t})\n})\n",
        "doc": null,
        "grammar": "lsp",
        "label": "_setupReactTest",
        "matches": [
          "_stest"
        ],
        "opts": []
      },
      {
        "content": "import 'react-native'\nimport renderer from 'react-test-renderer'\n\nimport ${1:${TM_FILENAME_BASE}} from '../${1:${TM_FILENAME_BASE}}'\n\ndescribe('<${1:${TM_FILENAME_BASE}} />', () => {\n\tconst defaultProps = {}\n\tconst wrapper = renderer.create(<${1:${TM_FILENAME_BASE}} {...defaultProps} />)\n\n\ttest('render', () => {\n\t\texpect(wrapper).toMatchSnapshot()\n\t})\n})\n",
        "doc": null,
        "grammar": "lsp",
        "label": "_setupReactNativeTest",
        "matches": [
          "_sntest"
        ],
        "opts": []
      },
      {
        "content": "import renderer from 'react-test-renderer'\nimport { Provider } from 'react-redux'\n\nimport store from 'src/store'\nimport { ${1:${TM_FILENAME_BASE}} } from '../${1:${TM_FILENAME_BASE}}'\n\ndescribe('<${1:${TM_FILENAME_BASE}} />', () => {\n\tconst defaultProps = {}\n\tconst wrapper = renderer.create(\n\t\t<Provider store={store}>\n\t\t <${1:${TM_FILENAME_BASE}} {...defaultProps} />\n\t\t</Provider>,\n\t)\n\n\ttest('render', () => {\n\t\texpect(wrapper).toMatchSnapshot()\n\t})\n})\n",
        "doc": "Create test component",
        "grammar": "lsp",
        "label": "_setupReactComponentTestWithRedux",
        "matches": [
          "_srtest"
        ],
        "opts": []
      },
      {
        "content": "import 'react-native'\nimport renderer from 'react-test-renderer'\nimport { Provider } from 'react-redux'\n\nimport store from 'src/store'\nimport ${1:${TM_FILENAME_BASE}} from '../${1:${TM_FILENAME_BASE}}'\n\ndescribe('<${1:${TM_FILENAME_BASE}} />', () => {\n\tconst defaultProps = {}\n\tconst wrapper = renderer.create(\n\t\t<Provider store={store}>\n\t\t\t<${1:${TM_FILENAME_BASE}} {...defaultProps} />\n\t\t</Provider>,\n\t)\n\n\ttest('render', () => {\n\t\texpect(wrapper).toMatchSnapshot()\n\t})\n})\n",
        "doc": null,
        "grammar": "lsp",
        "label": "_setupReactNativeTestWithRedux",
        "matches": [
          "_snrtest"
        ],
        "opts": []
      },
      {
        "content": "import PropTypes from 'prop-types'\nimport { connect } from 'react-redux'\n\nexport const mapStateToProps = state => ({\n\n})\n\nexport const mapDispatchToProps = {\n \n}\n\nexport const ${1:hocComponentName} = (WrappedComponent) => {\n\tconst hocComponent = ({ ...props }) => <WrappedComponent {...props} />\n\n\thocComponent.propTypes = {\n\t}\n\n\treturn hocComponent\n}\n\nexport default WrapperComponent => connect(mapStateToProps, mapDispatchToProps)(${1:hocComponentName}(WrapperComponent))\n",
        "doc": null,
        "grammar": "lsp",
        "label": "_hocComponentWithRedux",
        "matches": [
          "_hocredux"
        ],
        "opts": []
      },
      {
        "content": "import PropTypes from 'prop-types'\n\nexport default (WrappedComponent) => {\n\tconst hocComponent = ({ ...props }) => <WrappedComponent {...props} />\n\n\thocComponent.propTypes = {\n\t}\n\n\treturn hocComponent\n}\n",
        "doc": null,
        "grammar": "lsp",
        "label": "_hocComponent",
        "matches": [
          "_hoc"
        ],
        "opts": []
      },
      {
        "content": "const ${1:${TM_FILENAME_BASE}} = () => {\n\t$2\n}\n\nexport default ${1:${TM_FILENAME_BASE}}",
        "doc": "Creates a React Custom Hook with ES7 module system",
        "grammar": "lsp",
        "label": "reactCustomHook",
        "matches": [
          "rch"
        ],
        "opts": []
      },
      {
        "content": "snippet ${1:trigger} \"${2:description}\"\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "snip"
        ],
        "opts": []
      },
      {
        "content": "{VISUAL}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "v"
        ],
        "opts": []
      },
      {
        "content": "${${1:1}:${0:text}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "$"
        ],
        "opts": []
      },
      {
        "content": "`!p snip.rv = \"snippet\"` ${1:Tab_trigger} \"${2:Description}\" ${3:b}\n${0:${VISUAL}}\n`!p snip.rv = \"endsnippet\"`",
        "doc": null,
        "grammar": "snu",
        "label": "Ultisnips snippet definition",
        "matches": [
          "usnip"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "`!p snip.rv = \"global\"` !p\n${0:${VISUAL}}\n`!p snip.rv = \"endglobal\"`",
        "doc": null,
        "grammar": "snu",
        "label": "Global snippet",
        "matches": [
          "global"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "\\$\\{VISUAL${1:${2:default}${3:/transform/}}\\}",
        "doc": null,
        "grammar": "snu",
        "label": "${VISUAL}",
        "matches": [
          "vis"
        ],
        "opts": [
          "i"
        ]
      }
    ],
    "snippets-ts": [
      {
        "content": "import styled from 'styled-components/native';\n\nexport const ${1:Container} = styled.${2:View}`\n  ${3}\n`;\n",
        "doc": "Create React Native Styled Components file",
        "grammar": "lsp",
        "label": "styles",
        "matches": [
          "styled-react-native"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react';\nimport { View } from 'react-native';\n\n// import { Container } from './styles';\n\nconst ${1:${TM_DIRECTORY/^.*(\\/|\\\\)([^(\\/|\\\\)]+)$/$2/}}: React.FC = () => {\n  return <View />;\n}\n\nexport default ${1:${TM_DIRECTORY/^.*(\\/|\\\\)([^(\\/|\\\\)]+)$/$2/}};",
        "doc": "Create React Native TypeScript Functional Component",
        "grammar": "lsp",
        "label": "componentFunctionalTypescript",
        "matches": [
          "rnfc"
        ],
        "opts": []
      }
    ],
    "soy": [
      {
        "content": "{namespace ${1:name}}",
        "doc": null,
        "grammar": "snu",
        "label": "Namespace",
        "matches": [
          "ns"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "/**\n * ${2:TODO(`whoami`): Describe this template.}\n */\n{template .${1:name}}\n\t$0\n{/template}",
        "doc": null,
        "grammar": "snu",
        "label": "Template",
        "matches": [
          "tmpl"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "{msg desc=\"${1:description}\"}\n\t$0\n{/msg}",
        "doc": null,
        "grammar": "snu",
        "label": "Message",
        "matches": [
          "msg"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "{let $${1:identifier}: ${2:expression} /}",
        "doc": null,
        "grammar": "snu",
        "label": "let command",
        "matches": [
          "let"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "{if ${1:expression}}\n\t$0\n{/if}",
        "doc": null,
        "grammar": "snu",
        "label": "if .. (if)",
        "matches": [
          "if"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "{if ${1:expression}}\n\t$2\n{else}\n\t$0\n{/if}",
        "doc": null,
        "grammar": "snu",
        "label": "if .. else (ife)",
        "matches": [
          "ife"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "{elif ${1:expression}}\n\t$0",
        "doc": null,
        "grammar": "snu",
        "label": "else if .. (eli)",
        "matches": [
          "eli"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "{foreach $${1:var} in ${2:ref}}\n\t$0\n{/foreach}",
        "doc": null,
        "grammar": "snu",
        "label": "foreach command",
        "matches": [
          "fore"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "{for $${1:var} in range(${2:rangeexpr})}\n\t$0\n{/for}",
        "doc": null,
        "grammar": "snu",
        "label": "for command",
        "matches": [
          "for"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "{call ${1:tmpl}}\n\t$0\n{/call}",
        "doc": null,
        "grammar": "snu",
        "label": "template call",
        "matches": [
          "call"
        ],
        "opts": [
          "b"
        ]
      }
    ],
    "sql": [
      {
        "content": "create table ${1:table} (\n\t${0:columns}\n);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tbl"
        ],
        "opts": []
      },
      {
        "content": "${1:name}\t${2:type}\t${3:default ''}\t${0:not null}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "col"
        ],
        "opts": []
      },
      {
        "content": "${1:name}\tvarchar2(${2:size})\t${3:default ''}\t${0:not null}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ccol"
        ],
        "opts": []
      },
      {
        "content": "${1:name}\tnumber\t${3:default 0}\t${0:not null}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ncol"
        ],
        "opts": []
      },
      {
        "content": "${1:name}\tdate\t${3:default sysdate}\t${0:not null}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dcol"
        ],
        "opts": []
      },
      {
        "content": "create index ${0:$1_$2} on ${1:table}(${2:column});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ind"
        ],
        "opts": []
      },
      {
        "content": "create unique index ${1:name} on ${2:table}(${0:column});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "uind"
        ],
        "opts": []
      },
      {
        "content": "comment on table ${1:table} is '${0:comment}';",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tblcom"
        ],
        "opts": []
      },
      {
        "content": "comment on column ${1:table}.${2:column} is '${0:comment}';",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "colcom"
        ],
        "opts": []
      },
      {
        "content": "alter table ${1:table} add (${2:column} ${0:type});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "addcol"
        ],
        "opts": []
      },
      {
        "content": "create sequence ${1:name} start with ${2:1} increment by ${3:1} minvalue ${0:1};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "seq"
        ],
        "opts": []
      },
      {
        "content": "select * from ${0:table}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "s*"
        ],
        "opts": []
      },
      {
        "content": "CREATE TABLE ${1:cities} (\n  ${0:name varchar(80), country_name text}\n);",
        "doc": "",
        "grammar": "snu",
        "label": "CREATE TABLE { ... }",
        "matches": [
          "CREATE_TABLE"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "CREATE INDEX ${1:_name} ON ${2:cities} (${3:name});",
        "doc": "",
        "grammar": "snu",
        "label": "CREATE INDEX ... ON ... ( ... )",
        "matches": [
          "CREATE_INDEX"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "DROP TABLE IF EXISTS ${1:table};",
        "doc": "",
        "grammar": "snu",
        "label": "DROP TABLE IF EXISTS ...",
        "matches": [
          "DROP_TABLE"
        ],
        "opts": []
      },
      {
        "content": "ALTER TABLE ${1:table}\nMODIFY ${2:column} ${3:new_column_desc};",
        "doc": "",
        "grammar": "snu",
        "label": "ALTER TABLE ... MODIFY ...",
        "matches": [
          "ALTER_TABLE"
        ],
        "opts": []
      },
      {
        "content": "TRUNCATE TABLE ${1:table};",
        "doc": "",
        "grammar": "snu",
        "label": "TRUNCATE TABLE ...",
        "matches": [
          "TRUNCATE_TABLE"
        ],
        "opts": []
      },
      {
        "content": "INSERT INTO ${1:cities}\nVALUES (${0:'Vancouver', 'Canada'});",
        "doc": "",
        "grammar": "snu",
        "label": "INSERT INTO ... VALUES ( ... )",
        "matches": [
          "INSERT_DATA"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "UPDATE ${1:table}\nSET ${2:column} = ${3:value}\nWHERE ${4:condition};",
        "doc": "",
        "grammar": "snu",
        "label": "UPDATE ... SET ... WHERE ...",
        "matches": [
          "UPDATE_DATA"
        ],
        "opts": []
      },
      {
        "content": "SELECT ${1:*}\nFROM ${2:cities} ${3:WHERE area = 'Asia'}\n${4: ORDER BY distance}\n${5: LIMIT 30};",
        "doc": "",
        "grammar": "snu",
        "label": "SELECT * from ... ORDER BY ... LIMIT ...",
        "matches": [
          "SELECT_DATA"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "SELECT ${1:*}\nFROM ${2:table1} ${3:T1}\nJOIN ${4:table2} ${5:T2}\nON T1.${6:column1} = T2.${7:column2}",
        "doc": "",
        "grammar": "snu",
        "label": "SELECT * FROM T1 JOIN T2 ... ON",
        "matches": [
          "SELECT_JOIN_DATA"
        ],
        "opts": []
      },
      {
        "content": "DELETE FROM ${1:table}\nWHERE ${2:condition};",
        "doc": "",
        "grammar": "snu",
        "label": "DELETE FROM ... WHERE ...",
        "matches": [
          "DELETE_DATA"
        ],
        "opts": []
      },
      {
        "content": "BEGIN TRANSACTION;\n${0:TARGET}\nCOMMIT;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "TRANSACTION",
          "BEGIN TRANSACTION"
        ],
        "opts": [
          "head"
        ]
      }
    ],
    "sshconfig": [
      {
        "content": "Host ${1:name}\n\tHostName $1.${2:domain}\n\tPort ${3}\n\t${4:User }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Host"
        ],
        "opts": [
          "head"
        ]
      }
    ],
    "styled-components": [
      {
        "content": "import styled from 'styled-components';",
        "doc": "import styled from 'styled-components'",
        "grammar": "lsp",
        "label": "styled-components-import-styled-from-styled-components",
        "matches": [
          "styled-components import styled",
          "imsc"
        ],
        "opts": []
      },
      {
        "content": "import styled from 'styled-components/native';",
        "doc": "import styled from 'styled-components/native'",
        "grammar": "lsp",
        "label": "styled-components-import-styled-from-styled-components-native",
        "matches": [
          "imscn",
          "styled-components import styled native'"
        ],
        "opts": []
      },
      {
        "content": "import { createGlobalStyle } from 'styled-components';",
        "doc": "import { createGlobalStyle } from 'styled-components'",
        "grammar": "lsp",
        "label": "styled-components-import-create-global-style-from-styled-components",
        "matches": [
          "styled-components import createglobalstyle",
          "imscg"
        ],
        "opts": []
      },
      {
        "content": "import { css } from 'styled-components';",
        "doc": "import { css } from 'styled-components'",
        "grammar": "lsp",
        "label": "styled-components-import-css-from-styled-components",
        "matches": [
          "styled-components import css",
          "imsccss"
        ],
        "opts": []
      },
      {
        "content": "import { withTheme } from 'styled-components';",
        "doc": "import { withTheme } from 'styled-components'",
        "grammar": "lsp",
        "label": "styled-components-import-with-theme-from-styled-components",
        "matches": [
          "imsct",
          "styled-components import withtheme"
        ],
        "opts": []
      },
      {
        "content": "const ${1} = styled.${2}`\n  ${3}\n`;",
        "doc": "Styled-Component",
        "grammar": "lsp",
        "label": "styled-components-styled-component",
        "matches": [
          "styled-components component",
          "sc"
        ],
        "opts": []
      },
      {
        "content": "export const ${1} = styled.${2}`\n  ${3}\n`;",
        "doc": "Export styled-component",
        "grammar": "lsp",
        "label": "styled-components-export-styled-component",
        "matches": [
          "styled-components export component",
          "exsc"
        ],
        "opts": []
      },
      {
        "content": "const Global${1} = createGlobalStyle`\n  ${2}\n`;",
        "doc": "createGlobalStyle",
        "grammar": "lsp",
        "label": "styled-components-create-global-style",
        "matches": [
          "styled-components createglobalstyle",
          "scg"
        ],
        "opts": []
      },
      {
        "content": "export const Global${1} = createGlobalStyle`\n  ${2}\n`;",
        "doc": "Export createGlobalStyle",
        "grammar": "lsp",
        "label": "styled-components-export-create-global-style",
        "matches": [
          "styled-components export createglobalstyle",
          "exscg"
        ],
        "opts": []
      },
      {
        "content": "const ${1} = styled(${2})`\n  ${3}\n`;",
        "doc": "Styled-Component from existing component",
        "grammar": "lsp",
        "label": "styled-components-styled-component-from-existing-component",
        "matches": [
          "styled-components component from existing",
          "scc"
        ],
        "opts": []
      },
      {
        "content": "export const ${1} = styled(${2})`\n  ${3}\n`;",
        "doc": "Export styled-component from existing component",
        "grammar": "lsp",
        "label": "styled-components-export-styled-component-from-existing-component",
        "matches": [
          "styled-components export component from existing",
          "exscc"
        ],
        "opts": []
      },
      {
        "content": "import styled from 'styled-components';\n\nconst ${1} = styled.${2}`\n  ${3}\n`;\n\nexport default ${1};",
        "doc": "Styled-Components file",
        "grammar": "lsp",
        "label": "styled-components-styled-components-file",
        "matches": [
          "styled-components file",
          "scf"
        ],
        "opts": []
      },
      {
        "content": "<ThemeProvider theme={${1}}>\n  ${2}\n</ThemeProvider>",
        "doc": "ThemeProvider",
        "grammar": "lsp",
        "label": "styled-components-theme-provider",
        "matches": [
          "themeprovider",
          "styled-components themeprovider"
        ],
        "opts": []
      },
      {
        "content": "// Define what props.theme will look like\nconst theme = {\n  ${1}: '${2}'\n};",
        "doc": "styled-component theme",
        "grammar": "lsp",
        "label": "styled-components-styled-component-theme",
        "matches": [
          "styled-components theme",
          "sct"
        ],
        "opts": []
      },
      {
        "content": "const ${1} = styled.${2}.attrs({\n  ${3}: ${4}\n})`\n  ${5}\n`;",
        "doc": "Styled-Component with attributes",
        "grammar": "lsp",
        "label": "styled-components-styled-component-with-attributes",
        "matches": [
          "scattrs",
          "styled-components component with attributes"
        ],
        "opts": []
      },
      {
        "content": "export const ${1} = styled.${2}.attrs({\n  ${3}: ${4}\n})`\n  ${5}\n`;",
        "doc": "Export styled-component with attributes",
        "grammar": "lsp",
        "label": "styled-components-export-styled-component-with-attributes",
        "matches": [
          "styled-components export component with attributes",
          "exscattrs"
        ],
        "opts": []
      },
      {
        "content": "${({ theme }) => theme.$1};",
        "doc": "Use props.theme inside styled-component",
        "grammar": "lsp",
        "label": "styled-components-use-props-theme-inside-styled-component",
        "matches": [
          "scpt",
          "styled-components propstheme inside component"
        ],
        "opts": []
      },
      {
        "content": "${props => props.$1};",
        "doc": "Use props inside styled-component",
        "grammar": "lsp",
        "label": "styled-components-use-props-inside-styled-component",
        "matches": [
          "scp",
          "styled-components props inside component"
        ],
        "opts": []
      }
    ],
    "stylus": [
      {
        "content": "!important",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "!"
        ],
        "opts": []
      },
      {
        "content": "align-content ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac"
        ],
        "opts": []
      },
      {
        "content": "align-content start",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:s"
        ],
        "opts": []
      },
      {
        "content": "align-content end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:e"
        ],
        "opts": []
      },
      {
        "content": "align-content center",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:c"
        ],
        "opts": []
      },
      {
        "content": "align-content flex-start",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:fs"
        ],
        "opts": []
      },
      {
        "content": "align-content flex-end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:fe"
        ],
        "opts": []
      },
      {
        "content": "align-content space-between",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:sb"
        ],
        "opts": []
      },
      {
        "content": "align-content space-around",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:sa"
        ],
        "opts": []
      },
      {
        "content": "align-content space-evenly",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:se"
        ],
        "opts": []
      },
      {
        "content": "align-content stretch",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:st"
        ],
        "opts": []
      },
      {
        "content": "align-content baseline",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:b"
        ],
        "opts": []
      },
      {
        "content": "align-content first baseline",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:fb"
        ],
        "opts": []
      },
      {
        "content": "align-content last baseline",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ac:lb"
        ],
        "opts": []
      },
      {
        "content": "align-items ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ai"
        ],
        "opts": []
      },
      {
        "content": "align-items start",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ai:s"
        ],
        "opts": []
      },
      {
        "content": "align-items end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ai:e"
        ],
        "opts": []
      },
      {
        "content": "align-items center",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ai:c"
        ],
        "opts": []
      },
      {
        "content": "align-items flex-start",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ai:fs"
        ],
        "opts": []
      },
      {
        "content": "align-items flex-end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ai:fe"
        ],
        "opts": []
      },
      {
        "content": "align-items stretch",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ai:st"
        ],
        "opts": []
      },
      {
        "content": "align-items baseline",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ai:b"
        ],
        "opts": []
      },
      {
        "content": "align-items first baseline",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ai:fb"
        ],
        "opts": []
      },
      {
        "content": "align-items last baseline",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ai:lb"
        ],
        "opts": []
      },
      {
        "content": "align-self ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as"
        ],
        "opts": []
      },
      {
        "content": "align-self start",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as:s"
        ],
        "opts": []
      },
      {
        "content": "align-self end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as:e"
        ],
        "opts": []
      },
      {
        "content": "align-self center",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as:c"
        ],
        "opts": []
      },
      {
        "content": "align-self stretch",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as:st"
        ],
        "opts": []
      },
      {
        "content": "align-self flex-start",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as:fs"
        ],
        "opts": []
      },
      {
        "content": "align-self flex-end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as:fe"
        ],
        "opts": []
      },
      {
        "content": "align-self baseline",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as:b"
        ],
        "opts": []
      },
      {
        "content": "align-self first baseline",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as:fb"
        ],
        "opts": []
      },
      {
        "content": "align-self last baseline",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "as:lb"
        ],
        "opts": []
      },
      {
        "content": "-moz-border-image url(${1}) ${2:0} ${3:0} ${4:0} ${5:0} ${6:stretch} ${0:stretch}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdi:m+"
        ],
        "opts": []
      },
      {
        "content": "-moz-border-image ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdi:m"
        ],
        "opts": []
      },
      {
        "content": "-moz-border-radius ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdrz:m"
        ],
        "opts": []
      },
      {
        "content": "-moz-box-shadow ${1:0} ${2:0} ${3:0} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bxsh:m+"
        ],
        "opts": []
      },
      {
        "content": "-moz-box-shadow ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bxsh:m"
        ],
        "opts": []
      },
      {
        "content": "-webkit-border-image url(${1}) ${2:0} ${3:0} ${4:0} ${5:0} ${6:stretch} ${0:stretch}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdi:w+"
        ],
        "opts": []
      },
      {
        "content": "-webkit-border-image ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdi:w"
        ],
        "opts": []
      },
      {
        "content": "-webkit-border-radius ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdrz:w"
        ],
        "opts": []
      },
      {
        "content": "-webkit-box-shadow ${1:0} ${2:0} ${3:0} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bxsh:w+"
        ],
        "opts": []
      },
      {
        "content": "-webkit-box-shadow ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bxsh:w"
        ],
        "opts": []
      },
      {
        "content": "@font-face ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@f"
        ],
        "opts": []
      },
      {
        "content": "@import '${0}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@i"
        ],
        "opts": []
      },
      {
        "content": "@require '${0}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@r"
        ],
        "opts": []
      },
      {
        "content": "@media ${1:screen}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@m"
        ],
        "opts": []
      },
      {
        "content": "@media screen and (min-width: ${0}px)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@msmw"
        ],
        "opts": []
      },
      {
        "content": "@extend .${1}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "@ext"
        ],
        "opts": []
      },
      {
        "content": "background ${1} url(${2}) ${3:0} ${4:0} ${0:no-repeat}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bg+"
        ],
        "opts": []
      },
      {
        "content": "background-attachment ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bga"
        ],
        "opts": []
      },
      {
        "content": "background-attachment fixed",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bga:f"
        ],
        "opts": []
      },
      {
        "content": "background-attachment scroll",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bga:s"
        ],
        "opts": []
      },
      {
        "content": "background-break ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgbk"
        ],
        "opts": []
      },
      {
        "content": "background-break bounding-box",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgbk:bb"
        ],
        "opts": []
      },
      {
        "content": "background-break continuous",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgbk:c"
        ],
        "opts": []
      },
      {
        "content": "background-break each-box",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgbk:eb"
        ],
        "opts": []
      },
      {
        "content": "background-clip ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgcp"
        ],
        "opts": []
      },
      {
        "content": "background-clip border-box",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgcp:bb"
        ],
        "opts": []
      },
      {
        "content": "background-clip content-box",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgcp:cb"
        ],
        "opts": []
      },
      {
        "content": "background-clip no-clip",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgcp:nc"
        ],
        "opts": []
      },
      {
        "content": "background-clip padding-box",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgcp:pb"
        ],
        "opts": []
      },
      {
        "content": "background-color ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgc"
        ],
        "opts": []
      },
      {
        "content": "background-color transparent",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgc:t"
        ],
        "opts": []
      },
      {
        "content": "background-image url(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgi"
        ],
        "opts": []
      },
      {
        "content": "background-image none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgi:n"
        ],
        "opts": []
      },
      {
        "content": "background-origin ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgo"
        ],
        "opts": []
      },
      {
        "content": "background-origin border-box",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgo:bb"
        ],
        "opts": []
      },
      {
        "content": "background-origin content-box",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgo:cb"
        ],
        "opts": []
      },
      {
        "content": "background-origin padding-box",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgo:pb"
        ],
        "opts": []
      },
      {
        "content": "background-position-x ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgpx"
        ],
        "opts": []
      },
      {
        "content": "background-position-y ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgpy"
        ],
        "opts": []
      },
      {
        "content": "background-position ${1:0} ${0:0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgp"
        ],
        "opts": []
      },
      {
        "content": "background-repeat ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgr"
        ],
        "opts": []
      },
      {
        "content": "background-repeat no-repeat",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgr:n"
        ],
        "opts": []
      },
      {
        "content": "background-repeat repeat-x",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgr:x"
        ],
        "opts": []
      },
      {
        "content": "background-repeat repeat-y",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgr:y"
        ],
        "opts": []
      },
      {
        "content": "background-repeat repeat",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgr:r"
        ],
        "opts": []
      },
      {
        "content": "background-size ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgz"
        ],
        "opts": []
      },
      {
        "content": "background-size auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgz:a"
        ],
        "opts": []
      },
      {
        "content": "background-size contain",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgz:ct"
        ],
        "opts": []
      },
      {
        "content": "background-size cover",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bgz:cv"
        ],
        "opts": []
      },
      {
        "content": "background ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bg"
        ],
        "opts": []
      },
      {
        "content": "filter progid:DXImageTransform.Microsoft.AlphaImageLoader(src='${1}',sizingMethod='${0:crop}')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bg:ie"
        ],
        "opts": []
      },
      {
        "content": "background none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bg:n"
        ],
        "opts": []
      },
      {
        "content": "border ${1:1px} ${2:solid} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bd+"
        ],
        "opts": []
      },
      {
        "content": "border-bottom ${1:1px} ${2:solid} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdb+"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-color ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbc"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-image url(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbi"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-image none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbi:n"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-left-image url(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbli"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-left-image continue",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbli:c"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-left-image none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbli:n"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-left-radius ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdblrz"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-right-image url(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbri"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-right-image continue",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbri:c"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-right-image none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbri:n"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-right-radius ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbrrz"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-style ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbs"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-style none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbs:n"
        ],
        "opts": []
      },
      {
        "content": "border-bottom-width ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbw"
        ],
        "opts": []
      },
      {
        "content": "border-bottom ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdb"
        ],
        "opts": []
      },
      {
        "content": "border-bottom none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdb:n"
        ],
        "opts": []
      },
      {
        "content": "border-break ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbk"
        ],
        "opts": []
      },
      {
        "content": "border-break close",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdbk:c"
        ],
        "opts": []
      },
      {
        "content": "border-collapse ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdcl"
        ],
        "opts": []
      },
      {
        "content": "border-collapse collapse",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdcl:c"
        ],
        "opts": []
      },
      {
        "content": "border-collapse separate",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdcl:s"
        ],
        "opts": []
      },
      {
        "content": "border-color ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdc"
        ],
        "opts": []
      },
      {
        "content": "border-corner-image url(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdci"
        ],
        "opts": []
      },
      {
        "content": "border-corner-image continue",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdci:c"
        ],
        "opts": []
      },
      {
        "content": "border-corner-image none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdci:n"
        ],
        "opts": []
      },
      {
        "content": "border-fit ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdf"
        ],
        "opts": []
      },
      {
        "content": "border-fit clip",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdf:c"
        ],
        "opts": []
      },
      {
        "content": "border-fit overwrite",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdf:of"
        ],
        "opts": []
      },
      {
        "content": "border-fit overwrite",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdf:ow"
        ],
        "opts": []
      },
      {
        "content": "border-fit repeat",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdf:r"
        ],
        "opts": []
      },
      {
        "content": "border-fit scale",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdf:sc"
        ],
        "opts": []
      },
      {
        "content": "border-fit space",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdf:sp"
        ],
        "opts": []
      },
      {
        "content": "border-fit stretch",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdf:st"
        ],
        "opts": []
      },
      {
        "content": "border-image url(${1}) ${2:0} ${3:0} ${4:0} ${5:0} ${6:stretch} ${0:stretch}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdi"
        ],
        "opts": []
      },
      {
        "content": "border-image none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdi:n"
        ],
        "opts": []
      },
      {
        "content": "border-left ${1:1px} ${2:solid} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdl+"
        ],
        "opts": []
      },
      {
        "content": "border-left-color ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdlc"
        ],
        "opts": []
      },
      {
        "content": "border-left-image url(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdli"
        ],
        "opts": []
      },
      {
        "content": "border-left-image none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdli:n"
        ],
        "opts": []
      },
      {
        "content": "border-left-style ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdls"
        ],
        "opts": []
      },
      {
        "content": "border-left-style none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdls:n"
        ],
        "opts": []
      },
      {
        "content": "border-left-width ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdlw"
        ],
        "opts": []
      },
      {
        "content": "border-left ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdl"
        ],
        "opts": []
      },
      {
        "content": "border-left none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdl:n"
        ],
        "opts": []
      },
      {
        "content": "border-length ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdlt"
        ],
        "opts": []
      },
      {
        "content": "border-length auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdlt:a"
        ],
        "opts": []
      },
      {
        "content": "border-radius ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdrz"
        ],
        "opts": []
      },
      {
        "content": "border-right ${1:1px} ${2:solid} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdr+"
        ],
        "opts": []
      },
      {
        "content": "border-right-color ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdrc"
        ],
        "opts": []
      },
      {
        "content": "border-right-image url(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdri"
        ],
        "opts": []
      },
      {
        "content": "border-right-image none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdri:n"
        ],
        "opts": []
      },
      {
        "content": "border-right-style ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdrs"
        ],
        "opts": []
      },
      {
        "content": "border-right-style none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdrs:n"
        ],
        "opts": []
      },
      {
        "content": "border-right-width ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdrw"
        ],
        "opts": []
      },
      {
        "content": "border-right ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdr"
        ],
        "opts": []
      },
      {
        "content": "border-right none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdr:n"
        ],
        "opts": []
      },
      {
        "content": "border-spacing ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdsp"
        ],
        "opts": []
      },
      {
        "content": "border-style ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds"
        ],
        "opts": []
      },
      {
        "content": "border-style dashed",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:ds"
        ],
        "opts": []
      },
      {
        "content": "border-style dot-dash",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:dtds"
        ],
        "opts": []
      },
      {
        "content": "border-style dot-dot-dash",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:dtdtds"
        ],
        "opts": []
      },
      {
        "content": "border-style dotted",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:dt"
        ],
        "opts": []
      },
      {
        "content": "border-style double",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:db"
        ],
        "opts": []
      },
      {
        "content": "border-style groove",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:g"
        ],
        "opts": []
      },
      {
        "content": "border-style hidden",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:h"
        ],
        "opts": []
      },
      {
        "content": "border-style inset",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:i"
        ],
        "opts": []
      },
      {
        "content": "border-style none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:n"
        ],
        "opts": []
      },
      {
        "content": "border-style outset",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:o"
        ],
        "opts": []
      },
      {
        "content": "border-style ridge",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:r"
        ],
        "opts": []
      },
      {
        "content": "border-style solid",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:s"
        ],
        "opts": []
      },
      {
        "content": "border-style wave",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bds:w"
        ],
        "opts": []
      },
      {
        "content": "border-top ${1:1px} ${2:solid} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdt+"
        ],
        "opts": []
      },
      {
        "content": "border-top-color ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdtc"
        ],
        "opts": []
      },
      {
        "content": "border-top-image url(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdti"
        ],
        "opts": []
      },
      {
        "content": "border-top-image none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdti:n"
        ],
        "opts": []
      },
      {
        "content": "border-top-left-image url(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdtli"
        ],
        "opts": []
      },
      {
        "content": "border-corner-image continue",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdtli:c"
        ],
        "opts": []
      },
      {
        "content": "border-corner-image none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdtli:n"
        ],
        "opts": []
      },
      {
        "content": "border-top-left-radius ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdtlrz"
        ],
        "opts": []
      },
      {
        "content": "border-top-right-image url(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdtri"
        ],
        "opts": []
      },
      {
        "content": "border-top-right-image continue",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdtri:c"
        ],
        "opts": []
      },
      {
        "content": "border-top-right-image none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdtri:n"
        ],
        "opts": []
      },
      {
        "content": "border-top-right-radius ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdtrrz"
        ],
        "opts": []
      },
      {
        "content": "border-top-style ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdts"
        ],
        "opts": []
      },
      {
        "content": "border-top-style none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdts:n"
        ],
        "opts": []
      },
      {
        "content": "border-top-width ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdtw"
        ],
        "opts": []
      },
      {
        "content": "border-top ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdt"
        ],
        "opts": []
      },
      {
        "content": "border-top none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdt:n"
        ],
        "opts": []
      },
      {
        "content": "border-width ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bdw"
        ],
        "opts": []
      },
      {
        "content": "border ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bd"
        ],
        "opts": []
      },
      {
        "content": "border none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bd:n"
        ],
        "opts": []
      },
      {
        "content": "bottom ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "b"
        ],
        "opts": []
      },
      {
        "content": "bottom auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "b:a"
        ],
        "opts": []
      },
      {
        "content": "box-shadow ${1:0} ${2:0} ${3:0} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bxsh+"
        ],
        "opts": []
      },
      {
        "content": "box-shadow ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bxsh"
        ],
        "opts": []
      },
      {
        "content": "box-shadow none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bxsh:n"
        ],
        "opts": []
      },
      {
        "content": "box-sizing ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bxz"
        ],
        "opts": []
      },
      {
        "content": "box-sizing border-box",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bxz:bb"
        ],
        "opts": []
      },
      {
        "content": "box-sizing content-box",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bxz:cb"
        ],
        "opts": []
      },
      {
        "content": "caption-side ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cps"
        ],
        "opts": []
      },
      {
        "content": "caption-side bottom",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cps:b"
        ],
        "opts": []
      },
      {
        "content": "caption-side top",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cps:t"
        ],
        "opts": []
      },
      {
        "content": "clear ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cl"
        ],
        "opts": []
      },
      {
        "content": "clear both",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cl:b"
        ],
        "opts": []
      },
      {
        "content": "clear left",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cl:l"
        ],
        "opts": []
      },
      {
        "content": "clear none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cl:n"
        ],
        "opts": []
      },
      {
        "content": "clear right",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cl:r"
        ],
        "opts": []
      },
      {
        "content": "clip ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cp"
        ],
        "opts": []
      },
      {
        "content": "clip auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cp:a"
        ],
        "opts": []
      },
      {
        "content": "clip rect(${1:0} ${2:0} ${3:0} ${0:0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cp:r"
        ],
        "opts": []
      },
      {
        "content": "color ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "c"
        ],
        "opts": []
      },
      {
        "content": "content ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ct"
        ],
        "opts": []
      },
      {
        "content": "content attr(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ct:a"
        ],
        "opts": []
      },
      {
        "content": "content close-quote",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ct:cq"
        ],
        "opts": []
      },
      {
        "content": "content counter(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ct:c"
        ],
        "opts": []
      },
      {
        "content": "content counters(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ct:cs"
        ],
        "opts": []
      },
      {
        "content": "content no-close-quote",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ct:ncq"
        ],
        "opts": []
      },
      {
        "content": "content no-open-quote",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ct:noq"
        ],
        "opts": []
      },
      {
        "content": "content normal",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ct:n"
        ],
        "opts": []
      },
      {
        "content": "content open-quote",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ct:oq"
        ],
        "opts": []
      },
      {
        "content": "counter-increment ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "coi"
        ],
        "opts": []
      },
      {
        "content": "counter-reset ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cor"
        ],
        "opts": []
      },
      {
        "content": "cursor ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cur"
        ],
        "opts": []
      },
      {
        "content": "cursor auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cur:a"
        ],
        "opts": []
      },
      {
        "content": "cursor crosshair",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cur:c"
        ],
        "opts": []
      },
      {
        "content": "cursor default",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cur:d"
        ],
        "opts": []
      },
      {
        "content": "cursor hand",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cur:ha"
        ],
        "opts": []
      },
      {
        "content": "cursor help",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cur:he"
        ],
        "opts": []
      },
      {
        "content": "cursor move",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cur:m"
        ],
        "opts": []
      },
      {
        "content": "cursor pointer",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cur:p"
        ],
        "opts": []
      },
      {
        "content": "cursor text",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cur:t"
        ],
        "opts": []
      },
      {
        "content": "display ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d"
        ],
        "opts": []
      },
      {
        "content": "display -moz-inline-box",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:mib"
        ],
        "opts": []
      },
      {
        "content": "display -moz-inline-stack",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:mis"
        ],
        "opts": []
      },
      {
        "content": "display block",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:b"
        ],
        "opts": []
      },
      {
        "content": "display compact",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:cp"
        ],
        "opts": []
      },
      {
        "content": "display grid",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:g"
        ],
        "opts": []
      },
      {
        "content": "display flex",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:f"
        ],
        "opts": []
      },
      {
        "content": "display inline-block",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:ib"
        ],
        "opts": []
      },
      {
        "content": "display inline-table",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:itb"
        ],
        "opts": []
      },
      {
        "content": "display inline",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:i"
        ],
        "opts": []
      },
      {
        "content": "display list-item",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:li"
        ],
        "opts": []
      },
      {
        "content": "display none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:n"
        ],
        "opts": []
      },
      {
        "content": "display run-in",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:ri"
        ],
        "opts": []
      },
      {
        "content": "display table-caption",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:tbcp"
        ],
        "opts": []
      },
      {
        "content": "display table-cell",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:tbc"
        ],
        "opts": []
      },
      {
        "content": "display table-column-group",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:tbclg"
        ],
        "opts": []
      },
      {
        "content": "display table-column",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:tbcl"
        ],
        "opts": []
      },
      {
        "content": "display table-footer-group",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:tbfg"
        ],
        "opts": []
      },
      {
        "content": "display table-header-group",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:tbhg"
        ],
        "opts": []
      },
      {
        "content": "display table-row-group",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:tbrg"
        ],
        "opts": []
      },
      {
        "content": "display table-row",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:tbr"
        ],
        "opts": []
      },
      {
        "content": "display table",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "d:tb"
        ],
        "opts": []
      },
      {
        "content": "empty-cells ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ec"
        ],
        "opts": []
      },
      {
        "content": "empty-cells hide",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ec:h"
        ],
        "opts": []
      },
      {
        "content": "empty-cells show",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ec:s"
        ],
        "opts": []
      },
      {
        "content": "expression()",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "exp"
        ],
        "opts": []
      },
      {
        "content": "float ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fl"
        ],
        "opts": []
      },
      {
        "content": "float left",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fl:l"
        ],
        "opts": []
      },
      {
        "content": "float none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fl:n"
        ],
        "opts": []
      },
      {
        "content": "float right",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fl:r"
        ],
        "opts": []
      },
      {
        "content": "font ${1:1em} ${2:Arial},${0:sans-serif}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "f+"
        ],
        "opts": []
      },
      {
        "content": "font-effect ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fef"
        ],
        "opts": []
      },
      {
        "content": "font-effect emboss",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fef:eb"
        ],
        "opts": []
      },
      {
        "content": "font-effect engrave",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fef:eg"
        ],
        "opts": []
      },
      {
        "content": "font-effect none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fef:n"
        ],
        "opts": []
      },
      {
        "content": "font-effect outline",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fef:o"
        ],
        "opts": []
      },
      {
        "content": "font-emphasize-position ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "femp"
        ],
        "opts": []
      },
      {
        "content": "font-emphasize-position after",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "femp:a"
        ],
        "opts": []
      },
      {
        "content": "font-emphasize-position before",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "femp:b"
        ],
        "opts": []
      },
      {
        "content": "font-emphasize-style ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fems"
        ],
        "opts": []
      },
      {
        "content": "font-emphasize-style accent",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fems:ac"
        ],
        "opts": []
      },
      {
        "content": "font-emphasize-style circle",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fems:c"
        ],
        "opts": []
      },
      {
        "content": "font-emphasize-style disc",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fems:ds"
        ],
        "opts": []
      },
      {
        "content": "font-emphasize-style dot",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fems:dt"
        ],
        "opts": []
      },
      {
        "content": "font-emphasize-style none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fems:n"
        ],
        "opts": []
      },
      {
        "content": "font-emphasize ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fem"
        ],
        "opts": []
      },
      {
        "content": "font-family ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ff"
        ],
        "opts": []
      },
      {
        "content": "font-family ${0:'Monotype Corsiva','Comic Sans MS'},cursive",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ff:c"
        ],
        "opts": []
      },
      {
        "content": "font-family ${0:Capitals,Impact},fantasy",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ff:f"
        ],
        "opts": []
      },
      {
        "content": "font-family ${0:Monaco,'Courier New'},monospace",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ff:m"
        ],
        "opts": []
      },
      {
        "content": "font-family ${0:Helvetica,Arial},sans-serif",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ff:ss"
        ],
        "opts": []
      },
      {
        "content": "font-family ${0:Georgia,'Times New Roman'},serif",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ff:s"
        ],
        "opts": []
      },
      {
        "content": "font-size-adjust ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fza"
        ],
        "opts": []
      },
      {
        "content": "font-size-adjust none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fza:n"
        ],
        "opts": []
      },
      {
        "content": "font-size ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fz"
        ],
        "opts": []
      },
      {
        "content": "font-smooth ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fsm"
        ],
        "opts": []
      },
      {
        "content": "font-smooth always",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fsm:aw"
        ],
        "opts": []
      },
      {
        "content": "font-smooth auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fsm:a"
        ],
        "opts": []
      },
      {
        "content": "font-smooth never",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fsm:n"
        ],
        "opts": []
      },
      {
        "content": "font-stretch ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fst"
        ],
        "opts": []
      },
      {
        "content": "font-stretch condensed",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fst:c"
        ],
        "opts": []
      },
      {
        "content": "font-stretch expanded",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fst:e"
        ],
        "opts": []
      },
      {
        "content": "font-stretch extra-condensed",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fst:ec"
        ],
        "opts": []
      },
      {
        "content": "font-stretch extra-expanded",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fst:ee"
        ],
        "opts": []
      },
      {
        "content": "font-stretch normal",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fst:n"
        ],
        "opts": []
      },
      {
        "content": "font-stretch semi-condensed",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fst:sc"
        ],
        "opts": []
      },
      {
        "content": "font-stretch semi-expanded",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fst:se"
        ],
        "opts": []
      },
      {
        "content": "font-stretch ultra-condensed",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fst:uc"
        ],
        "opts": []
      },
      {
        "content": "font-stretch ultra-expanded",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fst:ue"
        ],
        "opts": []
      },
      {
        "content": "font-style ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fs"
        ],
        "opts": []
      },
      {
        "content": "font-style italic",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fs:i"
        ],
        "opts": []
      },
      {
        "content": "font-style normal",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fs:n"
        ],
        "opts": []
      },
      {
        "content": "font-style oblique",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fs:o"
        ],
        "opts": []
      },
      {
        "content": "font-variant ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fv"
        ],
        "opts": []
      },
      {
        "content": "font-variant normal",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fv:n"
        ],
        "opts": []
      },
      {
        "content": "font-variant small-caps",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fv:sc"
        ],
        "opts": []
      },
      {
        "content": "font-weight ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fw"
        ],
        "opts": []
      },
      {
        "content": "font-weight bold",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fw:b"
        ],
        "opts": []
      },
      {
        "content": "font-weight bolder",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fw:br"
        ],
        "opts": []
      },
      {
        "content": "font-weight lighter",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fw:lr"
        ],
        "opts": []
      },
      {
        "content": "font-weight normal",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fw:n"
        ],
        "opts": []
      },
      {
        "content": "font ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "f"
        ],
        "opts": []
      },
      {
        "content": "grid ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "g"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-flow ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gaf"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-flow ${1:row} ${0:dense}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gaf+"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-flow row",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gaf:r"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-flow column",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gaf:c"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-flow dense",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gaf:d"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-flow row dense",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gaf:rd"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-flow column dense",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gaf:cd"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-rows ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gar"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-rows auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gar:a"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-rows max-content",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gar:mac"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-rows min-content",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gar:mic"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-columns ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gac"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-columns auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gac:a"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-columns max-content",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gac:mac"
        ],
        "opts": []
      },
      {
        "content": "grid-auto-columns min-content",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gac:mic"
        ],
        "opts": []
      },
      {
        "content": "grid-template ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gt"
        ],
        "opts": []
      },
      {
        "content": "grid-template ${1} / ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gt+"
        ],
        "opts": []
      },
      {
        "content": "grid-template-rows ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gtr"
        ],
        "opts": []
      },
      {
        "content": "grid-template-columns ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gtc"
        ],
        "opts": []
      },
      {
        "content": "grid-template-areas ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gta"
        ],
        "opts": []
      },
      {
        "content": "grid-gap ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gg"
        ],
        "opts": []
      },
      {
        "content": "grid-gap ${1} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gg+"
        ],
        "opts": []
      },
      {
        "content": "grid-gap 0",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gg:0"
        ],
        "opts": []
      },
      {
        "content": "grid-row-gap ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "grg"
        ],
        "opts": []
      },
      {
        "content": "grid-row-gap 0",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "grg:0"
        ],
        "opts": []
      },
      {
        "content": "grid-column-gap ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gcg"
        ],
        "opts": []
      },
      {
        "content": "grid-column-gap 0",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gcg:0"
        ],
        "opts": []
      },
      {
        "content": "grid-row ${1} / ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gr"
        ],
        "opts": []
      },
      {
        "content": "grid-row-start ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "grs"
        ],
        "opts": []
      },
      {
        "content": "grid-row-end ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gre"
        ],
        "opts": []
      },
      {
        "content": "grid-column ${1} / ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gc"
        ],
        "opts": []
      },
      {
        "content": "grid-column-start ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gcs"
        ],
        "opts": []
      },
      {
        "content": "grid-column-end ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gce"
        ],
        "opts": []
      },
      {
        "content": "height ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "h"
        ],
        "opts": []
      },
      {
        "content": "height auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "h:a"
        ],
        "opts": []
      },
      {
        "content": "left ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "l"
        ],
        "opts": []
      },
      {
        "content": "left auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "l:a"
        ],
        "opts": []
      },
      {
        "content": "letter-spacing ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lts"
        ],
        "opts": []
      },
      {
        "content": "line-height ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lh"
        ],
        "opts": []
      },
      {
        "content": "list-style-image url(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lisi"
        ],
        "opts": []
      },
      {
        "content": "list-style-image none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lisi:n"
        ],
        "opts": []
      },
      {
        "content": "list-style-position ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lisp"
        ],
        "opts": []
      },
      {
        "content": "list-style-position inside",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lisp:i"
        ],
        "opts": []
      },
      {
        "content": "list-style-position outside",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lisp:o"
        ],
        "opts": []
      },
      {
        "content": "list-style-type ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "list"
        ],
        "opts": []
      },
      {
        "content": "list-style-type circle",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "list:c"
        ],
        "opts": []
      },
      {
        "content": "list-style-type decimal-leading-zero",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "list:dclz"
        ],
        "opts": []
      },
      {
        "content": "list-style-type decimal",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "list:dc"
        ],
        "opts": []
      },
      {
        "content": "list-style-type disc",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "list:d"
        ],
        "opts": []
      },
      {
        "content": "list-style-type lower-roman",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "list:lr"
        ],
        "opts": []
      },
      {
        "content": "list-style-type none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "list:n"
        ],
        "opts": []
      },
      {
        "content": "list-style-type square",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "list:s"
        ],
        "opts": []
      },
      {
        "content": "list-style-type upper-roman",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "list:ur"
        ],
        "opts": []
      },
      {
        "content": "list-style ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lis"
        ],
        "opts": []
      },
      {
        "content": "list-style none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lis:n"
        ],
        "opts": []
      },
      {
        "content": "margin-bottom ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mb"
        ],
        "opts": []
      },
      {
        "content": "margin-bottom auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mb:a"
        ],
        "opts": []
      },
      {
        "content": "margin-left ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ml"
        ],
        "opts": []
      },
      {
        "content": "margin-left auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ml:a"
        ],
        "opts": []
      },
      {
        "content": "margin-right ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mr"
        ],
        "opts": []
      },
      {
        "content": "margin-right auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mr:a"
        ],
        "opts": []
      },
      {
        "content": "margin-top ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mt"
        ],
        "opts": []
      },
      {
        "content": "margin-top auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mt:a"
        ],
        "opts": []
      },
      {
        "content": "margin ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "m"
        ],
        "opts": []
      },
      {
        "content": "margin ${1:0} ${2:0} ${3:0} ${0:0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "m:4"
        ],
        "opts": []
      },
      {
        "content": "margin ${1:0} ${2:0} ${0:0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "m:3"
        ],
        "opts": []
      },
      {
        "content": "margin ${1:0} ${0:0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "m:2"
        ],
        "opts": []
      },
      {
        "content": "margin 0",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "m:0"
        ],
        "opts": []
      },
      {
        "content": "margin auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "m:a"
        ],
        "opts": []
      },
      {
        "content": "max-height ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mah"
        ],
        "opts": []
      },
      {
        "content": "max-height none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mah:n"
        ],
        "opts": []
      },
      {
        "content": "max-width ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "maw"
        ],
        "opts": []
      },
      {
        "content": "max-width none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "maw:n"
        ],
        "opts": []
      },
      {
        "content": "min-height ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mih"
        ],
        "opts": []
      },
      {
        "content": "min-width ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "miw"
        ],
        "opts": []
      },
      {
        "content": "opacity ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "op"
        ],
        "opts": []
      },
      {
        "content": "filter progid:DXImageTransform.Microsoft.Alpha(Opacity=${0:100})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "op:ie"
        ],
        "opts": []
      },
      {
        "content": "-ms-filter 'progid:DXImageTransform.Microsoft.Alpha(Opacity=${0:100})'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "op:ms"
        ],
        "opts": []
      },
      {
        "content": "orphans ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "orp"
        ],
        "opts": []
      },
      {
        "content": "outline ${1:1px} ${2:solid} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "o+"
        ],
        "opts": []
      },
      {
        "content": "outline-color ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "oc"
        ],
        "opts": []
      },
      {
        "content": "outline-color invert",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "oc:i"
        ],
        "opts": []
      },
      {
        "content": "outline-offset ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "oo"
        ],
        "opts": []
      },
      {
        "content": "outline-style ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "os"
        ],
        "opts": []
      },
      {
        "content": "outline-width ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ow"
        ],
        "opts": []
      },
      {
        "content": "outline ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "o"
        ],
        "opts": []
      },
      {
        "content": "outline none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "o:n"
        ],
        "opts": []
      },
      {
        "content": "overflow-style ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovs"
        ],
        "opts": []
      },
      {
        "content": "overflow-style auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovs:a"
        ],
        "opts": []
      },
      {
        "content": "overflow-style marquee",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovs:mq"
        ],
        "opts": []
      },
      {
        "content": "overflow-style move",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovs:mv"
        ],
        "opts": []
      },
      {
        "content": "overflow-style panner",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovs:p"
        ],
        "opts": []
      },
      {
        "content": "overflow-style scrollbar",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovs:s"
        ],
        "opts": []
      },
      {
        "content": "overflow-x ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovx"
        ],
        "opts": []
      },
      {
        "content": "overflow-x auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovx:a"
        ],
        "opts": []
      },
      {
        "content": "overflow-x hidden",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovx:h"
        ],
        "opts": []
      },
      {
        "content": "overflow-x scroll",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovx:s"
        ],
        "opts": []
      },
      {
        "content": "overflow-x visible",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovx:v"
        ],
        "opts": []
      },
      {
        "content": "overflow-y ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovy"
        ],
        "opts": []
      },
      {
        "content": "overflow-y auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovy:a"
        ],
        "opts": []
      },
      {
        "content": "overflow-y hidden",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovy:h"
        ],
        "opts": []
      },
      {
        "content": "overflow-y scroll",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovy:s"
        ],
        "opts": []
      },
      {
        "content": "overflow-y visible",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ovy:v"
        ],
        "opts": []
      },
      {
        "content": "overflow ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ov"
        ],
        "opts": []
      },
      {
        "content": "overflow auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ov:a"
        ],
        "opts": []
      },
      {
        "content": "overflow hidden",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ov:h"
        ],
        "opts": []
      },
      {
        "content": "overflow scroll",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ov:s"
        ],
        "opts": []
      },
      {
        "content": "overflow visible",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ov:v"
        ],
        "opts": []
      },
      {
        "content": "padding-bottom ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pb"
        ],
        "opts": []
      },
      {
        "content": "padding-left ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pl"
        ],
        "opts": []
      },
      {
        "content": "padding-right ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pr"
        ],
        "opts": []
      },
      {
        "content": "padding-top ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pt"
        ],
        "opts": []
      },
      {
        "content": "padding ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p"
        ],
        "opts": []
      },
      {
        "content": "padding ${1:0} ${2:0} ${3:0} ${0:0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p:4"
        ],
        "opts": []
      },
      {
        "content": "padding ${1:0} ${2:0} ${0:0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p:3"
        ],
        "opts": []
      },
      {
        "content": "padding ${1:0} ${0:0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p:2"
        ],
        "opts": []
      },
      {
        "content": "padding 0",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "p:0"
        ],
        "opts": []
      },
      {
        "content": "place-content ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc"
        ],
        "opts": []
      },
      {
        "content": "place-content ${1} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc+"
        ],
        "opts": []
      },
      {
        "content": "place-content start",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc:s"
        ],
        "opts": []
      },
      {
        "content": "place-content end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc:e"
        ],
        "opts": []
      },
      {
        "content": "place-content center",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc:c"
        ],
        "opts": []
      },
      {
        "content": "place-content flex-start",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc:fs"
        ],
        "opts": []
      },
      {
        "content": "place-content flex-end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc:fe"
        ],
        "opts": []
      },
      {
        "content": "place-content space-between",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc:sb"
        ],
        "opts": []
      },
      {
        "content": "place-content space-around",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc:sa"
        ],
        "opts": []
      },
      {
        "content": "place-content space-evenly",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc:se"
        ],
        "opts": []
      },
      {
        "content": "place-content stretch",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pc:st"
        ],
        "opts": []
      },
      {
        "content": "page-break-after ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgba"
        ],
        "opts": []
      },
      {
        "content": "page-break-after always",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgba:aw"
        ],
        "opts": []
      },
      {
        "content": "page-break-after auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgba:a"
        ],
        "opts": []
      },
      {
        "content": "page-break-after left",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgba:l"
        ],
        "opts": []
      },
      {
        "content": "page-break-after right",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgba:r"
        ],
        "opts": []
      },
      {
        "content": "page-break-before ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgbb"
        ],
        "opts": []
      },
      {
        "content": "page-break-before always",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgbb:aw"
        ],
        "opts": []
      },
      {
        "content": "page-break-before auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgbb:a"
        ],
        "opts": []
      },
      {
        "content": "page-break-before left",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgbb:l"
        ],
        "opts": []
      },
      {
        "content": "page-break-before right",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgbb:r"
        ],
        "opts": []
      },
      {
        "content": "page-break-inside ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgbi"
        ],
        "opts": []
      },
      {
        "content": "page-break-inside auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgbi:a"
        ],
        "opts": []
      },
      {
        "content": "page-break-inside avoid",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pgbi:av"
        ],
        "opts": []
      },
      {
        "content": "place-items ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pi"
        ],
        "opts": []
      },
      {
        "content": "place-items ${1:stretch} ${0:stretch}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pi+"
        ],
        "opts": []
      },
      {
        "content": "place-items start",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pi:s"
        ],
        "opts": []
      },
      {
        "content": "place-items end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pi:e"
        ],
        "opts": []
      },
      {
        "content": "place-items center",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pi:c"
        ],
        "opts": []
      },
      {
        "content": "place-items stretch",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pi:st"
        ],
        "opts": []
      },
      {
        "content": "position ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pos"
        ],
        "opts": []
      },
      {
        "content": "position absolute",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pos:a"
        ],
        "opts": []
      },
      {
        "content": "position fixed",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pos:f"
        ],
        "opts": []
      },
      {
        "content": "position relative",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pos:r"
        ],
        "opts": []
      },
      {
        "content": "position static",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pos:s"
        ],
        "opts": []
      },
      {
        "content": "place-self ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ps"
        ],
        "opts": []
      },
      {
        "content": "place-self ${1:stretch} ${0:stretch}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ps+"
        ],
        "opts": []
      },
      {
        "content": "place-self start",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ps:s"
        ],
        "opts": []
      },
      {
        "content": "place-self end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ps:e"
        ],
        "opts": []
      },
      {
        "content": "place-self center",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ps:c"
        ],
        "opts": []
      },
      {
        "content": "place-self stretch",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ps:st"
        ],
        "opts": []
      },
      {
        "content": "quotes ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "q"
        ],
        "opts": []
      },
      {
        "content": "quotes '\\201C' '\\201D' '\\2018' '\\2019'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "q:en"
        ],
        "opts": []
      },
      {
        "content": "quotes none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "q:n"
        ],
        "opts": []
      },
      {
        "content": "quotes '\\00AB' '\\00BB' '\\201E' '\\201C'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "q:ru"
        ],
        "opts": []
      },
      {
        "content": "resize ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rz"
        ],
        "opts": []
      },
      {
        "content": "resize both",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rz:b"
        ],
        "opts": []
      },
      {
        "content": "resize horizontal",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rz:h"
        ],
        "opts": []
      },
      {
        "content": "resize none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rz:n"
        ],
        "opts": []
      },
      {
        "content": "resize vertical",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rz:v"
        ],
        "opts": []
      },
      {
        "content": "right ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "r"
        ],
        "opts": []
      },
      {
        "content": "right auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "r:a"
        ],
        "opts": []
      },
      {
        "content": "table-layout ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tbl"
        ],
        "opts": []
      },
      {
        "content": "table-layout auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tbl:a"
        ],
        "opts": []
      },
      {
        "content": "table-layout fixed",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tbl:f"
        ],
        "opts": []
      },
      {
        "content": "text-align-last ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tal"
        ],
        "opts": []
      },
      {
        "content": "text-align-last auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tal:a"
        ],
        "opts": []
      },
      {
        "content": "text-align-last center",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tal:c"
        ],
        "opts": []
      },
      {
        "content": "text-align-last left",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tal:l"
        ],
        "opts": []
      },
      {
        "content": "text-align-last right",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tal:r"
        ],
        "opts": []
      },
      {
        "content": "text-align ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ta"
        ],
        "opts": []
      },
      {
        "content": "text-align center",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ta:c"
        ],
        "opts": []
      },
      {
        "content": "text-align left",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ta:l"
        ],
        "opts": []
      },
      {
        "content": "text-align right",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ta:r"
        ],
        "opts": []
      },
      {
        "content": "text-decoration ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "td"
        ],
        "opts": []
      },
      {
        "content": "text-decoration line-through",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "td:l"
        ],
        "opts": []
      },
      {
        "content": "text-decoration none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "td:n"
        ],
        "opts": []
      },
      {
        "content": "text-decoration overline",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "td:o"
        ],
        "opts": []
      },
      {
        "content": "text-decoration underline",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "td:u"
        ],
        "opts": []
      },
      {
        "content": "text-emphasis ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "te"
        ],
        "opts": []
      },
      {
        "content": "text-emphasis accent",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "te:ac"
        ],
        "opts": []
      },
      {
        "content": "text-emphasis after",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "te:a"
        ],
        "opts": []
      },
      {
        "content": "text-emphasis before",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "te:b"
        ],
        "opts": []
      },
      {
        "content": "text-emphasis circle",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "te:c"
        ],
        "opts": []
      },
      {
        "content": "text-emphasis disc",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "te:ds"
        ],
        "opts": []
      },
      {
        "content": "text-emphasis dot",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "te:dt"
        ],
        "opts": []
      },
      {
        "content": "text-emphasis none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "te:n"
        ],
        "opts": []
      },
      {
        "content": "text-height ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "th"
        ],
        "opts": []
      },
      {
        "content": "text-height auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "th:a"
        ],
        "opts": []
      },
      {
        "content": "text-height font-size",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "th:f"
        ],
        "opts": []
      },
      {
        "content": "text-height max-size",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "th:m"
        ],
        "opts": []
      },
      {
        "content": "text-height text-size",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "th:t"
        ],
        "opts": []
      },
      {
        "content": "text-indent ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ti"
        ],
        "opts": []
      },
      {
        "content": "text-indent -9999px",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ti:-"
        ],
        "opts": []
      },
      {
        "content": "text-justify ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tj"
        ],
        "opts": []
      },
      {
        "content": "text-justify auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tj:a"
        ],
        "opts": []
      },
      {
        "content": "text-justify distribute",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tj:d"
        ],
        "opts": []
      },
      {
        "content": "text-justify inter-cluster",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tj:ic"
        ],
        "opts": []
      },
      {
        "content": "text-justify inter-ideograph",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tj:ii"
        ],
        "opts": []
      },
      {
        "content": "text-justify inter-word",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tj:iw"
        ],
        "opts": []
      },
      {
        "content": "text-justify kashida",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tj:k"
        ],
        "opts": []
      },
      {
        "content": "text-justify tibetan",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tj:t"
        ],
        "opts": []
      },
      {
        "content": "text-outline ${1:0} ${2:0} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "to+"
        ],
        "opts": []
      },
      {
        "content": "text-outline ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "to"
        ],
        "opts": []
      },
      {
        "content": "text-outline none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "to:n"
        ],
        "opts": []
      },
      {
        "content": "text-replace ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tr"
        ],
        "opts": []
      },
      {
        "content": "text-replace none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tr:n"
        ],
        "opts": []
      },
      {
        "content": "text-shadow ${1:0} ${2:0} ${3:0} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tsh+"
        ],
        "opts": []
      },
      {
        "content": "text-shadow ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tsh"
        ],
        "opts": []
      },
      {
        "content": "text-shadow none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tsh:n"
        ],
        "opts": []
      },
      {
        "content": "text-transform ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tt"
        ],
        "opts": []
      },
      {
        "content": "text-transform capitalize",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tt:c"
        ],
        "opts": []
      },
      {
        "content": "text-transform lowercase",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tt:l"
        ],
        "opts": []
      },
      {
        "content": "text-transform none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tt:n"
        ],
        "opts": []
      },
      {
        "content": "text-transform uppercase",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tt:u"
        ],
        "opts": []
      },
      {
        "content": "text-wrap ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tw"
        ],
        "opts": []
      },
      {
        "content": "text-wrap none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tw:no"
        ],
        "opts": []
      },
      {
        "content": "text-wrap normal",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tw:n"
        ],
        "opts": []
      },
      {
        "content": "text-wrap suppress",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tw:s"
        ],
        "opts": []
      },
      {
        "content": "text-wrap unrestricted",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tw:u"
        ],
        "opts": []
      },
      {
        "content": "top ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "t"
        ],
        "opts": []
      },
      {
        "content": "top auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "t:a"
        ],
        "opts": []
      },
      {
        "content": "vertical-align ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "va"
        ],
        "opts": []
      },
      {
        "content": "vertical-align baseline",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "va:bl"
        ],
        "opts": []
      },
      {
        "content": "vertical-align bottom",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "va:b"
        ],
        "opts": []
      },
      {
        "content": "vertical-align middle",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "va:m"
        ],
        "opts": []
      },
      {
        "content": "vertical-align sub",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "va:sub"
        ],
        "opts": []
      },
      {
        "content": "vertical-align super",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "va:sup"
        ],
        "opts": []
      },
      {
        "content": "vertical-align text-bottom",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "va:tb"
        ],
        "opts": []
      },
      {
        "content": "vertical-align text-top",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "va:tt"
        ],
        "opts": []
      },
      {
        "content": "vertical-align top",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "va:t"
        ],
        "opts": []
      },
      {
        "content": "visibility ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "v"
        ],
        "opts": []
      },
      {
        "content": "visibility collapse",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "v:c"
        ],
        "opts": []
      },
      {
        "content": "visibility hidden",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "v:h"
        ],
        "opts": []
      },
      {
        "content": "visibility visible",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "v:v"
        ],
        "opts": []
      },
      {
        "content": "white-space-collapse ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whsc"
        ],
        "opts": []
      },
      {
        "content": "white-space-collapse break-all",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whsc:ba"
        ],
        "opts": []
      },
      {
        "content": "white-space-collapse break-strict",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whsc:bs"
        ],
        "opts": []
      },
      {
        "content": "white-space-collapse keep-all",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whsc:k"
        ],
        "opts": []
      },
      {
        "content": "white-space-collapse loose",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whsc:l"
        ],
        "opts": []
      },
      {
        "content": "white-space-collapse normal",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whsc:n"
        ],
        "opts": []
      },
      {
        "content": "white-space ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whs"
        ],
        "opts": []
      },
      {
        "content": "white-space normal",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whs:n"
        ],
        "opts": []
      },
      {
        "content": "white-space nowrap",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whs:nw"
        ],
        "opts": []
      },
      {
        "content": "white-space pre-line",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whs:pl"
        ],
        "opts": []
      },
      {
        "content": "white-space pre-wrap",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whs:pw"
        ],
        "opts": []
      },
      {
        "content": "white-space pre",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "whs:p"
        ],
        "opts": []
      },
      {
        "content": "widows ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wid"
        ],
        "opts": []
      },
      {
        "content": "width ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "w"
        ],
        "opts": []
      },
      {
        "content": "width auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "w:a"
        ],
        "opts": []
      },
      {
        "content": "word-break ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wob"
        ],
        "opts": []
      },
      {
        "content": "word-break break-all",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wob:ba"
        ],
        "opts": []
      },
      {
        "content": "word-break break-strict",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wob:bs"
        ],
        "opts": []
      },
      {
        "content": "word-break keep-all",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wob:k"
        ],
        "opts": []
      },
      {
        "content": "word-break loose",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wob:l"
        ],
        "opts": []
      },
      {
        "content": "word-break normal",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wob:n"
        ],
        "opts": []
      },
      {
        "content": "word-spacing ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wos"
        ],
        "opts": []
      },
      {
        "content": "word-wrap ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wow"
        ],
        "opts": []
      },
      {
        "content": "word-wrap none",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wow:no"
        ],
        "opts": []
      },
      {
        "content": "word-wrap normal",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wow:n"
        ],
        "opts": []
      },
      {
        "content": "word-wrap suppress",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wow:s"
        ],
        "opts": []
      },
      {
        "content": "word-wrap unrestricted",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wow:u"
        ],
        "opts": []
      },
      {
        "content": "z-index ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "z"
        ],
        "opts": []
      },
      {
        "content": "z-index auto",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "z:a"
        ],
        "opts": []
      },
      {
        "content": "zoom 1",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "zoo"
        ],
        "opts": []
      },
      {
        "content": ":hover",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ":h"
        ],
        "opts": []
      },
      {
        "content": ":first-child",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ":fc"
        ],
        "opts": []
      },
      {
        "content": ":last-child",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ":lc"
        ],
        "opts": []
      },
      {
        "content": ":nth-child(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ":nc"
        ],
        "opts": []
      },
      {
        "content": ":nth-last-child(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ":nlc"
        ],
        "opts": []
      },
      {
        "content": ":only-child",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ":oc"
        ],
        "opts": []
      },
      {
        "content": ":after",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ":a"
        ],
        "opts": []
      },
      {
        "content": ":before",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ":b"
        ],
        "opts": []
      },
      {
        "content": "::after",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "::a"
        ],
        "opts": []
      },
      {
        "content": "::before",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "::b"
        ],
        "opts": []
      },
      {
        "content": "if ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "${1}(${0})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mix"
        ],
        "opts": []
      },
      {
        "content": "for ${1:i} in ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "@keyframes ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "keyf"
        ],
        "opts": []
      },
      {
        "content": "justify-content ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc"
        ],
        "opts": []
      },
      {
        "content": "justify-content start",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc:s"
        ],
        "opts": []
      },
      {
        "content": "justify-content end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc:e"
        ],
        "opts": []
      },
      {
        "content": "justify-content center",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc:c"
        ],
        "opts": []
      },
      {
        "content": "justify-content flex-start",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc:fs"
        ],
        "opts": []
      },
      {
        "content": "justify-content flex-end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc:fe"
        ],
        "opts": []
      },
      {
        "content": "justify-content space-between",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc:sb"
        ],
        "opts": []
      },
      {
        "content": "justify-content space-around",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc:sa"
        ],
        "opts": []
      },
      {
        "content": "justify-content space-evenly",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc:se"
        ],
        "opts": []
      },
      {
        "content": "justify-content space-evenly",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc:st"
        ],
        "opts": []
      },
      {
        "content": "justify-content left",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc:l"
        ],
        "opts": []
      },
      {
        "content": "justify-content right",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "jc:r"
        ],
        "opts": []
      },
      {
        "content": "justify-items ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ji"
        ],
        "opts": []
      },
      {
        "content": "justify-items start",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ji:s"
        ],
        "opts": []
      },
      {
        "content": "justify-items end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ji:e"
        ],
        "opts": []
      },
      {
        "content": "justify-items center",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ji:c"
        ],
        "opts": []
      },
      {
        "content": "justify-items stretch",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ji:st"
        ],
        "opts": []
      },
      {
        "content": "justify-self ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "js"
        ],
        "opts": []
      },
      {
        "content": "justify-self start",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "js:s"
        ],
        "opts": []
      },
      {
        "content": "justify-self end",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "js:e"
        ],
        "opts": []
      },
      {
        "content": "justify-self center",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "js:c"
        ],
        "opts": []
      },
      {
        "content": "justify-self stretch",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "js:st"
        ],
        "opts": []
      }
    ],
    "supercollider": [
      {
        "content": "(\n\t${0}\n)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "b"
        ],
        "opts": []
      },
      {
        "content": "if (${1}) {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "if (${1}) {\n\t${2}\n} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "for (${1:1}, ${2:10}) { |i|\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "SynthDef(\\\\${1:synthName}, {${2}\n\t${0}\n}).add;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sdef"
        ],
        "opts": []
      },
      {
        "content": "for (${1:1}, ${2:10}) {${3: |i}|}\n\t$0\n}",
        "doc": null,
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "SynthDef(\\\\${1:synthName}, {${2: |${3:x}|}\n\t$0\n}).add;",
        "doc": null,
        "grammar": "snu",
        "label": null,
        "matches": [
          "sdef"
        ],
        "opts": []
      }
    ],
    "svelte": [
      {
        "content": "<script>\n\t${1:// your script goes here}\n</script>\n\n<style>\n\t${2:/* your styles go here */}\n</style>\n\n${3:<!-- markup (zero or more items) goes here -->}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-component-format",
        "matches": [
          "svcomponent",
          "svelte component template"
        ],
        "opts": []
      },
      {
        "content": "<script>\n\t${1:// your script goes here}\n</script>",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-script-tag",
        "matches": [
          "svelte script",
          "svscript"
        ],
        "opts": []
      },
      {
        "content": "<script context=\"module\">\n\t${1:// your script goes here}\n</script>",
        "doc": "add a script with context=\"module\" to your svelte file",
        "grammar": "lsp",
        "label": "svelte-script-context",
        "matches": [
          "svelte script context",
          "svscriptc"
        ],
        "opts": []
      },
      {
        "content": "<style>\n\t${1:/* your styles go here */}\n</style>",
        "doc": "add styles to your svelte file",
        "grammar": "lsp",
        "label": "svelte-style-tag",
        "matches": [
          "svstyle",
          "svelte style"
        ],
        "opts": []
      },
      {
        "content": "{${1:expression}}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-expression",
        "matches": [
          "svexp",
          "svelte expression"
        ],
        "opts": []
      },
      {
        "content": "{@html ${1:expression}}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-expression-html",
        "matches": [
          "svexphtml",
          "svelte expression html"
        ],
        "opts": []
      },
      {
        "content": "{@debug ${1:var1}${2:,var2}}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-expression-debug",
        "matches": [
          "svelte expression debug",
          "svexpdebug"
        ],
        "opts": []
      },
      {
        "content": "{#if ${1:condition}}\n\t${2: <!-- content here -->}\n{/if}",
        "doc": "if block",
        "grammar": "lsp",
        "label": "svelte-if-block",
        "matches": [
          "svif",
          "svelte if-block"
        ],
        "opts": []
      },
      {
        "content": "{#if ${1:condition}}\n\t${2: <!-- content here -->}\n{:else}\n\t${3: <!-- else content here -->}\n{/if}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-if-else-block",
        "matches": [
          "svelte if else",
          "svif-else"
        ],
        "opts": []
      },
      {
        "content": "{:else}\n\t${1: <!-- else content here -->}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-else-block",
        "matches": [
          "svelte else",
          "svelse"
        ],
        "opts": []
      },
      {
        "content": "{#if ${1:condition}}\n\t${2: <!-- content here -->}\n{:else if ${3: otherCondition}}\n\t${4: <!-- else if content here -->}\n{:else}\n\t${5: <!-- else content here -->}\n{/if}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-if-else-if-block",
        "matches": [
          "svelte if else if",
          "svif-else-if"
        ],
        "opts": []
      },
      {
        "content": "{:else if ${1: otherCondition}}\n\t${2: <!-- else if content here -->}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-else-if-block",
        "matches": [
          "svelte else if",
          "svelse-if"
        ],
        "opts": []
      },
      {
        "content": "{#each ${1:items} as ${2:item}}\n\t${3: <!-- content here -->}\n{/each}",
        "doc": "each block",
        "grammar": "lsp",
        "label": "svelte-each-block",
        "matches": [
          "svelte each",
          "sveach"
        ],
        "opts": []
      },
      {
        "content": "{#each ${1:items} as ${2:item}}\n\t${3: <!-- content here -->}\n{:else}\n\t${4: <!-- empty list -->}\n{/each}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-each-else-block",
        "matches": [
          "svelte each else",
          "sveach-else"
        ],
        "opts": []
      },
      {
        "content": "{#each ${1:items} as ${2:item}, ${3:i}}\n\t${4: <!-- content here -->}\n{/each}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-each-index-block",
        "matches": [
          "svelte each index",
          "sveach-index"
        ],
        "opts": []
      },
      {
        "content": "{#each ${1:items} as ${2:item}, (${3:key})}\n\t${4: <!-- content here -->}\n{/each}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-each-key-block",
        "matches": [
          "sveach-key",
          "svelte each key"
        ],
        "opts": []
      },
      {
        "content": "{#each ${1:items} as ${2:item}, i (${3:key})}\n\t${4: <!-- content here -->}\n{/each}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-each-index-key-block",
        "matches": [
          "sveach-i-k",
          "svelte each index key"
        ],
        "opts": []
      },
      {
        "content": "{#await ${1:promise}}\n\t${2: <!-- content when promise is pending -->}\n{:then ${3:value}}\n\t${4: <!-- content when promise was fulfilled -->}\n{/await}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-await-then-block",
        "matches": [
          "svelte await then",
          "svawait"
        ],
        "opts": []
      },
      {
        "content": "{:then ${1:value}}\n\t${2: <!-- content when promise was fulfilled -->}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-then-block",
        "matches": [
          "svthen",
          "svelte then"
        ],
        "opts": []
      },
      {
        "content": "{#await ${1:promise} then ${2:value}}\n\t${3: <!-- content when promise was fulfilled -->}\n{/await}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-await-short-block",
        "matches": [
          "svelte await short",
          "svawait-short"
        ],
        "opts": []
      },
      {
        "content": "{#await ${1:promise}}\n\t${2: <!-- content when promise is pending -->}\n{:then ${3:value}}\n\t${4: <!-- content when promise was fulfilled -->}\n{:catch error}\n\t${5: <!-- content when promise was rejected -->}\n{/await}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-await-catch-block",
        "matches": [
          "svawait-catch",
          "svelte await catch"
        ],
        "opts": []
      },
      {
        "content": "{:catch error}\n\t<!-- promise was rejected -->",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-catch-block",
        "matches": [
          "svelte catch",
          "svcatch"
        ],
        "opts": []
      },
      {
        "content": "on:${1:eventname}={${2:handler}}",
        "doc": "on event",
        "grammar": "lsp",
        "label": "svelte-on-event",
        "matches": [
          "svelte on event",
          "svon"
        ],
        "opts": []
      },
      {
        "content": "on:${1:eventname}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-on-event-forward",
        "matches": [
          "svon-foward",
          "svelte on event foward"
        ],
        "opts": []
      },
      {
        "content": "on:${1:eventname}|${2|preventDefault,stopPropagation,passive,capture,once|}={${3:handler}}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-on-event-modifiers",
        "matches": [
          "svon-modifiers",
          "svelte on event modifiers"
        ],
        "opts": []
      },
      {
        "content": "on:${1:click}=\"{() => ${2:count += 1}}\"",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-on-event-inline",
        "matches": [
          "svon-inline",
          "svelte on event inline"
        ],
        "opts": []
      },
      {
        "content": "|${1|preventDefault,stopPropagation,passive,capture,once|}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-modifiers",
        "matches": [
          "svmodifier",
          "svelte modifier"
        ],
        "opts": []
      },
      {
        "content": "bind:${1:property}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-bind",
        "matches": [
          "svbind-simple",
          "svelte bind"
        ],
        "opts": []
      },
      {
        "content": "bind:${1:property}={${2:variable}}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-bind-property",
        "matches": [
          "svelte bind property",
          "svbind-property"
        ],
        "opts": []
      },
      {
        "content": "<video\nsrc={${1:clip}}\nbind:${2:duration}\nbind:${3:buffered}\nbind:${4:seekable}\nbind:${5:played}\nbind:${6:currentTime}\nbind:${7:paused}\nbind:${8:volume}\n></video>",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-bind-video",
        "matches": [
          "svbind-video",
          "svelte bind video"
        ],
        "opts": []
      },
      {
        "content": "bind:${1|clientWidth,clientHeight,offsetWidth,offsetHeight|}={${2:variable}}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-bind-block-level",
        "matches": [
          "svelte bind level",
          "svbind-level"
        ],
        "opts": []
      },
      {
        "content": "bind:group={${1:variable}}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-bind-group",
        "matches": [
          "svbind-group",
          "svelte bind group"
        ],
        "opts": []
      },
      {
        "content": "bind:this={${1:dom_node}}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-bind-this",
        "matches": [
          "svbind-this",
          "svelte bind this"
        ],
        "opts": []
      },
      {
        "content": "class:${1:name}={${2:condition}}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-class",
        "matches": [
          "svcl",
          "svelte class"
        ],
        "opts": []
      },
      {
        "content": "class:${1:name}}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-class-short",
        "matches": [
          "svcls",
          "svelte class short"
        ],
        "opts": []
      },
      {
        "content": "use:action",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-use",
        "matches": [
          "svu",
          "svelte use"
        ],
        "opts": []
      },
      {
        "content": "use:action={${1:parameters}}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-use-parameters",
        "matches": [
          "svelte use parameters",
          "svupar"
        ],
        "opts": []
      },
      {
        "content": "${1|transition,in,out|}:${2:name}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-transition",
        "matches": [
          "svelte transition",
          "svt"
        ],
        "opts": []
      },
      {
        "content": "${1|transition,in,out|}:${2:name}={${3:params}}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-transition-params",
        "matches": [
          "svelte transition params",
          "svtp"
        ],
        "opts": []
      },
      {
        "content": "on:${1|introstart,introend,outrostart,outroend|}=\"{() => status = '${1|introstart,introend,outrostart,outroend|}'}\"",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-transition-events",
        "matches": [
          "svte",
          "svelte transition events"
        ],
        "opts": []
      },
      {
        "content": "${1|transition,in,out|}:${2:name}|${3:local}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-transition-local",
        "matches": [
          "svtl",
          "svelte transition local"
        ],
        "opts": []
      },
      {
        "content": "${1|transition,in,out|}:${2:name}|${3:local}={${4:params}}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-transition-all",
        "matches": [
          "svta",
          "svelte transition all"
        ],
        "opts": []
      },
      {
        "content": "animate:${1:name}={${2:params}}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-animate",
        "matches": [
          "sva",
          "svelte animate"
        ],
        "opts": []
      },
      {
        "content": "<slot>${1:<!-- optional fallback -->}</slot>",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-slot",
        "matches": [
          "svelte slot",
          "svsl"
        ],
        "opts": []
      },
      {
        "content": "<slot name=\"${1:x}\">${2:<!-- optional fallback -->}</slot>",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-slot-name",
        "matches": [
          "svelte slot name",
          "svsn"
        ],
        "opts": []
      },
      {
        "content": "<slot ${1:prop}={${2:value}}>${3:<!-- optional fallback -->}</slot>",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-slot-prop",
        "matches": [
          "svelte slot prop",
          "svsp"
        ],
        "opts": []
      },
      {
        "content": "<svelte:self />",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-self",
        "matches": [
          "svelte self",
          "svse"
        ],
        "opts": []
      },
      {
        "content": "<svelte:self ${1:prop}={${2:value}} />",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-self-prop",
        "matches": [
          "svsep",
          "svelte self prop"
        ],
        "opts": []
      },
      {
        "content": "<svelte:component this={${1:component}} />",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-component",
        "matches": [
          "svelte component",
          "svc"
        ],
        "opts": []
      },
      {
        "content": "<svelte:window />",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-window",
        "matches": [
          "svelte window",
          "svw"
        ],
        "opts": []
      },
      {
        "content": "bind:${1|innerWidth,innerHeight,outerWidth,outerHeight,scrollX,scrollY,online|}={${2:variable}}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-window-bind",
        "matches": [
          "svelte window bind",
          "svwb"
        ],
        "opts": []
      },
      {
        "content": "<svelte:body />",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-body",
        "matches": [
          "svb",
          "svelte body"
        ],
        "opts": []
      },
      {
        "content": "<svelte:head>\n\t${1:<!-- head content -->}\n</svelte:head>",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-head",
        "matches": [
          "svelte head",
          "svh"
        ],
        "opts": []
      },
      {
        "content": "<svelte:options ${1|immutable,accessors,namespace,tag|}={${2:value}}/>",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-options",
        "matches": [
          "svelte options",
          "svop"
        ],
        "opts": []
      },
      {
        "content": "const component = new ${1:App}({\n\ttarget: ${2|target,document.body|},\n\tprops: ${3:props},\n\tanchor: ${4:anchor},\n\thydrate: ${5|false,true|},\n\tintro: ${5|false,true|}\n})",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-create-component",
        "matches": [
          "svcreate-component",
          "svelte create component"
        ],
        "opts": []
      },
      {
        "content": "$: ${1:variable} = ${2:prop}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-reactive-statement",
        "matches": [
          "svelte reactive statement",
          "svrs"
        ],
        "opts": []
      },
      {
        "content": "$: { ${1:console.log(${2:prop});}}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-reactive-block",
        "matches": [
          "svelte reactive",
          "svrb"
        ],
        "opts": []
      },
      {
        "content": "function ${1:foo}(node) {\n\t// the node has been mounted in the DOM\n\treturn {\n\t\tdestroy() {\n\t\t\t// the node has been removed from the DOM\n\t\t}\n\t};\n}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-action",
        "matches": [
          "svelte action",
          "svaction"
        ],
        "opts": []
      },
      {
        "content": "function ${1:foo}(node, ${2:parameters}) {\n\t// the node has been mounted in the DOM\n\treturn {\n\t\tdestroy() {\n\t\t\t// the node has been removed from the DOM\n\t\t}\n\t};\n}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-action-parameters",
        "matches": [
          "svelte action parameters",
          "svactionp"
        ],
        "opts": []
      },
      {
        "content": "function ${1:foo}(node, ${2:parameters}) {\n\t// the node has been mounted in the DOM\n\treturn {\n\t\tupdate(${2:parameters}) {\n\t\t\t// the value of `${2:parameters}` has changed\n\t\t}\n\t\tdestroy() {\n\t\t\t// the node has been removed from the DOM\n\t\t}\n\t};\n}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-action-update",
        "matches": [
          "svelte action update",
          "svactionu"
        ],
        "opts": []
      },
      {
        "content": "onMount(() => {\n\t${1:// content here}\n});",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-on-mount",
        "matches": [
          "svlfm",
          "svelte lifecycle mount"
        ],
        "opts": []
      },
      {
        "content": "beforeUpdate(() => {\n\t${1:// content here}\n});",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-before-update",
        "matches": [
          "svelte lifecycle before update",
          "svlfbu"
        ],
        "opts": []
      },
      {
        "content": "afterUpdate(() => {\n\t${1:// content here}\n});",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-after-update",
        "matches": [
          "svelte lifecycle-after-update",
          "svlfap"
        ],
        "opts": []
      },
      {
        "content": "onDestroy(() => {\n\t${1:// content here}\n});",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-on-destroy",
        "matches": [
          "svelte lifecycle destroy",
          "svlfd"
        ],
        "opts": []
      },
      {
        "content": "await tick()",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-tick",
        "matches": [
          "svelte tick",
          "sv-tick"
        ],
        "opts": []
      },
      {
        "content": "setContext(${1:key}, ${2:context})",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-set-context",
        "matches": [
          "svelte set content",
          "sv-content"
        ],
        "opts": []
      },
      {
        "content": "getContext(${1:key})",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-get-context",
        "matches": [
          "svgetc",
          "svelte get content"
        ],
        "opts": []
      },
      {
        "content": "const dispatch = createEventDispatcher();",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-dispatch",
        "matches": [
          "svdp",
          "svelte dispatch"
        ],
        "opts": []
      },
      {
        "content": "dispatch(${1:key},${2:data})",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-dispatch-event",
        "matches": [
          "svdpe",
          "svelte dispatch event"
        ],
        "opts": []
      },
      {
        "content": "const ${1:store} = writable(${2:initialValue});",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-writeable",
        "matches": [
          "svelte writeable",
          "svw"
        ],
        "opts": []
      },
      {
        "content": "const ${1:store} = writable(${2:initialValue}, () => {\n\t${3:console.log('got a subscriber');}\n\treturn () => ${4:console.log('no more subscribers');}\n});",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-writeable-set",
        "matches": [
          "svwt",
          "svelte writeable set"
        ],
        "opts": []
      },
      {
        "content": "const ${1:store} = readable(${2:initialValue}, () => {\n\t${3:console.log('got a subscriber');}\n\treturn () => ${4:console.log('no more subscribers');}\n});",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-readable",
        "matches": [
          "svr",
          "svelte readable"
        ],
        "opts": []
      },
      {
        "content": "const ${1:derivedStore} = derived(${2:storeA}, $${2:storeA} => $${2:storeA} * 2);",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-derived",
        "matches": [
          "svelte derived",
          "svder"
        ],
        "opts": []
      },
      {
        "content": "const ${1:derivedStore} = derived([${2:storeA}, ${3:storeB}], ([$${2:storeA}, $${3:storeB}]) => $${2:storeA} + $${3:storeB});",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-derived-multiple",
        "matches": [
          "svelte derived multiple",
          "svderm"
        ],
        "opts": []
      },
      {
        "content": "const ${1:derivedStore} = derived(${2:storeA}, ($${2:storeA}, set) => {\n\tsetTimeout(() => set($${2:storeA}), 1000);\n}, 'one moment...');",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-derived-set",
        "matches": [
          "svders",
          "svelte derived set"
        ],
        "opts": []
      },
      {
        "content": "const ${1:derivedStore} = derived([${2:storeA}, ${3:storeB}], ([$${2:storeA}, $${3:storeB}], set) => {\n\tsetTimeout(() => set($${2:storeA} + $${3:storeB}), 1000);\n}, 'one moment...');",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-derived-multiple-set",
        "matches": [
          "svelte derived multiple set",
          "svderms"
        ],
        "opts": []
      },
      {
        "content": "const ${1:value} = get(${2:store});",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-store-get",
        "matches": [
          "svstoregm",
          "svelte store-get-value"
        ],
        "opts": []
      },
      {
        "content": "${1:component}.$set(${2: params});",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-component-set",
        "matches": [
          "svelte component set",
          "svcoms"
        ],
        "opts": []
      },
      {
        "content": "${1:component}.$on(${2:eventname}, ${3:handler});",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-component-on",
        "matches": [
          "svelte component on",
          "svcomon"
        ],
        "opts": []
      },
      {
        "content": "${1:component}.$destroy();",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-component-destroy",
        "matches": [
          "svelte component destroy",
          "svcomd"
        ],
        "opts": []
      },
      {
        "content": "const { head, html, css } = ${1:App}.render({\n\tprops: ${3:props},\n})",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-render-component",
        "matches": [
          "svelte render component",
          "svrcom"
        ],
        "opts": []
      },
      {
        "content": "const ${1:store} = tweened(${2:value}, ${3:options});",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-tweened",
        "matches": [
          "svelte tweened",
          "svtw"
        ],
        "opts": []
      },
      {
        "content": "const ${1:store} = spring(${2:value}, ${3:options});",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-spring",
        "matches": [
          "svsp",
          "svelte spring"
        ],
        "opts": []
      },
      {
        "content": "require('svelte/register');\nconst ${1:App} = require('${2:./App.svelte}').default;",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-register",
        "matches": [
          "svreg",
          "svelte register"
        ],
        "opts": []
      },
      {
        "content": "import { Route, Router } from 'svelte-routing'",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-routing-import",
        "matches": [
          "svroute",
          "svelte import routing"
        ],
        "opts": []
      },
      {
        "content": ":global(${1:body}) {\n\t/* this will apply to <body> */\n\t${2:/* your styles go here */}\n}",
        "doc": null,
        "grammar": "lsp",
        "label": "svelte-global-style",
        "matches": [
          "svelte global style",
          "svsglobal"
        ],
        "opts": []
      }
    ],
    "swift": [
      {
        "content": "struct ${1:name} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "struct"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "class ${1:name} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "class"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "enum ${1:name} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "enum"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "case ${1:pattern}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "protocol ${1:name} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "protocol"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "var ${1:name}: ${2:Int}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "var"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "let ${1:name}: ${2:Int}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "let"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "extension ${1:Int} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "extension"
        ],
        "opts": []
      },
      {
        "content": "func ${1:name}(${2:#:arguments}) -> ${3:Int}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "func name(...) -> Type { ... }",
        "matches": [
          "func"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "func ${1:name}(${2:#:arguments})${0}",
        "doc": "",
        "grammar": "snu",
        "label": "func name(...) { ... }",
        "matches": [
          "void"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "for var ${1:i = 0}; ${2:i < j}; ${3:i++} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "for ${1:item} in ${2:collection} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "iter"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "while ${1:false} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "while"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "repeat {\n    ${0:TARGET}\n} while ${1:false}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "repeat"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "if ${1:false} {\n    ${0:TARGET}\n}${9}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "else if ${1:false} {\n    ${0:TARGET}\n}${9}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "elif"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "else {\n    ${0:TARGET}\n}${9}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "else"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "if ${1:let} ${2:name} = ${3:expression} else {\n    ${0:TARGET}\n}${9}",
        "doc": "",
        "grammar": "snu",
        "label": "if let/case ... { ... }",
        "matches": [
          "optional"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "guard let ${1} = ${2} else {\n    ${0:TARGET}\n}\n${9}",
        "doc": "",
        "grammar": "snu",
        "label": "guard let ... else { ... }",
        "matches": [
          "guard"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "switch ${1:expression} {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "switch"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "do {\n    ${0:TARGET}\n}${9}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "do"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "catch${1:#:pattern} {\n    ${0:TARGET}\n}${9}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "catch"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "defer {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "defer"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "import ${1:module}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "import"
        ],
        "opts": []
      },
      {
        "content": "subscript(${1:index: Int}) -> ${2:Int} {\n    ${0:TARGET}\n}\n${9}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "subscript"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "init${1:#:?}(${2:#:arguments}) {\n    ${0:TARGET}\n}\n${9}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "init"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "deinit {\n    ${0:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "deinit"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "{ ${1:#capture}(${2:#:arguments}) -> ${3:Void} in\n    ${0:TARGET}\n}\n${9}",
        "doc": "",
        "grammar": "snu",
        "label": "{ (...) -> Type in ... }",
        "matches": [
          "closure"
        ],
        "opts": [
          "word"
        ]
      }
    ],
    "systemverilog": [
      {
        "content": "foreach (${1}) begin\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forea"
        ],
        "opts": []
      },
      {
        "content": "do begin\n\t${0}\nend while (${1});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dowh"
        ],
        "opts": []
      },
      {
        "content": "always_comb begin ${1:: statement_label}\n\t${0}\nend $1",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "alc"
        ],
        "opts": []
      },
      {
        "content": "always_ff @(posedge ${1:clk}) begin ${2:: statement_label}\n\t${0}\nend $2",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "alff"
        ],
        "opts": []
      },
      {
        "content": "always_latch begin ${1:: statement_label}\n\t${0}\nend $1",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "all"
        ],
        "opts": []
      },
      {
        "content": "class ${1:class_name};\n\t// data or class properties\n\t${0}\n\t// initialization\n\tfunction new();\n\tendfunction : new\nendclass : $1",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cl"
        ],
        "opts": []
      },
      {
        "content": "typedef struct {\n\t${0}\n} ${1:name_t};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "types"
        ],
        "opts": []
      },
      {
        "content": "program ${1:program_name} ();\n\t${0}\nendprogram : $1",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prog"
        ],
        "opts": []
      },
      {
        "content": "interface ${1:program_name} ();\n\t// nets\n\t${0}\n\t// clocking\n\t// modports\nendinterface : $1",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "intf"
        ],
        "opts": []
      },
      {
        "content": "clocking ${1:clocking_name} @(${2:posedge} ${3:clk});\n\t${0}\nendclocking : $1",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "clock"
        ],
        "opts": []
      },
      {
        "content": "covergroup ${1:group_name} @(${2:posedge} ${3:clk});\n\t${0}\nendgroup : $1",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cg"
        ],
        "opts": []
      },
      {
        "content": "package ${1:package_name};\n\t${0}\nendpackage : $1",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pkg"
        ],
        "opts": []
      },
      {
        "content": "always_comb begin\n    ${1:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "always_comb",
        "matches": [
          "alc"
        ],
        "opts": []
      },
      {
        "content": "always @(posedge ${1:clk} iff !${2:rst} or posedge $2) begin\n    if (${2}) begin\n        ${3:TARGET}\n    end else begin\n    end\nend",
        "doc": "",
        "grammar": "snu",
        "label": "always_ff @()",
        "matches": [
          "alf"
        ],
        "opts": []
      },
      {
        "content": "always_latch begin\n    if (${1:enable}) begin\n        ${2:TARGET}\n    end\nend",
        "doc": "",
        "grammar": "snu",
        "label": "always_latch",
        "matches": [
          "all"
        ],
        "opts": []
      },
      {
        "content": "logic${1:#: nbit} ${2:reg}_r, $2_w;${3:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "logic [] _r, _w;",
        "matches": [
          "rw"
        ],
        "opts": []
      },
      {
        "content": "typedef struct packed {\n    ${2:TARGET}\n} ${1:name} ;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "struct"
        ],
        "opts": []
      },
      {
        "content": "typedef enum {${2:TARGET}} ${1:name};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "enum"
        ],
        "opts": []
      },
      {
        "content": "for (int ${1:i} = ${2}; $1 < ${3}; ${4:do what}) begin\n    ${5:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "unique case (${1}) begin\n    ${2:'b0}: begin\n        ${3}\n    end\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case_parallel"
        ],
        "opts": []
      },
      {
        "content": "priority case (${1}) begin\n    ${2:'b0}: begin\n        ${3}\n    end\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case_full"
        ],
        "opts": []
      }
    ],
    "tcl": [
      {
        "content": "#!/usr/bin/env tclsh",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#!"
        ],
        "opts": []
      },
      {
        "content": "proc ${1:function_name} {${2:args}} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pro"
        ],
        "opts": []
      },
      {
        "content": "${1:expr}? ${2:true} : ${0:false}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "xif"
        ],
        "opts": []
      },
      {
        "content": "if {${1}} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "if {${1}} {\n\t${2}\n} else {\n\t${0:# else...}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "elseif {${1}} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eif"
        ],
        "opts": []
      },
      {
        "content": "if {${1}} {\n\t${2}\n} elseif {${3}} {\n\t${4:# elsif...}\n} else {\n\t${0:# else...}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifee"
        ],
        "opts": []
      },
      {
        "content": "if { [catch {${1:#do something...}} ${2:err}] } {\n\t${0:# handle failure...}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ifc"
        ],
        "opts": []
      },
      {
        "content": "catch {${1}} ${2:err} ${0:options}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "catch"
        ],
        "opts": []
      },
      {
        "content": "while {${1}} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh"
        ],
        "opts": []
      },
      {
        "content": "for {set ${2:var} 0} {$$2 < ${1:count}} {${3:incr} $2} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "foreach ${1:x} {${2:#list}} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fore"
        ],
        "opts": []
      },
      {
        "content": "after ${1:ms} ${0:#do something}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "af"
        ],
        "opts": []
      },
      {
        "content": "after cancel ${0:id or script}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "afc"
        ],
        "opts": []
      },
      {
        "content": "after idle ${0:script}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "afi"
        ],
        "opts": []
      },
      {
        "content": "after info ${0:id}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "afin"
        ],
        "opts": []
      },
      {
        "content": "expr {${0:#expression here}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "exp"
        ],
        "opts": []
      },
      {
        "content": "switch ${1:var} {\n\t${3:pattern 1} {\n\t\t${0:#do something}\n\t}\n\tdefault {\n\t\t${2:#do something}\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sw"
        ],
        "opts": []
      },
      {
        "content": "${1:pattern} {\n\t${2:#do something}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ca"
        ],
        "opts": []
      },
      {
        "content": "namespace eval ${1:path} {${0:#script...}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ns"
        ],
        "opts": []
      },
      {
        "content": "namespace current",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nsc"
        ],
        "opts": []
      },
      {
        "content": "for {${1:set i 0}} {${2:\\$i < \\$n}} {${3:incr i}} {\n\t$4\n}\n",
        "doc": null,
        "grammar": "snu",
        "label": "for... (for)",
        "matches": [
          "for"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "foreach ${1:var} ${2:\\$list} {\n\t$3\n}\n",
        "doc": null,
        "grammar": "snu",
        "label": "foreach... (foreach)",
        "matches": [
          "foreach"
        ],
        "opts": []
      },
      {
        "content": "if {${1:condition}} {\n\t$2\n}\n",
        "doc": null,
        "grammar": "snu",
        "label": "if... (if)",
        "matches": [
          "if"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "proc ${1:name} {${2:args}} \\\n{\n\t$3\n}\n",
        "doc": null,
        "grammar": "snu",
        "label": "proc... (proc)",
        "matches": [
          "proc"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "switch ${1:-exact} -- ${2:\\$var} {\n\t${3:match} {\n\t\t$4\n\t}\n\tdefault {$5}\n}\n",
        "doc": null,
        "grammar": "snu",
        "label": "switch... (switch)",
        "matches": [
          "switch"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "while {${1:condition}} {\n\t$2\n}\n",
        "doc": null,
        "grammar": "snu",
        "label": "while... (while)",
        "matches": [
          "while"
        ],
        "opts": [
          "b"
        ]
      }
    ],
    "tex": [
      {
        "content": "\\documentclass[${1}]{${2:article}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "documentclass",
          "\\documentclass"
        ],
        "opts": []
      },
      {
        "content": "$${1:#:expression}$${2}",
        "doc": "",
        "grammar": "snu",
        "label": "$ expression $",
        "matches": [
          "$",
          "mathexpression"
        ],
        "opts": []
      },
      {
        "content": "$$${1:#:expression}$$${2}",
        "doc": "",
        "grammar": "snu",
        "label": "$$ expression $$",
        "matches": [
          "mathenva",
          "$$"
        ],
        "opts": []
      },
      {
        "content": "\\[${1:#:expression}\\]${2}",
        "doc": "",
        "grammar": "snu",
        "label": "\\[ expression \\]",
        "matches": [
          "mathenvb",
          "\\["
        ],
        "opts": []
      },
      {
        "content": "\\begin{${1:#:type}}\n\t${2:TARGET}\n\\end{$1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "begin",
          "\\begin"
        ],
        "opts": []
      },
      {
        "content": "\\begin{list}\n\t${1:TARGET}\n\\end{list}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\begin{list} \\list",
          "list"
        ],
        "opts": []
      },
      {
        "content": "\\begin{quotation}\n\t${1:TARGET}\n\\end{quotation}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "quotation",
          "\\begin{quotation} \\quotation"
        ],
        "opts": []
      },
      {
        "content": "\\begin{description}\n\t\\item[${1}] ${0}\n\\end{description}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "description",
          "\\begin{description} \\description desc"
        ],
        "opts": []
      },
      {
        "content": "\\item[${1}] ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "item[ \\item[",
          "itd"
        ],
        "opts": []
      },
      {
        "content": "\\item ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "item \\item",
          "it"
        ],
        "opts": []
      },
      {
        "content": "\\begin{sloppypar}\n\t${1:TARGET}\n\\end{sloppypar}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sloppypar",
          "\\begin{sloppypar} \\sloppypar"
        ],
        "opts": []
      },
      {
        "content": "\\begin{enumerate}\n\t\\item ${1:TARGET}\n\\end{enumerate}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\begin{enumerate} \\enumerate enum",
          "enumerate"
        ],
        "opts": []
      },
      {
        "content": "\\begin{theindex}\n\t${1:TARGET}\n\\end{theindex}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\begin{theindex} \\theindex",
          "theindex"
        ],
        "opts": []
      },
      {
        "content": "\\begin{itemize}\n\t\\item ${1:TARGET}\n\\end{itemize}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\begin{itemize} \\itemize",
          "itemize"
        ],
        "opts": []
      },
      {
        "content": "\\begin{titlepage}\n\t${1:TARGET}\n\\end{titlepage}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "titlepage",
          "\\begin{titlepage} \\titlepage"
        ],
        "opts": []
      },
      {
        "content": "\\begin{verbatim}\n\t${1:TARGET}\n\\end{verbatim}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\begin{verbatim} verb \\verbatim",
          "verbatim"
        ],
        "opts": []
      },
      {
        "content": "\\begin{verbatimtab}[${1:8}]\n\t${2:TARGET}\n\\end{verbatim}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\begin{verbatimtab} \\verbatimtab",
          "verbatimtab"
        ],
        "opts": []
      },
      {
        "content": "\\begin{trivlist}\n\t${1:TARGET}\n\\end{trivlist}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "trivlist",
          "\\begin{trivlist} \\trivlist"
        ],
        "opts": []
      },
      {
        "content": "\\begin{verse}\n\t${1:TARGET}\n\\end{verse}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\begin{verse} \\verse",
          "verse"
        ],
        "opts": []
      },
      {
        "content": "\\begin{table}[${1}]\n\t\\centering\n\t\\caption{${2}}\n\t\\label{${3}}\n\t\\begin{tabular}{${4}}\n\t\t${5}\n\t\\end{tabular}\n\\end{table}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\begin{table} \\table",
          "table"
        ],
        "opts": []
      },
      {
        "content": "\\begin{thebibliography}\n\t${1:TARGET}\n\\end{thebibliography}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\begin{thebibliography} \\thebibliography",
          "thebibliography"
        ],
        "opts": []
      },
      {
        "content": "\\begin{tabbing}\n\t${1:TARGET}\n\\end{tabbing}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tabbing",
          "\\begin{tabbing} \\tabbing"
        ],
        "opts": []
      },
      {
        "content": "\\begin{note}\n\t${1:TARGET}\n\\end{note}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\begin{note} \\note",
          "note"
        ],
        "opts": []
      },
      {
        "content": "\\begin{tabular}{${1}}\n\t${2:TARGET}\n\\end{tabular}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\begin{tabular} \\tabular",
          "tabular"
        ],
        "opts": []
      },
      {
        "content": "\\begin{overlay}\n\t${1:TARGET}\n\\end{overlay}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "overlay",
          "\\begin{overlay} \\overlay"
        ],
        "opts": []
      },
      {
        "content": "\\begin{array}{${1}}\n\t${2:TARGET}\n\\end{array}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\begin{array} \\array",
          "array"
        ],
        "opts": []
      },
      {
        "content": "\\begin{cases}{${1}}\n\t${2:TARGET}\n\\end{cases}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cases",
          "\\begin{cases} \\cases"
        ],
        "opts": []
      },
      {
        "content": "\\begin{slide}\n\t${1:TARGET}\n\\end{slide}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "slide",
          "\\begin{slide} \\slide"
        ],
        "opts": []
      },
      {
        "content": "\\begin{displaymath}\n\t${1:TARGET}\n\\end{displaymath}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\begin{displaymath} \\displaymath",
          "displaymath"
        ],
        "opts": []
      },
      {
        "content": "\\begin{abstract}\n\t${1:TARGET}\n\\end{abstract}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "abstract",
          "\\begin{abstract} \\abstract"
        ],
        "opts": []
      },
      {
        "content": "\\begin{align}\n\t${1:TARGET}\n\\end{align}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "align",
          "\\begin{align} \\align"
        ],
        "opts": []
      },
      {
        "content": "\\begin{align*}\n\t${1:TARGET}\n\\end{align*}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "align*",
          "\\begin{align*} \\align*"
        ],
        "opts": []
      },
      {
        "content": "\\begin{aligned}\n        ${1:TARGET}\n\\end{aligned}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "aligned",
          "\\begin{aligned} \\aligned"
        ],
        "opts": []
      },
      {
        "content": "\\begin{eqnarray}\n\t${1:TARGET}\n\\end{eqnarray}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\begin{eqnarray} \\eqnarray",
          "eqnarray"
        ],
        "opts": []
      },
      {
        "content": "\\begin{eqnarray*}\n\t${1:TARGET}\n\\end{eqnarray*}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eqnarray*",
          "\\begin{eqnarray*} \\eqnarray*"
        ],
        "opts": []
      },
      {
        "content": "\\begin{equation}\n\t${1:TARGET}\n\\end{equation}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "equation",
          "\\begin{equation} \\equation"
        ],
        "opts": []
      },
      {
        "content": "\\begin{equation*}\n\t${1:TARGET}\n\\end{equation*}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\begin{equation*} \\equation*",
          "equation*"
        ],
        "opts": []
      },
      {
        "content": "\\begin{center}\n\t${1:TARGET}\n\\end{center}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "center",
          "\\begin{center} \\center"
        ],
        "opts": []
      },
      {
        "content": "\\begin{document}\n\t${1:TARGET}\n\\end{document}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "document",
          "\\begin{document} \\document"
        ],
        "opts": []
      },
      {
        "content": "\\begin{figure}[${1}]\n\t\\centering\n\t\\includegraphics[${2:width=${3\\}}]{${4}}\n\t\\caption{${5}}\n\t\\label{${6}}\n\\end{figure}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\begin{figure} \\figure",
          "figure"
        ],
        "opts": []
      },
      {
        "content": "\\begin{filecontents}\n\t${1:TARGET}\n\\end{filecontents}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\begin{filecontents} \\filecontents",
          "filecontents"
        ],
        "opts": []
      },
      {
        "content": "\\begin{lrbox}\n\t${1:TARGET}\n\\end{lrbox}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\begin{lrbox} \\lrbox",
          "lrbox"
        ],
        "opts": []
      },
      {
        "content": "\\begin{flushleft}\n\t${1:TARGET}\n\\end{flushleft}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\begin{flushleft} \\flushleft",
          "flushleft"
        ],
        "opts": []
      },
      {
        "content": "\\begin{flushright}\n\t${1:TARGET}\n\\end{flushright}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\begin{flushright} \\flushright",
          "flushright"
        ],
        "opts": []
      },
      {
        "content": "\\begin{minipage}{${1:0.45}\\linewidth}\n\t${2:TARGET}\n\\end{minipage}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "minipage",
          "\\begin{minipage} \\minipage"
        ],
        "opts": []
      },
      {
        "content": "\\begin{picture}\n\t${1:TARGET}\n\\end{picture}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\begin{picture} \\picture",
          "picture"
        ],
        "opts": []
      },
      {
        "content": "\\begin{math}\n\t${1:TARGET}\n\\end{math}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "math",
          "\\begin{math} \\math"
        ],
        "opts": []
      },
      {
        "content": "\\begin{quote}\n\t${1:TARGET}\n\\end{quote}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "quote",
          "\\begin{quote} \\quote"
        ],
        "opts": []
      },
      {
        "content": "\\begin{matrix}\n\t${1:TARGET}\n\\end{matrix}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\begin{matrix} \\matrix",
          "matrix"
        ],
        "opts": []
      },
      {
        "content": "\\begin{bmatrix}\n\t${1:TARGET}\n\\end{bmatrix}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bmatrix",
          "\\begin{bmatrix} \\bmatrix"
        ],
        "opts": []
      },
      {
        "content": "\\begin{pmatrix}\n\t${1:TARGET}\n\\end{pmatrix}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pmatrix",
          "\\pegin{bmatrix} \\pmatrix"
        ],
        "opts": []
      },
      {
        "content": "\\begin{vmatrix}\n\t${1:TARGET}\n\\end{vmatrix}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vmatrix",
          "\\begin{vmatrix} \\vmatrix"
        ],
        "opts": []
      },
      {
        "content": "\\begin{Bmatrix}\n\t${1:TARGET}\n\\end{Bmatrix}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\begin{Bmatrix} \\Bmatrix",
          "Bmatrix"
        ],
        "opts": []
      },
      {
        "content": "\\begin{Vmatrix}\n\t${1:TARGET}\n\\end{Vmatrix}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "Vmatrix",
          "\\begin{Vmatrix} \\Vmatrix"
        ],
        "opts": []
      },
      {
        "content": "\\part{${1}}\n${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\part",
          "part \\part{"
        ],
        "opts": []
      },
      {
        "content": "\\chapter{${1}}\n${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\chapter",
          "chapter \\chapter{"
        ],
        "opts": []
      },
      {
        "content": "\\section{${1}}\n${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\section",
          "section \\section{"
        ],
        "opts": []
      },
      {
        "content": "\\subsection{${1}}\n${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "subsection \\subsection{",
          "\\subsection"
        ],
        "opts": []
      },
      {
        "content": "\\subsubsection{${1}}\n${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "subsubsection \\subsubsection{",
          "\\subsubsection"
        ],
        "opts": []
      },
      {
        "content": "\\paragraph{${1}}\n${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "paragraph \\paragraph{",
          "\\paragraph"
        ],
        "opts": []
      },
      {
        "content": "\\subparagraph{${1}}\n${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "subparagraph \\subparagraph{",
          "\\subparagraph"
        ],
        "opts": []
      },
      {
        "content": "\\frac{${1}}{${2}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\frac",
          "frac \\frac{"
        ],
        "opts": []
      },
      {
        "content": "\\left${1:(} ${3:#:body} \\right${2:)}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "\\left \\right",
        "matches": [
          "\\left",
          "left"
        ],
        "opts": []
      },
      {
        "content": "\\begin{bfseries}\n\t${1:TARGET}\n\\end{bfseries}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\begin{bfseries} \\bfseries",
          "bfseries"
        ],
        "opts": []
      },
      {
        "content": "\\begin{mdseries}\n\t${1:TARGET}\n\\end{mdseries}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mdseries",
          "\\begin{mdseries} \\mdseries"
        ],
        "opts": []
      },
      {
        "content": "\\begin{ttfamily}\n\t${1:TARGET}\n\\end{ttfamily}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ttfamily",
          "\\begin{ttfamily} \\ttfamily"
        ],
        "opts": []
      },
      {
        "content": "\\begin{sffamily}\n\t${1:TARGET}\n\\end{sffamily}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sffamily",
          "\\begin{sffamily} \\sffamily"
        ],
        "opts": []
      },
      {
        "content": "\\begin{rmfamily}\n\t${1:TARGET}\n\\end{rmfamily}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rmfamily",
          "\\begin{rmfamily} \\rmfamily"
        ],
        "opts": []
      },
      {
        "content": "\\begin{upshape}\n\t${1:TARGET}\n\\end{upshape}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "upshape",
          "\\begin{upshape} \\upshape"
        ],
        "opts": []
      },
      {
        "content": "\\begin{slshape}\n\t${1:TARGET}\n\\end{slshape}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\begin{slshape} \\slshape",
          "slshape"
        ],
        "opts": []
      },
      {
        "content": "\\begin{scshape}\n\t${1:TARGET}\n\\end{scshape}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\begin{scshape} \\scshape",
          "scshape"
        ],
        "opts": []
      },
      {
        "content": "\\begin{itshape}\n\t${1:TARGET}\n\\end{itshape}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\begin{itshape} \\itshape",
          "itshape"
        ],
        "opts": []
      },
      {
        "content": "\\textbf{${1:TARGET}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "textbf \\textbf{",
          "\\textbf"
        ],
        "opts": []
      },
      {
        "content": "\\textmd{${1:TARGET}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\textmd",
          "textmd \\textmd{"
        ],
        "opts": []
      },
      {
        "content": "\\texttt{${1:TARGET}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\texttt",
          "texttt \\texttt{"
        ],
        "opts": []
      },
      {
        "content": "\\textsf{${1:TARGET}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "textsf \\textsf{",
          "\\textsf"
        ],
        "opts": []
      },
      {
        "content": "\\textrm{${1:TARGET}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\textrm",
          "textrm \\textrm{"
        ],
        "opts": []
      },
      {
        "content": "\\textup{${1:TARGET}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\textup",
          "textup \\textup{"
        ],
        "opts": []
      },
      {
        "content": "\\textsl{${1:TARGET}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\textsl",
          "textsl \\textsl{"
        ],
        "opts": []
      },
      {
        "content": "\\textsc{${1:TARGET}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "textsc \\textsc{",
          "\\textsc"
        ],
        "opts": []
      },
      {
        "content": "\\textit{${1:TARGET}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\textit",
          "textit \\textit{"
        ],
        "opts": []
      },
      {
        "content": "\\begin{frame}{${1:#:frametitle}}\n\t${2:TARGET}\n\\end{frame}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "frame",
          "\\begin{frame} \\frame"
        ],
        "opts": []
      },
      {
        "content": "\\begin{block}{${1:#:title}}\n\t${2:TARGET}\n\\end{block}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "block",
          "\\begin{block}"
        ],
        "opts": []
      },
      {
        "content": "\\begin{exampleblock}{${1:#:title}}\n\t${2:TARGET}\n\\end{exampleblock}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "exampleblock",
          "\\begin{exampleblock}"
        ],
        "opts": []
      },
      {
        "content": "\\begin{alertblock}{${1:#:title}}\n\t${2:TARGET}\n\\end{alertblock}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "alertblock",
          "\\begin{alertblock}"
        ],
        "opts": []
      },
      {
        "content": "\\begin{columns}\n\t\\begin{column}{${1:#:width}${2:\\\\\\textwidth}}\n\t\t${0:#:body}\n\t\\end{column}\n\\end{columns}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "columns",
          "\\begin{columns} \\columns"
        ],
        "opts": []
      },
      {
        "content": "\\begin{column}{${1:#:width}${2:\\\\\\textwidth}}\n\t${0:#:body}\n\\end{column}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\begin{column} \\column",
          "column"
        ],
        "opts": []
      },
      {
        "content": "\\begin{figure}[${1}]\n\t\\centering\n\t\\begin{tikzpicture}[${2}]\n\t\t${3:TARGET}\n\t\\end{tikzpicture}\n\t\\caption{${4}}\n\t\\label{${5}}\n\\end{figure}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "figuretikz",
          "tikzfig"
        ],
        "opts": []
      },
      {
        "content": "\\begin{tikzpicture}[${1}]\n\t${2:TARGET}\n\\end{tikzpicture}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tikzpicture",
          "\\begin{tikzpicture}"
        ],
        "opts": []
      },
      {
        "content": "\\begin{scope}[${1}]\n\t${2:TARGET}\n\\end{scope}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "scope",
          "\\begin{scope}"
        ],
        "opts": []
      },
      {
        "content": "\\path[${1}] ${2};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\path",
          "path"
        ],
        "opts": []
      },
      {
        "content": "\\draw[${1}] ${2};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "draw",
          "\\draw"
        ],
        "opts": []
      },
      {
        "content": "\\fill[${1}] ${2};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fill",
          "\\fill"
        ],
        "opts": []
      },
      {
        "content": "\\filldraw[${1}] ${2};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "filldraw",
          "\\filldraw"
        ],
        "opts": []
      },
      {
        "content": "\\shade[${1}] ${2};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\shade",
          "shade"
        ],
        "opts": []
      },
      {
        "content": "\\coordinate[${1}](${2:name}) ${3};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "coordinate",
          "\\coordinate"
        ],
        "opts": []
      },
      {
        "content": "\\node[${1}](${2:name}) ${3};${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\node",
          "node"
        ],
        "opts": []
      },
      {
        "content": "\\addbibresource{${1:resource}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\addbibresource",
          "addbibresource"
        ],
        "opts": []
      },
      {
        "content": "\\cite{${1}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cite",
          "\\cite"
        ],
        "opts": []
      },
      {
        "content": "\\nocite{${1}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\nocite",
          "nocite"
        ],
        "opts": []
      },
      {
        "content": "\\supercite{${1}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "supercite",
          "\\supercite"
        ],
        "opts": []
      },
      {
        "content": "\\autocite{${1}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\autocite",
          "autocite"
        ],
        "opts": []
      },
      {
        "content": "\\fullcite{${1}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fullcite",
          "\\fullcite"
        ],
        "opts": []
      },
      {
        "content": "\\usepackage${1:[${2\\}]}{${3}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "usepackage",
          "\\usepackage"
        ],
        "opts": []
      },
      {
        "content": "\\ref{${1}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\ref",
          "ref"
        ],
        "opts": []
      },
      {
        "content": "\\label{${1}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "label",
          "\\label"
        ],
        "opts": []
      },
      {
        "content": "\\\\documentclass{${1:class}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dcl \\documentclass{}"
        ],
        "opts": []
      },
      {
        "content": "\\\\documentclass[${1:options}]{${2:class}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dclo \\documentclass[]{}"
        ],
        "opts": []
      },
      {
        "content": "\\\\newcommand{\\\\${1:cmd}}[${2:opt}]{${3:realcmd}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nc \\newcommand"
        ],
        "opts": []
      },
      {
        "content": "\\\\usepackage[${1:options}]{${2:package}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "up \\usepackage"
        ],
        "opts": []
      },
      {
        "content": "\\\\newunicodechar{${1}}{${2:\\\\ensuremath}${3:tex-substitute}}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nuc \\newunicodechar"
        ],
        "opts": []
      },
      {
        "content": "\\\\DeclareMathOperator{${1}}{${2}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dmo \\DeclareMathOperator"
        ],
        "opts": []
      },
      {
        "content": "\\\\begin{${1:env}}\n\t${0:${VISUAL}}\n\\\\end{$1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "begin \\begin{} ... \\end{} block"
        ],
        "opts": []
      },
      {
        "content": "\\\\maketitle",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mkt maketitle"
        ],
        "opts": []
      },
      {
        "content": "\\\\begin{${1:tabular}}{${2:c}}\n\t${0:${VISUAL}}\n\\\\end{$1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tab tabular (or arbitrary) environment"
        ],
        "opts": []
      },
      {
        "content": "\\\\begin[${1:author}]{${2:thm}}\n\t${0:${VISUAL}}\n\\\\end{$2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "thm thm (or arbitrary) environment with optional argument"
        ],
        "opts": []
      },
      {
        "content": "\\\\begin{center}\n\t${0:${VISUAL}}\n\\\\end{center}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "center center environment"
        ],
        "opts": []
      },
      {
        "content": "\\\\begin{align${1:ed}}\n\t\\\\label{eq:${2}}\n\t${0:${VISUAL}}\n\\\\end{align$1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ali align(ed) environment"
        ],
        "opts": []
      },
      {
        "content": "\\\\begin{gather${1:ed}}\n\t${0:${VISUAL}}\n\\\\end{gather$1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "gat gather(ed) environment"
        ],
        "opts": []
      },
      {
        "content": "\\\\begin{equation}\n\t${0:${VISUAL}}\n\\\\end{equation}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eq equation environment"
        ],
        "opts": []
      },
      {
        "content": "\\\\begin{equation}\n\t\\\\label{eq:${2}}\n${0:${VISUAL}}\n\\\\end{equation}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eql Labeled equation environment"
        ],
        "opts": []
      },
      {
        "content": "\\\\begin{equation*}\n\t${0:${VISUAL}}\n\\\\end{equation*}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eq* unnumbered equation environment"
        ],
        "opts": []
      },
      {
        "content": "\\\\[\n\t${0:${VISUAL}}\n\\\\]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\ unnumbered equation: \\[ ... \\]"
        ],
        "opts": []
      },
      {
        "content": "\\\\begin{eqnarray}\n\t${0:${VISUAL}}\n\\\\end{eqnarray}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eqnarray eqnarray environment"
        ],
        "opts": []
      },
      {
        "content": "\\\\label{${1:eq:}${2:fig:}${3:tab:}${0}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lab \\label"
        ],
        "opts": []
      },
      {
        "content": "\\\\begin{enumerate}\n\t\\\\item ${0}\n\\\\end{enumerate}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "enum enumerate environment"
        ],
        "opts": []
      },
      {
        "content": "\\\\begin{enumerate}[(a)]\n\t\\\\item ${0}\n\\\\end{enumerate}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "enuma enumerate environment"
        ],
        "opts": []
      },
      {
        "content": "\\\\begin{enumerate}[(i)]\n\t\\\\item ${0}\n\\\\end{enumerate}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "enumi enumerate environment"
        ],
        "opts": []
      },
      {
        "content": "\\\\begin{itemize}\n\t\\\\item ${0}\n\\\\end{itemize}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "item itemize environment"
        ],
        "opts": []
      },
      {
        "content": "\\\\item ${1:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "it \\item"
        ],
        "opts": []
      },
      {
        "content": "\\\\begin{description}\n\t\\\\item[${1}] ${0}\n\\\\end{description}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "desc description environment"
        ],
        "opts": []
      },
      {
        "content": "\\\\item ${1}\n\t${0:]i}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "]i \\item (recursive)"
        ],
        "opts": []
      },
      {
        "content": "\\\\begin{${1:p/b/v/V/B/small}matrix}\n\t${0:${VISUAL}}\n\\\\end{$1matrix}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mat smart matrix environment"
        ],
        "opts": []
      },
      {
        "content": "\\\\begin{cases}\n\t${1:equation}, &\\\\text{ if }${2:case}\\\\\n\t${0:${VISUAL}}\n\\\\end{cases}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cas cases environment"
        ],
        "opts": []
      },
      {
        "content": "\\\\begin{split}\n\t${0:${VISUAL}}\n\\\\end{split}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "spl split environment"
        ],
        "opts": []
      },
      {
        "content": "\\\\part{${1:part name}} % (fold)%\n\\\\label{prt:${2:$1}}\n${0}\n% part $2 (end)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "part document \\part"
        ],
        "opts": []
      },
      {
        "content": "\\\\chapter{${1:chapter name}}%\n\\\\label{cha:${2:$1}}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cha \\chapter"
        ],
        "opts": []
      },
      {
        "content": "\\\\section{${1:section name}}%\n\\\\label{sec:${2:$1}}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sec \\section"
        ],
        "opts": []
      },
      {
        "content": "\\\\section*{${1:section name}}%\n\\\\label{sec:${2:$1}}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sec* \\section*"
        ],
        "opts": []
      },
      {
        "content": "\\\\subsection{${1:subsection name}}%\n\\\\label{sub:${2:$1}}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sub \\subsection"
        ],
        "opts": []
      },
      {
        "content": "\\\\subsection*{${1:subsection name}}%\n\\\\label{sub:${2:$1}}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sub* \\subsection*"
        ],
        "opts": []
      },
      {
        "content": "\\\\subsubsection{${1:subsubsection name}}%\n\\\\label{ssub:${2:$1}}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ssub \\subsubsection"
        ],
        "opts": []
      },
      {
        "content": "\\\\subsubsection*{${1:subsubsection name}}%\n\\\\label{ssub:${2:$1}}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ssub* \\subsubsection*"
        ],
        "opts": []
      },
      {
        "content": "\\\\paragraph{${1:paragraph name}}%\n\\\\label{par:${2:$1}}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "par \\paragraph"
        ],
        "opts": []
      },
      {
        "content": "\\\\subparagraph{${1:subparagraph name}}%\n\\\\label{subp:${2:$1}}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "subp \\subparagraph"
        ],
        "opts": []
      },
      {
        "content": "\\\\noindent\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ni \\noindent"
        ],
        "opts": []
      },
      {
        "content": "\\\\item[${1:description}] ${0:item}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "itd description \\item"
        ],
        "opts": []
      },
      {
        "content": "${1:Figure}~\\\\ref{${2:fig:}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "figure reference to a figure"
        ],
        "opts": []
      },
      {
        "content": "${1:Table}~\\\\ref{${2:tab:}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "table reference to a table"
        ],
        "opts": []
      },
      {
        "content": "${1:Listing}~\\\\ref{${2:list}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "listing reference to a listing"
        ],
        "opts": []
      },
      {
        "content": "${1:Section}~\\\\ref{sec:${2}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "section reference to a section"
        ],
        "opts": []
      },
      {
        "content": "${1:page}~\\\\pageref{${2}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "page reference to a page"
        ],
        "opts": []
      },
      {
        "content": "\\\\index{${1:index}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "index \\index"
        ],
        "opts": []
      },
      {
        "content": "\\\\citen{${1}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "citen \\citen"
        ],
        "opts": []
      },
      {
        "content": "\\\\citep{${1}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "citep \\citep"
        ],
        "opts": []
      },
      {
        "content": "\\\\citet{${1}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "citet \\citet"
        ],
        "opts": []
      },
      {
        "content": "\\\\cite[${1}]{${2}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cite \\cite[]{}"
        ],
        "opts": []
      },
      {
        "content": "\\\\citeauthor{${1}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "citea \\citeauthor"
        ],
        "opts": []
      },
      {
        "content": "\\\\citeyear{${1}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "citey \\citeyear"
        ],
        "opts": []
      },
      {
        "content": "\\\\footcite[${1}]{${2}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fcite \\footcite[]{}"
        ],
        "opts": []
      },
      {
        "content": "\\\\textit{${1:${VISUAL:text}}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ita italic text"
        ],
        "opts": []
      },
      {
        "content": "\\\\textbf{${1:${VISUAL:text}}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bf bold face text"
        ],
        "opts": []
      },
      {
        "content": "\\\\underline{${1:${VISUAL:text}}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "under underline text"
        ],
        "opts": []
      },
      {
        "content": "\\\\overline{${1:${VISUAL:text}}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "over overline text"
        ],
        "opts": []
      },
      {
        "content": "\\\\emph{${1:${VISUAL:text}}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "emp emphasize text"
        ],
        "opts": []
      },
      {
        "content": "\\\\textsc{${1:${VISUAL:text}}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sc small caps text"
        ],
        "opts": []
      },
      {
        "content": "\\\\textsf{${1:${VISUAL:text}}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sf sans serife text"
        ],
        "opts": []
      },
      {
        "content": "\\\\textrm{${1:${VISUAL:text}}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rm roman font text"
        ],
        "opts": []
      },
      {
        "content": "\\\\texttt{${1:${VISUAL:text}}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tt typewriter (monospace) text"
        ],
        "opts": []
      },
      {
        "content": "\\\\textsubscript{${1:${VISUAL:text}}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tsub subscripted text"
        ],
        "opts": []
      },
      {
        "content": "\\\\textsuperscript{${1:${VISUAL:text}}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tsup superscripted text"
        ],
        "opts": []
      },
      {
        "content": "\\\\mathfrak{${1:${VISUAL:text}}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mf mathfrak"
        ],
        "opts": []
      },
      {
        "content": "\\\\mathcal{${1:${VISUAL:text}}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mc mathcal"
        ],
        "opts": []
      },
      {
        "content": "\\\\mathscr{${1:${VISUAL:text}}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ms mathscr"
        ],
        "opts": []
      },
      {
        "content": "\\\\footnote{${1:${VISUAL:text}}}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ft \\footnote"
        ],
        "opts": []
      },
      {
        "content": "\\\\begin{figure}\n\\\\begin{center}\n\t\\\\includegraphics[scale=${1}]{Figures/${2}}\n\\\\end{center}\n\\\\caption{${3}}\n\\\\label{fig:${4}}\n\\\\end{figure}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fig figure environment (includegraphics)"
        ],
        "opts": []
      },
      {
        "content": "\\\\begin{figure}[htpb]\n\\\\begin{center}\n\\\\begin{tikzpicture}[scale=${1:1}, transform shape]\n\t${2}\n\\\\end{tikzpicture}\n\\\\end{center}\n\\\\caption{${3}}%\n\\\\label{fig:${4}}\n\\\\end{figure}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tikz figure environment (tikzpicture)"
        ],
        "opts": []
      },
      {
        "content": "\\\\begin{subfigure}[${1}]{${2:\\\\textwidth}}\n\\\\begin{center}\n\t${3}\n\\\\end{center}\n\\\\caption{${4}}\n\\\\label{fig:${5}}\n\\\\end{subfigure}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "subfig subfigure environment"
        ],
        "opts": []
      },
      {
        "content": "\\\\begin{equation}\n\\\\begin{tikzcd}\n\t${1}\n\\\\end{tikzcd}\n\\\\end{equation}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tikzcd tikzcd environment in equation"
        ],
        "opts": []
      },
      {
        "content": "\\\\begin{equation*}\n\\\\begin{tikzcd}\n\t${1}\n\\\\end{tikzcd}\n\\\\end{equation*}\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tikzcd* tikzcd environment in equation*"
        ],
        "opts": []
      },
      {
        "content": "\\\\stackrel{${1:above}}{${2:below}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "stackrel \\stackrel{}{}"
        ],
        "opts": []
      },
      {
        "content": "\\\\frac{${1:num}}{${2:denom}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "frac \\frac{}{}"
        ],
        "opts": []
      },
      {
        "content": "\\\\sum^{${1:n}}_{${2:i=1}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sum \\sum^{}_{}"
        ],
        "opts": []
      },
      {
        "content": "\\\\lim_{${1:n \\\\to \\\\infty}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lim \\lim_{}"
        ],
        "opts": []
      },
      {
        "content": "\\\\begin{frame}[${1:t}]\n\t\\frametitle{${2:title}}\n\t\\framesubtitle{${3:subtitle}}\n\t${0:${VISUAL}}\n\\\\end{frame}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "frame frame environment"
        ],
        "opts": []
      },
      {
        "content": "\\\\begin{block}{${1:title}}\n\t${0:${VISUAL}}\n\\\\end{block}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "block block environment"
        ],
        "opts": []
      },
      {
        "content": "\\\\alert{${1:${VISUAL:text}}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "alert alert text"
        ],
        "opts": []
      },
      {
        "content": "\\\\begin{alertblock}{${1:title}}\n\t${0:${VISUAL}}\n\\\\end{alertblock}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "alertblock alertblock environment"
        ],
        "opts": []
      },
      {
        "content": "\\\\begin{exampleblock}{${1:title}}\n\t${0:${VISUAL}}\n\\\\end{exampleblock}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "example exampleblock environment"
        ],
        "opts": []
      },
      {
        "content": "\\\\begin{columns}\n\t\\\\begin{column}{0.5\\\\textwidth}\n\t\t${1}\n\t\\\\end{column}\n\t\\\\begin{column}{0.5\\\\textwidth}\n\t\t${0}\n\t\\\\end{column}\n\\\\end{columns}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "col2 two-column environment"
        ],
        "opts": []
      },
      {
        "content": "\\\\begin{multicols}{2}\n\t${1}\n\t\\columnbreak\n\t${0}\n\\\\end{multicols}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "multicol2 two-column environment with multicol"
        ],
        "opts": []
      },
      {
        "content": "\\\\{ ${0} \\\\}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\{ \\{ \\}"
        ],
        "opts": []
      },
      {
        "content": "\\\\left${1} ${0:${VISUAL}} \\\\right$1",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lr left right"
        ],
        "opts": []
      },
      {
        "content": "\\\\left( ${0:${VISUAL}} \\\\right)",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lr( left( right)"
        ],
        "opts": []
      },
      {
        "content": "\\\\left| ${0:${VISUAL}} \\\\right|",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lr| left| right|"
        ],
        "opts": []
      },
      {
        "content": "\\\\left\\\\{ ${0:${VISUAL}} \\\\right\\\\}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lr{ left\\{ right\\}"
        ],
        "opts": []
      },
      {
        "content": "\\\\left[ ${0:${VISUAL}} \\\\right]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lr[ left[ right]"
        ],
        "opts": []
      },
      {
        "content": "\\\\langle ${0:${VISUAL}} \\\\rangle",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lra langle rangle"
        ],
        "opts": []
      },
      {
        "content": "\\\\begin{listing}[language=${1:language}]\n\t${0:${VISUAL}}\n\\\\end{listing}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lst"
        ],
        "opts": []
      },
      {
        "content": "\\\\lstinline|${1}| ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lsi"
        ],
        "opts": []
      },
      {
        "content": "\\\\url{${1}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "url"
        ],
        "opts": []
      },
      {
        "content": "\\\\href{${1}}{${2}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "href"
        ],
        "opts": []
      },
      {
        "content": "\\\\url{`@+`} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "urlc"
        ],
        "opts": []
      },
      {
        "content": "\\\\href{`@+`}{${1}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "hrefc"
        ],
        "opts": []
      },
      {
        "content": "\\\\enquote{${1:${VISUAL:text}}} ${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "enq enquote"
        ],
        "opts": []
      },
      {
        "content": "\\\\frac{d}{dt} {$1} {$0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ddt time derivative"
        ],
        "opts": []
      },
      {
        "content": "\\\\lim_{{$1}} {{$2}} {$0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lim limit"
        ],
        "opts": []
      },
      {
        "content": "\\\\frac{\\\\partial {$1}}{\\partial {$2}} {$0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pdv partial derivation"
        ],
        "opts": []
      },
      {
        "content": "\\\\frac{\\partial^2 {$1}}{\\partial {$2} \\partial {$3}} {$0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ppdv second partial derivation"
        ],
        "opts": []
      },
      {
        "content": "\\\\frac{d {$1}}{d {$2}} {$0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dv derivative"
        ],
        "opts": []
      },
      {
        "content": "\\\\sum_{{$1}} {$0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "summ summation"
        ],
        "opts": []
      },
      {
        "content": "\\\\dot{{$1}} {$0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dot dot"
        ],
        "opts": []
      },
      {
        "content": "\\\\ddot{{$1}} {$0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ddot ddot"
        ],
        "opts": []
      },
      {
        "content": "\\\\vec{{$1}} {$0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vec vector"
        ],
        "opts": []
      },
      {
        "content": "\\\\times {$0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "\\x cross product"
        ],
        "opts": []
      },
      {
        "content": "\\\\cdot {$0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          ". dot product"
        ],
        "opts": []
      },
      {
        "content": "\\\\int_{{$1}}^{{$2}} {$3} \\: d{$4} {$5}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "int integral"
        ],
        "opts": []
      },
      {
        "content": "\\\\rightarrow {$0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ra rightarrow"
        ],
        "opts": []
      },
      {
        "content": "\\\\longrightarrow {$0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lra longrightarrow"
        ],
        "opts": []
      }
    ],
    "texmath": [
      {
        "content": "\\begin{equation*}\n\t${0:${VISUAL}}\n\\end{equation*}",
        "doc": null,
        "grammar": "snu",
        "label": "Equation without a number",
        "matches": [
          "eqnn"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "\\begin{align}\n\t${0:${VISUAL}}\n\\end{align}",
        "doc": null,
        "grammar": "snu",
        "label": "Align",
        "matches": [
          "al"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "\\begin{align*}\n\t${0:${VISUAL}}\n\\end{align*}",
        "doc": null,
        "grammar": "snu",
        "label": "Align without a number",
        "matches": [
          "alnn"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "\\begin{eqnarray}\n\t${1:${VISUAL}} & ${2:${VISUAL}} & ${0:${VISUAL}}\n\\end{eqnarray}",
        "doc": null,
        "grammar": "snu",
        "label": "Equation array",
        "matches": [
          "eqa"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "\\begin{eqnarray*}\n\t${1:${VISUAL}} & ${2:${VISUAL}} & ${0:${VISUAL}}\n\\end{eqnarray*}",
        "doc": null,
        "grammar": "snu",
        "label": "Equation array without a number",
        "matches": [
          "eqann"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "\\dv[${1:${VISUAL}}]{${2}}{${3}}",
        "doc": null,
        "grammar": "snu",
        "label": "Derivative",
        "matches": [
          "dv"
        ],
        "opts": [
          "w"
        ]
      },
      {
        "content": "\\pdv[${1:${VISUAL}}]{${2}}{${3}}",
        "doc": null,
        "grammar": "snu",
        "label": "Partial Derivative",
        "matches": [
          "pdv"
        ],
        "opts": [
          "w"
        ]
      },
      {
        "content": "\\SI{${1:${VISUAL}}}{${2}}",
        "doc": null,
        "grammar": "snu",
        "label": "SI-Unit",
        "matches": [
          "SI"
        ],
        "opts": [
          "w"
        ]
      }
    ],
    "textile": [
      {
        "content": "---\ntitle: ${1:title}\nlayout: post\ndate: ${2:date} ${0:hour:minute:second} -05:00\n---",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "header"
        ],
        "opts": []
      },
      {
        "content": "!${1:url}(${2:title}):${0:link}!",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "img"
        ],
        "opts": []
      },
      {
        "content": "|${1}|",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "|"
        ],
        "opts": []
      },
      {
        "content": "\"${1:link text}\":${0:url}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "link"
        ],
        "opts": []
      },
      {
        "content": "(${1:Expand acronym})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "("
        ],
        "opts": []
      },
      {
        "content": "[${1:ref number}] ${0}\nfn$1. ${2:footnote}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fn"
        ],
        "opts": []
      }
    ],
    "toml": [
      {
        "content": "[[plugins]]\nrepo = '`getreg('+')`'\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": "[[plugins]]",
        "matches": [
          "plugins"
        ],
        "opts": []
      }
    ],
    "ts-snippets": [
      {
        "content": "import React, { Component } from 'react'\n\ninterface Props {\n\t\n}\ninterface State {\n\t\n}\n\nexport default class ${1:${TM_FILENAME_BASE}} extends Component<Props, State> {\n\tstate = {}\n\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n",
        "doc": "Creates a React component class with ES7 module system and TypeScript interfaces",
        "grammar": "lsp",
        "label": "typeScriptReactClassComponent",
        "matches": [
          "tsrcc"
        ],
        "opts": []
      },
      {
        "content": "import React, { Component } from 'react'\n\ninterface Props {\n\t\n}\ninterface State {\n\t\n}\n\nclass ${1:${TM_FILENAME_BASE}} extends Component<Props, State> {\n\tstate = {}\n\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "Creates a React component class with ES7 module system and TypeScript interfaces",
        "grammar": "lsp",
        "label": "typeScriptReactClassExportComponent",
        "matches": [
          "tsrce"
        ],
        "opts": []
      },
      {
        "content": "import React, { ReactElement } from 'react'\n\ninterface Props {\n\t\n}\n\nfunction ${1:${TM_FILENAME_BASE}}({}: Props): ReactElement {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "Creates a React Functional Component with ES7 module system and TypeScript interface",
        "grammar": "lsp",
        "label": "typeScriptReactFunctionalExportComponent",
        "matches": [
          "tsrfce"
        ],
        "opts": []
      },
      {
        "content": "import React, { ReactElement } from 'react'\n\ninterface Props {\n\t\n}\n\nexport default function ${1:${TM_FILENAME_BASE}}({}: Props): ReactElement {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n",
        "doc": "Creates a React Functional Component with ES7 module system and TypeScript interface",
        "grammar": "lsp",
        "label": "typeScriptReactFunctionalComponent",
        "matches": [
          "tsrfc"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react'\n\ninterface Props {\n\t\n}\n\nconst ${1:${TM_FILENAME_BASE}} = (props: Props) => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "Creates a React Arrow Function Component with ES7 module system and TypeScript interface",
        "grammar": "lsp",
        "label": "typeScriptReactArrowFunctionExportComponent",
        "matches": [
          "tsrafce"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react'\n\ninterface Props {\n\t\n}\n\nexport const ${1:${TM_FILENAME_BASE}} = (props: Props) => {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}\n",
        "doc": "Creates a React Arrow Function Component with ES7 module system and TypeScript interface",
        "grammar": "lsp",
        "label": "typeScriptReactArrowFunctionComponent",
        "matches": [
          "tsrafc"
        ],
        "opts": []
      },
      {
        "content": "import React, { PureComponent } from 'react'\n\ninterface Props {\n\t\n}\n\nexport default class ${1:${TM_FILENAME_BASE}} extends PureComponent<Props> {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n",
        "doc": "Creates a React pure component class with ES7 module system and TypeScript interface",
        "grammar": "lsp",
        "label": "typeScriptReactClassPureComponent",
        "matches": [
          "tsrpc"
        ],
        "opts": []
      },
      {
        "content": "import React, { PureComponent } from 'react'\n\ninterface Props {\n\t\n}\n\nclass ${1:${TM_FILENAME_BASE}} extends PureComponent<Props> {\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "Creates a React pure component class with ES7 module system and TypeScript interface",
        "grammar": "lsp",
        "label": "typeScriptReactClassExportPureComponent",
        "matches": [
          "tsrpce"
        ],
        "opts": []
      },
      {
        "content": "import React, { memo } from 'react'\n\ninterface Props {\n\t\n}\n\nexport default memo(function ${1:${TM_FILENAME_BASE}}({}: Props) {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n})\n",
        "doc": "Creates a React Memo Function Component with ES7 module system and TypeScript interface",
        "grammar": "lsp",
        "label": "typeScriptReactFunctionMemoComponent",
        "matches": [
          "tsrmc"
        ],
        "opts": []
      },
      {
        "content": "import React, { Component } from 'react'\nimport { connect } from 'react-redux'\n\ninterface Props {\n\t\n}\ninterface State {\n\t\n}\n\nexport class ${1:${TM_FILENAME_BASE}} extends Component<Props, State> {\n\tstate = {}\n\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t$0\n\t\t\t</div>\n\t\t)\n\t}\n}\n\nconst mapStateToProps = (state) => ({\n\t\n})\n\nconst mapDispatchToProps = {\n\t\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(${1:${TM_FILENAME_BASE}})\n",
        "doc": "Creates a React component class with PropTypes with connected redux and ES7 module system and TypeScript interfaces",
        "grammar": "lsp",
        "label": "typeScriptReactClassCompomentRedux",
        "matches": [
          "tsrcredux"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react'\nimport { View, Text } from 'react-native'\n\ninterface Props {\n\t\n}\n\nconst ${1:${TM_FILENAME_BASE}} = (props: Props) => {\n\treturn (\n\t\t<View>\n\t\t\t<Text>$0</Text>\n\t\t</View>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "Creates a React Native Arrow Function Component with ES7 module system and TypeScript interface",
        "grammar": "lsp",
        "label": "typescriptReactNativeArrowFunctionComponent",
        "matches": [
          "tsrnf"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react'\nimport { View } from 'react-native'\n\ninterface ${1:${TM_FILENAME_BASE}}Props {\n\t\n}\n\nconst ${1:${TM_FILENAME_BASE}}: React.FunctionComponent<${1:${TM_FILENAME_BASE}}Props> = (props) => {\n\treturn (\n\t\t<View>\n\t\t\t$0\n\t\t</View>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n",
        "doc": "Creates a React Native Arrow Function Component with ES7 module system and named TypeScript interface",
        "grammar": "lsp",
        "label": "typescriptReactNativeArrowFunctionComponentNamedProps",
        "matches": [
          "tsrnfi"
        ],
        "opts": []
      },
      {
        "content": "import React from 'react'\nimport { StyleSheet, Text, View } from 'react-native'\n\ninterface Props {\n\t\n}\n\nconst ${1:${TM_FILENAME_BASE}} = (props: Props) => {\n\treturn (\n\t\t<View>\n\t\t\t<Text>$0</Text>\n\t\t</View>\n\t)\n}\n\nexport default ${1:${TM_FILENAME_BASE}}\n\nconst styles = StyleSheet.create({})\n",
        "doc": "Creates a React Native Arrow Function Component with ES7 module system, TypeScript interface and StyleSheet",
        "grammar": "lsp",
        "label": "typescriptReactNativeArrowFunctionComponentWithStyles",
        "matches": [
          "tsrnfs"
        ],
        "opts": []
      },
      {
        "content": "export interface ${1:${TM_FILENAME_BASE}} {$0}",
        "doc": null,
        "grammar": "lsp",
        "label": "Export interface",
        "matches": [
          "expint"
        ],
        "opts": []
      },
      {
        "content": "export type ${1:${TM_FILENAME_BASE}} = {$0}",
        "doc": null,
        "grammar": "lsp",
        "label": "Export type",
        "matches": [
          "exptp"
        ],
        "opts": []
      }
    ],
    "twig": [
      {
        "content": "{% autoescape ${1:#:strategy} %}\n\t${0:TARGET}\n{% autoescape %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% autoescape ... %} ... {% endautoescape %}",
        "matches": [
          "autoescape"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "{% block ${1:#:name} %}\n\t${0:TARGET}\n{% endblock %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% block ... %} ... {% endblock %}",
        "matches": [
          "block",
          "bl"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "<pre>\n\t{{ dump(${0:TARGET}) }}\n</pre>",
        "doc": "",
        "grammar": "snu",
        "label": "<pre> {{ dump(...) }} </pre>",
        "matches": [
          "dump"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "{% embed '${1:template}' %}\n\t{% block ${2} %}\n\t\t${0:TARGET}\n\t{% endblock %}\n{% endembed %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% embed ... %} ... {% endembed %}",
        "matches": [
          "embed"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "{% extends '${1:#:template}' %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% extends ... %}",
        "matches": [
          "ext",
          "extends"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "{% filter ${1} %}\n\t${0:TARGET}\n{% endfilter %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% filter ... %} ... {% endfilter %}",
        "matches": [
          "filter"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "{% flush %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% flush %}",
        "matches": [
          "flush"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "{% for ${1:#:value} in ${2:#:list} %}\n\t${0:TARGET}\n{% endfor %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% for ... in ... %} ... {% endfor %}",
        "matches": [
          "for"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "{% from '${1:#:module}' import ${2:#:macro} %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% from '...' import ... %}",
        "matches": [
          "from"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "{% if ${1} %}\n\t${0:TARGET}\n{% endif %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% if ... %} ... {% endif %}",
        "matches": [
          "if"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "{% elseif ${1} %}\n\t${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "{% elseif ... %} ...",
        "matches": [
          "elseif",
          "elif"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "{% else %}\n\t${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "{% else %} ...",
        "matches": [
          "else"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "{% import '${1:#:module}' as ${2:#:namespace} %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% import '...' as ... %}",
        "matches": [
          "import"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "{% include '${1:#:template}' %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% include '...' %}",
        "matches": [
          "include"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "{% include '${1:#:template}' with {${2:#:'key'}: ${2:#:'value'}} %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% include '...' %}",
        "matches": [
          "includewith"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "{% macro ${1:#:name}(${2:#:args}) %}\n\t${0:TARGET}\n{% endmacro %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% macro ...(...) %} ... {% endmacro %}",
        "matches": [
          "macro"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "{% sandbox %}\n\t${0:TARGET}\n{% endsandbox %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% sandbox %} ... {% endsandbox %}",
        "matches": [
          "sandbox"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "{% set ${1:#:var} = ${2:#:value} %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% set ... = ... %}",
        "matches": [
          "set"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "{% set ${1:#:var} %}\n\t${0:TARGET}\n{% endset %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% set ... %} ... {% endset %}",
        "matches": [
          "setblock"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "{% spaceless %}\n\t${0:TARGET}\n{% endspaceless %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% spaceless %} ... {% endspaceless %}",
        "matches": [
          "spaceless"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "{% use '${1:#:template}' %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% use '...' %}",
        "matches": [
          "use"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "{% verbatim %}\n\t${0:TARGET}\n{% endverbatim %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% verbatim %} ... {% endverbatim %}",
        "matches": [
          "verbatim"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "{# ${1:comment} #}",
        "doc": "",
        "grammar": "snu",
        "label": "{# ... #}",
        "matches": [
          "#",
          "comment"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "{% ${1:#:tag} %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% ... %}",
        "matches": [
          "tag",
          "%"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "{% ${1:#:tag} ${2:#:name} %}\n\t${0:TARGET}\n{% end$1 %}",
        "doc": "",
        "grammar": "snu",
        "label": "{% ... %} ... {% end... %}",
        "matches": [
          "tagblock"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "{% apply ${1} %}\n\t${0}\n{% endapply %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "apply \"twig apply\""
        ],
        "opts": []
      },
      {
        "content": "{% autoescape %}\n\t${0}\n{% endautoescape %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "autoescape \"twig autoescape\""
        ],
        "opts": []
      },
      {
        "content": "{% endautoescape %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "endautoescape \"twig endautoescape\""
        ],
        "opts": []
      },
      {
        "content": "{% block ${1} %}\n\t${0}\n{% endblock %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bl \"twig block\""
        ],
        "opts": []
      },
      {
        "content": "{% block ${1} %}\n\t${0}\n{% endblock %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "block \"twig block\""
        ],
        "opts": []
      },
      {
        "content": "{% endblock %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "endblock \"twig endblock\""
        ],
        "opts": []
      },
      {
        "content": "{% cache %}\n\t${0}\n{% endcache %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "cache \"twig cache\""
        ],
        "opts": []
      },
      {
        "content": "{% endcache %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "endcache \"twig endcache\""
        ],
        "opts": []
      },
      {
        "content": "{% css %}\n\t${0}\n{% endcss %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "css \"twig css\""
        ],
        "opts": []
      },
      {
        "content": "{% endcss %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "endcss \"twig endcss\""
        ],
        "opts": []
      },
      {
        "content": "{% dd ${1} %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dd \"twig dd\""
        ],
        "opts": []
      },
      {
        "content": "{% do ${1} %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "do \"twig do\""
        ],
        "opts": []
      },
      {
        "content": "{% embed \"${1}\" %}\n\t${0}\n{% endembed %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "embed \"twig embed\""
        ],
        "opts": []
      },
      {
        "content": "{% endembed %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "endembed \"twig endembed\""
        ],
        "opts": []
      },
      {
        "content": "{% exit ${1} %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "exit \"twig exit\""
        ],
        "opts": []
      },
      {
        "content": "{% extends \"${1}\" %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "extends \"twig extends\""
        ],
        "opts": []
      },
      {
        "content": "{% extends \"${1}\" %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ext \"twig extends\""
        ],
        "opts": []
      },
      {
        "content": "{% for ${1} in ${2} %}\n\t${0}\n{% endfor %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for \"twig for\""
        ],
        "opts": []
      },
      {
        "content": "{% for ${1} in ${2} %}\n\t${3}\n{% else %}\n\t${0}\n{% endfor %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fore \"twig for else\""
        ],
        "opts": []
      },
      {
        "content": "{% endfor %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "endfor \"twig endfor\""
        ],
        "opts": []
      },
      {
        "content": "{% from \"${1}\" import ${2} %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "from \"twig from\""
        ],
        "opts": []
      },
      {
        "content": "{% header \"${1}\" %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "header \"twig header\""
        ],
        "opts": []
      },
      {
        "content": "{% hook \"${1}\" %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "hook \"twig hook\""
        ],
        "opts": []
      },
      {
        "content": "{% html %}\n\t${0}\n{% endhtml %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "html \"twig html\""
        ],
        "opts": []
      },
      {
        "content": "{% endhtml %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "endhtml \"twig endhtml\""
        ],
        "opts": []
      },
      {
        "content": "{% if ${1} %}\n\t${0}\n{% endif %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if \"twig if\""
        ],
        "opts": []
      },
      {
        "content": "{% if ${1} %}\n\t${2}\n{% else %}\n\t${0}\n{% endif %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife \"twig if else\""
        ],
        "opts": []
      },
      {
        "content": "{% else %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "el \"twig else\""
        ],
        "opts": []
      },
      {
        "content": "{% elseif ${1} %}\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eif \"twig elseif\""
        ],
        "opts": []
      },
      {
        "content": "{% endif %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "endif \"twig endif\""
        ],
        "opts": []
      },
      {
        "content": "{% import \"${1}\" as ${2} %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "import \"twig import\""
        ],
        "opts": []
      },
      {
        "content": "{% include \"${1}\" %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "include \"twig include\""
        ],
        "opts": []
      },
      {
        "content": "{% include \"${1}\" with ${2} %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "includewith \"twig include with parameters\""
        ],
        "opts": []
      },
      {
        "content": "{% js %}\n\t${0}\n{% endjs %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "js \"twig js\""
        ],
        "opts": []
      },
      {
        "content": "{% endjs %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "endjs \"twig endjs\""
        ],
        "opts": []
      },
      {
        "content": "{% macro ${1}(${2}) %}\n\t${0}\n{% endmacro %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "macro \"twig macro\""
        ],
        "opts": []
      },
      {
        "content": "{% endmacro %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "endmacro \"twig endmacro\""
        ],
        "opts": []
      },
      {
        "content": "{% namespace \"${1}\" %}\n\t${0}\n{% endnamespace %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "namespace \"twig namespace\""
        ],
        "opts": []
      },
      {
        "content": "{% endnamespace %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "endnamespace \"twig endnamespace\""
        ],
        "opts": []
      },
      {
        "content": "{% nav ${1} in ${2} %}\n\t${0}\n{% endnav %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nav \"twig nav\""
        ],
        "opts": []
      },
      {
        "content": "{% endnav %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "endnav \"twig endnav\""
        ],
        "opts": []
      },
      {
        "content": "{% paginate ${1} as ${2} %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "paginate \"twig paginate\""
        ],
        "opts": []
      },
      {
        "content": "{% redirect \"${1}\" %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "redirect \"twig redirect\""
        ],
        "opts": []
      },
      {
        "content": "{% requireGuest %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "requireguest \"twig requireguest\""
        ],
        "opts": []
      },
      {
        "content": "{% requireLogin %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "requirelogin \"twig requirelogin\""
        ],
        "opts": []
      },
      {
        "content": "{% requirePermission \"${1}\" %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "requirepermission \"twig requirepermission\""
        ],
        "opts": []
      },
      {
        "content": "{% set ${1} = ${2} %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "set \"twig set\""
        ],
        "opts": []
      },
      {
        "content": "{% set ${1} %}\n\t${0}\n{% endset %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "setb \"twig set block\""
        ],
        "opts": []
      },
      {
        "content": "{% endset %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "endset \"twig endset\""
        ],
        "opts": []
      },
      {
        "content": "{% switch ${1} %}\n\t{% case \"${2}\" %}\n\t\t${0}\n\t{% default %}\n{% endswitch %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "switch \"twig switch\""
        ],
        "opts": []
      },
      {
        "content": "{% case \"${1}\" %}\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case \"twig switch case\""
        ],
        "opts": []
      },
      {
        "content": "{% default %}\n\t${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "default \"twig switch default\""
        ],
        "opts": []
      },
      {
        "content": "{% endswitch %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "endswitch \"twig endswitch\""
        ],
        "opts": []
      },
      {
        "content": "{% use \"${1}\" %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "use \"twig use\""
        ],
        "opts": []
      },
      {
        "content": "{% verbatim %}\n\t${0}\n{% endverbatim %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "verbatim \"twig verbatim\""
        ],
        "opts": []
      },
      {
        "content": "{% endverbatim %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "endverbatim \"twig endverbatim\""
        ],
        "opts": []
      },
      {
        "content": "{% with %}\n\t${0}\n{% endwith %}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "with \"twig with\""
        ],
        "opts": []
      },
      {
        "content": "{% endwith %}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "endwith \"twig endwith\""
        ],
        "opts": []
      },
      {
        "content": "<pre>\n\t{{ dump(${1}) }}\n</pre>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "dump \"twig dump\""
        ],
        "opts": []
      },
      {
        "content": "{{ \"${1}\"|t }}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "translate \"twig translate\""
        ],
        "opts": []
      }
    ],
    "typescript": [
      {
        "content": "import { Component, OnInit } from '@angular/core';\n\n@Component({\n\tselector: '${1:selector-name}',\n\ttemplateUrl: '${2:name}.component.html'\n})\n\nexport class ${3:Name}Component implements OnInit {\n\tconstructor() { }\n\n\tngOnInit() { }$0\n}",
        "doc": "Angular component",
        "grammar": "lsp",
        "label": "Angular Component",
        "matches": [
          "a-component"
        ],
        "opts": []
      },
      {
        "content": "import { Component, OnInit } from '@angular/core';\n\n@Component({\n\tselector: '${1:selector-name}',\n\ttemplate: `$0`\n})\n\nexport class ${2:Name}Component implements OnInit {\n\tconstructor() { }\n\n\tngOnInit() { }\n}",
        "doc": "Angular component with an inline template",
        "grammar": "lsp",
        "label": "Angular Component with Inline Template",
        "matches": [
          "a-component-inline"
        ],
        "opts": []
      },
      {
        "content": "import { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n\tname: '${1:selector-name}'\n})\n\nexport class ${2:Name}Pipe implements PipeTransform {\n\ttransform(value: any, ...args: any[]): any {\n\t\t$0\n\t}\n}",
        "doc": "Angular pipe",
        "grammar": "lsp",
        "label": "Angular Pipe",
        "matches": [
          "a-pipe"
        ],
        "opts": []
      },
      {
        "content": "import { Injectable } from '@angular/core';\n\n@Injectable({providedIn: ${1:'root'}})\nexport class ${2:ServiceName}Service {\n\tconstructor() { }\n\t$0\n}",
        "doc": "Angular Service with Injectable ProvidedIn Root",
        "grammar": "lsp",
        "label": "Angular Service",
        "matches": [
          "a-service"
        ],
        "opts": []
      },
      {
        "content": "{ path: '', pathMatch: 'full', redirectTo: '${1:path}' },$0",
        "doc": "Angular default route path",
        "grammar": "lsp",
        "label": "Angular Default Route Path",
        "matches": [
          "a-route-path-default"
        ],
        "opts": []
      },
      {
        "content": "{\n\tpath: '${1:path}', \n\tcomponent: ${2:Component},\n\tchildren: [\n\t\t{ path: '${3:childpath}', component: ${4:ChildComponent} }\n\t]\n},$0",
        "doc": "Angular route path with children",
        "grammar": "lsp",
        "label": "Angular Route Path with Children",
        "matches": [
          "a-route-path-with-children"
        ],
        "opts": []
      },
      {
        "content": "{ path: '**', component: ${1:PathNotFoundComponent} },$0",
        "doc": "Angular 404 route path",
        "grammar": "lsp",
        "label": "Angular 404 Route Path",
        "matches": [
          "a-route-path-404"
        ],
        "opts": []
      },
      {
        "content": "{ path: '${1:path}', component: ${2:Name}Component },$0",
        "doc": "Angular eager route path",
        "grammar": "lsp",
        "label": "Angular Eager Route Path",
        "matches": [
          "a-route-path-eager"
        ],
        "opts": []
      },
      {
        "content": "{\n\tpath: '${1:path}', \n\tloadChildren: () => import('${2:lazy-path}').then(m => m.${3:lazy-module})\n},$0",
        "doc": "Angular lazy route path",
        "grammar": "lsp",
        "label": "Angular Lazy Route Path",
        "matches": [
          "a-route-path-lazy"
        ],
        "opts": []
      },
      {
        "content": "this.route.paramMap\n\t.pipe(map(params => params.get('id')), tap(id => (this.id = +id)))\n\t.subscribe(id => {$1});\n$0",
        "doc": "Angular - subscribe to routing parameters",
        "grammar": "lsp",
        "label": "Routing Params - Subscribe",
        "matches": [
          "a-route-params-subscribe"
        ],
        "opts": []
      },
      {
        "content": "return this.httpClient.get('${1:url}');$0",
        "doc": "Angular HttpClient.get",
        "grammar": "lsp",
        "label": "HttpClient.get",
        "matches": [
          "a-httpclient-get"
        ],
        "opts": []
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\n@Injectable({providedIn: ${1:'root'}})\nexport class ${2:ServiceName}Service {\n\tconstructor(private httpClient: HttpClient) { }\n\t$0\n}",
        "doc": "Angular service with HttpClient",
        "grammar": "lsp",
        "label": "Angular HttpClient Service",
        "matches": [
          "a-service-httpclient"
        ],
        "opts": []
      },
      {
        "content": "import { HttpInterceptor, HttpHandler, HttpRequest, HttpEvent, HttpResponse } from '@angular/common/http';\nimport { Observable } from 'rxjs';\nimport { tap } from 'rxjs/operators';\n\n@Injectable()\nexport class LogInterceptor implements HttpInterceptor {\n\tconstructor() {}\n\n\tintercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n\t\tconst started = Date.now();\n\t\treturn next.handle(req).pipe(\n\t\t\ttap(event => {\n\t\t\t\tif (event instanceof HttpResponse) {\n\t\t\t\t\tconst elapsed = Date.now() - started;\n\t\t\t\t\tconsole.log(`Request for \\${req.urlWithParams} took \\${elapsed} ms.`);\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\t}\n}",
        "doc": "Angular HttpInterceptor for Logging HttpClient",
        "grammar": "lsp",
        "label": "Angular HttpInterceptor for Logging",
        "matches": [
          "a-http-interceptor-logging"
        ],
        "opts": []
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { HttpEvent, HttpInterceptor, HttpHandler, HttpRequest } from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class HeaderInterceptor implements HttpInterceptor {\n\tconstructor() {}\n\n\tintercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n\t\tconst headers = req.headers\n\t\t\t.set('Content-Type', 'application/json');\n\t\tconst authReq = req.clone({ headers });\n\t\treturn next.handle(authReq);\n\t}\n}",
        "doc": "Angular HttpInterceptor for headers HttpClient",
        "grammar": "lsp",
        "label": "Angular HttpInterceptor for Headers",
        "matches": [
          "a-http-interceptor-headers"
        ],
        "opts": []
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { HttpInterceptor, HttpEvent, HttpHandler, HttpRequest } from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class ${2:Your}Interceptor implements HttpInterceptor {\n\tintercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n\t\treturn next.handle(req);\n\t}\n}",
        "doc": "Empty Angular HttpInterceptor for HttpClient",
        "grammar": "lsp",
        "label": "Angular HttpInterceptor - Empty",
        "matches": [
          "a-http-interceptor"
        ],
        "opts": []
      },
      {
        "content": "@Output() ${1:eventName} = new EventEmitter<${2:eventType}>();",
        "doc": "Angular @Output event and emitter",
        "grammar": "lsp",
        "label": "Output Event",
        "matches": [
          "a-output-event"
        ],
        "opts": []
      },
      {
        "content": "this.${1:service}.${2:function}\n\t.subscribe(${3:arg} => this.${4:property} = ${3:arg});\n$0",
        "doc": "Angular observable subscribe",
        "grammar": "lsp",
        "label": "Subscribe",
        "matches": [
          "a-subscribe"
        ],
        "opts": []
      },
      {
        "content": "import { Component } from '@angular/core';\n\n@Component({\n\tselector: '${1:prefix-app}',\n\ttemplate: `\n\t\t<router-outlet></router-outlet>\n\t\t`\n})\nexport class ${2:App}Component { }\n$0",
        "doc": "Angular App root component",
        "grammar": "lsp",
        "label": "Angular Root Component",
        "matches": [
          "a-component-root"
        ],
        "opts": []
      },
      {
        "content": "import { NgModule } from '@angular/core';\nimport { BrowserModule  } from '@angular/platform-browser';\nimport { HttpModule } from '@angular/http';\n\nimport { ${1:App}Component } from './${1:app}.component';\n\n@NgModule({\n\timports: [\n\t\tBrowserModule,\n\t\tHttpModule,\n\t],\n\tdeclarations: [${1:App}Component],\n\tbootstrap: [${1:App}Component],\n})\nexport class ${1:App}Module { }\n$0",
        "doc": "Angular Root Module",
        "grammar": "lsp",
        "label": "Angular Root Module",
        "matches": [
          "a-module-root"
        ],
        "opts": []
      },
      {
        "content": "import { Routes } from '@angular/router';\n\nexport const routes: Routes = [${0}]",
        "doc": "Route definitions",
        "grammar": "lsp",
        "label": "Route definitions",
        "matches": [
          "a-routes"
        ],
        "opts": []
      },
      {
        "content": "import { NgModule } from '@angular/core';\n\nimport { ${1:Name}Component } from './${2:name}.component';\n\n@NgModule({\n\timports: [],\n\texports: [],\n\tdeclarations: [${1:Name}Component],\n\tproviders: [],\n})\nexport class ${1:Name}Module { }\n$0",
        "doc": "Angular Module",
        "grammar": "lsp",
        "label": "Angular Module",
        "matches": [
          "a-module"
        ],
        "opts": []
      },
      {
        "content": "import { Directive } from '@angular/core';\n\n@Directive({ selector: '[${1:selector-name}]' })\nexport class ${2:Name}Directive {\n\tconstructor() { }\n}",
        "doc": "Angular directive",
        "grammar": "lsp",
        "label": "Angular Directive",
        "matches": [
          "a-directive"
        ],
        "opts": []
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { ActivatedRouteSnapshot, CanActivate, RouterStateSnapshot } from '@angular/router';\n\n@Injectable({providedIn: ${1:'root'}})\nexport class ${2:Name}Guard implements CanActivate {\n\tconstructor() { }\n\n\tcanActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {\n\t\treturn true;$0\n\t}\n}",
        "doc": "Angular CanActivate guard",
        "grammar": "lsp",
        "label": "Angular CanActivate Guard",
        "matches": [
          "a-guard-can-activate"
        ],
        "opts": []
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { ActivatedRouteSnapshot, CanActivateChild, RouterStateSnapshot } from '@angular/router';\n\n@Injectable({providedIn: ${1:'root'}})\nexport class ${2:Name}Guard implements CanActivateChild {\n\tconstructor() { }\n\n\tcanActivateChild(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {\n\t\treturn true;$0\n\t}\n}",
        "doc": "Angular CanActivateChild guard",
        "grammar": "lsp",
        "label": "Angular CanActivateChild Guard",
        "matches": [
          "a-guard-can-activate-child"
        ],
        "opts": []
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { CanLoad, Route } from '@angular/router';\n\n@Injectable({providedIn: ${1:'root'}})\nexport class ${2:Name}Guard implements CanLoad {\n\tconstructor() { }\n\n\tcanLoad(route: Route) {\n\t\treturn true;$0\n\t}\n}",
        "doc": "Angular CanLoad guard",
        "grammar": "lsp",
        "label": "Angular CanLoad Guard",
        "matches": [
          "a-guard-can-load"
        ],
        "opts": []
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { ActivatedRouteSnapshot, CanDeactivate, RouterStateSnapshot } from '@angular/router';\nimport { Observable } from 'rxjs';\n\nimport { ${2:ComponentName}Component } from './${3:filename}.component';\n\n// Consider using this interface for all CanDeactivate guards,\n// and have your components implement this interface, too.\n//\n//   e.g. export class CanDeactivateGuard implements CanDeactivate<CanComponentDeactivate> {\n//\n// export interface CanComponentDeactivate {\n// canDeactivate: () => any;\n// }\n\n@Injectable({providedIn: ${4:'root'}})\nexport class ${1:Name}Guard implements CanDeactivate<${2:ComponentName}Component> {\n\tcanDeactivate(\n\t\tcomponent: ${2:ComponentName}Component,\n\t\tcurrentRoute: ActivatedRouteSnapshot, \n\t\tcurrentState: RouterStateSnapshot\n\t): Observable<boolean>|Promise<boolean>|boolean {\n\t\treturn false;$0\n\t}\n}",
        "doc": "Angular CanDeactivate guard",
        "grammar": "lsp",
        "label": "Angular CanDeactivate Guard",
        "matches": [
          "a-guard-can-deactivate"
        ],
        "opts": []
      },
      {
        "content": "import { PreloadingStrategy, Route } from '@angular/router';\nimport { Observable, of } from 'rxjs';\n\nexport class PreloadSelectedModulesList implements PreloadingStrategy {\n\tpreload(route: Route, load: Function): Observable<any> {\n\t\treturn route.data && route.data['${1:preload}'] ? load() : of(null);\n\t}\n}\n$0",
        "doc": "Angular opt-in preload strategy",
        "grammar": "lsp",
        "label": "Angular Opt-In Preload Strategy",
        "matches": [
          "a-preload-opt-in-strategy"
        ],
        "opts": []
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { PreloadingStrategy, Route } from '@angular/router';\nimport { Observable, EMPTY } from 'rxjs';\n\n// avoid typing issues for now\nexport declare var navigator;\n\n@Injectable({ providedIn: 'root' })\nexport class NetworkAwarePreloadStrategy implements PreloadingStrategy {\n\tpreload(route: Route, load: () => Observable<any>): Observable<any> {\n\t\treturn this.hasGoodConnection() ? load() : EMPTY;\n\t}\n\n\thasGoodConnection(): boolean {\n\t\tconst conn = navigator.connection;\n\t\tif (conn) {\n\t\t\tif (conn.saveData) {\n\t\t\t\treturn false; // save data mode is enabled, so dont preload\n\t\t\t}\n\t\t\tconst avoidTheseConnections = ['slow-2g', '2g' /* , '3g', '4g' */];\n\t\t\tconst effectiveType = conn.effectiveType || '';\n\t\t\tif (avoidTheseConnections.includes(effectiveType)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}",
        "doc": "Angular network aware preload strategy",
        "grammar": "lsp",
        "label": "Angular Network-Aware Preload Strategy",
        "matches": [
          "a-preload-network-strategy"
        ],
        "opts": []
      },
      {
        "content": "checkEvents() {\n\tthis.router.events.subscribe(event => {\n\t\tswitch (true) {\n\t\t\tcase event instanceof ${1:eventName}:\n\t\t\t\t$0\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t});\n}",
        "doc": "Angular Router Events",
        "grammar": "lsp",
        "label": "Angular Router Events",
        "matches": [
          "a-router-events"
        ],
        "opts": []
      },
      {
        "content": "constructor( @Optional() @SkipSelf() parentModule: ${1:ModuleName} {\n\tif (parentModule) {\n\t\tconst msg = `${1:ModuleName} has already been loaded. \n\t\t\tImport ${1:ModuleName} once, only, in the root AppModule.`;\n\t\tthrow new Error(msg);\n\t}\n}",
        "doc": "Angular Module SkipSelf constructor",
        "grammar": "lsp",
        "label": "Angular Module SkipSelf Constructor",
        "matches": [
          "a-ctor-skip-self"
        ],
        "opts": []
      },
      {
        "content": "import { ${1:Observable} } from 'rxjs';\n$0",
        "doc": "RxJs import",
        "grammar": "lsp",
        "label": "RxJs Import",
        "matches": [
          "a-rxjs-import"
        ],
        "opts": []
      },
      {
        "content": "import { ${1:map} } from 'rxjs/operators';\n$0",
        "doc": "RxJs import",
        "grammar": "lsp",
        "label": "RxJs Operator Import",
        "matches": [
          "a-rxjs-operator-import"
        ],
        "opts": []
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport { Resolve, ActivatedRouteSnapshot } from '@angular/router';\nimport { Observable } from 'rxjs';\n\n@Injectable({ providedIn: ${1:'root'} })\nexport class ${2:YourResolver} implements Resolve<${3:ObjectToResolve}> {\n\tresolve(route: ActivatedRouteSnapshot): Observable<${3:ObjectToResolve}> | Promise<${3:ObjectToResolve}> | ${3:ObjectToResolve} {\n\t\treturn ${0};\n\t}\n}",
        "doc": "Angular Resolver",
        "grammar": "lsp",
        "label": "Angular Resolver",
        "matches": [
          "a-resolver"
        ],
        "opts": []
      },
      {
        "content": "import { NgModule } from '@angular/core';\nimport { EffectsModule } from '@ngrx/effects';\nimport { StoreModule } from '@ngrx/store';\nimport { StoreDevtoolsModule } from '@ngrx/store-devtools';\nimport { environment } from '../../environments/environment';\n\n@NgModule({\n  imports: [\n    StoreModule.forRoot({}),\n    EffectsModule.forRoot([]),\n    environment.production ? [] : StoreDevtoolsModule.instrument()\n  ]\n})\nexport class $1StoreModule {}",
        "doc": "NgRx Store Module",
        "grammar": "lsp",
        "label": "NgRx Store Module",
        "matches": [
          "a-ngrx-store-module"
        ],
        "opts": []
      },
      {
        "content": "export const ${1:action} = createAction('[${2:Source}] ${3:Event}');",
        "doc": "Creates an NgRx Action",
        "grammar": "lsp",
        "label": "NgRx Create Action",
        "matches": [
          "a-ngrx-create-action"
        ],
        "opts": []
      },
      {
        "content": "export const ${1:action} = createAction('[${2:Source}] ${3:Event}', props<{${4:key}: ${5:type}}>());",
        "doc": "Creates an NgRx Action with Props",
        "grammar": "lsp",
        "label": "NgRx Create Action w/ Props",
        "matches": [
          "a-ngrx-create-action-props"
        ],
        "opts": []
      },
      {
        "content": "const ${1:feature}Reducer = createReducer(\n\tinitialState,\n\ton($1Actions.action, state => ({ ...state, ${2:prop}: ${3:updatedValue} })),\n);\n\nexport function reducer(state: State | undefined, action: Action) {\n\treturn $1Reducer(state, action);\n}",
        "doc": "Creates an NgRx Reducer",
        "grammar": "lsp",
        "label": "NgRx Create Reducer",
        "matches": [
          "a-ngrx-create-reducer"
        ],
        "opts": []
      },
      {
        "content": "${1:effectName}$ = createEffect(() => {\n\treturn this.actions$.pipe(\n\t\t\tofType(${2:action}),\n\t\t\t/** An EMPTY observable only emits completion. Replace with your own observable stream */\n\t\t\t${3:operator}(() => ${4:EMPTY}));\n});",
        "doc": "Creates an NgRx Effect",
        "grammar": "lsp",
        "label": "NgRx Create Effect",
        "matches": [
          "a-ngrx-create-effect"
        ],
        "opts": []
      },
      {
        "content": "${1:effectName}$ = createEffect(() => {\n\treturn this.actions$.pipe(\n\t\t\tofType(${2:Feature}Actions.${3:action}),\n\t\t\t${4:operator}(() =>\n\t\t\t\t${5:apiSource}.pipe(\n\t\t\t\t\tmap(data => $2Actions.$3Success({ data })),\n\t\t\t\t\tcatchError(error => of($2Actions.$3Failure({ error }))))\n\t\t\t\t),\n\t);\n});",
        "doc": "Creates an NgRx Effect Scaffolded for API Call",
        "grammar": "lsp",
        "label": "NgRx Create Effect for API Call",
        "matches": [
          "a-ngrx-create-effect-api"
        ],
        "opts": []
      },
      {
        "content": "export const select${1:Feature}${2:Property} = createSelector(\n\tselect$1,\n\t(state: $1State) => state.${3:property}\n);",
        "doc": "Creates an NgRx Selector",
        "grammar": "lsp",
        "label": "NgRx Create Selector",
        "matches": [
          "a-ngrx-create-selector"
        ],
        "opts": []
      },
      {
        "content": "export const select${1:Feature}${2:Property} = createSelector(\n\tselect$1,\n\t(state: $1State, props) => ${3:selectLogic}\n);",
        "doc": "Creates an NgRx Selector using props",
        "grammar": "lsp",
        "label": "NgRx Create Selector w/ Props",
        "matches": [
          "a-ngrx-create-selector-props"
        ],
        "opts": []
      },
      {
        "content": "EntityDataModule.forRoot(${1:entityConfig}),",
        "doc": "Import NgRx Entity Data Module",
        "grammar": "lsp",
        "label": "NgRx Data Import Entity Data Module",
        "matches": [
          "a-ngrx-data-entity-data-module-import"
        ],
        "opts": []
      },
      {
        "content": "import { EntityMetadataMap } from '@ngrx/data';\n\nconst entityMetadata: EntityMetadataMap = {\n  ${1:Model1}: {},${0}\n};\n\nexport const entityConfig = {\n  entityMetadata\n};",
        "doc": "NgRx Data Entity Metadata",
        "grammar": "lsp",
        "label": "NgRx Data Entity Metadata",
        "matches": [
          "a-ngrx-data-entity-metadata"
        ],
        "opts": []
      },
      {
        "content": "import { Injectable } from '@angular/core';\nimport {\n  EntityCollectionServiceBase,\n  EntityCollectionServiceElementsFactory\n} from '@ngrx/data';\nimport { ${1:Model} } from '${2:../core}';\n\n@Injectable({ providedIn: ${3:'root'} })\nexport class ${1:Model}Service extends EntityCollectionServiceBase<${1:Model}> {\n  constructor(serviceElementsFactory: EntityCollectionServiceElementsFactory) {\n    super('${1:Model}', serviceElementsFactory);\n  }\n}",
        "doc": "NgRx Data Entity Collection Data Service",
        "grammar": "lsp",
        "label": "NgRx Data Entity Collection Data Service",
        "matches": [
          "a-ngrx-data-entity-collection-data-service"
        ],
        "opts": []
      },
      {
        "content": "${1:trackBy}(index: number, ${2:name}: ${3:model}): ${4:number} {\n  return ${2:name}${5:.id};$0\n}",
        "doc": "TrackBy Function",
        "grammar": "lsp",
        "label": "TrackBy Function",
        "matches": [
          "a-trackby"
        ],
        "opts": []
      },
      {
        "content": "const ${1}: ${2:any} = ${3};\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tconst \"ts const\""
        ],
        "opts": []
      },
      {
        "content": "let ${1}: ${2:any} = ${3};\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tlet \"ts let\""
        ],
        "opts": []
      },
      {
        "content": "var ${1}: ${2:any} = ${3};\n${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tvar \"ts var\""
        ],
        "opts": []
      },
      {
        "content": "${1}: ${0:any}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "+ \"ts create field\""
        ],
        "opts": []
      },
      {
        "content": "#${1}: ${0:any}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#+ \"ts create private field using #\""
        ],
        "opts": []
      },
      {
        "content": "public ${1}: ${0:any}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tpfi \"ts create public field\""
        ],
        "opts": []
      },
      {
        "content": "private ${1}: ${0:any}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tprfi \"ts create private field\""
        ],
        "opts": []
      },
      {
        "content": "protected ${1}: ${0:any}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tprofi \"ts create protected field\""
        ],
        "opts": []
      },
      {
        "content": "interface ${1} {\n\t${2}: ${3:any};\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "int \"interface\""
        ],
        "opts": []
      },
      {
        "content": "interface ${1} extends ${2} {\n\t${3}: ${4:any};\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "intx \"interface extends\""
        ],
        "opts": []
      },
      {
        "content": "function ${1}(${2}): ${3:any} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tfun \"ts function\""
        ],
        "opts": []
      },
      {
        "content": "public ${1}(${2}): ${3:any} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tpmet \"ts public method\""
        ],
        "opts": []
      },
      {
        "content": "public static ${1}(${2}): ${3:any} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tpsmet \"ts public static method\""
        ],
        "opts": []
      },
      {
        "content": "private ${1}(${2}): ${3:any} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tprmet \"ts private method\""
        ],
        "opts": []
      },
      {
        "content": "protected ${1}(${2}): ${3:any} {\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tpromet \"ts protected method\""
        ],
        "opts": []
      },
      {
        "content": "class ${1} {\n\t${2}\n\tconstructor(public ${3}: ${4: any}) {\n\t\t${5}\n\t}\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tcla \"ts class\""
        ],
        "opts": []
      },
      {
        "content": "class ${1} extends ${2} {\n\t${3}\n\tconstructor(public ${4}: ${5: any}) {\n\t\t${6}\n\t}\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tclax \"ts class extends\""
        ],
        "opts": []
      },
      {
        "content": "var ${1:#:NAME}: ${2:#:TYPE} = ${0:#:TARGET};",
        "doc": "",
        "grammar": "snu",
        "label": "var NAME: TYPE = expr;",
        "matches": [
          "var-with-type"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "class ${1:#:NAME} {\n  constructor(${2:#:Args}) {\n    ${3:#:TARGET}\n  }\n  ${0:#:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "class NAME {...}",
        "matches": [
          "class"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "${1:#:NAME}(${2:#:Args}): ${3:#:TYPE} {\n  ${0:#:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "method"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "get ${1:#:NAME}(): ${2:#:TYPE} {\n  ${3:#:TARGET}\n}\nset $1(${4:value}: $2) {\n  ${0:#:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "accessor"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "static ${1:#:NAME}(${2:#:Args}) {\n  ${0:#:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "static f(){}",
        "matches": [
          "static"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "interface ${1:#:NAME} {\n  ${0:#:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "interface NAME {...}",
        "matches": [
          "interface"
        ],
        "opts": [
          "word"
        ]
      },
      {
        "content": "enum ${1:#:NAME} {\n  ${0:#:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "enum NAME {...}",
        "matches": [
          "enum"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "module ${1:#:NAME} {\n  ${0:#:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "module NAME {...}",
        "matches": [
          "module"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "namespace ${1:#:NAME} {\n  ${0:#:TARGET}\n}",
        "doc": "",
        "grammar": "snu",
        "label": "namespace NAME {...}",
        "matches": [
          "namespace"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "/// <reference path=\"${0:#:TARGET}\" />",
        "doc": "",
        "grammar": "snu",
        "label": "/// <reference path=\"...\" />",
        "matches": [
          "reference"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "(${1:#:Args}) => { ${0:#:TARGET} }",
        "doc": "",
        "grammar": "snu",
        "label": "() => {}",
        "matches": [
          "function-arrow",
          "arrow-function"
        ],
        "opts": [
          "word"
        ]
      }
    ],
    "typescriptreact": [],
    "verilog": [
      {
        "content": "if (${1}) begin\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "if (${1}) begin\n\t${2}\nend\nelse begin\n\t${3}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "else if (${1}) begin\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eif"
        ],
        "opts": []
      },
      {
        "content": "else begin\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "el"
        ],
        "opts": []
      },
      {
        "content": "while (${1}) begin\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh"
        ],
        "opts": []
      },
      {
        "content": "repeat (${1}) begin\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "rep"
        ],
        "opts": []
      },
      {
        "content": "case (${1:/* variable */})\n\t${2:/* value */}: begin\n\t\t${3}\n\tend\n\tdefault: begin\n\t\t${4}\n\tend\nendcase",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case"
        ],
        "opts": []
      },
      {
        "content": "casez (${1:/* variable */})\n\t${2:/* value */}: begin\n\t\t${3}\n\tend\n\tdefault: begin\n\t\t${4}\n\tend\nendcase",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "casez"
        ],
        "opts": []
      },
      {
        "content": "always @(${1:/* sensitive list */}) begin\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "al"
        ],
        "opts": []
      },
      {
        "content": "module ${1:`vim_snippets#Filename('$1', 'name')`} (${2});\n\t${0}\nendmodule",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "mod"
        ],
        "opts": []
      },
      {
        "content": "for (int ${2:i} = 0; $2 < ${1:count}; $2${3:++}) begin\n\t${4}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "forever begin\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forev"
        ],
        "opts": []
      },
      {
        "content": "function ${1:void} ${2:name}(${3});\n\t${0}\nendfunction: $2",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fun"
        ],
        "opts": []
      },
      {
        "content": "task ${1:name}(${2});\n\t${0}\nendtask: $1",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "task"
        ],
        "opts": []
      },
      {
        "content": "initial begin\n\t${0}\nend",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ini"
        ],
        "opts": []
      },
      {
        "content": "typedef struct packed {\n\tint ${2:data};\n} ${1:`vim_snippets#Filename('$1_t', 'name')`};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tdsp"
        ],
        "opts": []
      },
      {
        "content": "typedef enum ${2:logic[15:0]}\n{\n\t${3:REG = 16'h0000}\n} ${1:my_dest_t};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "tde"
        ],
        "opts": []
      },
      {
        "content": "always @(${1:*})${2:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "always @()",
        "matches": [
          "al"
        ],
        "opts": []
      },
      {
        "content": "always @(posedge clk${1})${2:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "always @(posedge clk)",
        "matches": [
          "alclk"
        ],
        "opts": []
      },
      {
        "content": "begin\n    ${1:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "begin ... end",
        "matches": [
          "beginend",
          "be"
        ],
        "opts": []
      },
      {
        "content": "module ${1:`expand(\"%:r\")`}(\n    ${2:TARGET}\n);\nendmodule",
        "doc": "",
        "grammar": "snu",
        "label": "module () ... endmodule",
        "matches": [
          "mod",
          "module"
        ],
        "opts": []
      },
      {
        "content": "reg${1:#: nbit} ${2:reg}_r, $2_w;${3:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "reg [] _r, _w;",
        "matches": [
          "rw"
        ],
        "opts": []
      },
      {
        "content": "input${1:#: nbit} i_${2:name},",
        "doc": "",
        "grammar": "snu",
        "label": "input [] i_,",
        "matches": [
          "I"
        ],
        "opts": []
      },
      {
        "content": "output${1:#: nbit} o_${2:name},",
        "doc": "",
        "grammar": "snu",
        "label": "output [] o_,",
        "matches": [
          "O"
        ],
        "opts": []
      },
      {
        "content": "inout${1:#: nbit} io_${2:name},",
        "doc": "",
        "grammar": "snu",
        "label": "inout [] io_,",
        "matches": [
          "IO"
        ],
        "opts": []
      },
      {
        "content": "reg [${1}:${2:0}] ${3:name} [${4:0}:${5}];${6:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "reg [] name []",
        "matches": [
          "regmemory",
          "regm"
        ],
        "opts": []
      },
      {
        "content": "${1:reg}_r <= $1_w;${2:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "_r <= _w;",
        "matches": [
          "regseq"
        ],
        "opts": []
      },
      {
        "content": "${1:reg}_w = $1_r;${2:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "_w = _r",
        "matches": [
          "regkeep"
        ],
        "opts": []
      },
      {
        "content": "assign ${1:#:name} = ${2:#:val};${3:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "assign ... = ...",
        "matches": [
          "assign",
          "as"
        ],
        "opts": []
      },
      {
        "content": "parameter ${1:#:name} = ${2:#:val};${3:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "parameter ... = ...",
        "matches": [
          "parameter",
          "pa"
        ],
        "opts": []
      },
      {
        "content": "localparam ${1:#:name} = ${2:#:val};${3:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "localparam ... = ...",
        "matches": [
          "localparam",
          "lpa"
        ],
        "opts": []
      },
      {
        "content": "if (${1:#:condition})${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "if()",
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "else${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "else",
        "matches": [
          "else",
          "el"
        ],
        "opts": []
      },
      {
        "content": "else if (${1:#:condition})${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "else if ()",
        "matches": [
          "elseif"
        ],
        "opts": []
      },
      {
        "content": "initial begin\n    ${0:TARGET}\nend",
        "doc": "",
        "grammar": "snu",
        "label": "initial begin ... end",
        "matches": [
          "init",
          "initial"
        ],
        "opts": []
      },
      {
        "content": "for (${1:i} = ${2}; $1 < ${3}; ${4:$1 = $1 + 1})${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "for () begin ... end",
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "while (${1:#:condition})${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": "while () begin ... end",
        "matches": [
          "while"
        ],
        "opts": []
      },
      {
        "content": "case (${1})\n    ${2:'b0}: begin\n        ${3}\n    end\n    default : begin\n        ${4}\n    end\nendcase",
        "doc": "",
        "grammar": "snu",
        "label": "case () ... endcase",
        "matches": [
          "case"
        ],
        "opts": []
      },
      {
        "content": "function${1:# nbit} ${1:func_name};\n    ${2:portlist};\n    begin\n        ${0:TARGET};\n    end\nendfunction",
        "doc": "",
        "grammar": "snu",
        "label": "function ... endfunction",
        "matches": [
          "func",
          "function"
        ],
        "opts": []
      },
      {
        "content": "\\`include \"${1}\"${0}",
        "doc": "",
        "grammar": "snu",
        "label": "`include \"...\"",
        "matches": [
          "`inc, `include",
          "inc"
        ],
        "opts": []
      },
      {
        "content": "\\`define ${1} ${2}",
        "doc": "",
        "grammar": "snu",
        "label": "`define ... ...",
        "matches": [
          "def",
          "`def, `define"
        ],
        "opts": []
      },
      {
        "content": "\\`default_nettype ${1:none}${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "default_nettype",
          "dn, defn"
        ],
        "opts": []
      },
      {
        "content": "\\`timescale ${1:1ns}/${2:100ps}${0}",
        "doc": "",
        "grammar": "snu",
        "label": "`timescale 1ns/100ps",
        "matches": [
          "timescale",
          "ts, `time, `timescale"
        ],
        "opts": []
      },
      {
        "content": "(${1:#:condition}) ? ${2:#:a} : ${3:#:b}",
        "doc": "",
        "grammar": "snu",
        "label": "() ? a : b",
        "matches": [
          "ternary",
          "ter"
        ],
        "opts": []
      },
      {
        "content": "$dumpfile(\"${1:`expand(\"%:r\")`}.vcd\");${0}",
        "doc": "",
        "grammar": "snu",
        "label": "$dumpfile(\"....vcd\");",
        "matches": [
          "df",
          "dumpfile"
        ],
        "opts": []
      },
      {
        "content": "$dumpvars(${1:0}, ${2:`expand(\"%:r\")`});${0}",
        "doc": "",
        "grammar": "snu",
        "label": "$dumpvars(0, ...);",
        "matches": [
          "dumpvars",
          "dv"
        ],
        "opts": []
      },
      {
        "content": "$display(\"${1}\", ${2});",
        "doc": "",
        "grammar": "snu",
        "label": "$display(\"...\", ...);",
        "matches": [
          "display"
        ],
        "opts": []
      },
      {
        "content": "$strobe(\"${1}\", ${2});",
        "doc": "",
        "grammar": "snu",
        "label": "$strobe(\"...\", ...);",
        "matches": [
          "strobe"
        ],
        "opts": []
      }
    ],
    "vhdl": [
      {
        "content": "library ${1}\nuse $1.${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "lib"
        ],
        "opts": []
      },
      {
        "content": "library IEEE;\nuse IEEE.std_logic_1164.ALL;\nuse IEEE.numeric_std.ALL;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "libs"
        ],
        "opts": []
      },
      {
        "content": "library UNISIM;\nuse UNISIM.VCOMPONENTS.ALL;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "libx"
        ],
        "opts": []
      },
      {
        "content": "entity ${1:`vim_snippets#Filename()`} is\n\tgeneric (\n\t\t${2}\n\t);\n\tport (\n\t\t${3}\n\t);\nend entity $1;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ent"
        ],
        "opts": []
      },
      {
        "content": "architecture ${1:behav} of ${2:`vim_snippets#Filename()`} is\n\t${3}\nbegin\nend $1;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "arc"
        ],
        "opts": []
      },
      {
        "content": "signal ${1} : std_logic;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "st"
        ],
        "opts": []
      },
      {
        "content": "signal ${1} : std_logic_vector (${2} downto 0);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "sv"
        ],
        "opts": []
      },
      {
        "content": "${1} : in std_logic;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ist"
        ],
        "opts": []
      },
      {
        "content": "${1} : in std_logic_vector (${2} downto 0);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "isv"
        ],
        "opts": []
      },
      {
        "content": "${1} : out std_logic;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ost"
        ],
        "opts": []
      },
      {
        "content": "${1} : out std_logic_vector (${2} downto 0);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "osv"
        ],
        "opts": []
      },
      {
        "content": "signal ${1} : unsigned (${2} downto 0);",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "un"
        ],
        "opts": []
      },
      {
        "content": "process (${1})\nbegin\n\t${2}\nend process;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pr"
        ],
        "opts": []
      },
      {
        "content": "process (${1:clk})\nbegin\n\tif rising_edge ($1) then\n\t\t${2}\n\tend if;\nend process;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prc"
        ],
        "opts": []
      },
      {
        "content": "process (${1:clk}, ${2:nrst})\nbegin\n\tif ($2 = '${3:0}') then\n\t\t${4}\n\telsif rising_edge($1) then\n\t\t${5}\n\tend if;\nend process;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "prcr"
        ],
        "opts": []
      },
      {
        "content": "process (${1:all})\nbegin\n\t${2}\nend process;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "pra"
        ],
        "opts": []
      },
      {
        "content": "if ${1} then\n\t${2}\nend if;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "if ${1} then\n\t${2}\nelse\n\t${3}\nend if;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "else\n\t${1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "el"
        ],
        "opts": []
      },
      {
        "content": "elsif ${1} then\n\t${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eif"
        ],
        "opts": []
      },
      {
        "content": "case ${1} is\n\t${2}\nend case;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ca"
        ],
        "opts": []
      },
      {
        "content": "when ${1} =>\n\t${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh"
        ],
        "opts": []
      },
      {
        "content": "for ${1:i} in ${2} ${3:to} ${4} loop\n\t${5}\nend loop;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "while ${1} loop\n\t${2}\nend loop;",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh"
        ],
        "opts": []
      },
      {
        "content": "(others => '${1:0}');",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "oth"
        ],
        "opts": []
      }
    ],
    "vim": [
      {
        "content": "if ${1:#:condition}\n  ${0:TARGET}\nendif",
        "doc": "",
        "grammar": "snu",
        "label": "if endif",
        "matches": [
          "if"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "elseif ${1:#:condition}\n    ${0:TARGET}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "elseif"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "if ${1:#:condition}\n  ${2:TARGET}\nelse\n  ${3}\nendif",
        "doc": "",
        "grammar": "snu",
        "label": "if else endif",
        "matches": [
          "ifelse"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "for ${1:#:var} in ${2:#:list}\n  ${0:TARGET}\nendfor",
        "doc": "",
        "grammar": "snu",
        "label": "for in endfor",
        "matches": [
          "for"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "while ${1:#:condition}\n  ${0:TARGET}\nendwhile",
        "doc": "",
        "grammar": "snu",
        "label": "while endwhile",
        "matches": [
          "while"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "function! ${1:#:func_name}(${2}) abort\n  ${0:TARGET}\nendfunction",
        "doc": "",
        "grammar": "snu",
        "label": "func endfunc",
        "matches": [
          "func",
          "function"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "try\n  ${1:TARGET}\ncatch /${2:#:pattern}/\n  ${3}\nendtry",
        "doc": "",
        "grammar": "snu",
        "label": "try endtry",
        "matches": [
          "try"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "try\n  ${1:TARGET}\nfinally\n  ${2}\nendtry",
        "doc": "",
        "grammar": "snu",
        "label": "try ... finally ... endtry",
        "matches": [
          "tryfinally",
          "tryf"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "catch ${1:/${2:#:pattern: empty, E484, Vim(cmdname):{errmsg\\\\}\\}/}",
        "doc": "",
        "grammar": "snu",
        "label": "catch /pattern/",
        "matches": [
          "catch"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "echomsg string(${1:TARGET})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "log",
          "echomsg"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "command! ${1:#:command_name} call ${2:#:func_name}",
        "doc": "",
        "grammar": "snu",
        "label": "command call function",
        "matches": [
          "command"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "function! ${1:#:func_name}(arglead, cmdline, cursorpos) abort\n  return filter(${2:#:list}, 'stridx(v:val, a:arglead) == 0')\nendfunction",
        "doc": "",
        "grammar": "snu",
        "label": "customlist complete function",
        "matches": [
          "customlist"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "augroup ${1:#:augroup_name}\n  autocmd!\n  autocmd ${2:#:event}\naugroup END",
        "doc": "",
        "grammar": "snu",
        "label": "augroup with autocmds",
        "matches": [
          "augroup"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "redir => ${1:#:var}\n\t${2::TARGET}\nredir END",
        "doc": "",
        "grammar": "snu",
        "label": "redir => var",
        "matches": [
          "redir"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "NeoBundle '`getreg('+')=='' ? '<\\`0\\`>' : getreg('+')`'${0}",
        "doc": "",
        "grammar": "snu",
        "label": "NeoBundle ''",
        "matches": [
          "NeoBundle",
          "neobundle"
        ],
        "opts": []
      },
      {
        "content": "NeoBundleLazy '`getreg('+')=='' ? '<\\`0\\`>' : getreg('+')`', {\n  \\ ${0}\n  \\ }",
        "doc": "",
        "grammar": "snu",
        "label": "NeoBundleLazy ''",
        "matches": [
          "NeoBundleLazy",
          "neobundlelazy"
        ],
        "opts": []
      },
      {
        "content": "let s:hooks = neobundle#get_hooks('${1}')\nfunction! s:hooks.on_source(bundle) abort\n  ${0}\nendfunction\nunlet s:hooks",
        "doc": "",
        "grammar": "snu",
        "label": "neobundle hooks",
        "matches": [
          "bundle_hooks"
        ],
        "opts": []
      },
      {
        "content": "function! `substitute(matchstr(neosnippet#util#expand('%:p:r'), '/autoload/\\zs.*$'), '/', '#', 'g')`#${1:#:func_name}(${2:#:args}) abort\n  ${0}\nendfunction",
        "doc": "",
        "grammar": "snu",
        "label": "autoload func endfunc",
        "matches": [
          "autoload",
          "afunction afunc"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "if exists('g:loaded_${1}')\n  finish\nendif\n${0}\nlet g:loaded_$1 = 1",
        "doc": "",
        "grammar": "snu",
        "label": "if exists('g:loaded_{plugin-name}')",
        "matches": [
          "loaded",
          "g:loaded"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "\" vim: ${0:foldmethod=marker}",
        "doc": "",
        "grammar": "snu",
        "label": "\" vim: {modeline}",
        "matches": [
          "modeline"
        ],
        "opts": []
      },
      {
        "content": "if !exists('b:undo_ftplugin')\n  let b:undo_ftplugin = ''\nendif\n${1}\nlet b:undo_ftplugin .= '\n\\ | setlocal ${2:#:option_name1< option_name2<...}\n\\'",
        "doc": "",
        "grammar": "snu",
        "label": "if !exists('b:undo_ftplugin')",
        "matches": [
          "b:undo_ftplugin",
          "undo_ftplugin"
        ],
        "opts": []
      },
      {
        "content": "python << EOF\n${0}\nEOF",
        "doc": "",
        "grammar": "snu",
        "label": "python <<EOF | EOF",
        "matches": [
          "python",
          "py"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "python3 << EOF\n${0}\nEOF",
        "doc": "",
        "grammar": "snu",
        "label": "python3 <<EOF | EOF",
        "matches": [
          "py3",
          "python3"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "lua << EOF\n${0}\nEOF",
        "doc": "",
        "grammar": "snu",
        "label": "lua <<EOF | EOF",
        "matches": [
          "lua"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "let pos_save = getpos('.')\ntry\n  ${0}\nfinally\n  call setpos('.', pos_save)\nendtry",
        "doc": "",
        "grammar": "snu",
        "label": "use pos save",
        "matches": [
          "save_pos"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "let save_reg_$1 = getreg('${1}')\nlet save_regtype_$1 = getregtype('$1')\ntry\n  ${0}\nfinally\n  call setreg('$1', save_reg_$1, save_regtype_$1)\nendtry",
        "doc": "",
        "grammar": "snu",
        "label": "use register save",
        "matches": [
          "save_register"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "let $1_save = &${1}\nlet &$1 = ${2}\ntry\n  ${0}\nfinally\n  let &$1 = $1_save\nendtry",
        "doc": "",
        "grammar": "snu",
        "label": "use option save",
        "matches": [
          "save_option"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "echomsg string([${0:TARGET}])",
        "doc": "",
        "grammar": "snu",
        "label": "debug-echomsg",
        "matches": [
          "p"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "v:version > ${1} || (v:version == $1 && has('patch${2}'))",
        "doc": "",
        "grammar": "snu",
        "label": "vim-version-check",
        "matches": [
          "version"
        ],
        "opts": []
      },
      {
        "content": "has('patch-${1}')",
        "doc": "",
        "grammar": "snu",
        "label": "vim-version-check-new",
        "matches": [
          "version_new"
        ],
        "opts": []
      },
      {
        "content": "\" File: ${1:`expand('%:t')`}\n\" Author: ${2:`g:snips_author`}\n\" Description: ${3}\n${0:\" Last Modified: `strftime(\"%B %d, %Y\")`}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "header standard Vim script file header"
        ],
        "opts": []
      },
      {
        "content": "if exists('${1:did_`vim_snippets#Filename()`}') || &cp${2: || version < 700}\n\tfinish\nendif\nlet $1 = 1${0}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "guard script reload guard"
        ],
        "opts": []
      },
      {
        "content": "fun! ${1:`expand('%') =~ 'autoload' ? substitute(matchstr(expand('%:p'),'autoload/\\zs.*\\ze.vim'),'[/\\\\]','#','g').'#' : ''`}${2:function_name}(${3})\n\t${0}\nendf",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "f function"
        ],
        "opts": []
      },
      {
        "content": "try\n\t${1:${VISUAL}}\ncatch ${2}\n\t${0}\nendtry",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "t try ... catch statement"
        ],
        "opts": []
      },
      {
        "content": "for ${1} in ${2}\n\t${0:${VISUAL}}\nendfor",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for for ... in loop"
        ],
        "opts": []
      },
      {
        "content": "for [${1},${2}] in items(${3})\n\t${0}\n\tunlet $1 $2\nendfor",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "forkv for [key, value] in loop"
        ],
        "opts": []
      },
      {
        "content": "while ${1}\n\t${0:${VISUAL}}\nendw",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh while loop"
        ],
        "opts": []
      },
      {
        "content": "if ${1}\n\t${0:${VISUAL}}\nendif",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if if statement"
        ],
        "opts": []
      },
      {
        "content": "if ${1}\n\t${2:${VISUAL}}\nelse\n\t${0}\nendif",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife if ... else statement"
        ],
        "opts": []
      },
      {
        "content": "augroup ${1:AU_NAME}\n\tautocmd!\n\tautocmd ${2:BufRead,BufNewFile} ${3:*.ext,*.ext3|<buffer[=N]>} ${0}\naugroup END",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "au augroup ... autocmd block"
        ],
        "opts": []
      },
      {
        "content": "augroup ${1:AU_NAME}\n\tautocmd!\n\t${0:${VISUAL}}\naugroup END",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "auv augroupvisual ... autocmd block with visual placeholder"
        ],
        "opts": []
      },
      {
        "content": "Plugin '${0}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "bun Vundle.vim Plugin definition"
        ],
        "opts": []
      },
      {
        "content": "Plug '${0}'",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "plug vim-plug Plugin definition"
        ],
        "opts": []
      },
      {
        "content": "Plug '${1}', { 'do': '${0}' }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "plugdo vim-plug Plugin definition with { 'do': '' }"
        ],
        "opts": []
      },
      {
        "content": "Plug '${1}', { 'on': '${0}' }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "plugon vim-plug Plugin definition with { 'on': '' }"
        ],
        "opts": []
      },
      {
        "content": "Plug '${1}', { 'for': '${0}' }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "plugfor vim-plug Plugin definition with { 'for': '' }"
        ],
        "opts": []
      },
      {
        "content": "Plug '${1}', { 'branch': '${0}' }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "plugbr vim-plug Plugin definition with { 'branch': '' }"
        ],
        "opts": []
      },
      {
        "content": "Plug '${1}', { 'tag': '${0}' }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "plugtag vim-plug Plugin definition with { 'tag': '' }"
        ],
        "opts": []
      },
      {
        "content": "let ${1:variable} = ${0: value}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "let"
        ],
        "opts": []
      },
      {
        "content": "set ${1:setting};",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "se"
        ],
        "opts": []
      },
      {
        "content": "set ${1:setting} = ${0:value}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "set"
        ],
        "opts": []
      },
      {
        "content": "nnoremap ${1} ${2}<CR>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "nn"
        ],
        "opts": []
      },
      {
        "content": "noremap ${1} ${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "no"
        ],
        "opts": []
      },
      {
        "content": "vmap ${1} ${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vm"
        ],
        "opts": []
      },
      {
        "content": "imap ${1} ${2}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "im"
        ],
        "opts": []
      },
      {
        "content": "execute ${1}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "exe"
        ],
        "opts": []
      },
      {
        "content": "`Filename()`",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "filename"
        ],
        "opts": []
      },
      {
        "content": "if !exists(\"g:${1:MyUltraImportantVar}\")\n\tlet g:$1 = ${2:\"${3:<tab>}\"}\nendif",
        "doc": null,
        "grammar": "snu",
        "label": "Global / configuration variable",
        "matches": [
          "gvar"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "if exists('${1:did_`!p snip.rv = snip.fn.replace('.','_')`}') || &cp${2: || version < 700}\n\tfinish\nendif\nlet $1 = 1$3",
        "doc": null,
        "grammar": "snu",
        "label": "script reload guard",
        "matches": [
          "guard"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "fun ${1:function_name}($2)\n\t${3:\" code}\nendf",
        "doc": null,
        "grammar": "snu",
        "label": "function",
        "matches": [
          "f"
        ],
        "opts": [
          "b"
        ]
      }
    ],
    "vimshell": [
      {
        "content": "ls",
        "doc": "",
        "grammar": "snu",
        "label": "=> ls?",
        "matches": [
          "sl"
        ],
        "opts": []
      }
    ],
    "vimspec": [
      {
        "content": "function! s:suite.${1}()\n  ${2:TARGET}\n  call s:assert.equal(${3:expected}, ${4:actual})\nendfunction",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "suite"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "call themis#log(${TARGET})",
        "doc": "",
        "grammar": "snu",
        "label": "p",
        "matches": [
          "themis#log (This is an undocumented function)"
        ],
        "opts": [
          "head"
        ]
      }
    ],
    "vimwiki": [
      {
        "content": "*${1}*${2}",
        "doc": "",
        "grammar": "snu",
        "label": "*text*",
        "matches": [
          "bold"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "~~${1}~~${2}",
        "doc": "",
        "grammar": "snu",
        "label": "~~scratch~~",
        "matches": [
          "scratch"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "_${1}_${2}",
        "doc": "",
        "grammar": "snu",
        "label": "_italic_",
        "matches": [
          "italic"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": ",,${1},,${2}",
        "doc": "",
        "grammar": "snu",
        "label": ",,sub,,",
        "matches": [
          "sub"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "^${1}^${2}",
        "doc": "",
        "grammar": "snu",
        "label": "^upper^",
        "matches": [
          "upper"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "{{local:${1:image_path}}}${2}",
        "doc": "",
        "grammar": "snu",
        "label": "{{<image path>}}",
        "matches": [
          "image_local"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "{{http://${1:image_url}}}${2}",
        "doc": "",
        "grammar": "snu",
        "label": "{{<image url>}}",
        "matches": [
          "image"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "|${1:title}|${2:title}|\n|---|---|\n|${3:value}|${4:value}${5:TARGET}|",
        "doc": "",
        "grammar": "snu",
        "label": "table template",
        "matches": [
          "table"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "term:: ${1:definintion}",
        "doc": "",
        "grammar": "snu",
        "label": "definition",
        "matches": [
          "definintion"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": ":${1:tag}:${3}",
        "doc": "",
        "grammar": "snu",
        "label": ":tag1:tag2:",
        "matches": [
          "tag"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "{{{\n${0:TARGET}\n}}}",
        "doc": "",
        "grammar": "snu",
        "label": "{{{<code>}}}",
        "matches": [
          "code"
        ],
        "opts": [
          "head"
        ]
      }
    ],
    "vital": [
      {
        "content": "vital#${1:#:plugin_name}#new()",
        "doc": "",
        "grammar": "snu",
        "label": "vital#...#new()",
        "matches": [
          "vital_new_without_let"
        ],
        "opts": []
      },
      {
        "content": "let ${1:s:V} = vital#${2:#:plugin_name}#new()",
        "doc": "",
        "grammar": "snu",
        "label": "let s:V = vital#...#new()",
        "matches": [
          "vital_new"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "${1:s:V}.import('${2:#:module_name}')",
        "doc": "",
        "grammar": "snu",
        "label": "s:V.import('...')",
        "matches": [
          "vital_import_without_let"
        ],
        "opts": []
      },
      {
        "content": "let ${1:s:M} = ${2:s:V}.import('${3:#:module_name}')",
        "doc": "",
        "grammar": "snu",
        "label": "let s:M = s:V.import('...')",
        "matches": [
          "vital_import"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "${1:s:V}.load('${2:#:module_name}')",
        "doc": "",
        "grammar": "snu",
        "label": "s:V.load('...')",
        "matches": [
          "vital_load_without_call"
        ],
        "opts": []
      },
      {
        "content": "call ${1:s:V}.load('${2:#:module_name}')",
        "doc": "",
        "grammar": "snu",
        "label": "call s:V.load('...')",
        "matches": [
          "vital_load"
        ],
        "opts": [
          "head"
        ]
      }
    ],
    "vue": [
      {
        "content": "<template>\n\t<${1:div}$2>\n\t\t$0\n\t</${1:div}>\n</template>",
        "doc": "template element",
        "grammar": "lsp",
        "label": "vue-template",
        "matches": [
          "template",
          "vue template"
        ],
        "opts": []
      },
      {
        "content": "v-text=\"${1:msg}\"",
        "doc": "Expects: string. Updates the element’s textContent.",
        "grammar": "lsp",
        "label": "vue-v-text",
        "matches": [
          "vtext",
          "vue v-text"
        ],
        "opts": []
      },
      {
        "content": "v-html=\"${1:html}\"",
        "doc": "Expects: string. Updates the element’s innerHTML.",
        "grammar": "lsp",
        "label": "vue-v-html",
        "matches": [
          "vhtml",
          "vue v-html"
        ],
        "opts": []
      },
      {
        "content": "v-show=\"${1:condition}\"",
        "doc": "Expects: any",
        "grammar": "lsp",
        "label": "vue-v-show",
        "matches": [
          "vue v-show",
          "vshow"
        ],
        "opts": []
      },
      {
        "content": "v-if=\"${1:condition}\"",
        "doc": "Expects: any",
        "grammar": "lsp",
        "label": "vue-v-if",
        "matches": [
          "vue v-if",
          "vif"
        ],
        "opts": []
      },
      {
        "content": "v-else",
        "doc": "Does not expect expression. previous sibling element must have v-if or v-else-if.",
        "grammar": "lsp",
        "label": "vue-v-else",
        "matches": [
          "velse",
          "vue v-else"
        ],
        "opts": []
      },
      {
        "content": "v-else-if=\"${1:condition}\"",
        "doc": "Expects: any. previous sibling element must have v-if or v-else-if.",
        "grammar": "lsp",
        "label": "vue-v-else-if",
        "matches": [
          "vue v-else-if",
          "velseif"
        ],
        "opts": []
      },
      {
        "content": "v-for=\"${1:item} in ${2:items}\"",
        "doc": "Expects: Array | Object | number | string",
        "grammar": "lsp",
        "label": "vue-v-for-without-key",
        "matches": [
          "vforwithoutkey",
          "vue v-for-without-key"
        ],
        "opts": []
      },
      {
        "content": "v-for=\"(${1:item}, ${2:index}) in ${3:items}\" :key=\"${4:index}\"",
        "doc": "Expects: Array | Object | number | string",
        "grammar": "lsp",
        "label": "vue-v-for",
        "matches": [
          "vue v-for",
          "vfor"
        ],
        "opts": []
      },
      {
        "content": "v-on:${1:event}=\"${2:handle}\"",
        "doc": "Expects: Function | Inline Statement",
        "grammar": "lsp",
        "label": "vue-v-on",
        "matches": [
          "von",
          "vue v-on"
        ],
        "opts": []
      },
      {
        "content": "v-bind$1=\"${2}\"",
        "doc": "Expects: any (with argument) | Object (without argument)",
        "grammar": "lsp",
        "label": "vue-v-bind",
        "matches": [
          "vue v-bind",
          "vbind"
        ],
        "opts": []
      },
      {
        "content": "v-model=\"${1:something}\"",
        "doc": "Expects: varies based on value of form inputs element or output of components",
        "grammar": "lsp",
        "label": "vue-v-model",
        "matches": [
          "vmodel",
          "vue v-model"
        ],
        "opts": []
      },
      {
        "content": "v-pre",
        "doc": "Does not expect expression",
        "grammar": "lsp",
        "label": "vue-v-pre",
        "matches": [
          "vpre",
          "vue v-pre"
        ],
        "opts": []
      },
      {
        "content": "v-cloak",
        "doc": "Does not expect expression",
        "grammar": "lsp",
        "label": "vue-v-cloak",
        "matches": [
          "vue v-cloak",
          "vcloak"
        ],
        "opts": []
      },
      {
        "content": "v-once",
        "doc": "Does not expect expression",
        "grammar": "lsp",
        "label": "vue-v-once",
        "matches": [
          "vue v-once",
          "vonce"
        ],
        "opts": []
      },
      {
        "content": ":key=\"${1:key}\"",
        "doc": "Expects: string. Children of the same common parent must have unique keys. Duplicate keys will cause render errors.",
        "grammar": "lsp",
        "label": "vue-key",
        "matches": [
          "key",
          "vue key"
        ],
        "opts": []
      },
      {
        "content": "ref=\"${1:reference}\"$0",
        "doc": "Expects: string. ref is used to register a reference to an element or a child component. The reference will be registered under the parent component’s $refs object. If used on a plain DOM element, the reference will be that element; if used on a child component, the reference will be component instance.",
        "grammar": "lsp",
        "label": "vue-ref",
        "matches": [
          "ref",
          "vue ref"
        ],
        "opts": []
      },
      {
        "content": "slot=\"$1\"$0",
        "doc": "slot=''. Expects: string. Used on content inserted into child components to indicate which named slot the content belongs to.",
        "grammar": "lsp",
        "label": "vue-slota",
        "matches": [
          "slota",
          "vue slota"
        ],
        "opts": []
      },
      {
        "content": "<slot$1>$2</slot>$0",
        "doc": "<slot></slot>. Expects: string. Used on content inserted into child components to indicate which named slot the content belongs to.",
        "grammar": "lsp",
        "label": "vue-slote",
        "matches": [
          "vue slote",
          "slote"
        ],
        "opts": []
      },
      {
        "content": "slot-scope=\"$1\"$0",
        "doc": "Used to denote an element or component as a scoped slot. The attribute’s value should be a valid JavaScript expression that can appear in the argument position of a function signature. This means in supported environments you can also use ES2015 destructuring in the expression. Serves as a replacement for scope in 2.5.0+.",
        "grammar": "lsp",
        "label": "vue-slotscope",
        "matches": [
          "slotscope",
          "vue slotscope"
        ],
        "opts": []
      },
      {
        "content": "scope=\"${1:this api replaced by slot-scope in 2.5.0+}\"$0",
        "doc": "Used to denote a <template> element as a scoped slot, which is replaced by `slot-scope` in 2.5.0+.",
        "grammar": "lsp",
        "label": "vue-scope",
        "matches": [
          "vue scope",
          "scope"
        ],
        "opts": []
      },
      {
        "content": "<component :is=\"${1:componentId}\"></component>$0",
        "doc": "component element",
        "grammar": "lsp",
        "label": "vue-component",
        "matches": [
          "component",
          "vue component"
        ],
        "opts": []
      },
      {
        "content": "<keep-alive$1>\n$2\n</keep-alive>$0",
        "doc": "keep-alive element",
        "grammar": "lsp",
        "label": "vue-keep-alive",
        "matches": [
          "vue keep-alive",
          "keepalive"
        ],
        "opts": []
      },
      {
        "content": "<transition$1>\n$2\n</transition>$0",
        "doc": "transition element",
        "grammar": "lsp",
        "label": "vue-transition",
        "matches": [
          "vue transition",
          "transition"
        ],
        "opts": []
      },
      {
        "content": "<transition-group$1>\n$2\n</transition-group>",
        "doc": "transition-group element",
        "grammar": "lsp",
        "label": "vue-transition-group",
        "matches": [
          "transitiongroup",
          "vue transition-group"
        ],
        "opts": []
      },
      {
        "content": "enter-class=\"$1\"$0",
        "doc": "enter-class=''. Expects: string.",
        "grammar": "lsp",
        "label": "vue-enter-class",
        "matches": [
          "enterclass",
          "vue enter-class"
        ],
        "opts": []
      },
      {
        "content": "leave-class=\"$1\"$0",
        "doc": "leave-class=''. Expects: string.",
        "grammar": "lsp",
        "label": "vue-leave-class",
        "matches": [
          "vue leave-class",
          "leaveclass"
        ],
        "opts": []
      },
      {
        "content": "appear-class=\"$1\"$0",
        "doc": "appear-class=''. Expects: string.",
        "grammar": "lsp",
        "label": "vue-appear-class",
        "matches": [
          "appearclass",
          "vue appear-class"
        ],
        "opts": []
      },
      {
        "content": "enter-to-class=\"$1\"$0",
        "doc": "enter-to-class=''. Expects: string.",
        "grammar": "lsp",
        "label": "vue-enter-to-class",
        "matches": [
          "entertoclass",
          "vue enter-to-class"
        ],
        "opts": []
      },
      {
        "content": "leave-to-class=\"$1\"$0",
        "doc": "leave-to-class=''. Expects: string.",
        "grammar": "lsp",
        "label": "vue-leave-to-class",
        "matches": [
          "vue leave-to-class",
          "leavetoclass"
        ],
        "opts": []
      },
      {
        "content": "appear-to-class=\"$1\"$0",
        "doc": "appear-to-class=''. Expects: string.",
        "grammar": "lsp",
        "label": "vue-appear-to-class",
        "matches": [
          "appeartoclass",
          "vue appear-to-class"
        ],
        "opts": []
      },
      {
        "content": "enter-active-class=\"$1\"$0",
        "doc": "enter-active-class=''. Expects: string.",
        "grammar": "lsp",
        "label": "vue-enter-active-class",
        "matches": [
          "enteractiveclass",
          "vue enter-active-class"
        ],
        "opts": []
      },
      {
        "content": "leave-active-class=\"$1\"$0",
        "doc": "leave-active-class=''. Expects: string.",
        "grammar": "lsp",
        "label": "vue-leave-active-class",
        "matches": [
          "vue leave-active-class",
          "leaveactiveclass"
        ],
        "opts": []
      },
      {
        "content": "appear-active-class=\"$1\"$0",
        "doc": "appear-active-class=''. Expects: string.",
        "grammar": "lsp",
        "label": "vue-appear-active-class",
        "matches": [
          "appearactiveclass",
          "vue appear-active-class"
        ],
        "opts": []
      },
      {
        "content": "@before-enter=\"$1\"$0",
        "doc": "@before-enter=''",
        "grammar": "lsp",
        "label": "vue-before-enter",
        "matches": [
          "vue before-enter",
          "beforeenterevent"
        ],
        "opts": []
      },
      {
        "content": "@before-leave=\"$1\"$0",
        "doc": "@before-leave=''",
        "grammar": "lsp",
        "label": "vue-before-leave",
        "matches": [
          "vue before-leave",
          "beforeleaveevent"
        ],
        "opts": []
      },
      {
        "content": "@before-appear=\"$1\"$0",
        "doc": "@before-appear=''",
        "grammar": "lsp",
        "label": "vue-before-appear",
        "matches": [
          "vue before-appear",
          "beforeappearevent"
        ],
        "opts": []
      },
      {
        "content": "@enter=\"$1\"$0",
        "doc": "@enter=''",
        "grammar": "lsp",
        "label": "vue-enter",
        "matches": [
          "enterevent",
          "vue enter"
        ],
        "opts": []
      },
      {
        "content": "@leave=\"$1\"$0",
        "doc": "@leave=''",
        "grammar": "lsp",
        "label": "vue-leave",
        "matches": [
          "vue leave",
          "leaveevent"
        ],
        "opts": []
      },
      {
        "content": "@appear=\"$1\"$0",
        "doc": "@appear=''",
        "grammar": "lsp",
        "label": "vue-appear",
        "matches": [
          "appearevent",
          "vue appear"
        ],
        "opts": []
      },
      {
        "content": "@after-enter=\"$1\"$0",
        "doc": "@after-enter=''",
        "grammar": "lsp",
        "label": "vue-after-enter",
        "matches": [
          "afterenterevent",
          "vue after-enter"
        ],
        "opts": []
      },
      {
        "content": "@after-leave=\"$1\"$0",
        "doc": "@after-leave=''",
        "grammar": "lsp",
        "label": "vue-after-leave",
        "matches": [
          "afterleaveevent",
          "vue after-leave"
        ],
        "opts": []
      },
      {
        "content": "@after-appear=\"$1\"$0",
        "doc": "@after-appear=''",
        "grammar": "lsp",
        "label": "vue-after-appear",
        "matches": [
          "afterappearevent",
          "vue after-appear"
        ],
        "opts": []
      },
      {
        "content": "@enter-cancelled=\"$1\"$0",
        "doc": "@enter-cancelled=''",
        "grammar": "lsp",
        "label": "vue-enter-cancelled",
        "matches": [
          "entercancelledevent",
          "vue enter-cancelled"
        ],
        "opts": []
      },
      {
        "content": "@leave-cancelled=\"$1\"$0",
        "doc": "@leave-cancelled='' (v-show only)",
        "grammar": "lsp",
        "label": "vue-leave-cancelled",
        "matches": [
          "leavecancelledevent",
          "vue leave-cancelled"
        ],
        "opts": []
      },
      {
        "content": "@appear-cancelled=\"$1\"$0",
        "doc": "@appear-cancelled=''",
        "grammar": "lsp",
        "label": "vue-appear-cancelled",
        "matches": [
          "appearcancelledevent",
          "vue appear-cancelled"
        ],
        "opts": []
      },
      {
        "content": "<router-link $1>$2</router-link>$0",
        "doc": "router-link element",
        "grammar": "lsp",
        "label": "vue-routerlink",
        "matches": [
          "vue routerlink",
          "routerlink"
        ],
        "opts": []
      },
      {
        "content": "<router-link to=\"$1\">$2</router-link>$0",
        "doc": "<router-link to=''></router-link>. router-link element",
        "grammar": "lsp",
        "label": "vue-routerlinkto",
        "matches": [
          "routerlinkto",
          "vue routerlinkto"
        ],
        "opts": []
      },
      {
        "content": "to=\"$1\"$0",
        "doc": "to=''",
        "grammar": "lsp",
        "label": "vue-to",
        "matches": [
          "to",
          "vue to"
        ],
        "opts": []
      },
      {
        "content": "tag=\"$1\"$0",
        "doc": "tag=''",
        "grammar": "lsp",
        "label": "vue-tag",
        "matches": [
          "tag",
          "vue tag"
        ],
        "opts": []
      },
      {
        "content": "<router-view>$1</router-view>$0",
        "doc": "router-view element",
        "grammar": "lsp",
        "label": "vue-routerview",
        "matches": [
          "routerview",
          "vue routerview"
        ],
        "opts": []
      },
      {
        "content": "data() {\n\treturn {\n\t\t${1:key}: ${2:value}\n\t}\n},",
        "doc": "Vue Component Data",
        "grammar": "lsp",
        "label": "vue-data",
        "matches": [
          "vue data",
          "vdata"
        ],
        "opts": []
      },
      {
        "content": "methods: {\n\t${1:name}() {\n\t\t${0}\n\t}\n},",
        "doc": "vue method",
        "grammar": "lsp",
        "label": "vue-methods",
        "matches": [
          "vmethod",
          "vue methods"
        ],
        "opts": []
      },
      {
        "content": "computed: {\n\t${1:name}() {\n\t\treturn this.${2:data} ${0}\n\t}\n},",
        "doc": "computed value",
        "grammar": "lsp",
        "label": "vue-computed",
        "matches": [
          "vue computed",
          "vcomputed"
        ],
        "opts": []
      },
      {
        "content": "beforeCreate () {\n\t${0};\n},",
        "doc": "beforeCreate lifecycle method",
        "grammar": "lsp",
        "label": "vue-lifecycle-beforecreate",
        "matches": [
          "vue lifecycle beforecreate",
          "vbeforecreate"
        ],
        "opts": []
      },
      {
        "content": "created () {\n\t${0};\n},",
        "doc": "created lifecycle method",
        "grammar": "lsp",
        "label": "vue-lifecycle-created",
        "matches": [
          "vcreated",
          "vue lifecycle created"
        ],
        "opts": []
      },
      {
        "content": "beforeMount () {\n\t${0};\n},",
        "doc": "beforeMount lifecycle method",
        "grammar": "lsp",
        "label": "vue-lifecycle-beforemount",
        "matches": [
          "vue lifecycle beforemount",
          "vbeforemount"
        ],
        "opts": []
      },
      {
        "content": "mounted () {\n\t${0};\n},",
        "doc": "mounted lifecycle method",
        "grammar": "lsp",
        "label": "vue-lifecycle-mounted",
        "matches": [
          "vmounted",
          "vue lifecycle mounted"
        ],
        "opts": []
      },
      {
        "content": "beforeUpdate () {\n\t${0};\n},",
        "doc": "beforeUpdate lifecycle method",
        "grammar": "lsp",
        "label": "vue-lifecycle-beforeupdate",
        "matches": [
          "vue lifecycle beforeupdate",
          "vbeforeupdate"
        ],
        "opts": []
      },
      {
        "content": "updated () {\n\t${0};\n},",
        "doc": "updated lifecycle method",
        "grammar": "lsp",
        "label": "vue-lifecycle-updated",
        "matches": [
          "vupdated",
          "vue lifecycle updated"
        ],
        "opts": []
      },
      {
        "content": "beforeDestroy () {\n\t${0};\n},",
        "doc": "beforeDestroy lifecycle method",
        "grammar": "lsp",
        "label": "vue-lifecycle-beforedestroy",
        "matches": [
          "vbeforedestroy",
          "vue lifecycle beforedestroy"
        ],
        "opts": []
      },
      {
        "content": "destroyed () {\n\t${0};\n},",
        "doc": "destroyed lifecycle method",
        "grammar": "lsp",
        "label": "vue-lifecycle-destroyed",
        "matches": [
          "vue lifecycle destroyed",
          "vdestroyed"
        ],
        "opts": []
      },
      {
        "content": "watch: {\n\t${1:data}(${2:newValue}, ${3:oldValue}) {\n\t\t${0}\n\t}\n},",
        "doc": "vue watcher",
        "grammar": "lsp",
        "label": "vue-watchers",
        "matches": [
          "vwatcher",
          "vue watchers"
        ],
        "opts": []
      },
      {
        "content": "watch: {\n\t${1:data}: {\n\t\timmediate: ${2:true},\n\t\tdeep: ${3:true},\n\t\thandler(${4:newValue}, ${5:oldValue}) {\n\t\t\t${0}\n\t\t}\n\t}\n},",
        "doc": "vue watcher with options",
        "grammar": "lsp",
        "label": "vue-watchers-with-options",
        "matches": [
          "vue watchers with options",
          "vwatcher-options"
        ],
        "opts": []
      },
      {
        "content": "props: {\n\t${1:propName}: {\n\t\ttype: ${2:Number},\n\t\tdefault: ${0}\n\t},\n},",
        "doc": "Vue Props with Default",
        "grammar": "lsp",
        "label": "vue-props-with-default",
        "matches": [
          "vprops",
          "vue props with default"
        ],
        "opts": []
      },
      {
        "content": "import ${1:New} from '@/components/${1:New}.vue';",
        "doc": "Import one component into another",
        "grammar": "lsp",
        "label": "vue-import-file",
        "matches": [
          "vue import file",
          "vimport"
        ],
        "opts": []
      },
      {
        "content": "components: {\n\t${1:New},\n},",
        "doc": "Import one component into another, within export statement",
        "grammar": "lsp",
        "label": "vue-import-into-the-component",
        "matches": [
          "vue import into the component",
          "vcomponents"
        ],
        "opts": []
      },
      {
        "content": "import ${1:Name} from '@/components/${1:Name}.vue'\n\nexport default {\n\tcomponents: {\n\t\t${1:Name}\n\t},\n}",
        "doc": "import a component and include it in export default",
        "grammar": "lsp",
        "label": "vue-import-export",
        "matches": [
          "vimport-export",
          "vue import export"
        ],
        "opts": []
      },
      {
        "content": "import { mapState } from 'vuex'\n\nexport default {\n\tcomputed: {\n\t\t...mapState([\n\t\t\t${1:'nameOfState'},\n\t\t])\n\t},\n}",
        "doc": "map getters inside a vue component",
        "grammar": "lsp",
        "label": "vue-mapstate",
        "matches": [
          "vue mapstate",
          "vmapstate"
        ],
        "opts": []
      },
      {
        "content": "import { mapGetters } from 'vuex'\n\nexport default {\n\tcomputed: {\n\t\t...mapGetters([\n\t\t\t${1:'nameOfGetter'},\n\t\t])\n\t},\n}",
        "doc": "mapgetters inside a vue component",
        "grammar": "lsp",
        "label": "vue-mapgetters",
        "matches": [
          "vmapgetters",
          "vue mapgetters"
        ],
        "opts": []
      },
      {
        "content": "import { mapMutations } from 'vuex'\n\nexport default {\n\tmethods: {\n\t\t...mapMutations([\n\t\t\t${1:'nameOfMutation'}, //also supports payload `this.nameOfMutation(amount)` \n\t\t])\n\t},\n}",
        "doc": "mapmutations inside a vue component",
        "grammar": "lsp",
        "label": "vue-mapmutations",
        "matches": [
          "vmapmutations",
          "vue mapmutations"
        ],
        "opts": []
      },
      {
        "content": "import { mapActions } from 'vuex'\n\nexport default {\n\tmethods: {\n\t\t...mapActions([\n\t\t\t${1:'nameOfAction'}, //also supports payload `this.nameOfAction(amount)` \n\t\t])\n\t},\n}",
        "doc": "mapactions inside a vue component",
        "grammar": "lsp",
        "label": "vue-mapactions",
        "matches": [
          "vmapactions",
          "vue mapactions"
        ],
        "opts": []
      },
      {
        "content": "filters: {\n\t${1:fnName}: function(${2:value}) {\n\t\treturn ${2:value}${0};\n\t}\n}",
        "doc": "vue filter",
        "grammar": "lsp",
        "label": "vue-filter",
        "matches": [
          "vue filter",
          "vfilter"
        ],
        "opts": []
      },
      {
        "content": "const ${1:mixinName} = {\n\tmounted() {\n\t\tconsole.log('hello from mixin!')\n\t},\n}",
        "doc": "vue mixin",
        "grammar": "lsp",
        "label": "vue-mixin",
        "matches": [
          "vmixin",
          "vue mixin"
        ],
        "opts": []
      },
      {
        "content": "mixins: [${1:mixinName}],",
        "doc": "vue use mixin",
        "grammar": "lsp",
        "label": "vue-use-mixin",
        "matches": [
          "vmixin-use",
          "vue use mixin"
        ],
        "opts": []
      },
      {
        "content": "Vue.directive('${1:directiveName}', {\n\tbind(el, binding, vnode) {\n\t\tel.style.${2:arg} = binding.value.${2:arg};\n\t}\n});",
        "doc": "vue custom directive",
        "grammar": "lsp",
        "label": "vue-custom-directive",
        "matches": [
          "vc-direct",
          "vue custom directive"
        ],
        "opts": []
      },
      {
        "content": "import { ${1:libName} } from '${1:libName}'",
        "doc": "import a library",
        "grammar": "lsp",
        "label": "vue-import-library",
        "matches": [
          "vue import library",
          "vimport-lib"
        ],
        "opts": []
      },
      {
        "content": "import { TimelineMax, ${1:Ease} } from 'gsap'",
        "doc": "component methods options that dispatch an action from vuex store.",
        "grammar": "lsp",
        "label": "vue-import-gsap",
        "matches": [
          "vue import gsap",
          "vimport-gsap"
        ],
        "opts": []
      },
      {
        "content": "beforeEnter(el) {\n\tconsole.log('beforeEnter');\n},\nenter(el, done) {\n\tconsole.log('enter');\n\tdone();\n},\nbeforeLeave(el) {\n\tconsole.log('beforeLeave');\n},\nleave(el, done) {\n\tconsole.log('leave');\n\tdone();\n},",
        "doc": "transition component js hooks",
        "grammar": "lsp",
        "label": "vue-transition-methods-with-javascript-hooks",
        "matches": [
          "vue transition methods with javascript hooks",
          "vanimhook-js"
        ],
        "opts": []
      },
      {
        "content": "${1:mutationName}() {\n\tthis.\\$store.commit('${1:mutationName}', ${2:payload})\n}",
        "doc": "commit to vuex store in methods for mutation",
        "grammar": "lsp",
        "label": "vue-commit-vuex-store-in-methods",
        "matches": [
          "vue commit vuex store in methods",
          "vcommit"
        ],
        "opts": []
      },
      {
        "content": "${1:actionName}() {\n\tthis.\\$store.dispatch('${1:actionName}', ${2:payload})\n}",
        "doc": "dispatch to vuex store in methods for action",
        "grammar": "lsp",
        "label": "vue-dispatch-vuex-store-in-methods",
        "matches": [
          "vue dispatch vuex store in methods",
          "vdispatch"
        ],
        "opts": []
      },
      {
        "content": "return ${1:this.num} += ${2:1}",
        "doc": "increment",
        "grammar": "lsp",
        "label": "vue-incrementer",
        "matches": [
          "vinc",
          "vue incrementer"
        ],
        "opts": []
      },
      {
        "content": "return ${1:this.num} -= ${2:1}",
        "doc": "decrement",
        "grammar": "lsp",
        "label": "vue-decrementer",
        "matches": [
          "vdec",
          "vue decrementer"
        ],
        "opts": []
      },
      {
        "content": "import Vue from 'vue'\nimport ${1:HelloWorld} from './components/${1:HelloWorld}'\n\ndescribe('${1:HelloWorld}.vue', () => {\n\tit('${2:should render correct contents}', () => {\n\t\tconst Constructor = Vue.extend(${1:HelloWorld})\n\t\tconst vm = new Constructor().$mount()\n\t\texpect(vm.$el.querySelector('.hello h1').textContent)\n\t\t\t.to.equal(${3:'Welcome to Your Vue.js App'})\n\t})\n})",
        "doc": "unit test component",
        "grammar": "lsp",
        "label": "vue-unit-test",
        "matches": [
          "vue unit test",
          "vtest"
        ],
        "opts": []
      },
      {
        "content": "module.exports = {\n\tcss: {\n\t\tloaderOptions: {\n\t\t\t${1:sass}: {\n\t\t\t\tdata: `${2:@import '@/styles/_variables.scss';}`\n\t\t\t}\n\t\t}\n\t}\n}",
        "doc": "vue.config.js",
        "grammar": "lsp",
        "label": "vue-vue-config-js-import",
        "matches": [
          "vue vue.config.js import",
          "vconfig"
        ],
        "opts": []
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script>\n\texport default {\n\t\t${0}\n\t}\n</script>\n\n<style lang=\"scss\" scoped>\n\n</style>",
        "doc": "Base for Vue File with SCSS",
        "grammar": "lsp",
        "label": "vue-single-file-component",
        "matches": [
          "vue base"
        ],
        "opts": []
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script>\n\texport default {\n\t\t${0}\n\t}\n</script>\n\n<style lang=\"postcss\" scoped>\n\n</style>",
        "doc": "Base for Vue File with PostCSS",
        "grammar": "lsp",
        "label": "vue-single-file-component-with-postcss",
        "matches": [
          "vue base postcss"
        ],
        "opts": []
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script>\n\texport default {\n\t\t${0}\n\t}\n</script>\n\n<style scoped>\n\n</style>",
        "doc": "Base for Vue File with CSS",
        "grammar": "lsp",
        "label": "vue-single-file-component-with-css",
        "matches": [
          "vue base css"
        ],
        "opts": []
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script lang=\"ts\">\n\timport Vue from 'vue'\n\n\texport default Vue.extend({\n\t\t${0}\n\t})\n</script>\n\n<style scoped>\n\n</style>",
        "doc": "Base for Vue File with Typescript",
        "grammar": "lsp",
        "label": "vue-single-file-component-with-typescript",
        "matches": [
          "vue base ts"
        ],
        "opts": []
      },
      {
        "content": "const ${1:name} = reactive({\n\t${2:count}: ${3:0}\n})",
        "doc": "Set reactive property - Vue Composition API",
        "grammar": "lsp",
        "label": "vue-v3reactive",
        "matches": [
          "vue v3 reactive"
        ],
        "opts": []
      },
      {
        "content": "const ${1:name} = computed(() => {\n\treturn ${2}\n})",
        "doc": "Set computed property - Vue Composition API",
        "grammar": "lsp",
        "label": "vue-v3computed",
        "matches": [
          "vue v3 computed"
        ],
        "opts": []
      },
      {
        "content": "watch(() => ${1:foo}, (newValue, oldValue) => {\n\t${2}\n})",
        "doc": "Requires watching a specific data source, and applies side effects in a separate callback function.",
        "grammar": "lsp",
        "label": "vue-v3watch",
        "matches": [
          "vue v3 watch"
        ],
        "opts": []
      },
      {
        "content": "watch([${1:foo}, ${2:bar}], ([new${1}, new${2}], [prev${1}, prev${2}]) => {\n\t${3}\n})",
        "doc": "Requires watching an array, and applies side effects in a separate callback function.",
        "grammar": "lsp",
        "label": "vue-v3watch-array",
        "matches": [
          "vue v3 watch-array"
        ],
        "opts": []
      },
      {
        "content": "watchEffect(() => {\n\t${1}\n})",
        "doc": "Run a function immediately while reactively tracking its dependencies, and re-run it whenever the dependencies have changed.",
        "grammar": "lsp",
        "label": "vue-v3watcheffect",
        "matches": [
          "vue v3 watcheffect"
        ],
        "opts": []
      },
      {
        "content": "const ${1:name} = ref(${2:initialValue})",
        "doc": "Takes an inner value and returns a reactive and mutable ref object.",
        "grammar": "lsp",
        "label": "vue-v3ref",
        "matches": [
          "vue v3ref"
        ],
        "opts": []
      },
      {
        "content": "import ${1|onBeforeMount,onMounted,onBeforeUpdate,onUpdated,onBeforeUnmount,onUnmounted,,onActivated,onDeactivated,onErrorCaptured,onRenderTracked,onRenderTriggered|} from '${2|vue,@vue/composition-api|}'",
        "doc": "Import Lifecycle hooks to use in file",
        "grammar": "lsp",
        "label": "vue-v3lifecyclehook-import",
        "matches": [
          "vue v3 importlifecyclehook "
        ],
        "opts": []
      },
      {
        "content": "${1|onBeforeMount,onMounted,onBeforeUpdate,onUpdated,onBeforeUnmount,onUnmounted,,onActivated,onDeactivated,onErrorCaptured,onRenderTracked,onRenderTriggered|}(() => {${2}})",
        "doc": "Lifecycle hooks can be registered with directly imported `onXXX` functions:",
        "grammar": "lsp",
        "label": "vue-v3lifecyclehook",
        "matches": [
          "vue v3 lifecyclehook"
        ],
        "opts": []
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script>\nimport { ${0|ref,reactive,computed,readonly,watchEffect,watch|} } from '${1|vue,@vue/composition-api|}'\nexport default {\n\tsetup () {\n\t\t${2}\n\n\t\treturn {}\n\t}\n}\n</script>\n\n<style lang=\"scss\" scoped>\n\n</style>",
        "doc": "Base for Vue File Composition API with SCSS",
        "grammar": "lsp",
        "label": "vue-single-file-component-v3",
        "matches": [
          "vue v3 base"
        ],
        "opts": []
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script lang=\"ts\">\nimport Vue from 'vue'\n\nexport default Vue.extend({\n\tsetup () {\n\t\t${0}\n\n\t\treturn {}\n\t}\n})\n</script>\n\n<style scoped>\n\n</style>",
        "doc": "Base for Vue File Composition API - Typescript",
        "grammar": "lsp",
        "label": "vue-single-file-component-with-typescript-v3",
        "matches": [
          "vue v3 base ts"
        ],
        "opts": []
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script>\n\texport default {\n\t\t${0}\n\t}\n</script>\n\n<style lang=\"scss\" scoped>\n\n</style>",
        "doc": "Base for Vue File with SCSS",
        "grammar": "lsp",
        "label": "Vue Single File Component",
        "matches": [
          "vbase"
        ],
        "opts": []
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script>\n\texport default {\n\t\t${0}\n\t}\n</script>\n\n<style lang=\"sass\" scoped>\n\n</style>",
        "doc": "Base for Vue File with PostCSS",
        "grammar": "lsp",
        "label": "Vue Single File Component with SASS",
        "matches": [
          "vbase-sass"
        ],
        "opts": []
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script>\n\texport default {\n\t\t${0}\n\t}\n</script>\n\n<style lang=\"less\" scoped>\n\n</style>",
        "doc": "Base for Vue File with PostCSS",
        "grammar": "lsp",
        "label": "Vue Single File Component with LESS",
        "matches": [
          "vbase-less"
        ],
        "opts": []
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script>\n\texport default {\n\t\t${0}\n\t}\n</script>\n\n<style lang=\"postcss\" scoped>\n\n</style>",
        "doc": "Base for Vue File with PostCSS",
        "grammar": "lsp",
        "label": "Vue Single File Component with postcss",
        "matches": [
          "vbase-pcss"
        ],
        "opts": []
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script>\n\texport default {\n\t\t${0}\n\t}\n</script>\n\n<style scoped>\n\n</style>",
        "doc": "Base for Vue File with CSS",
        "grammar": "lsp",
        "label": "Vue Single File Component with Css",
        "matches": [
          "vbase-css"
        ],
        "opts": []
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script>\n\texport default {\n\t\t${0}\n\t}\n</script>\n\n<style lang=\"stylus\" scoped>\n\n</style>",
        "doc": "Base for Vue File with Stylus",
        "grammar": "lsp",
        "label": "Vue Single File Component with Stylus",
        "matches": [
          "vbase-styl"
        ],
        "opts": []
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script lang=\"ts\">\n\timport Vue from 'vue'\n\n\texport default Vue.extend({\n\t\t${0}\n\t})\n</script>\n\n<style scoped>\n\n</style>",
        "doc": "Base for Vue File with Typescript",
        "grammar": "lsp",
        "label": "Vue Single File Component with Typescript",
        "matches": [
          "vbase-ts"
        ],
        "opts": []
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script>\n\texport default {\n\t\t${0}\n\t}\n</script>",
        "doc": "Base for Vue File with no styles",
        "grammar": "lsp",
        "label": "Vue Single File Component with No Style",
        "matches": [
          "vbase-ns"
        ],
        "opts": []
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script>\nexport default {\n\tsetup () {\n\t\t${0}\n\n\t\treturn {}\n\t}\n}\n</script>\n\n<style lang=\"scss\" scoped>\n\n</style>",
        "doc": "Base for Vue File Composition API with SCSS",
        "grammar": "lsp",
        "label": "Vue Single File Component Composition API",
        "matches": [
          "vbase-3"
        ],
        "opts": []
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script setup>\n\n</script>\n\n<style lang=\"scss\" scoped>\n\n</style>",
        "doc": "Base for Vue File Setup Composition API with SCSS",
        "grammar": "lsp",
        "label": "Vue Single File Component Setup Composition API",
        "matches": [
          "vbase-3-setup"
        ],
        "opts": []
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script>\nimport { reactive, toRefs } from '@vue/composition-api'\n\nexport default {\n\tsetup () {\n\t\tconst state = reactive({\n\t\t\t${0:count}: ${1:0},\n\t\t})\n\t\n\t\treturn {\n\t\t\t...toRefs(state),\n\t\t}\n\t}\n}\n</script>\n\n<style lang=\"scss\" scoped>\n\n</style>",
        "doc": "Base for Vue File Composition API with SCSS",
        "grammar": "lsp",
        "label": "Vue Single File Component Composition API Reactive",
        "matches": [
          "vbase-3-reactive"
        ],
        "opts": []
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent } from 'vue'\n\nexport default defineComponent({\n\tsetup () {\n\t\t${0}\n\n\t\treturn {}\n\t}\n})\n</script>\n\n<style scoped>\n\n</style>",
        "doc": "Base for Vue File Composition API - Typescript",
        "grammar": "lsp",
        "label": "Vue Single File Component Composition API with Typescript",
        "matches": [
          "vbase-3-ts"
        ],
        "opts": []
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script setup lang=\"ts\">\n\n</script>\n\n<style scoped>\n\n</style>",
        "doc": "Base for Vue File Setup Composition API - Typescript",
        "grammar": "lsp",
        "label": "Vue Single File Component Setup Composition API with Typescript",
        "matches": [
          "vbase-3-ts-setup"
        ],
        "opts": []
      },
      {
        "content": "<template>\n\t<div>\n\n\t</div>\n</template>\n\n<script lang=\"ts\">\n\timport { Component, Vue } from 'vue-property-decorator';\n\n\t@Component\n\texport default class ${0} extends Vue {\n\t\t\n\t}\n</script>\n\n<style scoped>\n\n</style>",
        "doc": "Base for Vue File with Class based Typescript format",
        "grammar": "lsp",
        "label": "Vue Single File Component with Class based Typescript format",
        "matches": [
          "vbase-ts-class"
        ],
        "opts": []
      },
      {
        "content": "<slot></slot>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "slot"
        ],
        "opts": []
      },
      {
        "content": "<template></template>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "template"
        ],
        "opts": []
      },
      {
        "content": "<transition></transition>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "transition"
        ],
        "opts": []
      },
      {
        "content": "<template>\n\t<div>\n\t</div>\n</template>\n<script>\n\texport default{\n\t\t${0}\n\t}\n</script>\n<style scoped>\n</style>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vbase"
        ],
        "opts": []
      },
      {
        "content": "import ${1:Name} from './components/$1.vue';\nexport default {\n\tcomponents: {\n\t\t$1\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vimport:c"
        ],
        "opts": []
      },
      {
        "content": "actions: {\n\t${1:updateValue}({commit}, ${2:payload}) {\n\t\tcommit($1, $2);\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vactions"
        ],
        "opts": []
      },
      {
        "content": "<transition\n  @before-enter=\"beforeEnter\"\n  @enter=\"enter\"\n  @after-enter=\"afterEnter\"\n  @enter-cancelled=\"enterCancelled\"\n  @before-Leave=\"beforeLeave\"\n  @leave=\"leave\"\n  @after-leave=\"afterLeave\"\n  @leave-cancelled=\"leaveCancelled\"\n  :css=\"false\">\n </transition>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vanim:js:el"
        ],
        "opts": []
      },
      {
        "content": "methods: {\n\tbeforeEnter(el) {\n\t\tconsole.log('beforeEnter');\n\t},\n\tenter(el, done) {\n\t\tconsole.log('enter');\n\t\tdone();\n\t},\n\tafterEnter(el) {\n\t\tconsole.log('afterEnter');\n\t},\n\tenterCancelled(el, done) {\n\t\tconsole.log('enterCancelled');\n\t},\n\tbeforeLeave(el) {\n\t\tconsole.log('beforeLeave');\n\t},\n\tleave(el, done) {\n\t\tconsole.log('leave');\n\t\tdone();\n\t},\n\tafterLeave(el) {\n\t\tconsole.log('afterLeave');\n\t},\n\tleaveCancelled(el, done) {\n\t\tconsole.log('leaveCancelled');\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vanim:js:method"
        ],
        "opts": []
      },
      {
        "content": "@click=\"${1}\"",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vcl"
        ],
        "opts": []
      },
      {
        "content": "data() {\n\treturn {\n\t\t${1:key}: ${2:value}\n\t};\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vdata"
        ],
        "opts": []
      },
      {
        "content": "filters: {\n\t${1:fnName}: function(${2:value}) {\n\t\treturn;\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vfilter"
        ],
        "opts": []
      },
      {
        "content": "<div v-for=\"${1:item} in ${2:items}\" :key=\"$1.id\">\n\t{{ $1 }}\n</div>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vfor"
        ],
        "opts": []
      },
      {
        "content": "getters: {\n\t${1:value}: state => {\n\t\treturn state.$1;\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vgetters"
        ],
        "opts": []
      },
      {
        "content": "import ${1:New} from './components/$1.vue';",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vimport"
        ],
        "opts": []
      },
      {
        "content": "<keep-alive>\n\t<component :is=\"\">\n\t\t<p>default</p>\n\t</component>\n</keep-alive>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vkeep"
        ],
        "opts": []
      },
      {
        "content": "const ${1:mixinName} = {\n\tmounted() {\n\t\tconsole.log('hello from mixin!')\n\t},\n}\nconst ${2:Component} = Vue.extend({\n\tmixins: [$1]\n})",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vmixin"
        ],
        "opts": []
      },
      {
        "content": "mutations: {\n\t${1:updateValue}(state, ${3:payload}) => {\n\t\tstate.${2:value} = $3;\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vmutations"
        ],
        "opts": []
      },
      {
        "content": "${1:propName}: {\n  type: ${2:Number},\n  default: ${0}\n},",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vprops:d"
        ],
        "opts": []
      },
      {
        "content": "${1:propName}: {\n\ttype: ${2:Number}\n},",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vprops"
        ],
        "opts": []
      },
      {
        "content": "import Vue from 'vue';\nimport Vuex from 'vuex';\nVue.use(Vuex);\nexport const store = new Vuex.Store({\n\tstate: {\n\t\t${1:key}: ${2:value}\n\t}\n});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "vstore"
        ],
        "opts": []
      },
      {
        "content": "$t('$1')",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "trans"
        ],
        "opts": []
      },
      {
        "content": "$t('$1', { $2: $3 })",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "transc"
        ],
        "opts": []
      },
      {
        "content": "<template>\n  ${0}\n</template>\n<script>\nexport default {\n}\n</script>\n<style>\n</style>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <template> <script> and <style>",
        "matches": [
          "scaffold"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "<template>\n  ${0}\n</template>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <template> with html",
        "matches": [
          "template_with_html"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "<template lang=\"pug\">\n  ${0}\n</template>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <template> with pug",
        "matches": [
          "template_with_pug"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "<script>\nexport default {\n  ${0}\n}\n</script>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <script> with JavaScript",
        "matches": [
          "script_with_JavaScript"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "<script lang=\"ts\">\nimport Vue from 'vue'\nexport default Vue.extend({\n  ${0}\n})\n</script>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <script> with TypeScript",
        "matches": [
          "script_with_TypeScript"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "<style>\n${0}\n</style>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <style> with CSS",
        "matches": [
          "style_with_CSS"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "<style scoped>\n${0}\n</style>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <style> with CSS scoped",
        "matches": [
          "style_with_CSS_scoped"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "<style lang=\"scss\">\n${0}\n</style>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <style> with scss",
        "matches": [
          "style_with_scss"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "<style lang=\"scss\" scoped>\n${0}\n</style>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <style> with scss scoped",
        "matches": [
          "style_with_scss_scoped"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "<style lang=\"less\">\n${0}\n</style>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <style> with less",
        "matches": [
          "style_with_less"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "<style lang=\"less\" scoped>\n${0}\n</style>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <style> with less scoped",
        "matches": [
          "style_with_less_scoped"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "<style lang=\"sass\">\n${0}\n</style>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <style> with sass",
        "matches": [
          "style_with_sass"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "<style lang=\"sass\" scoped>\n${0}\n</style>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <style> with sass scoped",
        "matches": [
          "style_with_sass_scoped"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "<style lang=\"postcss\">\n${0}\n</style>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <style> with postcss",
        "matches": [
          "style_with_postcss"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "<style lang=\"postcss\" scoped>\n${0}\n</style>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <style> with postcss scoped",
        "matches": [
          "style_with_postcss_scoped"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "<style lang=\"stylus\">\n${0}\n</style>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <style> with stylus",
        "matches": [
          "style_with_stylus"
        ],
        "opts": [
          "head"
        ]
      },
      {
        "content": "<style lang=\"stylus\" scoped>\n${0}\n</style>",
        "doc": "",
        "grammar": "snu",
        "label": "Scaffold <style> with stylus scoped",
        "matches": [
          "style_with_stylus_scoped"
        ],
        "opts": [
          "head"
        ]
      }
    ],
    "vue-pug": [
      {
        "content": "${1:div}(v-for=\"${2:item} in ${2:item}s\" :key=\"${2:item}.id\")\n\t| {{ ${2:item} }}",
        "doc": "vfor statement",
        "grammar": "lsp",
        "label": "Vue v-for",
        "matches": [
          "vfor"
        ],
        "opts": []
      },
      {
        "content": "input(v-model=\"${1:data}\" type=\"text\")",
        "doc": "v-model directive",
        "grammar": "lsp",
        "label": "Vue v-model Directive",
        "matches": [
          "vmodel"
        ],
        "opts": []
      },
      {
        "content": "input(v-model.number=\"${1:numData}\" type=\"number\" step=\"1\")",
        "doc": "v-model directive number input",
        "grammar": "lsp",
        "label": "Vue v-model Number Directive",
        "matches": [
          "vmodel-num"
        ],
        "opts": []
      },
      {
        "content": "@click=\"${1:handler}(${2:arg}, $event)\"",
        "doc": "v-on click handler with arguments",
        "grammar": "lsp",
        "label": "Vue v-on Shortcut Directive",
        "matches": [
          "von"
        ],
        "opts": []
      },
      {
        "content": "${1:component}(:${1:propName}=\"${0}\")",
        "doc": "component element with props",
        "grammar": "lsp",
        "label": "Vue Component with Props Binding",
        "matches": [
          "vel-props"
        ],
        "opts": []
      },
      {
        "content": "img(:src=\"'/path/to/images/' + ${1:fileName}\" alt=\"${2:altText}\")",
        "doc": "image source binding",
        "grammar": "lsp",
        "label": "Vue Image Source Binding",
        "matches": [
          "vsrc"
        ],
        "opts": []
      },
      {
        "content": "${1:div}(:style=\"{ fontSize: ${2:data} + 'px' }\")",
        "doc": "vue inline style binding",
        "grammar": "lsp",
        "label": "Vue Style Binding",
        "matches": [
          "vstyle"
        ],
        "opts": []
      },
      {
        "content": "${1:div}(:style=\"[${2:styleObjectA}, ${3:styleObjectB]}\")",
        "doc": "vue inline style binding, objects",
        "grammar": "lsp",
        "label": "Vue Style Binding Object",
        "matches": [
          "vstyle-obj"
        ],
        "opts": []
      },
      {
        "content": "${1:div}(:class=\"{ ${2:className}: ${3:data} }\")",
        "doc": "vue class binding",
        "grammar": "lsp",
        "label": "Vue Class Binding",
        "matches": [
          "vclass"
        ],
        "opts": []
      },
      {
        "content": "${1:div}(:class=\"[${2:classNameA}, ${3:classNameB}]\")",
        "doc": "vue class binding",
        "grammar": "lsp",
        "label": "Vue Class Binding Object",
        "matches": [
          "vclass-obj"
        ],
        "opts": []
      },
      {
        "content": "${1:div}(:class=\"[${2:classNameA}, {${3:classNameB} : ${4:condition}}]\")",
        "doc": "vue multiple conditional class bindings",
        "grammar": "lsp",
        "label": "Vue Multiple Conditional Class Bindings",
        "matches": [
          "vclass-obj-mult"
        ],
        "opts": []
      },
      {
        "content": "transition(\n\tmode=\"out-in\"\n\t@before-enter=\"beforeEnter\"\n\t@enter=\"enter\"\n\n\t@before-leave=\"beforeLeave\"\n\t@leave=\"leave\"\n\t:css=\"false\"\n)",
        "doc": "transition component js hooks",
        "grammar": "lsp",
        "label": "Vue Transition Component with JavaScript Hooks",
        "matches": [
          "vanim"
        ],
        "opts": []
      },
      {
        "content": "nuxt-link(to=\"/${1:page}\") ${1:page}",
        "doc": "nuxt routing link",
        "grammar": "lsp",
        "label": "Vue Nuxt Routing Link",
        "matches": [
          "vnuxtl"
        ],
        "opts": []
      },
      {
        "content": "@change=\"$emit('change', $event.target.value)\"",
        "doc": "Vue Emit from Child Component",
        "grammar": "lsp",
        "label": "Vue Emit from Child",
        "matches": [
          "vemit-child"
        ],
        "opts": []
      },
      {
        "content": "@change=\"${1:foo} = $event\"",
        "doc": "Vue Emit to Parent Component",
        "grammar": "lsp",
        "label": "Vue Emit to Parent",
        "matches": [
          "vemit-parent"
        ],
        "opts": []
      }
    ],
    "vue-script": [
      {
        "content": "data() {\n\treturn {\n\t\t${1:key}: ${2:value}\n\t}\n},",
        "doc": "Vue Component Data",
        "grammar": "lsp",
        "label": "Vue Data",
        "matches": [
          "vdata"
        ],
        "opts": []
      },
      {
        "content": "methods: {\n\t${1:name}() {\n\t\t${0}\n\t}\n},",
        "doc": "vue method",
        "grammar": "lsp",
        "label": "Vue Methods",
        "matches": [
          "vmethod"
        ],
        "opts": []
      },
      {
        "content": "computed: {\n\t${1:name}() {\n\t\treturn this.${2:data} ${0}\n\t}\n},",
        "doc": "computed value",
        "grammar": "lsp",
        "label": "Vue Computed",
        "matches": [
          "vcomputed"
        ],
        "opts": []
      },
      {
        "content": "beforeCreate () {\n\t${0};\n},",
        "doc": "beforeCreate lifecycle method",
        "grammar": "lsp",
        "label": "Vue Lifecycle beforeCreate",
        "matches": [
          "vbeforecreate"
        ],
        "opts": []
      },
      {
        "content": "created () {\n\t${0};\n},",
        "doc": "created lifecycle method",
        "grammar": "lsp",
        "label": "Vue Lifecycle created",
        "matches": [
          "vcreated"
        ],
        "opts": []
      },
      {
        "content": "beforeMount () {\n\t${0};\n},",
        "doc": "beforeMount lifecycle method",
        "grammar": "lsp",
        "label": "Vue Lifecycle beforeMount",
        "matches": [
          "vbeforemount"
        ],
        "opts": []
      },
      {
        "content": "mounted () {\n\t${0};\n},",
        "doc": "mounted lifecycle method",
        "grammar": "lsp",
        "label": "Vue Lifecycle mounted",
        "matches": [
          "vmounted"
        ],
        "opts": []
      },
      {
        "content": "beforeUpdate () {\n\t${0};\n},",
        "doc": "beforeUpdate lifecycle method",
        "grammar": "lsp",
        "label": "Vue Lifecycle beforeUpdate",
        "matches": [
          "vbeforeupdate"
        ],
        "opts": []
      },
      {
        "content": "updated () {\n\t${0};\n},",
        "doc": "updated lifecycle method",
        "grammar": "lsp",
        "label": "Vue Lifecycle updated",
        "matches": [
          "vupdated"
        ],
        "opts": []
      },
      {
        "content": "beforeDestroy () {\n\t${0};\n},",
        "doc": "beforeDestroy lifecycle method",
        "grammar": "lsp",
        "label": "Vue Lifecycle beforeDestroy",
        "matches": [
          "vbeforedestroy"
        ],
        "opts": []
      },
      {
        "content": "destroyed () {\n\t${0};\n},",
        "doc": "destroyed lifecycle method",
        "grammar": "lsp",
        "label": "Vue Lifecycle destroyed",
        "matches": [
          "vdestroyed"
        ],
        "opts": []
      },
      {
        "content": "watch: {\n\t${1:data}(${2:newValue}, ${3:oldValue}) {\n\t\t${0}\n\t}\n},",
        "doc": "vue watcher",
        "grammar": "lsp",
        "label": "Vue Watchers",
        "matches": [
          "vwatcher"
        ],
        "opts": []
      },
      {
        "content": "watch: {\n\t${1:data}: {\n\t\timmediate: ${2:true},\n\t\tdeep: ${3:true},\n\t\thandler(${4:newValue}, ${5:oldValue}) {\n\t\t\t${0}\n\t\t}\n\t}\n},",
        "doc": "vue watcher with options",
        "grammar": "lsp",
        "label": "Vue Watchers with Options",
        "matches": [
          "vwatcher-options"
        ],
        "opts": []
      },
      {
        "content": "props: {\n\t${1:propName}: {\n\t\ttype: ${2:Number},\n\t\tdefault: ${0}\n\t},\n},",
        "doc": "Vue Props with Default",
        "grammar": "lsp",
        "label": "Vue Props with Default",
        "matches": [
          "vprops"
        ],
        "opts": []
      },
      {
        "content": "import ${1:New} from '@/components/${1:New}.vue';",
        "doc": "Import one component into another",
        "grammar": "lsp",
        "label": "Vue Import File",
        "matches": [
          "vimport"
        ],
        "opts": []
      },
      {
        "content": "components: {\n\t${1:New},\n},",
        "doc": "Import one component into another, within export statement",
        "grammar": "lsp",
        "label": "Vue Import into the Component",
        "matches": [
          "vcomponents"
        ],
        "opts": []
      },
      {
        "content": "import ${1:Name} from '@/components/${1:Name}.vue';\n\nexport default {\n\tcomponents: {\n\t\t${1:Name}\n\t},\n};",
        "doc": "import a component and include it in export default",
        "grammar": "lsp",
        "label": "Vue Import Export",
        "matches": [
          "vimport-export"
        ],
        "opts": []
      },
      {
        "content": "${1:New} = () => import('@/components/${1:New}.vue')",
        "doc": "Import component that should be lazy loaded",
        "grammar": "lsp",
        "label": "Vue Import Component Dynamically",
        "matches": [
          "vimport-dynamic"
        ],
        "opts": []
      },
      {
        "content": "import { mapState } from 'vuex';\n\nexport default {\n\tcomputed: {\n\t\t...mapState([\n\t\t\t${1:'nameOfState'},\n\t\t])\n\t},\n};",
        "doc": "map getters inside a vue component",
        "grammar": "lsp",
        "label": "Vue MapState",
        "matches": [
          "vmapstate"
        ],
        "opts": []
      },
      {
        "content": "import { mapGetters } from 'vuex';\n\nexport default {\n\tcomputed: {\n\t\t...mapGetters([\n\t\t\t${1:'nameOfGetter'},\n\t\t])\n\t},\n};",
        "doc": "mapgetters inside a vue component",
        "grammar": "lsp",
        "label": "Vue MapGetters",
        "matches": [
          "vmapgetters"
        ],
        "opts": []
      },
      {
        "content": "import { mapMutations } from 'vuex';\n\nexport default {\n\tmethods: {\n\t\t...mapMutations([\n\t\t\t${1:'nameOfMutation'}, //also supports payload `this.nameOfMutation(amount)` \n\t\t])\n\t},\n};",
        "doc": "mapmutations inside a vue component",
        "grammar": "lsp",
        "label": "Vue MapMutations",
        "matches": [
          "vmapmutations"
        ],
        "opts": []
      },
      {
        "content": "import { mapActions } from 'vuex';\n\nexport default {\n\tmethods: {\n\t\t...mapActions([\n\t\t\t${1:'nameOfAction'}, //also supports payload `this.nameOfAction(amount)` \n\t\t])\n\t},\n};",
        "doc": "mapactions inside a vue component",
        "grammar": "lsp",
        "label": "Vue MapActions",
        "matches": [
          "vmapactions"
        ],
        "opts": []
      },
      {
        "content": "filters: {\n\t${1:fnName}: function(${2:value}) {\n\t\treturn ${2:value}${0};\n\t}\n}",
        "doc": "vue filter",
        "grammar": "lsp",
        "label": "Vue Filter",
        "matches": [
          "vfilter"
        ],
        "opts": []
      },
      {
        "content": "const ${1:mixinName} = {\n\tmounted() {\n\t\tconsole.log('hello from mixin!');\n\t},\n};",
        "doc": "vue mixin",
        "grammar": "lsp",
        "label": "Vue Mixin",
        "matches": [
          "vmixin"
        ],
        "opts": []
      },
      {
        "content": "mixins: [${1:mixinName}],",
        "doc": "vue use mixin",
        "grammar": "lsp",
        "label": "Vue Use Mixin",
        "matches": [
          "vmixin-use"
        ],
        "opts": []
      },
      {
        "content": "Vue.directive('${1:directiveName}', {\n\tbind(el, binding, vnode) {\n\t\tel.style.${2:arg} = binding.value.${2:arg};\n\t}\n});",
        "doc": "vue custom directive",
        "grammar": "lsp",
        "label": "Vue Custom Directive",
        "matches": [
          "vc-direct"
        ],
        "opts": []
      },
      {
        "content": "import { ${1:libName} } from '${1:libName}';",
        "doc": "import a library",
        "grammar": "lsp",
        "label": "Vue Import Library",
        "matches": [
          "vimport-lib"
        ],
        "opts": []
      },
      {
        "content": "import gsap from 'gsap';",
        "doc": "import gsap library",
        "grammar": "lsp",
        "label": "Vue Import GSAP",
        "matches": [
          "vimport-gsap"
        ],
        "opts": []
      },
      {
        "content": "beforeEnter(el) {\n\tconsole.log('beforeEnter');\n},\nenter(el, done) {\n\tconsole.log('enter');\n\tdone();\n},\nbeforeLeave(el) {\n\tconsole.log('beforeLeave');\n},\nleave(el, done) {\n\tconsole.log('leave');\n\tdone();\n},",
        "doc": "transition component js hooks",
        "grammar": "lsp",
        "label": "Vue Transition Methods with JavaScript Hooks",
        "matches": [
          "vanimhook-js"
        ],
        "opts": []
      },
      {
        "content": "${1:mutationName}() {\n\tthis.\\$store.commit('${1:mutationName}', ${2:payload});\n}",
        "doc": "commit to vuex store in methods for mutation",
        "grammar": "lsp",
        "label": "Vue Commit Vuex Store in Methods",
        "matches": [
          "vcommit"
        ],
        "opts": []
      },
      {
        "content": "${1:actionName}() {\n\tthis.\\$store.dispatch('${1:actionName}', ${2:payload});\n}",
        "doc": "dispatch to vuex store in methods for action",
        "grammar": "lsp",
        "label": "Vue Dispatch Vuex Store in Methods",
        "matches": [
          "vdispatch"
        ],
        "opts": []
      },
      {
        "content": "import Vue from 'vue';\nimport ${1:HelloWorld} from './components/${1:HelloWorld}';\n\ndescribe('${1:HelloWorld}.vue', () => {\n\tit('${2:should render correct contents}', () => {\n\t\tconst Constructor = Vue.extend(${1:HelloWorld});\n\t\tconst vm = new Constructor().$mount();\n\t\texpect(vm.$el.querySelector('.hello h1').textContent)\n\t\t\t.to.equal(${3:'Welcome to Your Vue.js App'});\n\t});\n});",
        "doc": "unit test component",
        "grammar": "lsp",
        "label": "Unit Test",
        "matches": [
          "vtest"
        ],
        "opts": []
      },
      {
        "content": "module.exports = {\n\tcss: {\n\t\tloaderOptions: {\n\t\t\t${1:sass}: {\n\t\t\t\tdata: `${2:@import '@/styles/_variables.scss';}`\n\t\t\t}\n\t\t}\n\t}\n}",
        "doc": "vue.config.js",
        "grammar": "lsp",
        "label": "Vue.config.js Import",
        "matches": [
          "vconfig"
        ],
        "opts": []
      },
      {
        "content": "const ${1:name} = reactive({\n\t${2:count}: ${3:0}\n})",
        "doc": "Vue Composition api - reactive",
        "grammar": "lsp",
        "label": "Vue Composition API - Reactive",
        "matches": [
          "v3reactive"
        ],
        "opts": []
      },
      {
        "content": "const ${1:name} = computed(() => {\n\treturn ${2}\n})",
        "doc": "Vue Composition api - computed",
        "grammar": "lsp",
        "label": "Vue Composition API - Computed",
        "matches": [
          "v3computed"
        ],
        "opts": []
      },
      {
        "content": "watch(() => ${1:foo}, (newValue, oldValue) => {\n\t${2}\n})",
        "doc": "Vue Composition api - watcher single source",
        "grammar": "lsp",
        "label": "Vue Composition API - watch - single source",
        "matches": [
          "v3watch"
        ],
        "opts": []
      },
      {
        "content": "watch([${1:foo}, ${2:bar}], ([new${1}, new${2}], [prev${1}, prev${2}]) => {\n\t${3}\n})",
        "doc": "Vue Composition api - watch as array",
        "grammar": "lsp",
        "label": "Vue Composition API - watch - array",
        "matches": [
          "v3watch-array"
        ],
        "opts": []
      },
      {
        "content": "watchEffect(() => {\n\t${1}\n})",
        "doc": "Vue Composition api - watchEffect",
        "grammar": "lsp",
        "label": "Vue Composition API - watchEffect",
        "matches": [
          "v3watcheffect"
        ],
        "opts": []
      },
      {
        "content": "const ${1:name} = ref(${2:initialValue})",
        "doc": "Vue Ref",
        "grammar": "lsp",
        "label": "Vue Composition API - Vue ref",
        "matches": [
          "v3ref"
        ],
        "opts": []
      },
      {
        "content": "onMounted(() => {${1}})",
        "doc": "Vue Mounted Lifecycle hook",
        "grammar": "lsp",
        "label": "Vue Lifecycle Hooks - onMounted",
        "matches": [
          "v3onmounted"
        ],
        "opts": []
      },
      {
        "content": "onBeforeMount(() => {${1}})",
        "doc": "Vue onBeforeMount Lifecycle hook",
        "grammar": "lsp",
        "label": "Vue Lifecycle Hooks - onBeforeMount",
        "matches": [
          "v3onbeforemount"
        ],
        "opts": []
      },
      {
        "content": "onBeforeUpdate(() => {${1}})",
        "doc": "Vue onBeforeUpdate Lifecycle hook",
        "grammar": "lsp",
        "label": "Vue Lifecycle Hooks - onBeforeUpdate",
        "matches": [
          "v3onbeforeupdate"
        ],
        "opts": []
      },
      {
        "content": "onUpdated(() => {${1}})",
        "doc": "Vue onUpdated Lifecycle hook",
        "grammar": "lsp",
        "label": "Vue Lifecycle Hooks - onUpdated",
        "matches": [
          "v3onupdated"
        ],
        "opts": []
      },
      {
        "content": "onErrorCaptured(() => {${1}})",
        "doc": "Vue onErrorCaptured Lifecycle hook",
        "grammar": "lsp",
        "label": "Vue Lifecycle Hooks - onErrorCaptured",
        "matches": [
          "v3onerrorcaptured"
        ],
        "opts": []
      },
      {
        "content": "onUnmounted(() => {${1}})",
        "doc": "(destroyed) Vue onUnmounted Lifecycle hook",
        "grammar": "lsp",
        "label": "Vue Lifecycle Hooks - onUnmounted",
        "matches": [
          "v3onunmounted"
        ],
        "opts": []
      },
      {
        "content": "onBeforeUnmount(() => {${1}})",
        "doc": "(beforeDestroy) Vue onBeforeUnmount Lifecycle hook",
        "grammar": "lsp",
        "label": "Vue Lifecycle Hooks - onBeforeUnmount",
        "matches": [
          "v3onbeforeunmount"
        ],
        "opts": []
      },
      {
        "content": "import Vue from 'vue'\nimport ${1:VueCompositionApi} from '${2:@vue/composition-api}'\n\nVue.use(${1:VueCompositionApi})",
        "doc": "Import a plugin to main.js or plugins file",
        "grammar": "lsp",
        "label": "Plugin import",
        "matches": [
          "vplugin"
        ],
        "opts": []
      },
      {
        "content": "import { reactive, toRefs } from '@vue/composition-api'\n\nexport default {\n\tsetup () {\n\t\tconst state = reactive({\n\t\t\t${0:count}: ${1:0},\n\t\t})\n\t\n\t\treturn {\n\t\t\t...toRefs(state),\n\t\t}\n\t}\n}",
        "doc": "Vue Composition API Script with Reactive",
        "grammar": "lsp",
        "label": "Vue Composition API Reactive Script",
        "matches": [
          "v3reactive-setup"
        ],
        "opts": []
      },
      {
        "content": "import { ${0:component} } from '@/composables/${0:component}.js'\n\nexport default {\n\tsetup () {\n\t\tconst { ${1:name} } = ${0:component}()\n\t\n\t\treturn {\n\t\t\t${1:name}\n\t\t}\n\t}\n}",
        "doc": "Use Composition API within Options API",
        "grammar": "lsp",
        "label": "Use Composition API within Options API",
        "matches": [
          "v3useinoptions"
        ],
        "opts": []
      }
    ],
    "vue-script-router": [
      {
        "content": "import Vue from 'vue';\nimport VueRouter from 'vue-router';\n\nVue.use(VueRouter);\n\nexport const router = new VueRouter({\n\tbase: '/',\n\tmode: 'history',\n\troutes: [\n\t\t{ path: '/path', component: component }\n\t]\n});",
        "doc": "Base for Vue Router",
        "grammar": "lsp",
        "label": "Vue Router",
        "matches": [
          "vrouter"
        ],
        "opts": []
      },
      {
        "content": "scrollBehavior(to, from, savedPosition) {\n\tif(savedPosition) {\n\t\treturn savedPosition;\n\t} else {\n\t\treturn { x: 0, y: 0 };\n\t}\n},",
        "doc": "Vue Router scrollBehavior",
        "grammar": "lsp",
        "label": "Vue Router scrollBehavior",
        "matches": [
          "vscrollbehavior"
        ],
        "opts": []
      },
      {
        "content": "router.beforeEach((to, from, next) => {\n\t${1:next();}\n});",
        "doc": "Vue Router global guards beforeEach",
        "grammar": "lsp",
        "label": "Vue Router beforeEach",
        "matches": [
          "vbeforeeach"
        ],
        "opts": []
      },
      {
        "content": "router.beforeResolve((to, from, next) => {\n\t${1:next();}\n});",
        "doc": "Vue Router global guards beforeResolve",
        "grammar": "lsp",
        "label": "Vue Router beforeResolve",
        "matches": [
          "vbeforeresolve"
        ],
        "opts": []
      },
      {
        "content": "router.afterEach((to, from) => {\n\t\n});",
        "doc": "Vue Router global guards afterEach",
        "grammar": "lsp",
        "label": "Vue Router afterEach",
        "matches": [
          "vaftereach"
        ],
        "opts": []
      },
      {
        "content": "beforeEnter(to, from, next) {\n\t${1:next();}\n},",
        "doc": "Vue Router per-route guard beforeEnter",
        "grammar": "lsp",
        "label": "Vue Router beforeEnter",
        "matches": [
          "vbeforeenter"
        ],
        "opts": []
      },
      {
        "content": "beforeRouteEnter(to, from, next) {\n\tnext(vm => {${1:}});\n},",
        "doc": "Vue Router component guards beforeRouteEnter",
        "grammar": "lsp",
        "label": "Vue Router beforeRouteEnter",
        "matches": [
          "vbeforerouteenter"
        ],
        "opts": []
      },
      {
        "content": "beforeRouteUpdate(to, from, next) {\n\t${1:next();}\n},",
        "doc": "Vue Router component guards beforeRouteUpdate",
        "grammar": "lsp",
        "label": "Vue Router beforeRouteUpdate",
        "matches": [
          "vbeforerouteupdate"
        ],
        "opts": []
      },
      {
        "content": "beforeRouteLeave(to, from, next) {\n\t${1:next();}\n},",
        "doc": "Vue Router component guards beforeRouteLeave",
        "grammar": "lsp",
        "label": "Vue Router beforeRouteLeave",
        "matches": [
          "vbeforerouteleave"
        ],
        "opts": []
      },
      {
        "content": "{\n\tpath: '${1:pathName}',\n\tname: '${2:routeName}',\n\tcomponent: () => import('./${3:pathToComponent}'),\n},",
        "doc": "Vue Router route with per route code-splitting",
        "grammar": "lsp",
        "label": "Vue Router Route",
        "matches": [
          "vroute-named"
        ],
        "opts": []
      }
    ],
    "vue-script-vuex": [
      {
        "content": "import Vue from 'vue';\nimport Vuex from 'vuex';\n\nVue.use(Vuex);\n\nexport const store = new Vuex.Store({\n\tstate: {\n\t\t${1:key}: ${2:value}\n\t}\n});",
        "doc": "Base for Vuex store",
        "grammar": "lsp",
        "label": "Vuex Store",
        "matches": [
          "vstore"
        ],
        "opts": []
      },
      {
        "content": "getters: {\n\t${1:value}: state => {\n\t\treturn state.${1:value};\n\t}\n}",
        "doc": "vuex getter",
        "grammar": "lsp",
        "label": "Vuex Getters",
        "matches": [
          "vgetter"
        ],
        "opts": []
      },
      {
        "content": "mutations: {\n\t${1:updateValue}(state, ${3:payload}) {\n\t\tstate.${2:value} = ${3:payload};\n\t}\n}",
        "doc": "vuex mutation",
        "grammar": "lsp",
        "label": "Vuex Mutation",
        "matches": [
          "vmutation"
        ],
        "opts": []
      },
      {
        "content": "actions: {\n\t${1:updateValue}({commit}, ${2:payload}) {\n\t\tcommit('${1:updateValue}', ${2:payload});\n\t}\n}",
        "doc": "vuex action",
        "grammar": "lsp",
        "label": "Vuex Action",
        "matches": [
          "vaction"
        ],
        "opts": []
      },
      {
        "content": "import { store } from './store/index';",
        "doc": "import vuex store into main.js",
        "grammar": "lsp",
        "label": "Vue Import Vuex Store",
        "matches": [
          "vstore-import"
        ],
        "opts": []
      },
      {
        "content": "export default {\n\tstate: {\n\t\tvalue: 'my value'\n\t},\n\tgetters: {\n\t\tvalue: state => {\n\t\t\treturn state.value;\n\t\t}\n\t},\n\tmutations: {\n\t\tupdateValue(state, payload) {\n\t\t\tstate.value = payload;\n\t\t}\n\t},\n\tactions: {\n\t\tupdateValue({commit}, payload) {\n\t\t\tcommit('updateValue', payload);\n\t\t}\n\t}\n};",
        "doc": "vuex module",
        "grammar": "lsp",
        "label": "Vuex Module",
        "matches": [
          "vmodule"
        ],
        "opts": []
      },
      {
        "content": "export const state = () => ({\n\tvalue: 'myvalue'\n})\n\nexport const getters = {\n\tgetterValue: state => {\n\t\treturn state.value\n\t}\n}\n\nexport const mutations = {\n\tupdateValue: (state, payload) => {\n\t\tstate.value = payload\n\t}\n}\n\nexport const actions = {\n\tupdateActionValue({ commit }) {\n\t\tcommit('updateValue', payload)\n\t}\n}",
        "doc": "vuex store 2",
        "grammar": "lsp",
        "label": "Vuex Store 2",
        "matches": [
          "vstore2"
        ],
        "opts": []
      }
    ],
    "vue-template": [
      {
        "content": "<${1:div} v-for=\"${2:item} in ${2:item}s\" :key=\"${2:item}.id\">\n\t{{ ${2:item} }}\n</${1:div}>",
        "doc": "vfor statement",
        "grammar": "lsp",
        "label": "Vue v-for",
        "matches": [
          "vfor"
        ],
        "opts": []
      },
      {
        "content": "<input v-model=\"${1:data}\" type=\"text\" />",
        "doc": "v-model directive",
        "grammar": "lsp",
        "label": "Vue v-model Directive",
        "matches": [
          "vmodel"
        ],
        "opts": []
      },
      {
        "content": "<input v-model.number=\"${1:numData}\" type=\"number\" step=\"1\" />",
        "doc": "v-model directive number input",
        "grammar": "lsp",
        "label": "Vue v-model Number Directive",
        "matches": [
          "vmodel-num"
        ],
        "opts": []
      },
      {
        "content": "@click=\"${1:handler}(${2:arg}, $event)\"",
        "doc": "v-on click handler with arguments",
        "grammar": "lsp",
        "label": "Vue v-on Shortcut Directive",
        "matches": [
          "von"
        ],
        "opts": []
      },
      {
        "content": "<${1:component} :${1:propName}=\"${0}\"></${1:component}>",
        "doc": "component element with props",
        "grammar": "lsp",
        "label": "Vue Component with Props Binding",
        "matches": [
          "vel-props"
        ],
        "opts": []
      },
      {
        "content": "<template v-slot:${0:name}>${1:defaultcontent}</template>",
        "doc": "named slot",
        "grammar": "lsp",
        "label": "Vue Named Slot",
        "matches": [
          "vslot-named"
        ],
        "opts": []
      },
      {
        "content": "<img :src=\"'/path/to/images/' + ${1:fileName}\" alt=\"${2:altText}\"/>",
        "doc": "image source binding",
        "grammar": "lsp",
        "label": "Vue Image Source Binding",
        "matches": [
          "vsrc"
        ],
        "opts": []
      },
      {
        "content": "<${1:div} :style=\"{ fontSize: ${2:data} + 'px' }\"></${1:div}>",
        "doc": "vue inline style binding",
        "grammar": "lsp",
        "label": "Vue Style Binding",
        "matches": [
          "vstyle"
        ],
        "opts": []
      },
      {
        "content": "<${1:div} :style=\"[${2:styleObjectA}, ${3:styleObjectB]}\"></${1:div}>",
        "doc": "vue inline style binding, objects",
        "grammar": "lsp",
        "label": "Vue Style Binding Object",
        "matches": [
          "vstyle-obj"
        ],
        "opts": []
      },
      {
        "content": "<${1:div} :class=\"{ ${2:className}: ${3:data} }\"></${1:div}>",
        "doc": "vue class binding",
        "grammar": "lsp",
        "label": "Vue Class Binding",
        "matches": [
          "vclass"
        ],
        "opts": []
      },
      {
        "content": "<${1:div} :class=\"[${2:classNameA}, ${3:classNameB}]\"></${1:div}>",
        "doc": "vue class binding",
        "grammar": "lsp",
        "label": "Vue Class Binding Object",
        "matches": [
          "vclass-obj"
        ],
        "opts": []
      },
      {
        "content": "<${1:div} :class=\"[${2:classNameA}, {${3:classNameB} : ${4:condition}}]\"></${1:div}>",
        "doc": "vue multiple conditional class bindings",
        "grammar": "lsp",
        "label": "Vue Multiple Conditional Class Bindings",
        "matches": [
          "vclass-obj-mult"
        ],
        "opts": []
      },
      {
        "content": "@change=\"$emit('change', $event.target.value)\"",
        "doc": "Vue Emit from Child Component",
        "grammar": "lsp",
        "label": "Vue Emit from Child",
        "matches": [
          "vemit-child"
        ],
        "opts": []
      },
      {
        "content": "@change=\"${1:foo} = $event\"",
        "doc": "Vue Emit to Parent Component",
        "grammar": "lsp",
        "label": "Vue Emit to Parent",
        "matches": [
          "vemit-parent"
        ],
        "opts": []
      },
      {
        "content": "<transition\n\tmode=\"out-in\"\n\t@before-enter=\"beforeEnter\"\n\t@enter=\"enter\"\n\n\t@before-leave=\"beforeLeave\"\n\t@leave=\"leave\"\n\t:css=\"false\">\n\n</transition>",
        "doc": "transition component js hooks",
        "grammar": "lsp",
        "label": "Vue Transition Component with JavaScript Hooks",
        "matches": [
          "vanim"
        ],
        "opts": []
      },
      {
        "content": "<nuxt-link to=\"/${1:page}\">${1:page}</nuxt-link>",
        "doc": "nuxt routing link",
        "grammar": "lsp",
        "label": "Vue Nuxt Routing Link",
        "matches": [
          "vnuxtl"
        ],
        "opts": []
      },
      {
        "content": "<router-link :to=\"{name: '${1:name}'}\">${2:LinkTitle}</router-link>",
        "doc": "Named routing link",
        "grammar": "lsp",
        "label": "Vue Named Routing Link",
        "matches": [
          "vroutename"
        ],
        "opts": []
      },
      {
        "content": "<router-link :to=\"{name: '${1:name}', params:{${2:id}: '${3:value}'} }\">${4:LinkTitle}</router-link>",
        "doc": "Named routing link w/ params",
        "grammar": "lsp",
        "label": "Vue Named Routing Link with Params",
        "matches": [
          "vroutenameparam"
        ],
        "opts": []
      },
      {
        "content": "<router-link to=\"${1:path}\">${2:LinkTitle}</router-link>",
        "doc": "Path routing link",
        "grammar": "lsp",
        "label": "Vue Path Routing Link",
        "matches": [
          "vroutepath"
        ],
        "opts": []
      }
    ],
    "vuex": [
      {
        "content": "import Vue from 'vue';\nimport Vuex from 'vuex';\n\nVue.use(Vuex);\n\nexport const store = new Vuex.Store({\n\tstate: {\n\t\t${1:key}: ${2:value}\n\t}\n});",
        "doc": "Base for Vuex store",
        "grammar": "lsp",
        "label": "vuex-store",
        "matches": [
          "vstore",
          "vuex store"
        ],
        "opts": []
      },
      {
        "content": "getters: {\n\t${1:value}: state => {\n\t\treturn state.${1:value};\n\t}\n}",
        "doc": "vuex getter",
        "grammar": "lsp",
        "label": "vuex-getters",
        "matches": [
          "vgetter",
          "vuex getters"
        ],
        "opts": []
      },
      {
        "content": "mutations: {\n\t${1:updateValue}(state, ${3:payload}) {\n\t\tstate.${2:value} = ${3:payload};\n\t}\n}",
        "doc": "vuex mutation",
        "grammar": "lsp",
        "label": "vuex-mutation",
        "matches": [
          "vmutation",
          "vuex mutation"
        ],
        "opts": []
      },
      {
        "content": "actions: {\n\t${1:updateValue}({commit}, ${2:payload}) {\n\t\tcommit('${1:updateValue}', ${2:payload});\n\t}\n}",
        "doc": "vuex action",
        "grammar": "lsp",
        "label": "vuex-action",
        "matches": [
          "vaction",
          "vuex action"
        ],
        "opts": []
      },
      {
        "content": "import { store } from './store/index';",
        "doc": "import vuex store into main.js",
        "grammar": "lsp",
        "label": "vuex-import-store",
        "matches": [
          "vstore-import",
          "vuex import store"
        ],
        "opts": []
      },
      {
        "content": "export default {\n\tstate: {\n\t\tvalue: 'my value'\n\t},\n\tgetters: {\n\t\tvalue: state => {\n\t\t\treturn state.value;\n\t\t}\n\t},\n\tmutations: {\n\t\tupdateValue(state, payload) {\n\t\t\tstate.value = payload;\n\t\t}\n\t},\n\tactions: {\n\t\tupdateValue({commit}, payload) {\n\t\t\tcommit('updateValue', payload);\n\t\t}\n\t}\n};",
        "doc": "vuex module",
        "grammar": "lsp",
        "label": "vuex-module",
        "matches": [
          "vmodule",
          "vuex module"
        ],
        "opts": []
      },
      {
        "content": "export const state = () => ({\n\tvalue: 'myvalue'\n})\n\nexport const getters = {\n\tgetterValue: state => {\n\t\treturn state.value\n\t}\n}\n\nexport const mutations = {\n\tupdateValue: (state, payload) => {\n\t\tstate.value = payload\n\t}\n}\n\nexport const actions = {\n\tupdateActionValue({ commit }) {\n\t\tcommit('updateValue', payload)\n\t}\n}",
        "doc": "vuex store 2",
        "grammar": "lsp",
        "label": "vuex-store-2",
        "matches": [
          "vuex store 2",
          "vstore2"
        ],
        "opts": []
      }
    ],
    "xhtml": [
      {
        "content": "<html xmlns=\"http://www.w3.org/1999/xhtml\">\n    ${1:TARGET}\n</html>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "xhtml"
        ],
        "opts": []
      }
    ],
    "xml": [
      {
        "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "xml"
        ],
        "opts": []
      },
      {
        "content": "<${1:}>\n\t${2}\n</$1>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "t"
        ],
        "opts": []
      },
      {
        "content": "<${1:}>${2}</$1>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ti"
        ],
        "opts": []
      },
      {
        "content": "<?xml version=\"1.0\"?>\n",
        "doc": null,
        "grammar": "snu",
        "label": "XML declaration",
        "matches": [
          "xml"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "<${1:tag}>\n\t${2:${VISUAL}}\n</${1/([\\w:._-]+).*/$1/}>",
        "doc": null,
        "grammar": "snu",
        "label": "Simple tag",
        "matches": [
          "t"
        ],
        "opts": [
          "b"
        ]
      },
      {
        "content": "<${1:tag}>${2:${VISUAL}}</${1/([\\w:._-]+).*/$1/}>",
        "doc": null,
        "grammar": "snu",
        "label": "Inline tag",
        "matches": [
          "ti"
        ],
        "opts": [
          "b"
        ]
      }
    ],
    "xslt": [
      {
        "content": "<xsl:apply-templates select=\"${1:*}\">\n\t<xsl:with-param name=\"${2:param}\">${3}</xsl:with-param>${4}\n</xsl:apply-templates>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "apply-templates with-param"
        ],
        "opts": []
      },
      {
        "content": "<xsl:apply-templates select=\"${1:*}\">\n\t<xsl:sort select=\"${2:node}\" order=\"${3:ascending}\" data-type=\"${4:text}\">${5}\n</xsl:apply-templates>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "apply-templates sort-by"
        ],
        "opts": []
      },
      {
        "content": "<xsl:apply-templates select=\"${1:*}\" />",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "apply-templates plain"
        ],
        "opts": []
      },
      {
        "content": "<xsl:attribute name=\"${1:name}\">${2}</xsl:attribute>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "attribute blank"
        ],
        "opts": []
      },
      {
        "content": "<xsl:attribute name=\"${1:name}\">\n\t<xsl:value-of select=\"${2:*}\" />\n</xsl:attribute>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "attribute value-of"
        ],
        "opts": []
      },
      {
        "content": "<xsl:call-template name=\"${1:template}\" />",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "call-template"
        ],
        "opts": []
      },
      {
        "content": "<xsl:call-template name=\"${1:template}\">\n\t<xsl:with-param name=\"${2:param}\">${3}</xsl:with-param>${4}\n</xsl:call-template>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "call-template with-param"
        ],
        "opts": []
      },
      {
        "content": "<xsl:choose>\n\t<xsl:when test=\"${1:value}\">\n\t\t${2}\n\t</xsl:when>\n</xsl:choose>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "choose"
        ],
        "opts": []
      },
      {
        "content": "<xsl:copy-of select=\"${1:*}\" />",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "copy-of"
        ],
        "opts": []
      },
      {
        "content": "<xsl:for-each select=\"${1:*}\">${2}\n</xsl:for-each>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for-each"
        ],
        "opts": []
      },
      {
        "content": "<xsl:if test=\"${1:test}\">${2}\n</xsl:if>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "<xsl:import href=\"${1:stylesheet}\" />",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "import"
        ],
        "opts": []
      },
      {
        "content": "<xsl:include href=\"${1:stylesheet}\" />",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "include"
        ],
        "opts": []
      },
      {
        "content": "<xsl:otherwise>${0}\n</xsl:otherwise>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "otherwise"
        ],
        "opts": []
      },
      {
        "content": "<xsl:param name=\"${1:name}\">${2}\n</xsl:param>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "param"
        ],
        "opts": []
      },
      {
        "content": "<xsl:stylesheet version=\"1.0\"\nxmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">${0}\n</xsl:stylesheet>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "stylesheet"
        ],
        "opts": []
      },
      {
        "content": "<xsl:template match=\"${1:*}\">${0}\n</xsl:template>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "template"
        ],
        "opts": []
      },
      {
        "content": "<xsl:template name=\"${1:name}\">${0}\n</xsl:template>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "template named"
        ],
        "opts": []
      },
      {
        "content": "<xsl:text>${0}</xsl:text>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "text"
        ],
        "opts": []
      },
      {
        "content": "<xsl:value-of select=\"${1:*}\" />",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "value-of"
        ],
        "opts": []
      },
      {
        "content": "<xsl:variable name=\"${1:name}\">${0}\n</xsl:variable>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "variable blank"
        ],
        "opts": []
      },
      {
        "content": "<xsl:variable select=\"${1:*}\" />",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "variable select"
        ],
        "opts": []
      },
      {
        "content": "<xsl:when test=\"${1:test}\">${0}\n</xsl:when>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "when"
        ],
        "opts": []
      },
      {
        "content": "<xsl:with-param name=\"${1:name}\">${0}</xsl:with-param>",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "with-param"
        ],
        "opts": []
      },
      {
        "content": "<xsl:with-param name=\"${1:name}\" select=\"${0:*}\" />",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "with-param select"
        ],
        "opts": []
      }
    ],
    "yii": [
      {
        "content": "Yii::app()->session['${0}'];",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yse"
        ],
        "opts": []
      },
      {
        "content": "$this->renderDynamic('${0:callback}');",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yrd"
        ],
        "opts": []
      },
      {
        "content": "Yii::app()->cache->set('${1:key}', ${2:value}, ${3:expire}, new C${4:}CacheDependency(${0}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ycas"
        ],
        "opts": []
      },
      {
        "content": "Yii::app()->cache->add('${1:key}', ${2:value}, ${3:expire}, new C${4}CacheDependency(${0}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ycad"
        ],
        "opts": []
      },
      {
        "content": "Yii::app()->clientScript->registerCssFile('${0:file}');",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yregcf"
        ],
        "opts": []
      },
      {
        "content": "Yii::app()->request->requestType",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yreqtype"
        ],
        "opts": []
      },
      {
        "content": "Yii::app()->request->isAjaxRequest",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yisajax"
        ],
        "opts": []
      },
      {
        "content": "Yii::t('${1:category}', '${2:message}',array(${0}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yt"
        ],
        "opts": []
      },
      {
        "content": "Yii::app()->clientScript->registerCss('${1:id}', '${0}');",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yregc"
        ],
        "opts": []
      },
      {
        "content": "Yii::log('${1:msg}', '${0:info}');",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ylog"
        ],
        "opts": []
      },
      {
        "content": "YYii::app()->request->userHostAddress",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yuserip"
        ],
        "opts": []
      },
      {
        "content": "Yii::app()->clientScript->registerScriptFile('${1:scriptUrl}', CClientScript::POS_${0:END});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yregsf"
        ],
        "opts": []
      },
      {
        "content": "$this->widget('CLinkPager', array('pages'=>$pages,'header'=>'${0}'}))",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ylinkpager"
        ],
        "opts": []
      },
      {
        "content": "CJSON::encode(${0:text});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yjec"
        ],
        "opts": []
      },
      {
        "content": "$dataProvider = new CActiveDataProvider('${1}', array(\n  'criteria' => array(\n\t\t'condition' => '${2}',\n\t\t'order' => '${3}',\n\t\t'with' => array('${4}')\n\t),\n//'pagination' => false,\n\t'pagination' => array(\n\t\t'pageSize'=>${5},\n\t),\n));\n${0}\n// $dataProvider->getData() will return a list of Post objects",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yadp"
        ],
        "opts": []
      },
      {
        "content": "$this->renderDynamic('${1:callback}', array('${2:key}'=>${0:value}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yrdi"
        ],
        "opts": []
      },
      {
        "content": "Yii::app()->clientScript->registerScript('${1:id}', '${2}', CClientScript::POS_${0:READY});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yregs"
        ],
        "opts": []
      },
      {
        "content": "Yii::app()->cache->flush();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ycaf"
        ],
        "opts": []
      },
      {
        "content": "Yii::app()->request->cookies['${0}']",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yco"
        ],
        "opts": []
      },
      {
        "content": "Yii::app()->user->",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yuser"
        ],
        "opts": []
      },
      {
        "content": "$this->refresh();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yrf"
        ],
        "opts": []
      },
      {
        "content": "Yii::import('${0}');",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yimp"
        ],
        "opts": []
      },
      {
        "content": "Yii::trace('${0:msg}');",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ytrace"
        ],
        "opts": []
      },
      {
        "content": "Yii::app()->params['${0}']",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ypar"
        ],
        "opts": []
      },
      {
        "content": "Yii::app()->request->isPostRequest",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yispost"
        ],
        "opts": []
      },
      {
        "content": "if(Yii::app()->request->isAjaxRequest == TRUE)\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yifisajax"
        ],
        "opts": []
      },
      {
        "content": "Yii::app()->cache->delete('${0:key}');",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ydelcache"
        ],
        "opts": []
      },
      {
        "content": "$this->render('${1:view}',array('${2:key}'=>${0:value}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yr"
        ],
        "opts": []
      },
      {
        "content": "$this->redirect(array('${1:controller}/${0:action}'));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yre"
        ],
        "opts": []
      },
      {
        "content": "Yii::app()->cache->get('${0:key}');",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ycag"
        ],
        "opts": []
      },
      {
        "content": "$this->renderText('${0}');",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yrt"
        ],
        "opts": []
      },
      {
        "content": "$this->renderPartial('${1:view}',array('${2:key}'=>${0:value}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yrp"
        ],
        "opts": []
      },
      {
        "content": "${1:ModelName}::model()->count(${2:condition}, array('${3:key}'=>${0:value}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ycountm"
        ],
        "opts": []
      },
      {
        "content": "${1:ModelName}::model()->countBySql(${2:sql},array('${3:key}'=>${0:value}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ycountbs"
        ],
        "opts": []
      },
      {
        "content": "${1:ModelName}::model()->updateAll(${2:array('attributes')}, ${3:condition},array('${4:key}'=>${0:value}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yupdatea"
        ],
        "opts": []
      },
      {
        "content": "${1:ModelName}::model()->updateByPk(${2:pk}, ${3:array('attributes')}, ${4:condition},array('${5:key}'=>${0:value}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yupdatebp"
        ],
        "opts": []
      },
      {
        "content": "${1:ModelName}::model()->deleteAll(${2:condition},array('${3:key}'=>${0:value}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ydela"
        ],
        "opts": []
      },
      {
        "content": "${1:ModelName}::model()->deleteByPk(${2:pk}, ${3:condition}, array('${4:key}'=>${0:value}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ydelbp"
        ],
        "opts": []
      },
      {
        "content": "${1:ModelName}::model()->find(${2:condition},array('${3:key}'=>${0:value}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yfind"
        ],
        "opts": []
      },
      {
        "content": "${1:ModelName}::model()->findAll(${2:condition},array('${3:key}'=>${0:value}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yfinda"
        ],
        "opts": []
      },
      {
        "content": "${1:ModelName}::model()->findByPk(${2:pk}, ${3:condition}, array('${4:key}'=>${0:value}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yfindbp"
        ],
        "opts": []
      },
      {
        "content": "${1:ModelName}::model()->findAllByPk(${2:pk}, ${3:condition},array('${4:key}'=>${0:value}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yfindabp"
        ],
        "opts": []
      },
      {
        "content": "${1:ModelName}::model()->findBySql(${2:sql}, array('${3:key}'=>${0:value}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yfindbs"
        ],
        "opts": []
      },
      {
        "content": "${1:ModelName}::model()->findAllByAttributes(array('${2:attributeName}'=>${3:attributeValue}), ${4:condition}, array('${5:key}'=>${0:value}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yfindaba"
        ],
        "opts": []
      },
      {
        "content": "${1:ModelName}::model()->exists(${2:condition}, array('${3:key}'=>${0:value}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yexists"
        ],
        "opts": []
      },
      {
        "content": "<?php\nclass ${1:ModelName} extends ${2:CActiveRecord}\n{\n\t/**\n\t * Returns the static model of the specified AR class.\n\t * @return CActiveRecord the static model class\n\t */\n\tpublic static function model($className=__CLASS__)\n\t{\n\t\treturn parent::model($className);\n\t}\n\t/**\n\t * @return string the associated database table name\n\t */\n\tpublic function tableName()\n\t{\n\t\treturn '${0:table_name}';\n\t}\n\t/**\n\t * @return array validation rules for model attributes.\n\t */\n\tpublic function rules()\n\t{\n\t\treturn array(\n\t\t);\n\t}\n\t/**\n\t * @return array relational rules.\n\t */\n\tpublic function relations()\n\t{\n\t\treturn array(\n\t\t);\n\t}\n\t/**\n\t * @return array customized attribute labels (name=&gt;label)\n\t */\n\tpublic function attributeLabels()\n\t{\n\t\treturn array(\n\t\t);\n\t}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ymodel"
        ],
        "opts": []
      },
      {
        "content": "<?php\n/**\n * ${1:}\n */\nclass ${2:Site}Controller extends ${3:CController}\n{\n\t  public function action${4:Index}()\n\t  {\n\t      ${0}\n\t  }\n\t// -----------------------------------------------------------\n\t// Uncomment the following methods and override them if needed\n\t/*\n\tpublic function filters()\n\t{\n\t\t// return the filter configuration for this controller, e.g.:\n\t\treturn array(\n\t\t\t'inlineFilterName',\n\t\t\tarray(\n\t\t\t\t'class'=>'path.to.FilterClass',\n\t\t\t\t'propertyName'=>'propertyValue',\n\t\t\t),\n\t\t);\n\t}\n\tpublic function actions()\n\t{\n\t\t// return external action classes, e.g.:\n\t\treturn array(\n\t\t\t'action1'=>'path.to.ActionClass',\n\t\t\t'action2'=>array(\n\t\t\t\t'class'=>'path.to.AnotherActionClass',\n\t\t\t\t'propertyName'=>'propertyValue',\n\t\t\t),\n\t\t);\n\t}\n\t*/\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ycontroller"
        ],
        "opts": []
      },
      {
        "content": "public function action${1:Index}(${2:params})\n{\n\t${0}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yact"
        ],
        "opts": []
      }
    ],
    "yii-chtml": [
      {
        "content": "echo CHtml::radioButton('${1:name}', ${2:false},array(${3:optionName}=>${0:optionValue} );",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhrb"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::asset('${0:path}');",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhass"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::activeLabelEx(${1:model}, '${2:attribute}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhale"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::encodeArray(array(${0}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yheca"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::normalizeUrl(array('${0}'));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhnurl"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::submitButton('${1:label}',array('${2:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhsb"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::linkButton('${1:lable}',array('${2:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhlinkb"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::activeTextArea(${1:model}, '${2:attribute}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhata"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::ajaxButton('${1:label}', '${2:url}',array('${3:ajaxOptionName}'=>${4:ajaxOptionValue}),array('${5:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhajb"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::activeId(${1:model}, '${0:attribute}');",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhai"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::activeCheckBox(${1:model}, '${2:attribute}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhacb"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::activeHiddenField(${1:model}, '${2:attribute}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhahf"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::encode(${0:text});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhec"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::metaTag('${1:content}', '${2:name}', '${3:httpEquiv}',array('${4:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhmtag"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::dropDownList('${1:name}', '${2:select}', array(${3}),array('${4:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhddl"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::listBox('${1:name}', '${2:select}',array(${3}),array('${4:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhlb"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::script('${0:test}');",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhjs"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::ajax(array(${0}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhaj"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::textField('${1:name}', '${2:value}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhtf"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::activePasswordField(${1:model}, '${2:attribute}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhapf"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::listData(array(${1}),'${2:valueField}', '${3:textField}','${0:groupField}');",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhld"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::mailto('${1:text}', '${2:email}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhmt"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::image('${1:src}', '${2:alt}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhimg"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::activeListBox(${1:model}, '${2:attribute}', array(${3}),array('${4:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhalb"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::activeFileField(${1:model}, '${2:attribute}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhaff"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::closeTag('${0:tag}');",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhct"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::activeInputField('${1:type}', ${2:model}, '${3:attribute}',array('${4:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhaif"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::scriptFile('${0:url}');",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhjsf"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::radioButtonList('${1:name}', ${2:select}, array(${3}),array('${4:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhrbl"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::cssFile('${1:url}','${0:media}');",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhcssf"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::error(${1:model}, '${0:attribute}');",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yherr"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::passwordField('${1:name}', '${2:value}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhpf"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::hiddenField('${1:name}', '${2:value}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhhf"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::cdata(${0:text});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhc"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::link('${1:text}',array(${2}),array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhlink"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::errorSummary(${1:model},'${2:headerHtml}','${0:footerHtml}');",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yherrs"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::tag('${1:tag}',array('${2:optionName}'=>${3:optionValue}),${4:false},${0:true});",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yht"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::ajaxLink('${1:label}', '${2:url}',array('${3:ajaxOptionName}'=>${4:ajaxOptionValue}),array('${5:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhajl"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::label('${1:label}', '${2:for}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhlabel"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::activeName(${1:model}, '${0:attribute}');",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhan"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::statefulForm(array('${1}'), '${2:post}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhsform"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::fileField('${1:name}', '${2:value}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhff"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::activeTextField(${1:model}, '${2:attribute}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhatf"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::css('${1:test}','${0:media}');",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhcss"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::imageButton('${1:src}',array('${2:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhimgb"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::ajaxSubmitButton('${1:label}', '${2:url}',array('${3:ajaxOptionName}'=>${4:ajaxOptionValue}),array('${5:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhajsb"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::button('${1:label}',array('${2:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhb"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::listOptions('${1:selection}', array(${2}), array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhlo"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::activeCheckBoxList(${1:model}, '${2:attribute}', array(${3}),array('${4:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhacbl"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::openTag('${1:tag}', array('${2:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhot"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::checkBox('${1:name}', ${2:false}, array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhcb"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::textArea('${1:name}', '${2:value}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhta"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::linkTag('${1:relation}', '${2:type}', '${3:href}', '${4:media}',array('${5:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhlinkt"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::resetButton('${1:label}',array('${2:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhrsb"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::activeRadioButtonList(${1:model}, '${2:attribute}', array(${3}),array('${4:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yharbl"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::checkBoxList('${1:name}', ${2:select}, array(${3}),array('${4:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhcbl"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::form(array('${1}'), '${2:post}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhform"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::beginForm(array('${1}'), '${2:post}',array('${3:optionName}'=>${4:optionValue}));\n${0}\necho CHtml::endForm();",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhbeform"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::activeDropDownList(${1:model}, '${2:attribute}', array(${3}),array('${4:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhaddl"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::activeRadioButton(${1:model}, '${2:attribute}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yharb"
        ],
        "opts": []
      },
      {
        "content": "echo CHtml::activeLabel(${1:model}, '${2:attribute}',array('${3:optionName}'=>${0:optionValue}));",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "yhal"
        ],
        "opts": []
      }
    ],
    "yup": [
      {
        "content": "yup.reach()",
        "doc": "yup.reach(schema: Schema, path: string, value?: object, context?: object): Schema\n\nFor nested schemas yup.reach will retrieve a nested schema based on the provided path.For nested schemas that need to resolve dynamically, you can provide a value and optionally\na context object.let schema = object().shape({\n  nested: object().shape({\n    arr: array().of(object().shape({ num: number().max(4) }))\n  })\n});\n\nreach(schema, \"nested.arr.num\");\nreach(schema, \"nested.arr[].num\");\nreach(schema, \"nested.arr[1].num\");\nreach(schema, 'nested[\"arr\"][1].num');\n",
        "grammar": "lsp",
        "label": "yup-reach",
        "matches": [
          "yup reach"
        ],
        "opts": []
      },
      {
        "content": "yup.addMethod()",
        "doc": "yup.addMethod(schemaType: Schema, name: string, method: ()=> Schema): void\n\nAdds a new method to the core schema types. A friendlier convenience method for schemaType.prototype[name] = method.yup.addMethod(yup.date, \"format\", function(formats, parseStrict) {\n  return this.transform(function(value, originalValue) {\n    if (this.isType(value)) return value;\n\n    value = Moment(originalValue, formats, parseStrict);\n\n    return value.isValid() ? value.toDate() : new Date(\"\");\n  });\n});\n",
        "grammar": "lsp",
        "label": "yup-add-method",
        "matches": [
          "yup addmethod"
        ],
        "opts": []
      },
      {
        "content": "yup.ref()",
        "doc": "yup.ref(path: string, options: { contextPrefix: string }): Ref\n\nCreates a reference to another sibling or sibling descendant field. Refs are resolved\nat validation/cast time and supported where specified. Refs are evaluated in the proper order so that\nthe ref value is resolved before the field using the ref (be careful of circular dependencies!).let schema = object({\n  baz: ref(\"foo.bar\"),\n  foo: object({\n    bar: string()\n  }),\n  x: ref(\"$x\")\n});\n\nschema.cast({ foo: { bar: \"boom\" } }, { context: { x: 5 } });\n// => { baz: 'boom',  x: 5, foo: { bar: 'boom' } }\n",
        "grammar": "lsp",
        "label": "yup-ref",
        "matches": [
          "yup ref"
        ],
        "opts": []
      },
      {
        "content": "yup.lazy()",
        "doc": "yup.lazy((value: any) => Schema): Lazy\n\nCreates a schema that is evaluated at validation/cast time. Useful for creating\nrecursive schema like Trees, for polymorphic fields and arrays.CAUTION! When defining parent-child recursive object schema, you want to reset the default()\nto undefined on the child otherwise the object will infinitely nest itself when you cast it!.let node = object({\n  id: number(),\n  child: yup.lazy(() => node.default(undefined))\n});\n\nlet renderable = yup.lazy(value => {\n  switch (typeof value) {\n    case \"number\":\n      return number();\n    case \"string\":\n      return string();\n    default:\n      return mixed();\n  }\n});\n\nlet renderables = array().of(renderable);\n",
        "grammar": "lsp",
        "label": "yup-lazy",
        "matches": [
          "yup lazy"
        ],
        "opts": []
      },
      {
        "content": "mixed.clone()",
        "doc": "mixed.clone(): Schema\n\nCreates a deep copy of the schema. Clone is used internally to return a new schema with every schema state change.",
        "grammar": "lsp",
        "label": "mixed-clone",
        "matches": [
          "yup mixed clone"
        ],
        "opts": []
      },
      {
        "content": "mixed.label()",
        "doc": "mixed.label(label: string): Schema\n\nOverrides the key name which is used in error messages.",
        "grammar": "lsp",
        "label": "mixed-label",
        "matches": [
          "yup mixed label"
        ],
        "opts": []
      },
      {
        "content": "mixed.meta()",
        "doc": "mixed.meta(metadata: object): Schema\n\nAdds to a metadata object, useful for storing data with a schema, that doesn't belong\nthe cast object itself.",
        "grammar": "lsp",
        "label": "mixed-meta",
        "matches": [
          "yup mixed meta"
        ],
        "opts": []
      },
      {
        "content": "mixed.describe()",
        "doc": "mixed.describe(): SchemaDescription\n\nCollects schema details (like meta, labels, and active tests) into a serializable\ndescription object.SchemaDescription {\n  type: string,\n  label: string,\n  meta: object,\n  tests: Array<{ name: string, params: object }>\n}\n",
        "grammar": "lsp",
        "label": "mixed-describe",
        "matches": [
          "yup mixed describe"
        ],
        "opts": []
      },
      {
        "content": "mixed.concat()",
        "doc": "mixed.concat(schema: Schema)\n\nCreates a new instance of the schema by combining two schemas. Only schemas of the same type can be concatenated.",
        "grammar": "lsp",
        "label": "mixed-concat",
        "matches": [
          "yup mixed concat"
        ],
        "opts": []
      },
      {
        "content": "mixed.validate()",
        "doc": "mixed.validate(value: any, options?: object): Promise<any, ValidationError>\n\nReturns the value (a cast value if isStrict is false) if the value is valid, and returns the errors otherwise.\nThis method is asynchronous and returns a Promise object, that is fulfilled with the value, or rejected\nwith a ValidationError.The options argument is an object hash containing any schema options you may want to override\n(or specify for the first time).Options = {\n  strict: boolean = false;\n  abortEarly: boolean = true;\n  stripUnknown: boolean = false;\n  recursive: boolean = true;\n  context?: object;\n}\n\nstrict: only validate the input, and skip and coercion or transformation\nabortEarly: return from validation methods on the first error rather\nthan after all validations run.\nstripUnknown: remove unspecified keys from objects.\nrecursive: when false validations will not descend into nested schema\n(relevant for objects or arrays).\ncontext: any context needed for validating schema conditions (see: when())\nschema.validate({ name: \"jimmy\", age: 24 }).then(function(value) {\n  value; // => { name: 'jimmy',age: 24 }\n});\n\nschema.validate({ name: \"jimmy\", age: \"hi\" }).catch(function(err) {\n  err.name; // => 'ValidationError'\n  err.errors; // => ['age must be a number']\n});\n",
        "grammar": "lsp",
        "label": "mixed-validate",
        "matches": [
          "yup mixed validate"
        ],
        "opts": []
      },
      {
        "content": "mixed.validateSync()",
        "doc": "mixed.validateSync(value: any, options?: object): any\n\nRuns validatations synchronously if possible and returns the resulting value,\nor throws a ValidationError. Accepts all the same options as validate.Synchronous validation only works if there are no configured async tests, e.g tests that return a Promise.\nFor instance this will work:let schema = number().test(\n  \"is-42\",\n  \"this isn't the number i want\",\n  value => value != 42\n);\n\nschema.validateSync(23); // throws ValidationError\nhowever this will not:let schema = number().test(\"is-42\", \"this isn't the number i want\", value =>\n  Promise.resolve(value != 42)\n);\n\nschema.validateSync(42); // throws Error\n",
        "grammar": "lsp",
        "label": "mixed-validate-sync",
        "matches": [
          "yup mixed validatesync"
        ],
        "opts": []
      },
      {
        "content": "mixed.validateAt()",
        "doc": "mixed.validateAt(path: string, value: any, options?: object): Promise<any, ValidationError>\n\nValidate a deeply nested path within the schema. Similar to how reach works,\nbut uses the resulting schema as the subject for validation.\nNote! The value here is the root value relative to the starting schema, not the value at the nested path.\nlet schema = object({\n  foo: array().of(\n    object({\n      loose: boolean(),\n      bar: string().when(\"loose\", {\n        is: true,\n        otherwise: s => s.strict()\n      })\n    })\n  )\n});\n\nlet rootValue = {\n  foo: [{ bar: 1 }, { bar: 1, loose: true }]\n};\n\nawait schema.validateAt(\"foo[0].bar\", rootValue); // => ValidationError: must be a string\n\nawait schema.validateAt(\"foo[1].bar\", rootValue); // => '1'\n",
        "grammar": "lsp",
        "label": "mixed-validate-at",
        "matches": [
          "yup mixed validateat"
        ],
        "opts": []
      },
      {
        "content": "mixed.validateSyncAt()",
        "doc": "mixed.validateSyncAt(path: string, value: any, options?: object): any\n\nSame as validateAt but synchronous.",
        "grammar": "lsp",
        "label": "mixed-validate-sync-at",
        "matches": [
          "yup mixed validatesyncat"
        ],
        "opts": []
      },
      {
        "content": "mixed.isValid()",
        "doc": "mixed.isValid(value: any, options?: object): Promise<boolean>\n\nReturns true when the passed in value matches the schema. isValid\nis asynchronous and returns a Promise object.Takes the same options as validate().",
        "grammar": "lsp",
        "label": "mixed-is-valid",
        "matches": [
          "yup mixed isvalid"
        ],
        "opts": []
      },
      {
        "content": "mixed.isValidSync()",
        "doc": "mixed.isValidSync(value: any, options?: object): boolean\n\nSynchronously returns true when the passed in value matches the schema.Takes the same options as validateSync() and has the same caveats around async tests.",
        "grammar": "lsp",
        "label": "mixed-is-valid-sync",
        "matches": [
          "yup mixed isvalidsync"
        ],
        "opts": []
      },
      {
        "content": "mixed.cast()",
        "doc": "mixed.cast(value: any, options = {}): any\n\nAttempts to coerce the passed in value to a value that matches the schema. For example: '5' will\ncast to 5 when using the number() type. Failed casts generally return null, but may also\nreturn results like NaN and unexpected strings.options parameter can be an object containing context. (For more info on context see mixed.validate)",
        "grammar": "lsp",
        "label": "mixed-cast",
        "matches": [
          "yup mixed cast"
        ],
        "opts": []
      },
      {
        "content": "mixed.isType()",
        "doc": "mixed.isType(value: any): boolean\n\nRuns a type check against the passed in value. It returns true if it matches,\nit does not cast the value. When nullable() is set null is considered a valid value of the type.\nYou should use isType for all Schema type checks.",
        "grammar": "lsp",
        "label": "mixed-is-type",
        "matches": [
          "yup mixed istype"
        ],
        "opts": []
      },
      {
        "content": "mixed.strict()",
        "doc": "mixed.strict(isStrict: boolean = false): Schema\n\nSets the strict option to true. Strict schemas skip coercion and transformation attempts,\nvalidating the value \"as is\".",
        "grammar": "lsp",
        "label": "mixed-strict",
        "matches": [
          "yup mixed strict"
        ],
        "opts": []
      },
      {
        "content": "mixed.strip()",
        "doc": "mixed.strip(stripField: boolean = true): Schema\n\nMarks a schema to be removed from an output object. Only works as a nested schema.let schema = object({\n  useThis: number(),\n  notThis: string().strip()\n});\n\nschema.cast({ notThis: \"foo\", useThis: 4 }); // => { useThis: 4 }\n",
        "grammar": "lsp",
        "label": "mixed-strip",
        "matches": [
          "yup mixed strip"
        ],
        "opts": []
      },
      {
        "content": "mixed.withMutation()",
        "doc": "mixed.withMutation(builder: (current: Schema) => void): void\n\nFirst the legally required Rich Hickey quote:\nIf a tree falls in the woods, does it make a sound?\nIf a pure function mutates some local data in order to produce an immutable return value, is that ok?\nwithMutation allows you to mutate the schema in place, instead of the default behavior which clones before each change.\nGenerally this isn't necessary since the vast majority of schema changes happen during the initial\ndeclaration, and only happen once over the lifetime of the schema, so performance isn't an issue.\nHowever certain mutations do occur at cast/validation time, (such as conditional schema using when()), or\nwhen instantiating a schema object.object()\n  .shape({ key: string() })\n  .withMutation(schema => {\n    return arrayOfObjectTests.forEach(test => {\n      schema.test(test);\n    });\n  });\n",
        "grammar": "lsp",
        "label": "mixed-with-mutation",
        "matches": [
          "yup mixed withmutation"
        ],
        "opts": []
      },
      {
        "content": "mixed.default()",
        "doc": "mixed.default(): Any\n\nCalling default with no arguments will return the current default value",
        "grammar": "lsp",
        "label": "mixed-default",
        "matches": [
          "yup mixed default"
        ],
        "opts": []
      },
      {
        "content": "mixed.nullable()",
        "doc": "mixed.nullable(isNullable: boolean = true): Schema\n\nIndicates that null is a valid value for the schema. Without nullable()\nnull is treated as a different type and will fail isType() checks.",
        "grammar": "lsp",
        "label": "mixed-nullable",
        "matches": [
          "yup mixed nullable"
        ],
        "opts": []
      },
      {
        "content": "mixed.required()",
        "doc": "mixed.required(message?: string | function): Schema\n\nMark the schema as required. All field values apart from undefined and null meet this requirement.",
        "grammar": "lsp",
        "label": "mixed-required",
        "matches": [
          "yup mixed required"
        ],
        "opts": []
      },
      {
        "content": "mixed.notRequired()",
        "doc": "mixed.notRequired(): Schema\n\nMark the schema as not required. Passing undefined as value will not fail validation.",
        "grammar": "lsp",
        "label": "mixed-not-required",
        "matches": [
          "yup mixed notrequired"
        ],
        "opts": []
      },
      {
        "content": "mixed.typeError()",
        "doc": "mixed.typeError(message: string): Schema\n\nDefine an error message for failed type checks. The ${value} and ${type} interpolation can\nbe used in the message argument.",
        "grammar": "lsp",
        "label": "mixed-type-error",
        "matches": [
          "yup mixed typeerror"
        ],
        "opts": []
      },
      {
        "content": "mixed.oneOf()",
        "doc": "mixed.oneOf(arrayOfValues: Array<any>, message?: string | function): Schema Alias: equals\n\nWhitelist a set of values. Values added are automatically removed from any blacklist if they are in it.\nThe ${values} interpolation can be used in the message argument.Note that undefined does not fail this validator, even when undefined is not included in arrayOfValues.\nIf you don't want undefined to be a valid value, you can use mixed.required.let schema = yup.mixed().oneOf([\"jimmy\", 42]);\n\nawait schema.isValid(42); // => true\nawait schema.isValid(\"jimmy\"); // => true\nawait schema.isValid(new Date()); // => false\n",
        "grammar": "lsp",
        "label": "mixed-one-of",
        "matches": [
          "yup mixed oneof"
        ],
        "opts": []
      },
      {
        "content": "mixed.notOneOf()",
        "doc": "mixed.notOneOf(arrayOfValues: Array<any>, message?: string | function)\n\nBlacklist a set of values. Values added are automatically removed from any whitelist if they are in it.\nThe ${values} interpolation can be used in the message argument.let schema = yup.mixed().notOneOf([\"jimmy\", 42]);\n\nawait schema.isValid(42); // => false\nawait schema.isValid(new Date()); // => true\n",
        "grammar": "lsp",
        "label": "mixed-not-one-of",
        "matches": [
          "yup mixed notoneof"
        ],
        "opts": []
      },
      {
        "content": "mixed.when()",
        "doc": "mixed.when(keys: string | Array<string>, builder: object | (value, schema)=> Schema): Schema\n\nAdjust the schema based on a sibling or sibling children fields. You can provide an object\nliteral where the key is is value or a matcher function, then provides the true schema and/or\notherwise for the failure condition.is conditions are strictly compared (===) if you want to use a different form of equality you\ncan provide a function like: is: (value) => value == true.Like joi you can also prefix properties with $ to specify a property that is dependent\non context passed in by validate() or isValid. when conditions are additive.let schema = object({\n  isBig: boolean(),\n  count: number()\n    .when(\"isBig\", {\n      is: true, // alternatively: (val) => val == true\n      then: yup.number().min(5),\n      otherwise: yup.number().min(0)\n    })\n    .when(\"$other\", (other, schema) => (other === 4 ? schema.max(6) : schema))\n});\n\nawait schema.validate(value, { context: { other: 4 } });\nYou can also specify more than one dependent key, in which case each value will be spread as an argument.let schema = object({\n  isSpecial: boolean(),\n  isBig: boolean(),\n  count: number().when([\"isBig\", \"isSpecial\"], {\n    is: true, // alternatively: (isBig, isSpecial) => isBig && isSpecial\n    then: yup.number().min(5),\n    otherwise: yup.number().min(0)\n  })\n});\n\nawait schema.validate({\n  isBig: true,\n  isSpecial: true,\n  count: 10\n});\nAlternatively you can provide a function that returns a schema\n(called with the value of the key and the current schema).let schema = yup.object({\n  isBig: yup.boolean(),\n  count: yup.number().when(\"isBig\", (isBig, schema) => {\n    return isBig ? schema.min(5) : schema.min(0);\n  })\n});\n\nawait schema.validate({ isBig: false, count: 4 });\n",
        "grammar": "lsp",
        "label": "mixed-when",
        "matches": [
          "yup mixed when"
        ],
        "opts": []
      },
      {
        "content": "mixed.test()",
        "doc": "mixed.test(options: object): Schema\n\nAlternative test(..) signature. options is an object containing some of the following options:Options = {\n  // unique name identifying the test\n  name: string;\n  // test function, determines schema validity\n  test: (value: any) => boolean;\n  // the validation error message\n  message: string;\n  // values passed to message for interpolation\n  params: ?object;\n  // mark the test as exclusive, meaning only one of the same can be active at once\n  exclusive: boolean = false;\n}\nIn the case of mixing exclusive and non-exclusive tests the following logic is used.\nIf a non-exclusive test is added to a schema with an exclusive test of the same name\nthe exclusive test is removed and further tests of the same name will be stacked.If an exclusive test is added to a schema with non-exclusive tests of the same name\nthe previous tests are removed and further tests of the same name will replace each other.let max = 64;\nlet schema = yup.mixed().test({\n  name: \"max\",\n  exclusive: true,\n  params: { max },\n  message: \"${path} must be less than ${max} characters\",\n  test: value => value == null || value.length <= max\n});\n",
        "grammar": "lsp",
        "label": "mixed-test",
        "matches": [
          "yup mixed test"
        ],
        "opts": []
      },
      {
        "content": "mixed.transform()",
        "doc": "mixed.transform((currentValue: any, originalValue: any) => any): Schema\n\nAdds a transformation to the transform chain. Transformations are central to the casting process,\ndefault transforms for each type coerce values to the specific type (as verified by isType()).\ntransforms are run before validations and only applied when strict is true. Some types have built in transformations.Transformations are useful for arbitrarily altering how the object is cast, however, you should take care\nnot to mutate the passed in value. Transforms are run sequentially so each value represents the\ncurrent state of the cast, you can use the originalValue param if you need to work on the raw initial value.let schema = string().transform(function(value, originalvalue) {\n  return this.isType(value) && value !== null ? value.toUpperCase() : value;\n});\n\nschema.cast(\"jimmy\"); // => 'JIMMY'\nEach types will handle basic coercion of values to the proper type for you, but occasionally\nyou may want to adjust or refine the default behavior. For example, if you wanted to use a different\ndate parsing strategy than the default one you could do that with a transform.module.exports = function(formats = \"MMM dd, yyyy\") {\n  return date().transform(function(value, originalvalue) {\n    // check to see if the previous transform already parsed the date\n    if (this.isType(value)) return value;\n\n    // the default coercion failed so lets try it with Moment.js instead\n    value = Moment(originalValue, formats);\n\n    // if its valid return the date object, otherwise return an `InvalidDate`\n    return value.isValid() ? value.toDate() : new Date(\"\");\n  });\n};\nstringDefine a string schema. Supports all the same methods as mixed.let schema = yup.string();\n\nawait schema.isValid(\"hello\"); // => true\nBy default, the cast logic of string is to call toString on the value if it exists.\nempty values are not coerced (use ensure() to coerce empty values to empty strings).Failed casts return the input value.",
        "grammar": "lsp",
        "label": "mixed-transform",
        "matches": [
          "yup mixed transform"
        ],
        "opts": []
      },
      {
        "content": "string.required()",
        "doc": "string.required(message?: string | function): Schema\n\nThe same as the mixed() schema required, except that empty strings are also considered 'missing' values.",
        "grammar": "lsp",
        "label": "string-required",
        "matches": [
          "yup string required"
        ],
        "opts": []
      },
      {
        "content": "string.length()",
        "doc": "string.length(limit: number | Ref, message?: string | function): Schema\n\nSet a required length for the string value. The ${length} interpolation can be used in the message argument",
        "grammar": "lsp",
        "label": "string-length",
        "matches": [
          "yup string length"
        ],
        "opts": []
      },
      {
        "content": "string.min()",
        "doc": "string.min(limit: number | Ref, message?: string | function): Schema\n\nSet a minimum length limit for the string value. The ${min} interpolation can be used in the message argument",
        "grammar": "lsp",
        "label": "string-min",
        "matches": [
          "yup string min"
        ],
        "opts": []
      },
      {
        "content": "string.max()",
        "doc": "string.max(limit: number | Ref, message?: string | function): Schema\n\nSet a maximum length limit for the string value. The ${max} interpolation can be used in the message argument",
        "grammar": "lsp",
        "label": "string-max",
        "matches": [
          "yup string max"
        ],
        "opts": []
      },
      {
        "content": "string.matches()",
        "doc": "string.matches(regex: Regex, options: { message: string, excludeEmptyString: bool }): Schema\n\nAn alternate signature for string.matches with an options object. excludeEmptyString, when true,\nshort circuits the regex test when the value is an empty stringlet schema = string().matches(/(hi|bye)/, { excludeEmptyString: true });\n\nawait schema.isValid(\"\"); // => true\n",
        "grammar": "lsp",
        "label": "string-matches",
        "matches": [
          "yup string matches"
        ],
        "opts": []
      },
      {
        "content": "string.email()",
        "doc": "string.email(message?: string | function): Schema\n\nValidates the value as an email address via a regex.",
        "grammar": "lsp",
        "label": "string-email",
        "matches": [
          "yup string email"
        ],
        "opts": []
      },
      {
        "content": "string.url()",
        "doc": "string.url(message?: string | function): Schema\n\nValidates the value as a valid URL via a regex.",
        "grammar": "lsp",
        "label": "string-url",
        "matches": [
          "yup string url"
        ],
        "opts": []
      },
      {
        "content": "string.ensure()",
        "doc": "string.ensure(): Schema\n\nTransforms undefined and null values to an empty string along with\nsetting the default to an empty string.",
        "grammar": "lsp",
        "label": "string-ensure",
        "matches": [
          "yup string ensure"
        ],
        "opts": []
      },
      {
        "content": "string.trim()",
        "doc": "string.trim(message?: string | function): Schema\n\nTransforms string values by removing leading and trailing whitespace. If\nstrict() is set it will only validate that the value is trimmed.",
        "grammar": "lsp",
        "label": "string-trim",
        "matches": [
          "yup string trim"
        ],
        "opts": []
      },
      {
        "content": "string.lowercase()",
        "doc": "string.lowercase(message?: string | function): Schema\n\nTransforms the string value to lowercase. If strict() is set it\nwill only validate that the value is lowercase.",
        "grammar": "lsp",
        "label": "string-lowercase",
        "matches": [
          "yup string lowercase"
        ],
        "opts": []
      },
      {
        "content": "string.uppercase()",
        "doc": "string.uppercase(message?: string | function): Schema\n\nTransforms the string value to uppercase. If strict() is set it\nwill only validate that the value is uppercase.numberDefine a number schema. Supports all the same methods as mixed.let schema = yup.number();\n\nawait schema.isValid(10); // => true\nThe default cast logic of number is: parseFloat.Failed casts return NaN.",
        "grammar": "lsp",
        "label": "string-uppercase",
        "matches": [
          "yup string uppercase"
        ],
        "opts": []
      },
      {
        "content": "number.min()",
        "doc": "number.min(limit: number | Ref, message?: string | function): Schema\n\nSet the minimum value allowed. The ${min} interpolation can be used in the\nmessage argument.",
        "grammar": "lsp",
        "label": "number-min",
        "matches": [
          "yup number min"
        ],
        "opts": []
      },
      {
        "content": "number.max()",
        "doc": "number.max(limit: number | Ref, message?: string | function): Schema\n\nSet the maximum value allowed. The ${max} interpolation can be used in the\nmessage argument.",
        "grammar": "lsp",
        "label": "number-max",
        "matches": [
          "yup number max"
        ],
        "opts": []
      },
      {
        "content": "number.lessThan()",
        "doc": "number.lessThan(max: number | Ref, message?: string | function): Schema\n\nValue must be less than max. The ${less} interpolation can be used in the\nmessage argument.",
        "grammar": "lsp",
        "label": "number-less-than",
        "matches": [
          "yup number lessthan"
        ],
        "opts": []
      },
      {
        "content": "number.moreThan()",
        "doc": "number.moreThan(min: number | Ref, message?: string | function): Schema\n\nValue must be strictly greater than min. The ${more} interpolation can be used in the\nmessage argument.",
        "grammar": "lsp",
        "label": "number-more-than",
        "matches": [
          "yup number morethan"
        ],
        "opts": []
      },
      {
        "content": "number.positive()",
        "doc": "number.positive(message?: string | function): Schema\n\nValue must be a positive number.",
        "grammar": "lsp",
        "label": "number-positive",
        "matches": [
          "yup number positive"
        ],
        "opts": []
      },
      {
        "content": "number.negative()",
        "doc": "number.negative(message?: string | function): Schema\n\nValue must be a negative number.",
        "grammar": "lsp",
        "label": "number-negative",
        "matches": [
          "yup number negative"
        ],
        "opts": []
      },
      {
        "content": "number.integer()",
        "doc": "number.integer(message?: string | function): Schema\n\nValidates that a number is an integer.",
        "grammar": "lsp",
        "label": "number-integer",
        "matches": [
          "yup number integer"
        ],
        "opts": []
      },
      {
        "content": "number.truncate()",
        "doc": "number.truncate(): Schema\n\nTransformation that coerces the value to an integer by stripping off the digits\nto the right of the decimal point.",
        "grammar": "lsp",
        "label": "number-truncate",
        "matches": [
          "yup number truncate"
        ],
        "opts": []
      },
      {
        "content": "number.round()",
        "doc": "number.round(type: 'floor' | 'ceil' | 'trunc' | 'round' = 'round'): Schema\n\nAdjusts the value via the specified method of Math (defaults to 'round').booleanDefine a boolean schema. Supports all the same methods as mixed.let schema = yup.boolean();\n\nawait schema.isValid(true); // => true\ndateDefine a Date schema. By default ISO date strings will parse correctly,\nfor more robust parsing options see the extending schema types at the end of the readme.\nSupports all the same methods as mixed.let schema = yup.date();\n\nawait schema.isValid(new Date()); // => true\nThe default cast logic of date is pass the value to the Date constructor, failing that, it will attempt\nto parse the date as an ISO date string.Failed casts return an invalid Date.",
        "grammar": "lsp",
        "label": "number-round",
        "matches": [
          "yup number round"
        ],
        "opts": []
      },
      {
        "content": "date.min()",
        "doc": "date.min(limit: Date | string | Ref, message?: string | function): Schema\n\nSet the minimum date allowed. When a string is provided it will attempt to cast to a date first\nand use the result as the limit.",
        "grammar": "lsp",
        "label": "date-min",
        "matches": [
          "yup date min"
        ],
        "opts": []
      },
      {
        "content": "date.max()",
        "doc": "date.max(limit: Date | string | Ref, message?: string | function): Schema\n\nSet the maximum date allowed, When a string is provided it will attempt to cast to a date first\nand use the result as the limit.arrayDefine an array schema. Arrays can be typed or not, When specifying the element type, cast and isValid\nwill apply to the elements as well. Options passed into isValid are passed also passed to child schemas.\nSupports all the same methods as mixed.let schema = yup.array().of(yup.number().min(2));\n\nawait schema.isValid([2, 3]); // => true\nawait schema.isValid([1, -24]); // => false\n\nschema.cast([\"2\", \"3\"]); // => [2, 3]\nYou can also pass a subtype schema to the array constructor as a convenience.array().of(yup.number());\n// or\narray(yup.number());\nThe default cast behavior for array is: JSON.parseFailed casts return: null;",
        "grammar": "lsp",
        "label": "date-max",
        "matches": [
          "yup date max"
        ],
        "opts": []
      },
      {
        "content": "array.of()",
        "doc": "array.of(type: Schema): Schema\n\nSpecify the schema of array elements. of() is optional and when omitted the array schema will\nnot validate its contents.",
        "grammar": "lsp",
        "label": "array-of",
        "matches": [
          "yup array of"
        ],
        "opts": []
      },
      {
        "content": "array.required()",
        "doc": "array.required(message?: string | function): Schema\n\nThe same as the mixed() schema required, except that empty arrays are also considered 'missing' values.",
        "grammar": "lsp",
        "label": "array-required",
        "matches": [
          "yup array required"
        ],
        "opts": []
      },
      {
        "content": "array.min()",
        "doc": "array.min(limit: number | Ref, message?: string | function): Schema\n\nSet a minimum length limit for the array. The ${min} interpolation can be used in the message argument.",
        "grammar": "lsp",
        "label": "array-min",
        "matches": [
          "yup array min"
        ],
        "opts": []
      },
      {
        "content": "array.max()",
        "doc": "array.max(limit: number | Ref, message?: string | function): Schema\n\nSet a maximum length limit for the array. The ${max} interpolation can be used in the message argument.",
        "grammar": "lsp",
        "label": "array-max",
        "matches": [
          "yup array max"
        ],
        "opts": []
      },
      {
        "content": "array.ensure()",
        "doc": "array.ensure(): Schema\n\nEnsures that the value is an array, by setting the default to [] and transforming null and undefined\nvalues to an empty array as well. Any non-empty, non-array value will be wrapped in an array.array()\n  .ensure()\n  .cast(null); // => []\narray()\n  .ensure()\n  .cast(1); // => [1]\narray()\n  .ensure()\n  .cast([1]); // => [1]\n",
        "grammar": "lsp",
        "label": "array-ensure",
        "matches": [
          "yup array ensure"
        ],
        "opts": []
      },
      {
        "content": "array.compact()",
        "doc": "array.compact(rejector: (value) => boolean): Schema\n\nRemoves falsey values from the array. Providing a rejecter function lets you specify the rejection criteria yourself.array()\n  .compact()\n  .cast([\"\", 1, 0, 4, false, null]); // => [1, 4]\n\narray()\n  .compact(function(v) {\n    return v == null;\n  })\n  .cast([\"\", 1, 0, 4, false, null]); // => ['', 1, 0, 4, false]\nobjectDefine an object schema. Options passed into isValid are also passed to child schemas.\nSupports all the same methods as mixed.yup.object().shape({\n  name: string().required(),\n  age: number()\n    .required()\n    .positive()\n    .integer(),\n  email: string().email(),\n  website: string().url()\n});\nYou can also pass a shape to the object constructor as a convenience.object().shape({\n  num: number()\n});\n// or\nobject({\n  num: number()\n});\nThe default cast behavior for object is: JSON.parseFailed casts return: null;",
        "grammar": "lsp",
        "label": "array-compact",
        "matches": [
          "yup array compact"
        ],
        "opts": []
      },
      {
        "content": "object.shape()",
        "doc": "object.shape(fields: object, noSortEdges?: Array<[string, string]>): Schema\n\nDefine the keys of the object and the schemas for said keys.Note that you can chain shape method, which acts like object extends, for example:object({\n  a: string(),\n  b: number()\n}).shape({\n  b: string(),\n  c: number()\n});\nwould be exactly the same as:object({\n  a: string(),\n  b: string(),\n  c: number()\n});\n",
        "grammar": "lsp",
        "label": "object-shape",
        "matches": [
          "yup object shape"
        ],
        "opts": []
      },
      {
        "content": "object.from()",
        "doc": "object.from(fromKey: string, toKey: string, alias: boolean = false): Schema\n\nTransforms the specified key to a new key. If alias is true then the old key will be left.let schema = object({\n  myProp: mixed(),\n  Other: mixed()\n})\n  .from(\"prop\", \"myProp\")\n  .from(\"other\", \"Other\", true);\n\nschema.cast({ prop: 5, other: 6 }); // => { myProp: 5, other: 6, Other: 6 }\n",
        "grammar": "lsp",
        "label": "object-from",
        "matches": [
          "yup object from"
        ],
        "opts": []
      },
      {
        "content": "object.noUnknown()",
        "doc": "object.noUnknown(onlyKnownKeys: boolean = true, message?: string | function): Schema\n\nValidate that the object value only contains keys specified in shape, pass false as the first\nargument to disable the check. Restricting keys to known, also enables stripUnknown option, when not in strict mode.",
        "grammar": "lsp",
        "label": "object-no-unknown",
        "matches": [
          "yup object nounknown"
        ],
        "opts": []
      },
      {
        "content": "object.camelCase()",
        "doc": "object.camelCase(): Schema\n\nTransforms all object keys to camelCase",
        "grammar": "lsp",
        "label": "object-camel-case",
        "matches": [
          "yup object camelcase"
        ],
        "opts": []
      },
      {
        "content": "object.constantCase()",
        "doc": "object.constantCase(): Schema\n\nTransforms all object keys to CONSTANT_CASE.Extending Schema TypesThe simplest way to extend an existing type is just to cache a configured schema and use that through your application.let yup = require(\"yup\");\nlet parseFormats = [\"MMM dd, yyy\"];\nlet invalidDate = new Date(\"\");\n\nmodule.exports = yup.date().transform(function(value, originalValue) {\n  if (this.isType(value)) return value;\n  // the default coercion transform failed so lets try it with Moment instead\n  value = Moment(originalValue, parseFormats);\n  return value.isValid() ? value.toDate() : invalidDate;\n});\nAlternatively, each schema is a normal JavaScript constructor function that you can mutate or delegate to\nusing the normal patterns. Generally you should not inherit from mixed unless you know what you are doing,\nbetter to think of it as an abstract class. The other types are fair game though.You should keep in mind some basic guidelines when extending schemas\nnever mutate an existing schema, always clone() and then mutate the new one before returning it.\nBuilt-in methods like test and transform take care of this for you, so you can safely use them (see below) without worrying\ntransforms should never mutate the value passed in, and should return an invalid object when one exists\n(NaN, InvalidDate, etc) instead of null for bad values.\nby the time validations run the value is guaranteed to be the correct type, however if nullable is\nset then null is a valid value for that type, so don't assume that a property or method exists on the value.\nAdjust core Typeslet invalidDate = new Date(\"\");\n\nfunction parseDateFromFormats(formats, parseStrict) {\n  return this.transform(function(value, originalValue) {\n    if (this.isType(value)) return value;\n\n    value = Moment(originalValue, formats, parseStrict);\n\n    return value.isValid() ? value.toDate() : invalidDate;\n  });\n}\n\n// `addMethod` doesn't do anything special it's\n// equivalent to: yup.date.prototype.format = parseDateFromFormats\nyup.addMethod(yup.date, \"format\", parseDateFromFormats);\nCreating new TypesYup schema use the common constructor pattern for modeling inheritance. You can use any\nutility or pattern that works with that pattern. The below demonstrates using the es6 class\nsyntax since its less verbose, but you absolutely aren't required to use it.let DateSchema = yup.date;\nlet invalidDate = new Date(\"\"); // our failed to coerce value\n\nclass MomentDateSchemaType extends DateSchema {\n  constructor() {\n    super();\n    this._validFormats = [];\n\n    this.withMutation(() => {\n      this.transform(function(value, originalvalue) {\n        if (this.isType(value))\n          // we have a valid value\n          return value;\n        return Moment(originalValue, this._validFormats, true);\n      });\n    });\n  }\n\n  _typeCheck(value) {\n    return (\n      super._typeCheck(value) || (moment.isMoment(value) && value.isValid())\n    );\n  }\n\n  format(formats) {\n    if (!formats) throw new Error(\"must enter a valid format\");\n    let next = this.clone();\n    next._validFormats = {}.concat(formats);\n  }\n}\n\nlet schema = new MomentDateSchemaType();\n\nschema.format(\"YYYY-MM-DD\").cast(\"It is 2012-05-25\"); // => Fri May 25 2012 00:00:00 GMT-0400 (Eastern Daylight Time)\nTypeScript SupportIf you are using TypeScript installing the Yup typings is recommendednpm install -D @types/yup\nYou can now infer a TypeScript type alias using the exported InferType. Given the following Yup schema:import * as yup from 'yup';\n\nconst personSchema = yup.object({\n  firstName: yup\n    .string(),\n  nickName: yup\n    .string()\n    .nullable(),\n  gender: yup\n    .mixed<'male' | 'female' | 'other'>()\n    .oneOf(['male', 'female', 'other']),\n  email: yup\n    .string()\n    .nullable()\n    .notRequired()\n    .email(),\n  birthDate: yup\n    .date()\n    .nullable()\n    .notRequired()\n    .min(new Date(1900, 0, 1)),\n});\nYou can derive the TypeScript type as follows:type Person = yup.InferType<typeof personSchema>;\nWhich is equivalent to the following TypeScript type alias:type Person = {\n  firstName: string;\n  nickName: string | null;\n  gender: \"male\" | \"female\" | \"other\";\n  email?: string | null | undefined;\n  birthDate?: Date | null | undefined;\n}\nMaking the following objects valid both for TypeScript and Yup validation:const minimalPerson: Person = {\n    firstName: \"Matt\",\n    nickName: null,\n    gender: \"male\"\n};\n\nconst fullPerson: Person = {\n    firstName: \"Matt\",\n    nickName: \"The Hammer\",\n    gender: \"male\",\n    email: \"matt@the-hammer.com\",\n    birthDate: new Date(1976, 9, 5)\n};\n",
        "grammar": "lsp",
        "label": "object-constant-case",
        "matches": [
          "yup object constantcase"
        ],
        "opts": []
      }
    ],
    "zsh": [
      {
        "content": "zplug \"`getreg('+')=='' ? '<\\`0\\`>' : getreg('+')`\"${0}",
        "doc": "",
        "grammar": "snu",
        "label": "zplug \"plugin\"",
        "matches": [
          "zplug"
        ],
        "opts": []
      },
      {
        "content": "#!/bin/zsh",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "#!"
        ],
        "opts": []
      },
      {
        "content": "if ${1:condition}; then\n\t${0:${VISUAL}}\nfi",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "if"
        ],
        "opts": []
      },
      {
        "content": "if ${1:condition}; then\n\t${2:${VISUAL}}\nelse\n\t${0:# statements}\nfi",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ife"
        ],
        "opts": []
      },
      {
        "content": "elif ${1:condition}; then\n\t${0:${VISUAL}}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "eif"
        ],
        "opts": []
      },
      {
        "content": "for (( ${2:i} = 0; $2 < ${1:count}; $2++ )); do\n\t${0:${VISUAL}}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "for"
        ],
        "opts": []
      },
      {
        "content": "for ${1:needle} in ${2:haystack}; do\n\t${0:${VISUAL}}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fori"
        ],
        "opts": []
      },
      {
        "content": "for ${1:item} in ${2:list}; do\n\t${0:${VISUAL}}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fore"
        ],
        "opts": []
      },
      {
        "content": "while ${1:condition}; do\n\t${0:${VISUAL}}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "wh"
        ],
        "opts": []
      },
      {
        "content": "until ${1:condition}; do\n\t${0:${VISUAL}}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "until"
        ],
        "opts": []
      },
      {
        "content": "repeat ${1:integer}; do\n\t${0:${VISUAL}}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "repeat"
        ],
        "opts": []
      },
      {
        "content": "case ${1:word} in\n\t${2:pattern})\n\t\t${0};;\nesac",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "case"
        ],
        "opts": []
      },
      {
        "content": "select ${1:answer} in ${2:choices}; do\n\t${0:${VISUAL}}\ndone",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "select"
        ],
        "opts": []
      },
      {
        "content": "( ${0:#statements} )",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "("
        ],
        "opts": []
      },
      {
        "content": "{ ${0:#statements} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "{"
        ],
        "opts": []
      },
      {
        "content": "[[ ${0:test} ]]",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "["
        ],
        "opts": []
      },
      {
        "content": "{ ${1:try} } always { ${0:always} }",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "always"
        ],
        "opts": []
      },
      {
        "content": "${1:function_name}() {\n\t${0:# function_body}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "fun"
        ],
        "opts": []
      },
      {
        "content": "function ${1:function_name}() {\n\t${0:# function_body}\n}",
        "doc": "",
        "grammar": "snu",
        "label": null,
        "matches": [
          "ffun"
        ],
        "opts": []
      },
      {
        "content": "#!/usr/bin/env zsh\n$0",
        "doc": null,
        "grammar": "snu",
        "label": "#!/usr/bin/env zsh",
        "matches": [
          "#!"
        ],
        "opts": [
          "b"
        ]
      }
    ]
  }
}